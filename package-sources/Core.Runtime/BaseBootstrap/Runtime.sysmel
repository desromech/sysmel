ProgramEntity
    withSelector: #ensureAnalysis addMethod: {:(ProgramEntity)self :: Void |
        void
    } makeVirtual.

Type
    withSelector: #=> addMethod: {:(Type)self :(Type)resultType :: SimpleFunctionType |
        SimpleFunctionTypeTemplate((self,), 0bflgs, resultType)
    } makePure makeFinal withEagerAnalysis;
    withSelector: #computeLayout addMethod: {:(Type)self :: Void |
        void
    } makeVirtual;
    withSelector: #computeGCLayout addMethod: {:(Type)self :: Void |
        void
    } makeVirtual;
    withSelector: #computeVirtualTableLayout addMethod: {:(Type)self :: Void |
        void
    } makeVirtual;
    withSelector: #ensureLayoutIsComputed addMethod: {:(Type)self :: Void |
        if: self instanceAlignment = 0sz then: (self computeLayout).
        if: self gcLayout == nil then: (self computeGCLayout).
        void
    } makeFinal;
    withSelector: #ensureVirtualTableLayoutIsComputed addMethod: {:(Type)self :: Void |
        if: self virtualTableLayout == nil then: (self computeVirtualTableLayout).
        void
    } makeInline makeFinal;
    withSelector: #ensureAnalysis addMethod: {:(Type)self :: Void |
        void
    } makeOverride withEagerAnalysis;
    withSelector: #createBasicInitializeMethod addMethod: {:(Type)self :: Void |
        void
    } makeVirtual withEagerAnalysis;
    withSelector: #validBasicInitializeMethod addMethod: {:(Type)self :: Function |
        let: #method with: (self __slotNamedAt__: #basicInitializeMethod).
        if: method == nil then: {
            self createBasicInitializeMethod.
            self __slotNamedAt__: #basicInitializeMethod
        } else: {
            method
        }
    } makeFinal withEagerAnalysis.

ValueBox
    withSelector: #loadFrom:atOffset:withType: addMethod: {:(ValueBox)self :(Untyped)containerBase :(IntPointer)offset :(Type)valueType :: valueType |
        self __slotNamedAt__: #value
    } makeFinal withEagerAnalysis;
    withSelector: #store:in:atOffset:withType: addMethod: {:(ValueBox)self :(Untyped)value :(Untyped)containerBase :(IntPointer)offset :(Type)valueType :: Void |
        self __slotNamedAt__: #value put: value.
        void
    } makeFinal withEagerAnalysis.

TypeSlot
    withSelector: #loadFrom:atOffset:withType: addMethod: {:(TypeSlot)self :(Untyped)containerBase :(IntPointer)offset :(Type)valueType :: valueType |
        (RawTuple::typeSlotAt:)(containerBase, self)
    } makeFinal withEagerAnalysis;
    withSelector: #store:in:atOffset:withType: addMethod: {:(TypeSlot)self :(Untyped)value :(Untyped)containerBase :(IntPointer)offset :(Type)valueType :: Void |
        (RawTuple::typeSlotAt:put:)(containerBase, self, value).
        void
    } makeFinal withEagerAnalysis.

AnyValue
    basicInitializeMethod: {:(AnyValue)self :: Void | void } makeVirtual withEagerAnalysis;
    withSelector: #basicInitialize addMethod: AnyValue basicInitializeMethod;
    withSelector: #initialize addMethod: {:(AnyValue)self :: Void | } makeVirtual withEagerAnalysis;
    withSelector: #finalize addMethod: {:(AnyValue)self :: Void | } makeVirtual withEagerAnalysis;
    withSelector: #yourself addMethod: {:(AnyValue)self :: self __type__ |
        <primitive: #yourself>
        <targetDefinedPrimitive>
        self
    } makePure makeFinal withEagerAnalysis;

    withSelector: #postCopy addMethod: {:(AnyValue)self :: Void | } makeVirtual withEagerAnalysis;
    withSelector: #shallowCopy addMethod: {:(AnyValue)self :: self __type__ | RawTuple::shallowCopy(self) } makeFinal withEagerAnalysis;
    withSelector: #copy addMethod: {:(AnyValue)self :: self __type__ | self shallowCopy postCopy; yourself } withEagerAnalysis;

    withSelector: #isNil addMethod: {:(AnyValue)self :: Boolean | self == nil } makePure makeFinal withEagerAnalysis;
    withSelector: #isNotNil addMethod: {:(AnyValue)self :: Boolean | self ~~ nil } makePure makeFinal withEagerAnalysis;

    withSelector: #hash addMethod: {:(AnyValue)self :: Size | self identityHash } makeVirtual makePure withEagerAnalysis;
    withSelector: #= addMethod: {:(AnyValue)self :other :: Boolean | self == other } makeVirtual makePure withEagerAnalysis;
    withSelector: #~= addMethod: {:(AnyValue)self :other :: Boolean | (self = other) not } makeVirtual makePure withEagerAnalysis;
    withSelector: #recordBindingWithOwner:andName: addMethod: {:(AnyValue)self :(ProgramEntity)owner :(Symbol)name :: Void | void} makeVirtual withEagerAnalysis.

Object
    withSelector: #class addMethod: {:(Object)self :: self __type__ __type__ | self __type__ } makePure makeFinal withEagerAnalysis;
    withSelector: #species addMethod: {:(Object)self :: Class | self class } makeVirtual withEagerAnalysis.

## Early new implementation
Type
    withSelector: #basicAllocate addMethod: {:(Type)self :: self |
        <primitive: #basicAllocate>
        let: #result with: (if: self isBytes
            then: RawTuple::byteNew(0sz)
            else: RawTuple::new(self totalSlotCount)).
        (RawTuple::type:)(result, self).
        if: self isWeak then: RawTuple::markWeak(result).
        result
    } makeVirtual withEagerAnalysis;
    withSelector: #basicNew addMethod: {:(Type)self :: self |
        <primitive: #basicNew>
        if: (Untyped::~~)(self __slotNamedAt__: #emptyTrivialSingleton, nil) then: {
            self __slotNamedAt__: #emptyTrivialSingleton
        } else: {
            let: #result with: self basicAllocate.
            let: #basicInitializeMethod with: self validBasicInitializeMethod.
            if: basicInitializeMethod ~~ nil then: basicInitializeMethod(result).
            if: self isEmptyTrivialSingleton then: {
                self __slotNamedAt__: #emptyTrivialSingleton put: result
            }.
            result
        }.
    } makeVirtual withEagerAnalysis;
    withSelector: #new addMethod: {:(Type)self :: self |
        <primitive: #new>
        if: (Untyped::~~)(self __slotNamedAt__: #emptyTrivialSingleton, nil) then: {
            self __slotNamedAt__: #emptyTrivialSingleton
        } else: {
            self basicNew initialize; yourself
        }
    } withEagerAnalysis.

Exception
    withSelector: #signal addMethod: {:(Exception)self :: Unwinds |
        <primitive: #Exception::signal>
        error(self messageText)
    } withEagerAnalysis;
    withSelector: #signal: addMethod: {:(Exception)self :(String)messageText :: Unwinds |
        self messageText: messageText; signal
    } withEagerAnalysis.

Exception __type__ 
    withSelector: #signal addMethod: {:(Exception __type__)self :: Unwinds | self new signal } withEagerAnalysis;
    withSelector: #signal: addMethod: {:(Exception __type__)self :(String)messageText :: Unwinds | self new signal: messageText } withEagerAnalysis.

AnyValue
    withSelector: #doesNotUnderstand: addMethod: {:(AnyValue)self :(Message)message |
        MessageNotUnderstood new
            message: message;
            receiver: self;
            signal
    } withEagerAnalysis.

Object
    withSelector: #error: addMethod: {:(Object)self :(String)errorMessage :: Unwinds |
        Error signal: errorMessage
    } withEagerAnalysis;
    withSelector: #primitiveFailed addMethod: {:(Object)self :: Unwinds |
        error("Primitive failed")
    } withEagerAnalysis;
    withSelector: #errorSubscriptBounds: addMethod: {:(Object)self :(Size)index :: Unwinds |
        error("Index is out of bounds")
    } withEagerAnalysis;
    withSelector: #assert: addMethod: {:(Object)self :(Boolean)condition :: Void |
        if: condition then: void else: {
            AssertionFailure signal
        }
    } withEagerAnalysis;
    withSelector: #assertion:failedAt: addMethod: {:(Object)self :(String)assertionString :(SourcePosition)assertionLocation :: Unwinds |
        AssertionFailure new
            sourcePosition: assertionLocation;
            signal: assertionString
    } withEagerAnalysis;
    withSelector: #subclassResponsibility addMethod: {:(Object)self :: Unwinds |
        self error: self __type__ printString -- " Subclass responsibility."
    } withEagerAnalysis;
    withSelector: #shouldBeImplemented addMethod: {:(Object)self :: Unwinds |
        self error: self __type__ printString -- " should be implemented."
    } withEagerAnalysis;
    withSelector: #doesNotUnderstand: addMethod: {:(AnyValue)self :(Message)message |
        MessageNotUnderstood new
            message: message;
            receiver: self;
            signal
    } makeVirtual withEagerAnalysis.

ASTDownCastNode __type__
    withSelector: #makeForASTNode:targetType: addMethod: {:(ASTDownCastNode __type__)self :(ASTNode)astNode :(Type)targetType :: self |
        let: #sourcePosition with: astNode sourcePosition.

        self new
            sourcePosition: sourcePosition;
            analyzedType: targetType;
            typeExpression: (ASTLiteralNode new
                analyzedType: targetType __type__;
                sourcePosition: sourcePosition;
                value: targetType;
                yourself);
            valueExpression: astNode;
            isUnchecked: false;
            yourself
    } withEagerAnalysis.

Untyped __type__
    withSelector: #coerceASTNode:into:withEnvironment: addMethod: {:(Type)self :(ASTNode)astNode :(Type)targetType :(AnalysisAndEvaluationEnvironment)environment :: ASTNode |
        if: self == targetType then: {
            astNode
        } else: {
            ASTDownCastNode makeForASTNode: astNode targetType: targetType
        }.
    } withEagerAnalysis.
    
TypeSlot
    withSelector: #isNoRTTIExcluded addMethod: {:(TypeSlot)self :: Boolean |
        self hasAnyFlags: (TypeSlotFlags::NoRTTIExcluded | TypeSlotFlags::MinRTTIExcluded) | TypeSlotFlags::NoSourceDefinitionExcluded
    } withEagerAnalysis;
    withSelector: #isMinRTTIExcluded addMethod: {:(TypeSlot)self :: Boolean |
        self hasAnyFlags: TypeSlotFlags::MinRTTIExcluded | TypeSlotFlags::NoSourceDefinitionExcluded
    } withEagerAnalysis;
    withSelector: #isNoSourceDefinitionExcluded addMethod: {:(TypeSlot)self :: Boolean |
        self hasAnyFlags: TypeSlotFlags::NoSourceDefinitionExcluded
    } withEagerAnalysis;
    withSelector: #isBytecode addMethod: {:(TypeSlot)self :: Boolean |
        self hasAnyFlags: TypeSlotFlags::Bytecode
    } withEagerAnalysis;
    withSelector: #isDebugInformation addMethod: {:(TypeSlot)self :: Boolean |
        self hasAnyFlags: TypeSlotFlags::DebugInformation
    } withEagerAnalysis;
    withSelector: #isJitSpecific addMethod: {:(TypeSlot)self :: Boolean |
        self hasAnyFlags: TypeSlotFlags::JitSpecific
    } withEagerAnalysis;
    withSelector: #isTargetGenerated addMethod: {:(TypeSlot)self :: Boolean |
        self hasAnyFlags: TypeSlotFlags::TargetGenerated
    } withEagerAnalysis;
    withSelector: #isCache addMethod: {:(TypeSlot)self :: Boolean |
        self hasAnyFlags: TypeSlotFlags::Cache
    } withEagerAnalysis.

Array
    withSelector: #at: addMethod: {:(Array)self :(Size)index |
        self __uncheckedSlotAt__: index
    } makeVirtual makeFinal makeAlwaysInline withEagerAnalysis;
    withSelector: #at:put: addMethod: {:(Array)self :(Size)index :value :: Void |
        self __uncheckedSlotAt__: index put: value
    } makeVirtual makeFinal makeAlwaysInline withEagerAnalysis;
    withSelector: #untypedAt: addMethod: {:(Array)self :(Size)index :: Untyped |
        self __uncheckedSlotAt__: index
    } makeVirtual makeFinal makeAlwaysInline withEagerAnalysis;
    withSelector: #untypedAt:put: addMethod: {:(Array)self :(Size)index :(Untyped)value :: Void |
        self __uncheckedSlotAt__: index put: value
    } makeVirtual makeFinal makeAlwaysInline withEagerAnalysis;
    withSelector: #size addMethod: {:(Array)self :: Size |
        self __uncheckedPointersSize__
    } makeVirtual makeFinal makeAlwaysInline withEagerAnalysis;
    withSelector: #doWithIndex: addMethod: {:(Array)self :aBlock :: Void |
        let: #i mutableWith: 0sz.
        let: #size with: self size.

        while: i < size do: {
            aBlock(self at: i, i)
        } continueWith: (i := i + 1sz)
    } makeVirtual makeFinal.

VirtualTable
    withSelector: #at: addMethod: {:(VirtualTable)self :(Size)index |
        self __uncheckedSlotAt__: index + 1sz
    } makeFinal makeAlwaysInline withEagerAnalysis;
    withSelector: #at:put: addMethod: {:(VirtualTable)self :(Size)index :value :: Void |
        self __uncheckedSlotAt__: index + 1sz put: value
    } makeFinal makeAlwaysInline withEagerAnalysis;
    withSelector: #size addMethod: {:(VirtualTable)self :: Size |
        self __uncheckedPointersSize__ - 1sz
    } makeFinal makeAlwaysInline withEagerAnalysis.

Type
    withSelector: #coerceASTNode:into:withEnvironment: addMethod: {:(Type)self :(ASTNode)astNode :(Type)targetType :(AnalysisAndEvaluationEnvironment)environment :: ASTNode |
        if: (self isSubtypeOf: targetType)
        then: astNode
        else: {
            if: self isDynamic then: {
                ASTDownCastNode makeForASTNode: astNode targetType: targetType
            } else: {
                error((((astNode sourcePosition printString -- ": Cannot coerce node from type ") -- self printString) -- " into type ") -- targetType printString)
            }
        }
    } makeVirtual withEagerAnalysis;
    withSelector: #coerceASTNode:withEnvironment: addMethod: {:(Type)self :(ASTNode)astNode :(AnalysisAndEvaluationEnvironment)environment :: ASTNode |
        let: #sourceType with: astNode analyzedType.
        if: (if: sourceType ~~ nil then: sourceType ~= self else: false)
        then: (sourceType coerceASTNode: astNode into: self withEnvironment: environment)
        else: astNode
    } makeVirtual withEagerAnalysis;
    withSelector: #isReferenceLikeType addMethod: {:(Type)self :: Boolean | false } makeVirtual makePure withEagerAnalysis;
    withSelector: #isReferenceType addMethod: {:(Type)self :: Boolean | false } makeVirtual makePure withEagerAnalysis;
    withSelector: #isTemporaryReferenceType addMethod: {:(Type)self :: Boolean | false } makeVirtual makePure withEagerAnalysis;
    withSelector: #isVoidType addMethod: {:(Type)self :: Boolean | false } makeVirtual makePure withEagerAnalysis;
    withSelector: #isUndefinedType addMethod: {:(Type)self :: Boolean | false } makeVirtual makePure withEagerAnalysis;

    withSelector: #addFlags: addMethod: {:(Type)self :(Bitflags)flag :: Void |
        self flags: self flags | flag
    } makeFinal makeAlwaysInline  withEagerAnalysis;

    withSelector: #makeNullable addMethod: {:(Type)self :: Type |
        self addFlags: TypeFlags::Nullable.
        self
    } withEagerAnalysis;
    withSelector: #isNullable addMethod: {:(Type)self :: Boolean |
        self hasAnyFlag: TypeFlags::Nullable.
    } makeFinal makeAlwaysInline  withEagerAnalysis;

    withSelector: #makeBytes addMethod: {:(Type)self :: Type |
        self addFlags: TypeFlags::Bytes.
        self
    } withEagerAnalysis;

    withSelector: #makeWeak addMethod: {:(Type)self :: Type |
        self addFlags: TypeFlags::Weak.
        self
    } withEagerAnalysis;

    withSelector: #makeImmediate addMethod: {:(Type)self :: Type |
        self addFlags: TypeFlags::Immediate.
        self
    } withEagerAnalysis;
    withSelector: #isImmediate addMethod: {:(Type)self :: Boolean |
        self hasAnyFlag: TypeFlags::Immediate.
    } makeFinal makeAlwaysInline  withEagerAnalysis;

    withSelector: #makeFinal addMethod: {:(Type)self :: Type |
        self addFlags: TypeFlags::Final.
        self
    } withEagerAnalysis;
    withSelector: #isFinal addMethod: {:(Type)self :: Boolean |
        self hasAnyFlag: TypeFlags::Final.
    } makeFinal makeAlwaysInline  withEagerAnalysis;

    withSelector: #makeAbstract addMethod: {:(Type)self :: Type |
        self addFlags: TypeFlags::Abstract.
        self
    } withEagerAnalysis;
    withSelector: #isAbstract addMethod: {:(Type)self :: Boolean |
        self hasAnyFlag: TypeFlags::Abstract.
    } makeFinal makeAlwaysInline  withEagerAnalysis;

    withSelector: #makeFunction addMethod: {:(Type)self :: Type |
        self addFlags: TypeFlags::Function.
        self
    } withEagerAnalysis;
    withSelector: #isFunction addMethod: {:(Type)self :: Boolean |
        self hasAnyFlag: TypeFlags::Function.
    } makeFinal makeAlwaysInline withEagerAnalysis;
    withSelector: #makeValue addMethod: {:(Type)self :: Type |
        self addFlags: TypeFlags::Value.
        self
    } withEagerAnalysis;

    withSelector: #defaultValue addMethod: {:(Type)self :: self |
        if: self isNullable
            then: nil
            else: (self error: "A proper default value must be defined for " -- self printString).
    } makeVirtual withEagerAnalysis;

    withSelector: #literalConstantRequiresShallowCopy addMethod: {:(Type)self :: Boolean | false} makeVirtual withEagerAnalysis;

    withSelector: #validSlotDictionary addMethod: {:(Type)self :: MethodDictionary |
        if: self slotDictionary == nil then: (self slotDictionary: MethodDictionary new).
        self slotDictionary
    } withEagerAnalysis;
    withSelector: #addSlotToDictionary: addMethod: {:(Type)self :(TypeSlot)slot :: Void |
        let: #slotName with: slot name.
        if: slotName ~~ nil then: {
            self validSlotDictionary at: slotName put: slot
        }
    } withEagerAnalysis;
    withSelector: #validSupertypeTotalSlotCount addMethod: {:(Type)self :: Size |
        let: #supertype with: self supertype.
        if: supertype == nil then: 0sz else: supertype validTotalSlotCount.
    } makeFinal;
    withSelector: #validSlots addMethod: {:(Type)self :: Array |
        let: #pendingSlots with: self pendingSlots.
        if: pendingSlots ~~ nil then: {

            let: #pendingSlotsArray with: pendingSlots asArray.
            let: #localBaseIndex with: self slots size.
            let: #baseIndex with: self validSupertypeTotalSlotCount + localBaseIndex.

            pendingSlotsArray doWithIndex: {:pendingSlot :pendingSlotIndex :: Void |
                let: #localSlotIndex with: localBaseIndex + pendingSlotIndex.
                let: #slotIndex with: baseIndex + pendingSlotIndex.
                pendingSlot
                    localIndex: localSlotIndex;
                    index: slotIndex
            }.

            self slots: self slots -- pendingSlotsArray.
            self pendingSlots: nil
        }.

        if: self slots == nil then: (self slots: #()).
        self slots
    } makeFinal;
    withSelector: #allValidSlots addMethod: {:(Type)self :: Array |
        if: self allSlots == nil then: {
            let: #supertype with: self supertype.
            let: #supertypeSlots with: (if: supertype ~~ nil then: supertype allValidSlots else: #()).
            self allSlots: supertypeSlots -- self validSlots
        }.

        self allSlots
    } makeFinal;
    withSelector: #validTotalSlotCount addMethod: {:(Type)self :: Size |
        let: #totalSlotCount with: self totalSlotCount.
        if: totalSlotCount == nil then: {
            self totalSlotCount: self validSupertypeTotalSlotCount + self validSlots size.
            self totalSlotCount
        } else: totalSlotCount
    } makeFinal withEagerAnalysis;
    withSelector: #registerSlotsInDictionary addMethod: {:(Type)self :: Void |
        let: #supertypeSlotCount with: self validSupertypeTotalSlotCount.

        self slots doWithIndex: {:(TypeSlot)slot :(Size)index :: Void |
            slot
                localIndex: index;
                index: supertypeSlotCount + index.
            self addSlotToDictionary: slot
        }
    } withEagerAnalysis;
    withSelector: #invalidateLayout addMethod: {:(Type)self  :: Void |
        self instanceSize: 0sz.
        self instanceAlignment: 0sz.
    } makeFinal withEagerAnalysis;
    withSelector: #addTypeSlot: addMethod: {:(Type)self :(TypeSlot)extraSlot :: Void |
        if: self totalSlotCount ~~ nil then: (self error: ((("Cannot add type slot " -- extraSlot printString) -- " into ") -- self printString) -- " when the total slot count has already been computed").
        if: self pendingSlots == nil then: (self pendingSlots: OrderedCollection new).

        self invalidateLayout.
        self pendingSlots add: extraSlot.
        self addSlotToDictionary: extraSlot.
        extraSlot owner: self.
        extraSlot generateAccessorsOn: self.
    } withEagerAnalysis;
    withSelector: #basicAllocate replaceMethod: {:(Type)self :: self |
        <primitive: #basicAllocate>
        let: #result with: (if: self isBytes
            then: RawTuple::byteNew(0sz)
            else: RawTuple::new(self validTotalSlotCount)).
        (RawTuple::type:)(result, self).
        if: self isWeak then: RawTuple::markWeak(result).
        result
    } makeVirtual withEagerAnalysis;
    withSelector: #basicAllocate: addMethod: {:(Type)self :(Size)variableSize :: self |
        let: #result with: (if: self isBytes
            then: RawTuple::byteNew(variableSize)
            else: RawTuple::new(self validTotalSlotCount + variableSize)).
        (RawTuple::type:)(result, self).
        if: self isWeak then: RawTuple::markWeak(result).
        result
    } makeVirtual withEagerAnalysis;
    withSelector: #basicNew: addMethod: {:(Type)self :(Size)variableSlotCount :: self |
        if: (if: variableSlotCount = 0sz then: (Untyped::~~)(self __slotNamedAt__: #emptyTrivialSingleton, nil) else: false) then: {
            self __slotNamedAt__: #emptyTrivialSingleton
        } else: {
            let: #result with: (self basicAllocate: variableSlotCount).
            let: #basicInitializeMethod with: self validBasicInitializeMethod.
            if: basicInitializeMethod ~~ nil then: basicInitializeMethod(result).
            if: (if: variableSlotCount = 0sz then: self isEmptyTrivialSingleton else: false) then: {
                self __slotNamedAt__: #emptyTrivialSingleton put: result
            }.
            result
        }
    } makeVirtual withEagerAnalysis;
    withSelector: #new replaceMethod: {:(Type)self :: self |
        <primitive: #new>
        if: (Untyped::~~)(self __slotNamedAt__: #emptyTrivialSingleton, nil) then: {
            self __slotNamedAt__: #emptyTrivialSingleton
        } else: {
            self basicNew initialize; yourself
        }
    } makeVirtual withEagerAnalysis;
    withSelector: #new: addMethod: {:(Type)self :(Size)variableSlotCount :: self |
        if: (if: variableSlotCount = 0sz then: (Untyped::~~)(self __slotNamedAt__: #emptyTrivialSingleton, nil) else: false) then: {
            self __slotNamedAt__: #emptyTrivialSingleton
        } else: {
            (self basicNew: variableSlotCount) initialize; yourself
        }
    } makeVirtual withEagerAnalysis;
    withSelector: #localSlotNamed: addMethod: {:(Type)self :(Symbol)name |
        let: #slotDictionary with: self slotDictionary.
        if: slotDictionary ~~ nil
            then: (slotDictionary atOrNil: name)
            else: nil
    };
    withSelector: #lookupSlot: addMethod: {:(Type)self :(Symbol)name |
        let: #slot with: (self localSlotNamed: name).
        if: slot ~~ nil
        then: slot
        else: {
            let: #supertype with: self supertype.
            if: supertype ~~ nil
                then: (supertype lookupSlot: name)
                else: (nil)
        }
    }.

ControlFlowEscapeType class
    withSelector: #coerceASTNode:into:withEnvironment: addMethod: {:(Type)self :(ASTNode)astNode :(Type)targetType :(AnalysisAndEvaluationEnvironment)environment :: ASTNode |
        astNode
    } makeOverride.

UndefinedObject class
    withSelector: #coerceASTNode:into:withEnvironment: addMethod: {:(Type)self :(ASTNode)astNode :(Type)targetType :(AnalysisAndEvaluationEnvironment)environment :: ASTNode |
        if: targetType isNullable
        then: astNode
        else: error("Cannot coerce nil into non-nullable type " -- targetType printString)
    } makeOverride.

Type
    withSelector: #isPointedReinterpretableInto: addMethod: {:(Type)self :(Type)targetType :: Boolean |
        self isDirectSubtypeOf: targetType
    }.

PointerType
    withSelector: #coerceASTNode:into:withEnvironment: addMethod: {:(ReferenceLikeType)self :(ASTNode)astNode :(Type)targetType :(AnalysisAndEvaluationEnvironment)environment :: ASTNode |
        if: (self isSubtypeOf: targetType)
        then: astNode
        else: {
            let: #sourcePosition with: astNode sourcePosition.
            let: #analyzerToken with: environment analyzerToken.

            if: targetType isPointerType then: {
                let: #targetPointerType with: (tuple: targetType downCastTo: PointerType).
                if: (self baseType isPointedReinterpretableInto: targetPointerType baseType) then: {
                    ASTFunctionApplicationNode new
                        sourcePosition: astNode sourcePosition;
                        functionExpression: (ASTLiteralNode new
                            sourcePosition: astNode sourcePosition;
                            value: (PointerType::reinterpretCastTo:);
                            analyzedType: (PointerType::reinterpretCastTo:) __type__;
                            analyzerToken: analyzerToken;
                            yourself);
                        arguments: (astNode, (ASTLiteralNode new
                            sourcePosition: astNode sourcePosition;
                            value: targetType;
                            analyzedType: targetType __type__;
                            analyzerToken: analyzerToken;
                            yourself));
                        analyzedType: targetType;
                        analyzerToken: analyzerToken;
                        applicationFlags: 0bflgs;
                        yourself
                } else: {
                    error(astNode sourcePosition printString -- ((("Cannot perform coercion from " -- self printString) -- " into ") -- targetType printString))
                }
            } else: {
                error(astNode sourcePosition printString -- ((("Cannot perform coercion from " -- self printString) -- " into ") -- targetType printString))
            }
        }.
    } makeOverride withEagerAnalysis.

ReferenceLikeType
    withSelector: #isReferenceLikeType addMethod: {:(ReferenceType)self :: Boolean | true } makeOverride makePure;
    withSelector: #asDecayedType addMethod: {:(ReferenceLikeType)self :: Type |
        self baseType asDecayedType
    } makePure makeOverride withEagerAnalysis;
    withSelector: #asDecayedReceiverType addMethod: {:(ReferenceLikeType)self :: Type |
        self baseType decayReferenceLikeForReceiverType: self
    } makePure makeOverride withEagerAnalysis;
    withSelector: #coerceASTNode:into:withEnvironment: addMethod: {:(ReferenceLikeType)self :(ASTNode)astNode :(Type)targetType :(AnalysisAndEvaluationEnvironment)environment :: ASTNode |
        if: (self isSubtypeOf: targetType)
        then: astNode
        else: {
            let: #sourcePosition with: astNode sourcePosition.
            let: #analyzerToken with: environment analyzerToken.

            if: targetType isReferenceLikeType then: {
                let: #targetReferenceLikeType with: (tuple: targetType downCastTo: ReferenceLikeType).
                if: (self baseType isPointedReinterpretableInto: targetReferenceLikeType baseType) then: {
                    ASTFunctionApplicationNode new
                        sourcePosition: astNode sourcePosition;
                        functionExpression: (ASTLiteralNode new
                            sourcePosition: astNode sourcePosition;
                            value: (PointerType::reinterpretCastTo:);
                            analyzedType: (PointerType::reinterpretCastTo:) __type__;
                            analyzerToken: analyzerToken;
                            yourself);
                        arguments: (astNode, (ASTLiteralNode new
                            sourcePosition: astNode sourcePosition;
                            value: targetType;
                            analyzedType: targetType __type__;
                            analyzerToken: analyzerToken;
                            yourself));
                        analyzedType: targetType;
                        analyzerToken: analyzerToken;
                        applicationFlags: 0bflgs;
                        yourself
                } else: {
                    error((("Cannot perform coercion from " -- self printString) -- " into ") -- targetType printString)
                }
            } else: {
                let: #loadValueFunction with: self loadValueFunction.
                let: #baseType with: self baseType.

                targetType
                    coerceASTNode: (ASTFunctionApplicationNode new
                        sourcePosition: astNode sourcePosition;
                        functionExpression: (ASTLiteralNode new
                            value: loadValueFunction;
                            analyzedType: loadValueFunction __type__;
                            analyzerToken: analyzerToken;
                            yourself);
                        arguments: (astNode,);
                        analyzedType: self baseType;
                        analyzerToken: analyzerToken;
                        applicationFlags: 0bflgs;
                        yourself)
                    withEnvironment: environment
            }
        }.
    } makeOverride withEagerAnalysis.

ReferenceType
    withSelector: #isReferenceType addMethod: {:(ReferenceType)self :: Boolean | true } makeOverride makePure;
    withSelector: #asCanonicalPendingInstanceType addMethod: {:(ReferenceType)self :: Type |
        let: #baseType with: self baseType.
        if: baseType ~~ nil
            then: (baseType asCanonicalPendingInstanceType refFor: self addressSpace)
            else: (AnyValue refFor: self addressSpace).
    } makePure makeOverride.

TemporaryReferenceType
    withSelector: #isTemporaryReferenceType addMethod: {:(TemporaryReferenceType)self :: Boolean | true } makeOverride makePure;
    withSelector: #asCanonicalPendingInstanceType addMethod: {:(TemporaryReferenceType)self :: Type |
        let: #baseType with: self baseType.
        if: baseType ~~ nil
            then: (baseType asCanonicalPendingInstanceType tempRefFor: self addressSpace)
            else: (AnyValue tempRefFor: self addressSpace).
    } makePure makeOverride.


Array ensureAnalysisOfMethodWithSelector: #doWithIndex:.

__Global__
    setSymbol: #tuple:downCastTo: bindingWithValue: {:(MacroContext)macroContext :(ASTNode)self :(ASTNode)targetTypeExpression :: ASTDownCastNode |
        ASTDownCastNode new
            sourcePosition: macroContext sourcePosition;
            typeExpression: targetTypeExpression;
            valueExpression: self;
            isUnchecked: false;
            yourself
    } makeMacro;
    setSymbol: #tuple:uncheckedDownCastTo: bindingWithValue: {:(MacroContext)macroContext :(ASTNode)self :(ASTNode)targetTypeExpression :: ASTDownCastNode |
        ASTDownCastNode new
            sourcePosition: macroContext sourcePosition;
            typeExpression: targetTypeExpression;
            valueExpression: self;
            isUnchecked: true;
            yourself
    } makeMacro.

AnyValue
    withSelector: #isNil addMacroMethod: {:(MacroContext)macroContext :(ASTNode)self :: ASTMessageSendNode |
        ASTMessageSendNode new
            sourcePosition: macroContext sourcePosition;
            receiver: self;
            selector: (ASTLiteralNode new
                sourcePosition: macroContext sourcePosition;
                value: #==;
                yourself);
            arguments: (ASTLiteralNode new
                sourcePosition: macroContext sourcePosition;
                value: nil;
                yourself,);
            yourself
    } makeMacro;
    withSelector: #isNotNil addMacroMethod: {:(MacroContext)macroContext :(ASTNode)self :: ASTMessageSendNode |
        ASTMessageSendNode new
            sourcePosition: macroContext sourcePosition;
            receiver: self;
            selector: (ASTLiteralNode new
                sourcePosition: macroContext sourcePosition;
                value: #~~;
                yourself);
            arguments: (ASTLiteralNode new
                sourcePosition: macroContext sourcePosition;
                value: nil;
                yourself,);
            yourself
    } makeMacro;
    withSelector: #&& addMacroMethod: {:(MacroContext)macroContext :(ASTNode)self :(ASTNode)other :: ASTIfNode |
        ASTIfNode new
            sourcePosition: macroContext sourcePosition;
            conditionExpression: self;
            trueExpression: other;
            falseExpression: (ASTLiteralNode new
                sourcePosition: macroContext sourcePosition;
                value: false;
                yourself);
            yourself
    } makeMacro;
    withSelector: #|| addMacroMethod: {:(MacroContext)macroContext :(ASTNode)self :(ASTNode)other :: ASTIfNode |
        ASTIfNode new
            sourcePosition: macroContext sourcePosition;
            conditionExpression: self;
            trueExpression: (ASTLiteralNode new
                sourcePosition: macroContext sourcePosition;
                value: true;
                yourself);
            falseExpression: other;
            yourself
    } makeMacro;

    withSelector: #implicitCastTo: addMacroMethod: {:(MacroContext)macroContext :(ASTNode)self :(ASTNode)targetTypeExpression :: ASTCoerceValueNode |
        ASTCoerceValueNode new
            sourcePosition: macroContext sourcePosition;
            typeExpression: targetTypeExpression;
            valueExpression: self;
            yourself
    } makeMacro;
    withSelector: #downCastTo: addMacroMethod: (tuple:downCastTo:);
    withSelector: #uncheckedDownCastTo: addMacroMethod: (tuple:uncheckedDownCastTo:);

    withSelector: #ifTrue: addMacroMethod: {:(MacroContext)macroContext :(ASTNode)self :(ASTNode)trueExpression :: ASTIfNode |
        ASTIfNode new
            sourcePosition: macroContext sourcePosition;
            conditionExpression: self;
            trueExpression: trueExpression;
            yourself
    } makeMacro;
    withSelector: #ifFalse: addMacroMethod: {:(MacroContext)macroContext :(ASTNode)self :(ASTNode)falseExpression :: ASTIfNode |
        ASTIfNode new
            sourcePosition: macroContext sourcePosition;
            conditionExpression: self;
            falseExpression: falseExpression;
            yourself
    } makeMacro;
    withSelector: #ifTrue:ifFalse: addMacroMethod: {:(MacroContext)macroContext :(ASTNode)self :(ASTNode)trueExpression :(ASTNode)falseExpression :: ASTIfNode |
        ASTIfNode new
            sourcePosition: macroContext sourcePosition;
            conditionExpression: self;
            trueExpression: trueExpression;
            falseExpression: falseExpression;
            yourself
    } makeMacro;
    withSelector: #ifFalse:ifTrue: addMacroMethod: {:(MacroContext)macroContext :(ASTNode)self :(ASTNode)falseExpression :(ASTNode)trueExpression :: ASTIfNode |
        ASTIfNode new
            sourcePosition: macroContext sourcePosition;
            conditionExpression: self;
            trueExpression: trueExpression;
            falseExpression: falseExpression;
            yourself
    } makeMacro;
    withSelector: #perform: addMacroMethod: {:(MacroContext)macroContext :(ASTNode)self :(ASTNode)selector :: ASTMessageSendNode |
        ASTMessageSendNode new
            sourcePosition: macroContext sourcePosition;
            receiver: self;
            selector: selector;
            arguments: Array new;
            isDynamic: true;
            yourself
    } makeMacro;
    withSelector: #perform:with: addMacroMethod: {:(MacroContext)macroContext :(ASTNode)self :(ASTNode)selector :(ASTNode)argument :: ASTMessageSendNode |
        ASTMessageSendNode new
            sourcePosition: macroContext sourcePosition;
            receiver: self;
            selector: selector;
            arguments: (Array with: argument);
            isDynamic: true;
            yourself
    } makeMacro;
    withSelector: #perform:with:with: addMacroMethod: {:(MacroContext)macroContext :(ASTNode)self :(ASTNode)selector :(ASTNode)firstArgument :(ASTNode)secondArgument :: ASTMessageSendNode |
        ASTMessageSendNode new
            sourcePosition: macroContext sourcePosition;
            receiver: self;
            selector: selector;
            arguments: (Array with: firstArgument with: secondArgument);
            isDynamic: true;
            yourself
    } makeMacro;
    withSelector: #perform:with:with:with: addMacroMethod: {:(MacroContext)macroContext :(ASTNode)self :(ASTNode)selector :(ASTNode)firstArgument :(ASTNode)secondArgument :(ASTNode)thirdArgument :: ASTMessageSendNode |
        ASTMessageSendNode new
            sourcePosition: macroContext sourcePosition;
            receiver: self;
            selector: selector;
            arguments: (Array with: firstArgument with: secondArgument with: thirdArgument);
            isDynamic: true;
            yourself
    } makeMacro;
    withSelector: #perform:with:with:with:with: addMacroMethod: {:(MacroContext)macroContext :(ASTNode)self :(ASTNode)selector :(ASTNode)firstArgument :(ASTNode)secondArgument :(ASTNode)thirdArgument :(ASTNode)fourthArgument :: ASTMessageSendNode |
        ASTMessageSendNode new
            sourcePosition: macroContext sourcePosition;
            receiver: self;
            selector: selector;
            arguments: (Array with: firstArgument with: secondArgument with: thirdArgument with: fourthArgument);
            isDynamic: true;
            yourself
    } makeMacro.

ASTNode
    withSelector: #postCopy addMethod: {:(ASTNode)self :: Void |
        (tuple: self withLookupStartingFrom: ASTNode supertype) postCopy.
        self analyzerToken: nil.
    } makeOverride.

Stream
    withSelector: #nextPut: addMethod: {:(Stream)self :element :: Void | 
        self subclassResponsibility
    } makeVirtual;
    withSelector: #nextPutAll: addMethod: {:(Stream)self :aCollection :: Void | 
        aCollection do: {:each :: Void | self nextPut: each}
    } makeVirtual;
    withSelector: #nextPutAllBytesOf: addMethod: {:(Stream)self :anObject :: Void | 
        let: #size mutableWith: RawTuple::byteSize(anObject).
        let: #i mutableWith: 0sz.
        while: i < size do: {
            self nextPut: (RawTuple::byteSlotAt:)(anObject, i)
        } continueWith: (i := i + 1sz)
    } makeVirtual;
    withSelector: #print: addMethod: {:(Stream)self :value :: Void | 
        value printOn: self
    };
    withSelector: #store: addMethod: {:(Stream)self :value :: Void | 
        value storeOn: self
    };
    withSelector: #string: addMethod: {:(Stream)self :value :: Void | 
        value stringOn: self
    };
    withSelector: #fullPrint: addMethod: {:(Stream)self :value :: Void | 
        value fullPrintOn: self
    };
    withSelector: #cr addMethod: {:(Stream)self :: Void | 
        self nextPut: '\r'c8
    };
    withSelector: #lf addMethod: {:(Stream)self :: Void | 
        self nextPut: '\n'c8
    };
    withSelector: #nl addMethod: {:(Stream)self :: Void | 
        self nextPut: '\n'c8
    };
    withSelector: #tab addMethod: {:(Stream)self :: Void | 
        self nextPut: '\t'c8
    };
    withSelector: #space addMethod: {:(Stream)self :: Void | 
        self nextPut: ' 'c8
    }.

AnyValue
    withSelector: #asString addMethod: {:(AnyValue)self :: String | 
        let: #stream with: StringStream new.
        self stringOn: stream.
        stream asString.
    } makeVirtual;
    withSelector: #printString addMethod: {:(AnyValue)self :: String | 
        let: #stream with: StringStream new.
        self printOn: stream.
        stream asString.
    } makeVirtual;
    withSelector: #printOn: addMethod: {:(AnyValue)self :(Stream)stream :: Void |
        stream nextPutAll: "a " ; print: self __type__
    } makeVirtual;
    withSelector: #storeOn: addMethod: {:(AnyValue)self :(Stream)stream :: Void |
        self printOn: stream
    } makeVirtual;
    withSelector: #stringOn: addMethod: {:(AnyValue)self :(Stream)stream :: Void |
        self printOn: stream
    } makeVirtual;
    withSelector: #fullPrintString addMethod: {:(AnyValue)self :: String | 
        let: #stream with: StringStream new.
        self fullPrintOn: stream.
        stream asString.
    } makeVirtual;
    withSelector: #fullPrintOn: addMethod: {:(AnyValue)self :(Stream)stream :: Void |
        self printOn: stream
    } makeVirtual.

ProgramEntity
    withSelector: #printAnonymousNameOn: addMethod: {:(ProgramEntity)self :(Stream)stream :: Void |
        stream nextPutAll: "a "; string: self class name
    } makeVirtual;
    withSelector: #printOwnerOn: addMethod: {:(ProgramEntity)self :(Stream)stream :: Void |
        let: #owner with: self owner.
        if: owner ~~ nil then: {
            stream print: owner; space
        }.
    } makeVirtual;
    withSelector: #printOn: addMethod: {:(ProgramEntity)self :(Stream)stream :: Void |
        let: #name with: self name.
        self printOwnerOn: stream.
        if: name ~~ nil
            then: (stream string: name)
            else: (self printAnonymousNameOn: stream).
    } makeOverride.

Type
    withSelector: #coerceValue:intoType: addMethod: {:(Type)self :(Untyped)value :(Type)targetType :: Untyped |
        error((("Cannot coerce value " -- value printString) -- " into the expected target type ") -- targetType printString)
    } makeVirtual;

    withSelector: #coerceValue: addMethod: {:(Type)self :(Untyped)value :: Untyped |
        let: #valueType with: RawTuple::type(value).
        if: (valueType isSubtypeOf: self)
            then: (value)
            else: (valueType coerceValue: value intoType: self)
    } makeVirtual;
    withSelector: #printAnonymousNameOn: addMethod: {:(Type)self :(Stream)stream :: Void |
        stream nextPutAll: "a Type"
    } makeOverride.

UndefinedObject class
    withSelector: #coerceValue:intoType: addMethod: {:(UndefinedObject class)self :(Untyped)value :(Type)targetType :: Untyped |
        if: targetType isNullable then: {
            return: nil
        } else: {
            error((("Cannot coerce value " -- value printString) -- " into the expected target type ") -- targetType printString)
        }
    } makeOverride.

Void class
    withSelector: #coerceASTNode:withEnvironment: addMethod: {:(Type)self :(ASTNode)astNode :(AnalysisAndEvaluationEnvironment)environment :: ASTNode |
        let: #sourceType with: astNode analyzedType.
        if: (if: sourceType ~~ nil then: (sourceType isDirectSubtypeOf: self) else: false)
        then: astNode
        else: (ASTFunctionApplicationNode new
            sourcePosition: astNode sourcePosition;
            analyzedType: Void;
            functionExpression: (ASTLiteralNode new
                sourcePosition: astNode sourcePosition;
                analyzedType: Void::fromAnyValue __type__;
                value: Void::fromAnyValue;
                yourself);
            arguments: (astNode,);
            applicationFlags: 0bflgs;
            yourself)
    } makeOverride withEagerAnalysis;
    withSelector: #coerceValue: addMethod: {:(Void class)self :value :: Void | void } makeOverride;
    withSelector: #isVoidType addMethod: {:(Type)self :: Boolean | true } makeOverride makePure withEagerAnalysis.

Void
    withSelector: #printString addMethod: {:(Void)self :: String | "void" } makeOverride;
    withSelector: #printOn: addMethod: {:(Void)self :(Stream)stream :: Void | stream nextPutAll: "void" } makeOverride.

UndefinedObject class
    withSelector: #isUndefinedType addMethod: {:(Type)self :: Boolean | true } makeOverride makePure withEagerAnalysis.

UndefinedObject
    withSelector: #doesNotUnderstand: addMethod: {:(UndefinedObject)self :(Message)message |
        self error: message selector printString -- " was sent to nil."
    } makeOverride;

    withSelector: #printString addMethod: {:(UndefinedObject)self :: String | "nil" } makeOverride;
    withSelector: #printOn: addMethod: {:(UndefinedObject)self :(Stream)stream :: Void | stream nextPutAll: "nil" } makeOverride.

False
    withSelector: #printString addMethod: {:(False)self :: String | "false" } makeOverride;
    withSelector: #printOn: addMethod: {:(False)self :(Stream)stream :: Void | stream nextPutAll: "false" } makeOverride.

True
    withSelector: #printString addMethod: {:(True)self :: String | "true" } makeOverride;
    withSelector: #printOn: addMethod: {:(True)self :(Stream)stream :: Void | stream nextPutAll: "true" } makeOverride.

String
    withSelector: #stringOn: addMethod: {:(String)self :(Stream)stream :: Void |
        stream nextPutAllBytesOf: self
    } makeOverride;
    withSelector: #printOn: addMethod: {:(String)self :(Stream)stream :: Void |
        ## TODO: Implement this part properly.
        stream nextPut: '"'c8.
        stream nextPutAllBytesOf: self.
        stream nextPut: '"'c8.
    } makeOverride.

StringSymbol
    withSelector: #stringOn: addMethod: {:(StringSymbol)self :(Stream)stream :: Void |
        stream nextPutAllBytesOf: self
    } makeOverride;
    withSelector: #printOn: addMethod: {:(StringSymbol)self :(Stream)stream :: Void |
        ## TODO: Implement this part properly.
        stream nextPut: '#'c8; nextPutAllBytesOf: self
    } makeOverride;
    withSelector: #fullPrintOn: addMethod: {:(StringSymbol)self :(Stream)stream :: Void |
        ## TODO: Implement this part properly.
        stream nextPut: '#'c8; nextPutAllBytesOf: self
    } makeOverride.


Class
    withSelector: #withSelector:addClassMethod: addMethod: {:(Class)self :selector :method :: Void |
        self class withSelector: selector addMethod: method
    }.

FunctionDefinition
    withSelector: #hasPragmaNamed: addMethod: {:(FunctionDefinition)self :selector :: Boolean |
        let: #pragmas with: self pragmas.
        if: pragmas ~~ nil then: {
            if: (pragmas anySatisfy: {:(Pragma)pragma :: Boolean | selector == pragma selector }) then: {
                return: true
            }
        }.
        
        let: #sourceDefinition with: self sourceDefinition.
        if: sourceDefinition ~~ nil then: {
            sourceDefinition bodyNode hasPragmaNamed: selector
        } else: {
            return: false
        }
    };
    withSelector: #sourcePosition addMethod: {:(FunctionDefinition)self :: SourcePosition |
        let: #bytecode with: self bytecode.
        if: bytecode ~~ nil then: {
            return: bytecode sourcePosition
        }.

        let: #sourceAnalyzedDefinition with: self sourceAnalyzedDefinition.
        if: sourceAnalyzedDefinition ~~ nil then: {
            return: sourceAnalyzedDefinition sourcePosition
        }.

        let: #sourceDefinition with: self sourceDefinition.
        if: sourceDefinition ~~ nil then: {
            return: sourceDefinition sourcePosition
        }.

        nil
    }.

Function
    withSelector: #hasAnyFlag: addMethod: {:(Function)self :(Bitflags)flag :: Boolean |
        (self flags & flag) ~= 0bflgs
    } makeFinal makeAlwaysInline;
    withSelector: #hasAllFlags: addMethod: {:(Function)self :(Bitflags)flags :: Boolean |
        (self flags & flags) = flags
    } makeFinal makeAlwaysInline;
    withSelector: #isMacro addMethod: {:(Function)self :: Boolean |
        self hasAnyFlag: FunctionFlags::Macro
    } makeFinal makeAlwaysInline;
    withSelector: #isVariadic addMethod: {:(Function)self :: Boolean |
        self hasAnyFlag: FunctionFlags::Variadic
    } makeFinal makeAlwaysInline;
    withSelector: #isCorePrimitive addMethod: {:(Function)self :: Boolean |
        self hasAnyFlag: FunctionFlags::CorePrimitive
    } makeFinal makeAlwaysInline;
    withSelector: #isBootstrapPrimitive addMethod: {:(Function)self :: Boolean |
        self isNotNil && (self isCorePrimitive || self definition isNil)
    } makeFinal makeAlwaysInline;
    withSelector: #isPure addMethod: {:(Function)self :: Boolean |
        self hasAnyFlag: FunctionFlags::Pure
    } makeFinal makeAlwaysInline;
    withSelector: #isFinal addMethod: {:(Function)self :: Boolean |
        self hasAnyFlag: FunctionFlags::Final
    } makeFinal makeAlwaysInline;
    withSelector: #isVirtual addMethod: {:(Function)self :: Boolean |
        self hasAnyFlag: FunctionFlags::Virtual
    } makeFinal makeAlwaysInline;
    withSelector: #isAbstract addMethod: {:(Function)self :: Boolean |
        self hasAnyFlag: FunctionFlags::Abstract
    } makeFinal makeAlwaysInline;
    withSelector: #isOverride addMethod: {:(Function)self :: Boolean |
        self hasAnyFlag: FunctionFlags::Override
    } makeFinal makeAlwaysInline;
    withSelector: #isStatic addMethod: {:(Function)self :: Boolean |
        self hasAnyFlag: FunctionFlags::Static
    } makeFinal makeAlwaysInline;
    withSelector: #isMemoized addMethod: {:(Function)self :: Boolean |
        self hasAnyFlag: FunctionFlags::Memoized
    } makeFinal makeAlwaysInline;
    withSelector: #isTemplate addMethod: {:(Function)self :: Boolean |
        self hasAnyFlag: FunctionFlags::Template
    } makeFinal makeAlwaysInline;
    withSelector: #isMemoizedTemplate addMethod: {:(Function)self :: Boolean |
        self hasAllFlags: FunctionFlags::Memoized | FunctionFlags::Template
    } makeFinal makeAlwaysInline;
    withSelector: #isInline addMethod: {:(Function)self :: Boolean |
        self hasAnyFlag: FunctionFlags::Inline
    } makeFinal makeAlwaysInline;
    withSelector: #isAlwaysInline addMethod: {:(Function)self :: Boolean |
        self hasAnyFlag: FunctionFlags::AlwaysInline
    } makeFinal makeAlwaysInline;
    withSelector: #isNeverInline addMethod: {:(Function)self :: Boolean |
        self hasAnyFlag: FunctionFlags::NeverInline
    } makeFinal makeAlwaysInline;
    withSelector: #isWithoutSourceDebugging addMethod: {:(Function)self :: Boolean |
        self hasAnyFlag: FunctionFlags::WithoutSourceDebugging
    } makeFinal makeAlwaysInline;
    withSelector: #isNoGC addMethod: {:(Function)self :: Boolean |
        self hasAnyFlag: FunctionFlags::NoGC
    } makeFinal makeAlwaysInline;
    withSelector: #hasOverrideDispatch addMethod: {:(Function)self :: Boolean |
        self hasAnyFlag: FunctionFlags::Override
    } makeFinal makeAlwaysInline withEagerAnalysis;
    withSelector: #hasVirtualDispatch addMethod: {:(Function)self :: Boolean |
        self hasAnyFlag: (FunctionFlags::Virtual | FunctionFlags::Abstract) | FunctionFlags::Override
    } makeFinal makeAlwaysInline withEagerAnalysis;
    withSelector: #requiresArgumentExpansionDuringApplication addMethod: {:(Function)self :: Boolean |
        self hasAnyFlag: FunctionFlags::Memoized | FunctionFlags::Variadic
    } makeFinal makeAlwaysInline withEagerAnalysis;

    withSelector: #hasPragmaNamed: addMethod: {:(Function)self :selector :: Boolean |
        let: #definition with: self definition.
        if: definition == nil then: false else: (definition hasPragmaNamed: selector)
    };
    
    withSelector: #printOn: addMethod: {:(Function)self :(Stream)stream :: Void |
        let: #name with: self name.
        let: #definition with: self definition.
        let: #sourcePosition with: (if: definition ~~ nil then: definition sourcePosition else: nil).

        stream nextPutAll: "Function(".

        if: name ~~ nil then: {
            let: #owner with: self owner.
            if: owner ~~ nil then: (stream print: owner; nextPutAll: " >> ").
            
            stream print: name.
            if: sourcePosition ~~ nil then: (stream space).

        }.
        if: sourcePosition ~~ nil then: {
            stream nextPutAll: "at "; print: sourcePosition
        }.

        stream nextPut: ')'c8
    } makeOverride.

FunctionDefinition
    withSelector: #hasAnyFlag: addMethod: {:(FunctionDefinition)self :(Bitflags)flag :: Boolean |
        (self flags & flag) ~= 0bflgs
    } makeFinal makeAlwaysInline;
    withSelector: #requiresArgumentExpansionDuringApplication addMethod: {:(FunctionDefinition)self :: Boolean |
        self hasAnyFlag: FunctionFlags::Memoized | FunctionFlags::Variadic
    } makeFinal makeAlwaysInline;
    withSelector: #isInline addMethod: {:(FunctionDefinition)self :: Boolean |
        self hasAnyFlag: FunctionFlags::Inline
    } makeFinal makeAlwaysInline;
    withSelector: #isAlwaysInline addMethod: {:(FunctionDefinition)self :: Boolean |
        self hasAnyFlag: FunctionFlags::AlwaysInline
    } makeFinal makeAlwaysInline;
    withSelector: #isNeverInline addMethod: {:(FunctionDefinition)self :: Boolean |
        self hasAnyFlag: FunctionFlags::NeverInline
    } makeFinal makeAlwaysInline;
    withSelector: #isWithoutSourceDebugging addMethod: {:(FunctionDefinition)self :: Boolean |
        self hasAnyFlag: FunctionFlags::WithoutSourceDebugging
    } makeFinal makeAlwaysInline;
    withSelector: #isNoGC addMethod: {:(FunctionDefinition)self :: Boolean |
        self hasAnyFlag: FunctionFlags::NoGC
    } makeFinal makeAlwaysInline.

ValueBox
    withSelector: #with: addClassMethod: {:(ValueBox class)self :value :: self |
        self basicNew
            value: value;
            yourself
    };
    withSelector: #_ addMethod: {:(ValueBox)self | self value };
    withSelector: #_: addMethod: {:(ValueBox)self :newValue | self value: newValue. newValue };
    withSelector: #":=" addMethod: {:(ValueBox)self :newValue | self value: newValue. newValue }.

Collection
    withSelector: #isEmpty addMethod: {:(Collection)self :: Boolean |
        self size = 0sz
    } makeInline;
    withSelector: #isNotEmpty addMethod: {:(Collection)self :: Boolean |
        self size ~= 0sz
    } makeInline;
    withSelector: #size addMethod: {:(Collection)self :: Size |
        self subclassResponsibility
    } makeAbstract;

    withSelector: #do: addMethod: {:(Collection)self :aBlock :: Void |
        self subclassResponsibility
    } makeAbstract;

    withSelector: #doWithoutTombstones: addMethod: {:(Collection)self :aBlock :: Void |
        self do: {:each :: Void |
            if: __tombstone__ ~~ each then: aBlock(each)
        }
    } makeInline;

    withSelector: #doWithIndex: addMethod: {:(Collection)self :aBlock :: Void |
        let: #i mutableWith: 0sz.
        self do: {:element :: Void |
            aBlock(element, i).
            i := 1sz + i
        }
    } makeVirtual;

    withSelector: #select: addMethod: {:(Collection)self :aBlock :: OrderedCollection |
        let: #result with: OrderedCollection new.
        self do: {:each :: Void |
            if: aBlock(each) then: (result add: each)
        }.
        result
    };
    withSelector: #reject: addMethod: {:(Collection)self :aBlock :: OrderedCollection |
        let: #result with: OrderedCollection new.
        self do: {:each :: Void |
            if: aBlock(each) not then: (result add: each)
        }.
        result
    };
    withSelector: #includes: addMethod: {:(Collection)self :element :: Boolean |
        self subclassResponsibility
    } makeAbstract;
    withSelector: #printOn: addMethod: {:(Collection)self :(Stream)stream :: Void |
        stream print: self class; nextPutAll: "(".
        self doWithIndex: {:element :(Size)index :: Void |
            if: index > 0sz then: (stream nextPutAll: ", ").
            stream print: element.
            void
        }.

        stream nextPutAll: ")"
    } makeOverride;
    withSelector: #fullPrintOn: addMethod: {:(Collection)self :(Stream)stream :: Void |
        stream print: self class; nextPutAll: "(".
        self doWithIndex: {:element :(Size)index :: Void |
            if: index > 0sz then: (stream nextPutAll: ", ").
            stream fullPrint: element.
            void
        }.

        stream nextPutAll: ")"
    } makeOverride;
    withSelector: #asArray addMethod: {:(Collection)self :: Array |
        let: #array with: (Array new: self size).
        self doWithIndex: {:element :(Size)index :: Void |
            array at: index put: element
        }.

        array
    } makeVirtual;
    withSelector: #addAllIntoOrderedCollection: addMethod: {:(Collection)self :(OrderedCollection)orderedCollection :: Void |
        self do: {:element :: Void |
            orderedCollection add: element
        }
    } makeVirtual.

SequenceableCollection
    withSelector: #=> addMethod: {:(SequenceableCollection)self :(Type)resultType :: SimpleFunctionType |
        SimpleFunctionTypeTemplate(self asArray, 0bflgs, resultType)
    } makePure makeFinal.

Association
    withSelector: #key:value: addClassMethod: {:(Association class)self :key :value :: self |
        self new key: key; value: value; yourself
    };
    withSelector: #printOn: addMethod: {:(Association)self :(Stream)stream :: Void |
        stream print: self key; nextPutAll: " -> "; print: self value
    } makeOverride.

WeakValueAssociation
    withSelector: #new addClassMethod: {:(WeakValueAssociation class)self :: self |
        self basicNew: 1sz
    } makeOverride;
    withSelector: #key:value: addClassMethod: {:(WeakValueAssociation class)self :key :value :: self |
        self new key: key; value: value; yourself
    };
    withSelector: #value addMethod: {:(WeakValueAssociation)self :: Untyped |
        (RawTuple::uncheckedSlotAt:)(self, 1sz)
    };
    withSelector: #value: addMethod: {:(WeakValueAssociation)self :(Untyped)newValue :: Void |
        (RawTuple::uncheckedSlotAt:put:)(self, 1sz, newValue)
    };
    withSelector: #printOn: addMethod: {:(WeakValueAssociation)self :(Stream)stream :: Void |
        stream print: self key; nextPutAll: " -> "; print: self value
    } makeOverride.

Object
    withSelector:#-> addMethod: {:(Object)self :value :: Association |
        Association key: self value: value
    }.

Dictionary
    withSelector: #do: addMethod: {:(Dictionary)self :aBlock :: Void |
        let: #storage with: self storage.
        if: storage ~~ nil then: {
            storage do: {:element :: Void |
                if: element ~~ nil then: aBlock(element).
            }
        }
    } makeOverride;
    withSelector: #ensureStorage addMethod: {:(Dictionary)self :: Void |
        if: self storage == nil then: (self storage: (Array new: 16sz)).
    };
    withSelector: #at:ifAbsent: addMethod: {:(Dictionary)self :key :ifAbsentBlock |
        self ensureStorage.
        let: #entryIndex with: (self scanFor: key) asSize.
        let: #storage with: self storage.
        let: #entry with: (storage at: entryIndex).
        if: entry == nil then: {
            ifAbsentBlock()
        } else: {
            entry value
        }
    } makeVirtual;
    withSelector: #at:ifAbsentPut: addMethod: {:(Dictionary)self :key :ifAbsentBlock |
        self ensureStorage.
        let: #entryIndex with: (self scanFor: key) asSize.
        let: #storage with: self storage.
        let: #entry with: (storage at: entryIndex).
        if: entry == nil then: {
            let: #value with: ifAbsentBlock().
            self at: key put: value.
            value
        } else: {
            entry value
        }
    };
    withSelector: #includesKey: addMethod: {:(Dictionary)self :(AnyValue)key :: Boolean |
        self ensureStorage.
        let: #entryIndex with: (self scanFor: key) asSize.
        let: #storage with: self storage.
        let: #entry with: (storage at: entryIndex).
        if: entry ~~ nil then: entry key = key else: false
    } makeVirtual;
    withSelector: #at:ifPresent: addMethod: {:(Dictionary)self :key :ifPresentBlock :: Void |
        self ensureStorage.
        let: #entryIndex with: (self scanFor: key) asSize.
        let: #storage with: self storage.
        let: #entry with: (storage at: entryIndex).
        if: entry ~~ nil then: {
            ifPresentBlock(entry value)
        }
    }.

IdentityDictionary
    withSelector: #untypedIncludesKey: addMethod: {:(IdentityDictionary)self :(Untyped)key :: Boolean |
        self ensureStorage.
        let: #entryIndex with: (self scanFor: key) asSize.
        let: #storage with: self storage.
        let: #entry with: (storage at: entryIndex).
        if: entry ~~ nil then: (Untyped::==)((RawTuple::slotAt:)(entry, 0sz), key) else: false
    };
    withSelector: #untypedAt: addMethod: {:(IdentityDictionary)self :(Untyped)key |
        self at: key
    };
    withSelector: #untypedAtOrNil: addMethod: {:(IdentityDictionary)self :(Untyped)key |
        self atOrNil: key
    };
    withSelector: #untypedAt:put: addMethod: {:(IdentityDictionary)self :(Untyped)key :value :: Void |
        self at: key put: value.
    };
    withSelector: #untypedAt:ifAbsentPut: addMethod: {:(IdentityDictionary)self :(Untyped)key :ifAbsentBlock |
        self ensureStorage.
        let: #entryIndex with: (self scanFor: key) asSize.
        let: #storage with: self storage.
        let: #entry with: (storage at: entryIndex).
        if: entry == nil then: {
            let: #value with: ifAbsentBlock().
            self untypedAt: key put: value.
            value
        } else: {
            entry value
        }
    };
    withSelector: #includesKey: addMethod: {:(IdentityDictionary)self :(AnyValue)key :: Boolean |
        self ensureStorage.
        let: #entryIndex with: (self scanFor: key) asSize.
        let: #storage with: self storage.
        let: #entry with: (storage at: entryIndex).
        if: entry ~~ nil then: entry key == key else: false
    } makeOverride.

MethodDictionary
    withSelector: #includesKey: addMethod: {:(MethodDictionary)self :(AnyValue)key :: Boolean |
        let: #storage with: self storage.
        if: storage ~~ nil then: {
            let: #entryIndex with: (self scanFor: key) asSize.
            let: #entryKey with: (storage at: entryIndex * 2sz).
            entryKey == key
        } else: {
            false
        }
    }.

Set
    withSelector: #do: addMethod: {:(Set)self :aBlock :: Void |
        let: #storage with: self storage.
        if: storage ~~ nil then: {
            storage do: {:element :: Void |
                if: __hashtableEmptyElement__ ~~ element then: aBlock(element).
            }
        }
    } makeOverride.

WeakSet
    withSelector: #do: addMethod: {:(WeakSet)self :aBlock :: Void |
        let: #storage with: self storage.
        if: storage ~~ nil then: {
            storage do: {:element :: Void |
                if: (__hashtableEmptyElement__ ~~ element) && (__tombstone__ ~~ element) then: aBlock(element).
            }
        }
    } makeOverride.

SequenceableCollection
    withSelector: #with: addClassMethod: {:(SequenceableCollection class)self :value :: self |
        (self new: 1sz)
            at: 0sz put: value;
            yourself
    };
    withSelector: #with:with: addClassMethod: {:(SequenceableCollection class)self :first :second :: self |
        (self new: 2sz)
            at: 0sz put: first;
            at: 1sz put: second;
            yourself
    };
    withSelector: #with:with:with: addClassMethod: {:(SequenceableCollection class)self :first :second :third :: self |
        (self new: 3sz)
            at: 0sz put: first;
            at: 1sz put: second;
            at: 2sz put: third;
            yourself
    };
    withSelector: #with:with:with:with: addClassMethod: {:(SequenceableCollection class)self :first :second :third :fourth :: self |
        (self new: 4sz)
            at: 0sz put: first;
            at: 1sz put: second;
            at: 2sz put: third;
            at: 3sz put: fourth;
            yourself
    };
    withSelector: #at: addMethod: {:(SequenceableCollection)self :(Size)index  |
        self subclassResponsibility
    } makeAbstract;
    withSelector: #at:put: addMethod: {:(SequenceableCollection)self :(Size)index :value :: Void |
        self subclassResponsibility
    } makeAbstract;
    withSelector: #atAllPut: addMethod: {:(SequenceableCollection)self :value :: Void |
        let: #i mutableWith: 0sz.
        let: #size with: self size.
        while: (i < size) do: (
            self at: i put: value
        ) continueWith: (i := i + 1sz)
    };
    withSelector: #anySatisfy: addMethod: {:(SequenceableCollection)self :aBlock :: Boolean |
        let: #i mutableWith: 0sz.
        let: #size with: self size.
        let: #hasFoundIt type: Boolean mutableWith: false.

        while: (if: hasFoundIt then: false else: i < self size) do: (
            hasFoundIt := aBlock(self at: i)
        ) continueWith: (i := i + 1sz).
        hasFoundIt
    } makeFinal;
    withSelector: #anySatisfyWithIndex: addMethod: {:(SequenceableCollection)self :aBlock :: Boolean |
        let: #i mutableWith: 0sz.
        let: #size with: self size.
        let: #hasFoundIt type: Boolean mutableWith: false.

        while: (if: hasFoundIt then: false else: i < self size) do: (
            hasFoundIt := aBlock(self at: i, i)
        ) continueWith: (i := i + 1sz).
        hasFoundIt
    } makeFinal;
    withSelector: #allSatisfy: addMethod: {:(SequenceableCollection)self :aBlock :: Boolean |
        let: #i mutableWith: 0sz.
        let: #size with: self size.
        let: #everythingIsFine type: Boolean mutableWith: true.

        while: (if: everythingIsFine then: i < self size else: false) do: (
            everythingIsFine := aBlock(self at: i)
        ) continueWith: (i := i + 1sz).
        everythingIsFine
    } makeFinal;
    withSelector: #allSatisfyWithIndex: addMethod: {:(SequenceableCollection)self :aBlock :: Boolean |
        let: #i mutableWith: 0sz.
        let: #size with: self size.
        let: #everythingIsFine type: Boolean mutableWith: true.

        while: (if: everythingIsFine then: i < self size else: false) do: (
            everythingIsFine := aBlock(self at: i, i)
        ) continueWith: (i := i + 1sz).
        everythingIsFine
    } makeFinal;
    withSelector: #indexOf: addMethod: {:(SequenceableCollection)self :value :: IntPointer |
        let: #i mutableWith: 0sz.
        let: #size with: self size.
        let: #hasFoundIt type: Boolean mutableWith: false.
        while: (i < size) do: (
            if: value = (self at: i) then: (return: i asIntPointer)
        ) continueWith: (i := i + 1sz).

        -1iptr
    };
    withSelector: #lastIndexOf: addMethod: {:(SequenceableCollection)self :value :: IntPointer |
        let: #i mutableWith: 0sz.
        let: #size with: self size.
        let: #bestFound mutableWith: -1iptr.
        while: (i < size) do: (
            if: value = (self at: i) then: (bestFound := i asIntPointer)
        ) continueWith: (i := i + 1sz).

        bestFound
    };
    withSelector: #includes: addMethod: {:(SequenceableCollection)self :element :: Boolean |
        let: #i mutableWith: 0sz.
        let: #size with: self size.
        let: #hasFoundIt type: Boolean mutableWith: false.

        while: (if: hasFoundIt then: false else: i < self size) do: (
            hasFoundIt := (self at: i) = element
        ) continueWith: (i := i + 1sz).
        hasFoundIt
    } makeOverride makeFinal;
    withSelector: #collect: addMethod: {:(SequenceableCollection)self :aBlock :: self species |
        let: #i mutableWith: 0sz.
        let: #size with: self size.
        let: #result with: (self species new: size).

        while: (i < size) do: (
            result at: i put: aBlock(self at: i)
        ) continueWith: (i := i + 1sz).

        result
    } makeFinal;
    withSelector: #collect:as: addMethod: {:(SequenceableCollection)self :aBlock :(SequenceableCollection class)resultType :: resultType |
        let: #i mutableWith: 0sz.
        let: #size with: self size.
        let: #result with: (resultType new: size).

        while: (i < size) do: (
            result at: i put: aBlock(self at: i)
        ) continueWith: (i := i + 1sz).

        result
    } makeFinal;
    withSelector: #collectWithIndex: addMethod: {:(SequenceableCollection)self :aBlock :: self species |
        let: #i mutableWith: 0sz.
        let: #size with: self size.
        let: #result with: (self species new: size).

        while: (i < size) do: (
            result at: i put: aBlock(self at: i, i)
        ) continueWith: (i := i + 1sz).

        result
    } makeFinal;
    withSelector: #detect:ifFound:ifNone: addMethod: {:(SequenceableCollection)self :aPredicate :foundBlock :notFoundBlock |
        let: #i mutableWith: 0sz.
        let: #size with: self size.
        let: #hasFoundIt type: Boolean mutableWith: false.
        let: #foundElement type: AnyValue mutableWith: nil.

        while: (if: hasFoundIt then: false else: i < self size) do: {
            foundElement := self at: i.
            hasFoundIt := aPredicate(foundElement)
        } continueWith: (i := i + 1sz).

        if: hasFoundIt
            then: foundBlock(foundElement)
            else: notFoundBlock(notFoundBlock)
    };
    withSelector: #detect:ifNone: addMethod: {:(SequenceableCollection)self :aPredicate :notFoundBlock |
        self detect: aPredicate ifFound: {:element | element } ifNone: notFoundBlock
    };
    withSelector: #do: addMethod: {:(SequenceableCollection)self :aBlock :: Void |
        let: #i mutableWith: 0sz.

        while: i < self size do: (
            aBlock(self at: i)
        ) continueWith: (i := i + 1sz)
    } makeOverride;
    withSelector: #doWithIndex: addMethod: {:(SequenceableCollection)self :aBlock :: Void |
        let: #i mutableWith: 0sz.
        let: #size with: self size.

        while: i < self size do: {
            aBlock(self at: i, i)
        } continueWith: (i := i + 1sz)
    } makeOverride;
    withSelector: #pairsDo: addMethod: {:(SequenceableCollection)self :aBlock :: Void |
        let: #i mutableWith: 0sz.
        let: #size with: self size.

        while: i < self size do: {
            aBlock(self at: i, self at: i + 1sz)
        } continueWith: (i := i + 2sz)
    } makeInline;
    withSelector: #-- addMethod: {:(SequenceableCollection)self :(SequenceableCollection)other :: self species |
        let: #size with: self size.
        let: #otherSize with: other size.
        if: otherSize = 0sz then: {
            if: self class == self species then: {
                return: self
            }
        }.

        if: size = 0sz then: {
            if: other class == self species then: {
                return: other
            }
        }.

        let: #result with: (self species new: size + otherSize ).

        {
            let: #i mutableWith: 0sz.
            while: i < size do: {
                result at: i put: (self at: i)
            } continueWith: (i := i + 1sz).
        }.

        {
            let: #i mutableWith: 0sz.
            while: i < otherSize do: {
                result at: size + i put: (other at: i)
            } continueWith: (i := i + 1sz).
        }.

        result
    } makeVirtual;
    withSelector: #replaceFrom:until:with: addMethod: {:(SequenceableCollection)self :(Size)start :(Size)stop :(SequenceableCollection)replacements :: Void |
        let: #i mutableWith: start.

        while: i < stop do: {
            self at: i put: (replacements at: i - start)
        } continueWith: (i := i + 1sz)
    };
    withSelector: #replaceAll:with: addMethod: {:(SequenceableCollection)self :oldObject :newObject :: Void |
        let: #i mutableWith: 0sz.
        let: #size with: self size.

        while: i < self size do: {
            if: (self at: i) = oldObject then: (self at: i put: newObject)
        } continueWith: (i := i + 1sz)
    };
    withSelector: #replaceAllWithDictionary: addMethod: {:(SequenceableCollection)self :(Dictionary)replacementDictionary :: Void |
        let: #i mutableWith: 0sz.
        let: #size with: self size.

        while: i < self size do: {
            replacementDictionary at: (self at: i) ifPresent: {:replacement :: Void |
                (self at: i put: replacement)
            }
        } continueWith: (i := i + 1sz)
    };
    withSelector: #first addMethod: {:(SequenceableCollection)self | self at: 0sz } makeFinal withEagerAnalysis;
    withSelector: #second addMethod: {:(SequenceableCollection)self | self at: 1sz } makeFinal withEagerAnalysis;
    withSelector: #third addMethod: {:(SequenceableCollection)self | self at: 2sz } makeFinal withEagerAnalysis;
    withSelector: #fourth addMethod: {:(SequenceableCollection)self | self at: 3sz } makeFinal withEagerAnalysis;
    withSelector: #fifth addMethod: {:(SequenceableCollection)self | self at: 4sz } makeFinal withEagerAnalysis;
    withSelector: #sixth addMethod: {:(SequenceableCollection)self | self at: 5sz } makeFinal withEagerAnalysis;
    withSelector: #seventh addMethod: {:(SequenceableCollection)self | self at: 6sz } makeFinal withEagerAnalysis;
    withSelector: #eighth addMethod: {:(SequenceableCollection)self | self at: 7sz } makeFinal withEagerAnalysis;
    withSelector: #ninth addMethod: {:(SequenceableCollection)self | self at: 8sz } makeFinal withEagerAnalysis;
    withSelector: #tenth addMethod: {:(SequenceableCollection)self | self at: 9sz } makeFinal withEagerAnalysis;

    withSelector: #last addMethod: {:(SequenceableCollection)self | self at: self size - 1sz } makeFinal withEagerAnalysis;
    withSelector: #nextToLast addMethod: {:(SequenceableCollection)self | self at: self size - 2sz } makeFinal withEagerAnalysis;

    withSelector: #copyFrom:until: addMethod: {:(SequenceableCollection)self :(Size)startIndex :(Size)endIndex :: self species |
        let: #resultSize with: (if: startIndex <= endIndex then: endIndex - startIndex else: 0sz).
        
        let: #result with: (self species new: resultSize).
        let: #i mutableWith: 0sz.
        while: i < resultSize do: (
            result at: i put: (self at: startIndex + i)
        ) continueWith: (i := i + 1sz).

        result
    } makeVirtual;
    withSelector: #copyFrom:count: addMethod: {:(SequenceableCollection)self :(Size)startIndex :(Size)count :: self species |
        self copyFrom: startIndex until: startIndex + count
    };

    withSelector: #first: addMethod: {:(SequenceableCollection)self :(Size)elementsToKeep :: self species |
        self copyFrom: 0sz until: elementsToKeep
    } makeAlwaysInline;
    withSelector: #allButFirst: addMethod: {:(SequenceableCollection)self :(Size)dropCount :: self species |
        self copyFrom: dropCount until: self size
    } makeAlwaysInline;
    withSelector: #allButFirst addMethod: {:(SequenceableCollection)self :: self species |
        self allButFirst: 1sz
    } makeAlwaysInline;
    withSelector: #allButLast: addMethod: {:(SequenceableCollection)self :(Size)dropCount :: self species |
        let: #size with: self size.
        self copyFrom: 0sz until: (if: dropCount >= size then: 0sz else: size - dropCount)
    } makeAlwaysInline;
    withSelector: #allButLast addMethod: {:(SequenceableCollection)self :: self species |
        self allButLast: 1sz
    } makeAlwaysInline;

    withSelector: #insertionSort:from:until: addMethod: {:(SequenceableCollection)self :lessThanComparison :(Size)startIndex :(Size)endIndex :: Void |
        ## Insertion sort algorithm from https://en.wikipedia.org/wiki/Insertion_sort [March 2023]
        let: #i mutableWith: startIndex + 1sz.
        let: #j mutableWith: 0sz.

        while: (i < endIndex) do: {
            let: #insertedElement with: (self at: i).
            j := i.
            while: (j > startIndex) && lessThanComparison(insertedElement, self at: j - 1sz) do: {
                self at: j put: (self at: j - 1sz)
            } continueWith: (j := j - 1sz).

            self at: j put: insertedElement.
        } continueWith: (i := i + 1sz)
    };
    withSelector: #partition:from:until: addMethod: {:(SequenceableCollection)self :lessThanComparison :(Size)startIndex :(Size)endIndex :: Size |
        let: #pivotIndex with: endIndex - 1sz.
        let: #pivot with: (self at: pivotIndex).

        let: #i mutableWith: startIndex.
        let: #j mutableWith: startIndex.
        while: (j < pivotIndex) do: {
            let: #element with: (self at: j).

            if: lessThanComparison(element, pivot) then: {
                if: i ~= j then: {
                    let: #temp with: (self at: i).
                    self at: i put: element.
                    self at: j put: temp.
                }.
                i := i + 1sz
            }
        } continueWith: (j := j + 1sz).

        let: #destElement with: (self at: i).
        self at: i put: pivot.
        self at: pivotIndex put: destElement.

        i
    };
    withSelector: #heapSort:from:until: addMethod: {:(SequenceableCollection)self :lessThanComparison :(Size)startIndex :(Size)endIndex :: Void |
        ## TODO: Implement this properly.
        self insertionSort: lessThanComparison from: startIndex until: endIndex
    };
    withSelector: #quickSort:from:until: addMethod: {:(SequenceableCollection)self :lessThanComparison :(Size)startIndex :(Size)endIndex :: Void |
        if: startIndex < endIndex then: {
            let: #partition with: (self partition: lessThanComparison from: startIndex until: endIndex).
            self quickSort: lessThanComparison from: startIndex until: partition.
            self quickSort: lessThanComparison from: partition + 1sz until: endIndex.
        }
    };
    withSelector: #introSort:from:until:maxDepth: addMethod: {:(SequenceableCollection)self :lessThanComparison :(Size)startIndex :(Size)endIndex :(Size)maxDepth :: Void |
        if: startIndex < endIndex then: {
            let: #rangeSize with: endIndex - startIndex.
            if: rangeSize <= 16sz then: {
                self insertionSort: lessThanComparison from: startIndex until: endIndex
            } else: {
                if: maxDepth = 0sz then: {
                    self heapSort: lessThanComparison from: startIndex until: endIndex
                } else: {
                    let: #partition with: (self partition: lessThanComparison from: startIndex until: endIndex).
                    self quickSort: lessThanComparison from: startIndex until: partition.
                    self quickSort: lessThanComparison from: partition + 1sz until: endIndex.
                }.
            }
        }
    };
    withSelector: #insertionSort: addMethod: {:(SequenceableCollection)self :lessThanComparison :: Void |
        self insertionSort: lessThanComparison from: 0sz until: self size
    };
    withSelector: #insertionSort addMethod: {:(SequenceableCollection)self :: Void |
        self sort: {:a :b :: Boolean | a < b }
    };
    withSelector: #heapSort: addMethod: {:(SequenceableCollection)self :lessThanComparison :: Void |
        self heapSort: lessThanComparison from: 0sz until: self size
    };
    withSelector: #heapSort addMethod: {:(SequenceableCollection)self :: Void |
        self sort: {:a :b :: Boolean | a < b }
    };
    withSelector: #quickSort: addMethod: {:(SequenceableCollection)self :lessThanComparison :: Void |
        self quickSort: lessThanComparison from: 0sz until: self size
    };
    withSelector: #quickSort addMethod: {:(SequenceableCollection)self :: Void |
        self sort: {:a :b :: Boolean | a < b }
    };
    withSelector: #sort: addMethod: {:(SequenceableCollection)self :lessThanComparison :: Void |
        self introSort: lessThanComparison from: 0sz until: self size maxDepth: 16sz
        ##self insertionSort: lessThanComparison from: 0sz until: self size
        ##self quickSort: lessThanComparison from: 0sz until: self size
        ##self heapSort: lessThanComparison from: 0sz until: self size
    };
    withSelector: #sort addMethod: {:(SequenceableCollection)self :: Void |
        self sort: {:a :b :: Boolean | a < b }
    };
    withSelector: #sorted: addMethod: {:(SequenceableCollection)self :lessThanComparison :: self __type__ |
        self copy sort: lessThanComparison; yourself
    };
    withSelector: #sorted addMethod: {:(SequenceableCollection)self :: self __type__ |
        self sorted: {:a :b :: Boolean | a < b }
    }.

OrderedCollection
    withSelector: #arrayType addClassMethod: {:(OrderedCollection class)self :: Array class |
        Array
    } makeVirtual;
    withSelector: #new: addClassMethod: {:(OrderedCollection class)self :(Size)initialSize :: self |
        self basicNew initializeWithSize: initialSize; yourself
    } makeOverride makeFinal;
    withSelector: #initialize addMethod: {:(OrderedCollection)self :: Void |
        self size: 0sz
    } makeOverride;
    withSelector: #initializeWithSize: addMethod: {:(OrderedCollection)self :(Size)initialSize :: Void |
        self size: initialSize.
        self storage: (self class arrayType new: initialSize).
    };
    withSelector: #capacity addMethod: {:(OrderedCollection)self :: Size |
        let: #storage with: self storage.
        if: storage == nil then: 0sz else: storage size
    };
    withSelector: #addAll: addMethod: {:(OrderedCollection)self :(Collection)elements :: Void|
        elements addAllIntoOrderedCollection: self
    };
    withSelector: #at: addMethod: {:(OrderedCollection)self :(Size)index |
        if: index < self size then: {
            self storage at: index
        } else: {
            self errorSubscriptBounds: index
        }
    } makeOverride;
    withSelector: #at:put: addMethod: {:(OrderedCollection)self :(Size)index :value :: Void |
        if: index < self size then: {
            self storage at: index put: value
        } else: {
            self errorSubscriptBounds: index
        }
    } makeOverride;
    withSelector: #removeAllThat: addMethod: {:(OrderedCollection)self :aPredicate :: Void |
        let: #size with: self size.
        let: #storage with: self storage.
        let: #newSize mutableWith: 0sz.
        let: #i mutableWith: 0sz.

        while: i < size do: {
            let: #element with: (storage at: i).
            (__tombstone__ == element) || aPredicate(element) ifFalse: {
                storage at: newSize put: element.
                newSize := newSize + 1sz
            }
        } continueWith: (i := i + 1sz).

        self size: newSize
    };
    withSelector: #removeAllOcurrencesOf: addMethod: {:(OrderedCollection)self :value :: Void |
        let: #size with: self size.
        let: #storage with: self storage.
        let: #newSize mutableWith: 0sz.
        let: #i mutableWith: 0sz.

        while: i < size do: {
            let: #element with: (storage at: i).
            (__tombstone__ == element) || (element = value) ifFalse: {
                storage at: newSize put: element.
                newSize := newSize + 1sz
            }
        } continueWith: (i := i + 1sz).

        self size: newSize
    };
    withSelector: #postCopy addMethod: {:(OrderedCollection)self :: Void |
        self storage: self storage copy
    } makeOverride.

Dictionary
    withSelector: #new: addClassMethod: {:(Dictionary class)self :(Size)initialCapacity :: self |
        self basicNew initializeWithCapacity: initialCapacity; yourself
    } makeOverride makeFinal;
    withSelector: #initializeWithCapacity: addMethod: {:(Dictionary)self :(Size)initialCapacity :: Void |
        let: #requiredStorageCapacity with: initialCapacity * 130sz / 100sz.
        self storage: (Array new: requiredStorageCapacity).
    };
    withSelector: #postCopy addMethod: {:(OrderedCollection)self :: Void |
        if: self storage ~~ nil then: {
            self storage: (self storage collect: {:(LookupKey)assoc :: LookupKey | assoc copy})
        }.
    } makeOverride.

MethodDictionary
    withSelector: #postCopy addMethod: {:(OrderedCollection)self :: Void |
        self storage: self storage copy
    } makeOverride.

Set
    withSelector: #postCopy addMethod: {:(Set)self :: Void |
        self storage: self storage copy
    } makeOverride.

WeakOrderedCollection
    withSelector: #arrayType addClassMethod: {:(WeakOrderedCollection class)self :: Array class |
        WeakArray
    } makeOverride.
    
Array
    withSelector: #new: addClassMethod: {:(Array class)self :(Size)initialSize :: self |
        self basicNew: initialSize
    } makeOverride makeFinal;
    withSelector: #asArray addMethod: {:(Array)self :: Array | self } makeOverride;
    withSelector: #asArraySlice addMethod: {:(Array)self :: ArraySlice |
        ArraySlice basicNew
            elements: self;
            offset: 0sz;
            size: self size;
            yourself
    }.

ByteArray
    withSelector: #new: addClassMethod: {:(ByteArray class)self :(Size)initialSize :: self |
        self basicNew: initialSize
    } makeOverride makeFinal;
    withSelector: #uint8At: addMethod: {:(ByteArray)self :(Size)index :: UInt8 |
        index >= self __byteSize__ ifTrue: (self errorSubscriptBounds: index).
        self __uncheckedByteSlotAt__: index
    } makeFinal makeAlwaysInline;
    withSelector: #uint8At:put: addMethod: {:(ByteArray)self :(Size)index :(UInt8)value :: Void |
        index >= self __byteSize__ ifTrue: (self errorSubscriptBounds: index).
        self __uncheckedByteSlotAt__: index put: value
    } makeFinal makeAlwaysInline;

    withSelector: #at: addMethod: {:(ByteArray)self :(Size)index |
        index >= self __byteSize__ ifTrue: (self errorSubscriptBounds: index).
        self __uncheckedByteSlotAt__: index
    } makeOverride makeFinal makeAlwaysInline;
    withSelector: #at:put: addMethod: {:(ByteArray)self :(Size)index :value :: Void |
        index >= self __byteSize__ ifTrue: (self errorSubscriptBounds: index).
        self __uncheckedByteSlotAt__: index put: (value uncheckedDownCastTo: UInt8)
    } makeOverride makeFinal makeAlwaysInline;
    withSelector: #size addMethod: {:(ByteArray)self :: Size |
        self __byteSize__
    } makeOverride makeFinal;

    withSelector: #printOn: addMethod: {:(ByteArray)self :(Stream)stream :: Void |
        stream nextPutAll: "#[".
        self doWithIndex: {:element :index :: Void |
            if: index > 0sz then: (stream nextPutAll: ". ").
            stream print: element.
            void
        }.

        stream nextPutAll: "]"
    } makeOverride.

String
    withSelector: #new: addClassMethod: {:(String class)self :(Size)initialSize :: self |
        self basicNew: initialSize
    } makeOverride makeFinal;
    withSelector: #char8At: addMethod: {:(String)self :(Size)index :: Char8 |
        index >= self __byteSize__ ifTrue: (self errorSubscriptBounds: index).
        (self __uncheckedByteSlotAt__: index) asChar8
    } makeFinal makeAlwaysInline;
    withSelector: #char8At:put: addMethod: {:(String)self :(Size)index :(Char8)value :: Void |
        index >= self __byteSize__ ifTrue: (self errorSubscriptBounds: index).
        self __uncheckedByteSlotAt__: index put: value asUInt8
    } makeFinal makeAlwaysInline;
    withSelector: #at: addMethod: {:(String)self :(Size)index |
        index >= self __byteSize__ ifTrue: (self errorSubscriptBounds: index).
        (self __uncheckedByteSlotAt__: index) asChar8
    } makeOverride makeFinal makeAlwaysInline;
    withSelector: #at:put: addMethod: {:(String)self :(Size)index :value :: Void |
        index >= self __byteSize__ ifTrue: (self errorSubscriptBounds: index).
        self __uncheckedByteSlotAt__: index put: (value uncheckedDownCastTo: Char8) asUInt8
    } makeOverride makeFinal makeAlwaysInline;
    withSelector: #size addMethod: {:(String)self :: Size |
        self __byteSize__
    } makeOverride makeFinal makeAlwaysInline;
    withSelector: #padLeft:with: addMethod: {:(String)self :(Size)requiredLength :(Char8)paddingCharacter :: self species |
        let: #size with: self size.
        if: size >= requiredLength then: self
        else: {
            let: #paddingSize with: requiredLength - size.
            let: #result with: (self species new: requiredLength).

            let: #i mutableWith: 0sz.
            while: i < paddingSize do: (
                result char8At: i put: paddingCharacter
            ) continueWith: (i := i + 1sz).
            
            i := 0sz.
            while: i < size do: (
                result char8At: i + paddingSize put: (self at: i)
            ) continueWith: (i := i + 1sz).
            result
        }
    };
    withSelector: #padLeft: addMethod: {:(String)self :(Size)requiredLength :: self species |
        self padLeft: requiredLength with: ' 'c8
    }.

StringSymbol
    withSelector: #at: addMethod: {:(StringSymbol)self :(Size)index :: Char8 |
        index >= self __byteSize__ ifTrue: (self errorSubscriptBounds: index).
        (self __uncheckedByteSlotAt__: index) asChar8
    } makeFinal makeAlwaysInline;
    withSelector: #at:put: addMethod: {:(StringSymbol)self :(Size)index :(Char8)value :: Void |
        index >= self __byteSize__ ifTrue: (self errorSubscriptBounds: index).
        self __uncheckedByteSlotAt__: index put: value asUInt8
    } makeFinal makeAlwaysInline;
    withSelector: #size addMethod: {:(StringSymbol)self :: Size |
        self __byteSize__
    }.

ByteStream
    withSelector: #nextPutUInt8: addMethod: {:(ByteStream)self :(UInt8)value :: Void |
        self nextPut: value
    };
    withSelector: #nextPutInt8: addMethod: {:(ByteStream)self :(Int8)value :: Void |
        self nextPutUInt8: value asUInt8
    };
    withSelector: #nextPutUInt16: addMethod: {:(ByteStream)self :(UInt16)value :: Void |
        self
            nextPut: value asUInt8;
            nextPut: (value >> 8u16) asUInt8
    };
    withSelector: #nextPutInt16: addMethod: {:(ByteStream)self :(Int16)value :: Void |
        self nextPutUInt16: value asUInt16
    };
    withSelector: #nextPutUInt32: addMethod: {:(ByteStream)self :(UInt32)value :: Void |
        self
            nextPut: value asUInt8;
            nextPut: (value >> 8u32) asUInt8;
            nextPut: (value >> 16u32) asUInt8;
            nextPut: (value >> 24u32) asUInt8
    };
    withSelector: #nextPutInt32: addMethod: {:(ByteStream)self :(Int32)value :: Void |
        self nextPutUInt32: value asUInt32
    };
    withSelector: #nextPutUInt64: addMethod: {:(ByteStream)self :(UInt64)value :: Void |
        self
            nextPut: value asUInt8;
            nextPut: (value >> 8u64) asUInt8;
            nextPut: (value >> 16u64) asUInt8;
            nextPut: (value >> 24u64) asUInt8;

            nextPut: (value >> 32u64) asUInt8;
            nextPut: (value >> 40u64) asUInt8;
            nextPut: (value >> 48u64) asUInt8;
            nextPut: (value >> 56u64) asUInt8
    };
    withSelector: #nextPutInt64: addMethod: {:(ByteStream)self :(Int64)value :: Void |
        self nextPutUInt64: value asUInt64
    }.

ArraySlice
    withSelector: #new: addClassMethod: {:(ArraySlice class)self :(Size)size :: self |
        self basicNew
            elements: (Array basicNew: size);
            offset: 0sz;
            size: size;
            yourself
    } makeOverride;
    withSelector: #at: addMethod: {:(ArraySlice)self :(Size)index |
        if: index < self size then: {
            self elements at: index + self offset
        } else: {
            self errorSubscriptBounds: index
        }
    } makeOverride;
    withSelector: #at:put: addMethod: {:(ArraySlice)self :(Size)index :value :: Void |
        if: index < self size then: {
            self elements at: index + self offset put: value
        } else: {
            self errorSubscriptBounds: index
        }
    } makeOverride.

MethodDictionary
    withSelector: #keysAndValuesDo: addMethod: {:(MethodDictionary)self :aBlock :: Void |
        let: #storage with: self storage.
        if: storage ~~ nil then: {
            self storage pairsDo: {:selector :method :: Void |
                if: selector ~~ __hashtableEmptyElement__ then: aBlock(selector, method)
            }
        }
    };
    withSelector: #do: addMethod: {:(MethodDictionary)self :aBlock :: Void |
        self keysAndValuesDo: {:selector :method :: Void |
            aBlock(Association key: selector value: method)
        }
    } makeOverride.

## Primitive numbers meta methods.
Char8 class
    withSelector: #defaultValue addMethod: {:(Char8 class)self :: Char8 | 0c8 } makeOverride;
    withSelector: #zero addMethod: {:(Char8 class)self :: Char8 | 0c8 } makePure makeFinal;
    withSelector: #one addMethod: {:(Char8 class)self :: Char8 | 1c8 } makePure makeFinal.

UInt8 class
    withSelector: #defaultValue addMethod: {:(UInt8 class)self :: UInt8 | 0u8 } makeOverride;
    withSelector: #zero addMethod: {:(UInt8 class)self :: UInt8 | 0u8 } makePure makeFinal;
    withSelector: #one addMethod: {:(UInt8 class)self :: UInt8 | 1u8 } makePure makeFinal.

Int8 class
    withSelector: #defaultValue addMethod: {:(Int8 class)self :: Int8 | 0i8 } makeOverride;
    withSelector: #zero addMethod: {:(Int8 class)self :: Int8 | 0i8 } makePure makeFinal;
    withSelector: #one addMethod: {:(Int8 class)self :: Int8 | 1i8 } makePure makeFinal.

Char16 class
    withSelector: #defaultValue addMethod: {:(Char16 class)self :: Char16 | 0c16 } makeOverride;
    withSelector: #zero addMethod: {:(Char16 class)self :: Char16 | 0c16 } makePure makeFinal;
    withSelector: #one addMethod: {:(Char16 class)self :: Char16 | 1c16 } makePure makeFinal.

UInt16 class
    withSelector: #defaultValue addMethod: {:(UInt16 class)self :: UInt16 | 0u16 } makeOverride;
    withSelector: #zero addMethod: {:(UInt16 class)self :: UInt16 | 0u16 } makePure makeFinal;
    withSelector: #one addMethod: {:(UInt16 class)self :: UInt16 | 1u16 } makePure makeFinal.

Int16 class
    withSelector: #defaultValue addMethod: {:(Int16 class)self :: Int16 | 0i16 } makeOverride;
    withSelector: #zero addMethod: {:(Int16 class)self :: Int16 | 0i16 } makePure makeFinal;
    withSelector: #one addMethod: {:(Int16 class)self :: Int16 | 1i16 } makePure makeFinal.

Char32 class
    withSelector: #defaultValue addMethod: {:(Char32 class)self :: Char32 | 0c32 } makeOverride;
    withSelector: #zero addMethod: {:(Char32 class)self :: Char32 | 0c32 } makePure makeFinal;
    withSelector: #one addMethod: {:(Char32 class)self :: Char32 | 1c32 } makePure makeFinal.

Char32
    withSelector: #c8 addMethod: Char32 >> #asChar8;
    withSelector: #c16 addMethod: Char32 >> #asChar16;
    withSelector: #c32 addMethod: Char32 >> #asChar32.

UInt32 class
    withSelector: #defaultValue addMethod: {:(UInt32 class)self :: UInt32 | 0u32 } makeOverride;
    withSelector: #zero addMethod: {:(UInt32 class)self :: UInt32 | 0u32 } makePure makeFinal;
    withSelector: #one addMethod: {:(UInt32 class)self :: UInt32 | 1u32 } makePure makeFinal.

Int32 class
    withSelector: #defaultValue addMethod: {:(Int32 class)self :: Int32 | 0i32 } makeOverride;
    withSelector: #zero addMethod: {:(Int32 class)self :: Int32 | 0i32 } makePure makeFinal;
    withSelector: #one addMethod: {:(Int32 class)self :: Int32 | 1i32 } makePure makeFinal;
    withSelector: #minVal addMethod: {:(Int32 class)self :: Int32 | 16r80000000 i32 } makePure makeFinal;
    withSelector: #maxVal addMethod: {:(Int32 class)self :: Int32 | 16r7FFFFFFF i32 } makePure makeFinal.

Int64 class
    withSelector: #defaultValue addMethod: {:(Int64 class)self :: Int64 | 0i64 } makeOverride;
    withSelector: #zero addMethod: {:(Int64 class)self :: Int64 | 0i64 } makePure makeFinal;
    withSelector: #one addMethod: {:(Int64 class)self :: Int64 | 1i64 } makePure makeFinal.

UInt64 class
    withSelector: #defaultValue addMethod: {:(UInt64 class)self :: UInt64 | 0u64 } makeOverride;
    withSelector: #zero addMethod: {:(UInt64 class)self :: UInt64 | 0u64 } makePure makeFinal;
    withSelector: #one addMethod: {:(UInt64 class)self :: UInt64 | 1u64 } makePure makeFinal.

Float32 class
    withSelector: #defaultValue addMethod: {:(Float32 class)self :: Float32 | 0.0f32 } makeOverride;
    withSelector: #zero addMethod: {:(Float32 class)self :: Float32 | 0.0f32 } makePure makeFinal;
    withSelector: #one addMethod: {:(Float32 class)self :: Float32 | 1.0f32 } makePure makeFinal.

Float64 class
    withSelector: #defaultValue addMethod: {:(Float64 class)self :: Float64 | 0.0 } makeOverride;
    withSelector: #zero addMethod: {:(Float64 class)self :: Float64 | 0.0 } makePure makeFinal;
    withSelector: #one addMethod: {:(Float64 class)self :: Float64 | 1.0 } makePure makeFinal.

Integer class
    withSelector: #defaultValue addMethod: {:(Integer class)self :: Integer | 0 } makeOverride;
    withSelector: #zero addMethod: {:(Integer class)self :: Integer | 0 } makePure makeFinal;
    withSelector: #one addMethod: {:(Integer class)self :: Integer | 1 } makePure makeFinal.

Boolean class
    withSelector: #defaultValue addMethod: {:(Boolean class)self :: Boolean | false } makeOverride makePure makeFinal.

TypeSlot
    withSelector: #requiresBasicInitialization addMethod: {:(TypeSlot)self :: Boolean |
        let: #type with: self type.
        (self initialValueBlock ~~ nil) || ((type ~~ nil) && (type isNullable not))
    } withEagerAnalysis;
    withSelector: #initialValueExpression addMethod: {:(TypeSlot)self :: ASTNode |
        let: #initialValueBlock with: self initialValueBlock.
        if: initialValueBlock ~~ nil then: {
            error("Generate initialValueBlock application")
        } else: {
            let: #type with: self type.
            let: #initialValueLiteral with: (ASTLiteralNode new
                sourcePosition: self sourcePosition;
                value: (if: type ~~ nil then: type defaultValue else: nil);
                yourself).
            if: type literalConstantRequiresShallowCopy
            then: (ASTFunctionApplicationNode new
                sourcePosition: self sourcePosition;
                functionExpression: (ASTLiteralNode new
                    sourcePosition: self sourcePosition;
                    value: RawTuple::shallowCopy;
                    yourself);
                arguments: (Array with: initialValueLiteral);
                applicationFlags: 0bflgs;
                yourself)
            else: initialValueLiteral
        }
    };
    withSelector: #validOffset addMethod: {:(TypeSlot)self :: Size |
        let: #owner with: self owner.
        if: owner ~~ nil then: ((owner downCastTo: Type) ensureLayoutIsComputed).
        self offset.
    };
    withSelector: #validReferenceType addMethod: {:(TypeSlot)self :: Type |
        if: self referenceType == nil then: (self referenceType: self type memberRef).
        self referenceType
    }.

Type
    withSelector: #validSlotsWithBasicInitialization addMethod: {:(Type)self :: Array |
        if: self slotsWithBasicInitialization == nil then: {
            let: #supertype with: self supertype.
            let: #result with: OrderedCollection new.
            if: supertype ~~ nil then: (result addAll: supertype validSlotsWithBasicInitialization).

            self validSlots do: {:(TypeSlot)typeSlot :: Void |
                if: typeSlot requiresBasicInitialization then: {
                    result add: typeSlot
                }.
            }.

            self slotsWithBasicInitialization: result asArray
        }.
        self slotsWithBasicInitialization
    };
    ensureAnalysisOfMethodWithSelector: #validSlotsWithBasicInitialization;
    withSelector: #needsNonDefaultBasicInitialization addMethod: {:(Type)self :: Boolean |
        self validSlotsWithBasicInitialization anySatisfy: {:(TypeSlot)typeSlot :: Boolean | typeSlot initialValueBlock ~~ nil }
    } makeVirtual.

{
    let: #createBasicInitializeMethod with: {:(Type)self :: Void |
        let: #ReceiverType with: self asReceiverType.
        let: #slots with: self validSlotsWithBasicInitialization.
        let: #slotCount with: slots size.

        let: #makeTypeSlotNode with: {:(TypeSlot)eachSlot :: ASTNode |
            ASTTupleSlotNamedAtPutNode new
                sourcePosition: eachSlot sourcePosition;
                tupleExpression: (ASTIdentifierReferenceNode new
                    sourcePosition: eachSlot sourcePosition;
                    value: #self;
                    yourself);
                valueExpression: eachSlot initialValueExpression;
                boundSlot: eachSlot;
                yourself
            }.

        let: #defaultValueSlots with: (slots select: {:(TypeSlot)each :: Boolean | each initialValueBlock == nil}).
        let: #defaultValueSlotInitialization with: (ASTSequenceNode new
            expressions: (defaultValueSlots collect: makeTypeSlotNode as: Array);
            pragmas: #();
            yourself).

        let: #initialValueSlots with: (slots select: {:(TypeSlot)each :: Boolean | each initialValueBlock ~~ nil}).
        let: #initialValueSlotInitialization with: (initialValueSlots collect: makeTypeSlotNode as: Array).

        let: #methodNode with: (ASTLambdaNode new
            arguments: (Array with: (ASTArgumentNode new
                isForAll: false;
                name: (ASTLiteralNode new
                    value: #self;
                    yourself);
                type: (ASTLiteralNode new
                    value: ReceiverType;
                    yourself);
                yourself));
            resultType: (ASTLiteralNode new
                value: Void;
                yourself);
            body: (ASTSequenceNode new
                expressions: (Array with: (ASTIfNode new
                    conditionExpression: (ASTFunctionApplicationNode new
                        functionExpression: (ASTLiteralNode new
                            value: ObjectModel::isLogical;
                            yourself);
                        arguments: #();
                        applicationFlags: 0bflgs;
                        yourself);
                    trueExpression: defaultValueSlotInitialization;
                    yourself)) -- initialValueSlotInitialization;
                    pragmas: #();
                yourself);
            flags: (if: self supertype ~~ nil
                then: FunctionFlags::Override
                else: FunctionFlags::Virtual);
            hasLazyAnalysis: false;
            yourself).
        let: #methodFromAST with: (methodNode analyzeAndEvaluateWithEnvironment: Environment defaultForEvaluation).

        self basicInitializeMethod: methodFromAST.
        self withSelector: #basicInitialize addOrReplaceMethod: self basicInitializeMethod.
    } makeVirtual withEagerAnalysis.

    createBasicInitializeMethod(Object).
    createBasicInitializeMethod(Array).
    createBasicInitializeMethod(Environment).
    createBasicInitializeMethod(OrderedCollection).
    createBasicInitializeMethod(Function).
    createBasicInitializeMethod(FunctionDefinition).
    createBasicInitializeMethod(String).
    createBasicInitializeMethod(StringSymbol).
    createBasicInitializeMethod(SymbolArgumentBinding).
    createBasicInitializeMethod(SymbolCaptureBinding).
    createBasicInitializeMethod(SymbolLocalBinding).
    createBasicInitializeMethod(SimpleFunctionType).
    createBasicInitializeMethod(ASTArgumentNode).
    createBasicInitializeMethod(ASTIdentifierReferenceNode).
    createBasicInitializeMethod(ASTIfNode).
    createBasicInitializeMethod(ASTLambdaNode).
    createBasicInitializeMethod(ASTFunctionApplicationNode).
    createBasicInitializeMethod(ASTVariableDefinitionNode).
    createBasicInitializeMethod(ASTLiteralNode).
    createBasicInitializeMethod(ASTSequenceNode).
    createBasicInitializeMethod(ASTTupleSlotNamedAtPutNode).
    Type withSelector: #createBasicInitializeMethod replaceMethod: createBasicInitializeMethod
}.

Type
    withSelector: #validSubtypeList addMethod: {:(Type)self :: WeakOrderedCollection |
        if: self subtypes == nil then: (self subtypes: WeakOrderedCollection new).
        self subtypes
    };
    withSelector: #addSubtype: addMethod: {:(Type)self :(Type)aSubtype :: Void |
        let: #subtypes with: self validSubtypeList.
        if: (subtypes includes: aSubtype) not then: (subtypes add: aSubtype)
    };
    withSelector: #registerInSuperMetatype addMethod: {:(Type)self :: Void |
        ## By default do nothing
    } makeVirtual;
    withSelector: #registerInSupertype addMethod: {:(Type)self :: Void |
        let: #supertype with: self supertype.
        if: supertype ~~ nil then: (supertype addSubtype: self).
        self __type__ registerInSuperMetatype
    };
    withSelector: #withSupertypesDo: addMethod: {:(Type)self :aBlock :: Void |
        aBlock(self).
        let: #supertype with: self supertype.
        if: supertype ~~ nil then: (supertype withSupertypesDo: aBlock).
    };
    withSelector: #subtypesDo: addMethod: {:(Type)self :aBlock :: Void |
        let: #subtypes with: self subtypes.
        if: subtypes ~~ nil then: (subtypes doWithoutTombstones: aBlock)
    };
    withSelector: #withSubtypesDo: addMethod: {:(Type)self :aBlock :: Void |
        aBlock(self).
        self subtypesDo: aBlock.
    };
    withSelector: #allSubtypesDo: addMethod: {:(Type)self :aBlock :: Void |
        self subtypesDo: {:(Type)each :: Void |
            aBlock(each).
            each allSubtypesDo: aBlock
        }
    };
    withSelector: #withAllSubtypesDo: addMethod: {:(Type)self :aBlock :: Void |
        aBlock(self).
        self allSubtypesDo: aBlock
    };

    withSelector: #allSubtypes addMethod: {:(Type)self :: OrderedCollection |
        let: #result with: OrderedCollection new.
        self allSubtypesDo: {:(Type)each :: Void |
            result add: each
        }.
        result
    };
    withSelector: #withAllSubtypes addMethod: {:(Type)self :: OrderedCollection |
        let: #result with: OrderedCollection new.
        self withAllSubtypesDo: {:(Type)each :: Void |
            result add: each
        }.
        result
    };

    withSelector: #selectorsDo: addMethod: {:(Type)self :aBlock :: Void |
        let: #methodDictionary with: self methodDictionary.
        if: methodDictionary ~~ nil then: (methodDictionary keysAndValuesDo: {:key :value |
            aBlock(key)
        })
    };
    withSelector: #selectors addMethod: {:(Type)self :: Array |
        let: #selectors with: OrderedCollection new.

        self selectorsDo: {:each :: Void |
            selectors add: each
        }.

        selectors asArray
    };
    withSelector: #allMethodsDo: addMethod: {:(Type)self :aBlock :: Void |
        let: #dictionaryIterationBlock with: {:selector :method :: Void |
            aBlock(method)
        }.

        let: #macroMethodDictionary with: self macroMethodDictionary.
        if: macroMethodDictionary ~~ nil then: (macroMethodDictionary keysAndValuesDo: dictionaryIterationBlock).

        let: #methodDictionary with: self methodDictionary.
        if: methodDictionary ~~ nil then: (methodDictionary keysAndValuesDo: dictionaryIterationBlock).

        let: #fallbackMethodDictionary with: self fallbackMethodDictionary.
        if: fallbackMethodDictionary ~~ nil then: (fallbackMethodDictionary keysAndValuesDo: dictionaryIterationBlock).
    };
    withSelector: #allInstancesDo: addMethod: {:(Type)self :aBlock :: Void |
        let: #instance mutableWith: RawTuple::firstInstanceWithType(self).
        while: instance ~~ nil do: (
            aBlock(instance)
        ) continueWith: (instance := RawTuple::nextInstanceWithSameType(instance))
    };
    withSelector: #allInstances addMethod: {:(Type)self :: Array |
        let: #instance mutableWith: RawTuple::firstInstanceWithType(self).
        let: #result with: OrderedCollection new.
        while: instance ~~ nil do: (
            result add: instance
        ) continueWith: (instance := RawTuple::nextInstanceWithSameType(instance)).

        result asArray
    };
    withSelector: #allSlotsDo: addMethod: {:(Type)self :(TypeSlot => Void)aBlock :: Void |
        let: #supertype with: self supertype.
        if: supertype ~~ nil then: (supertype allSlotsDo: aBlock).
        self validSlots do: aBlock
    }.

Metatype
    withSelector: #registerInSuperMetatype addMethod: {:(Type)self :: Void |
        self registerInSupertype
    } makeOverride.

## Construct the subtype links
BootstrapEnv::IntrinsicTypes do: {:(Type)each :: Void |
    each registerInSupertype 
}.

TypeSlot
    withSelector: #named:type:flags: addClassMethod: {:(TypeSlot class)self :name :(Type)type :(Size)flags :: self |
        self new
            name: name;
            type: type;
            flags: flags;
            localIndex: 0sz;
            index: 0sz;
            yourself
    };
    withSelector: #named:type:flags:initialValueBlock: addClassMethod: {:(TypeSlot class)self :name :(Type)type :(Size)flags :(AnyValue)initialValueBlock :: self |
        self new
            name: name;
            type: type;
            flags: flags;
            localIndex: 0sz;
            index: 0sz;
            initialValueBlock: initialValueBlock;
            yourself
    };
    withSelector: #named:type: addClassMethod: {:(TypeSlot class)self :name :(Type)type :: self |
        self named: name type: type flags: TypeSlotFlags::None
    };
    withSelector: #named:flags: addClassMethod: {:(TypeSlot class)self :name :(Size)flags :: self |
        self named: name type: AnyValue flags: flags
    };
    withSelector: #named:flags:initialValueBlock: addClassMethod: {:(TypeSlot class)self :name :(Size)flags :(AnyValue)initialValueBlock :: self |
        self named: name type: AnyValue flags: flags initialValueBlock: initialValueBlock
    };
    withSelector: #named: addClassMethod: {:(TypeSlot class)self :name :(Type)type :: self |
        self publicNamed: name type: AnyValue
    };
    withSelector: #publicNamed:type: addClassMethod: {:(TypeSlot class)self :name :(Type)type :: self |
        self named: name type: type flags: TypeSlotFlags::Public
    };
    withSelector: #publicNamed: addClassMethod: {:(TypeSlot class)self :name :(Type)type :: self |
        self publicNamed: name type: AnyValue
    }.

Type
    withSelector: #generatePublicAccessors addMethod: {:(Type)self :: Void |
        let: #baseSlotIndex with: self validSupertypeTotalSlotCount.
        self slots doWithIndex: {:slot :index :: Void |
            let: #slotIndex with: baseSlotIndex + index.
            slot localIndex: index.
            slot index: slotIndex.
            slot generateAccessorsOn: self
        }.
    } makeVirtual.

Metatype
    withSelector: #printOn: addMethod: {:(Metatype)self :(Stream)stream :: Void |
        let: #thisType with: self thisType.
        if: thisType ~~ nil
        then: (stream print: thisType; nextPutAll: " __type__")
        else: (stream nextPutAll: "a "; print: self __type__)
    } makeOverride.

Metaclass
    withSelector: #thisClass addMethod: {:(Metaclass)self :: Type | self thisType };
    withSelector: #thisClass: addMethod: {:(Metaclass)self :(Type)thisClass :: Void | self thisType: thisClass };
    withSelector: #printOn: addMethod: {:(Metaclass)self :(Stream)stream :: Void |
        let: #thisClass with: self thisClass.
        if: thisClass ~~ nil
        then: (stream print: thisClass; nextPutAll: " class")
        else: (stream nextPutAll: "a "; print: self __type__)
    } makeOverride.

AddressSpace
    withSelector: #uniqueInstance addClassMethod: {:(AddressSpace class)self :: self |
        if: (Untyped::==)(self __slotNamedAt__: #emptyTrivialSingleton, nil) then: {
            self __slotNamedAt__: #emptyTrivialSingleton put: self basicAllocate
        }.

        self __slotNamedAt__: #emptyTrivialSingleton
    }.
    
Type
    withSelector: #refFor: addMethod: {:(Type)self :(AddressSpace)addressSpace :: ReferenceType |
        ReferenceTypeTemplate(self, addressSpace)
    } makeVirtual makePure;
    withSelector: #ref addMethod: {:(Type)self :: ReferenceType |
        self refFor: GenericAddressSpace uniqueInstance
    } makeVirtual makePure;
    withSelector: #memberRef addMethod: {:(Type)self :: ReferenceType |
        self refFor: MemberAddressSpace uniqueInstance
    } makePure;
    withSelector: #tempRefFor: addMethod: {:(Type)self :(AddressSpace)addressSpace :: ReferenceLikeType |
        TemporaryReferenceTypeTemplate(self, addressSpace)
    } makeVirtual makePure;
    withSelector: #tempRef addMethod: {:(Type)self :: ReferenceLikeType |
        self tempRefFor: GenericAddressSpace uniqueInstance
    } makeVirtual makePure;
    withSelector: #memberTempRef addMethod: {:(Type)self :: ReferenceLikeType |
        self tempRefFor: MemberAddressSpace uniqueInstance
    } makeVirtual makePure;
    withSelector: #pointerFor: addMethod: {:(Type)self :(AddressSpace)addressSpace :: PointerType |
        PointerTypeTemplate(self, addressSpace)
    } makePure;
    withSelector: #pointer addMethod: {:(Type)self :: PointerType |
        self pointerFor: GenericAddressSpace uniqueInstance
    } makePure;
    withSelector: #memberPointer addMethod: {:(Type)self :: PointerType |
        self pointerFor: MemberAddressSpace uniqueInstance
    } makePure;
    withSelector: #const addMethod: {:(Type)self :: Type |
        self
    } makePure;
    withSelector: #restrict addMethod: {:(Type)self :: Type |
        self
    } makePure.

AddressSpace
    withSelector: #prettyPointerSuffix addMethod: {:(AddressSpace)self :: String | nil} makeVirtual;
    withSelector: #prettyReferenceSuffix addMethod: {:(AddressSpace)self :: String | nil} makeVirtual;
    withSelector: #prettyTempReferenceSuffix addMethod: {:(AddressSpace)self :: String | nil} makeVirtual.

GenericAddressSpace
    withSelector: #prettyPointerSuffix addMethod: {:(AddressSpace)self :: String | "pointer" } makeOverride;
    withSelector: #prettyReferenceSuffix addMethod: {:(AddressSpace)self :: String | "ref" } makeOverride;
    withSelector: #prettyTempReferenceSuffix addMethod: {:(AddressSpace)self :: String | "tempRef" } makeOverride.

MemberAddressSpace
    withSelector: #prettyPointerSuffix addMethod: {:(AddressSpace)self :: String | "memberPointer" } makeOverride;
    withSelector: #prettyReferenceSuffix addMethod: {:(AddressSpace)self :: String | "memberRef" } makeOverride;
    withSelector: #prettyTempReferenceSuffix addMethod: {:(AddressSpace)self :: String | "memberTempRef" } makeOverride.

PointerType
    withSelector: #printOn: addMethod: {:(PointerType)self :(Stream)stream :: Void |
        stream print: self baseType.
        let: #suffix with: self addressSpace prettyPointerSuffix.
        if: suffix ~~ nil then: {
            stream space; string: suffix
        } else: {
            stream nextPutAll: " pointerFor: "; print: self addressSpace
        }.
    } makeOverride.

ReferenceType
    withSelector: #printOn: addMethod: {:(ReferenceType)self :(Stream)stream :: Void |
        stream print: self baseType.
        let: #suffix with: self addressSpace prettyReferenceSuffix.

        if: suffix ~~ nil then: {
            stream space; string: suffix
        } else: {
            stream nextPutAll: " refFor: "; print: self addressSpace
        }.
    } makeOverride;
    withSelector: #refFor: addMethod: {:(ReferenceType)self :addressSpace :: ReferenceType |
        self baseType refFor: addressSpace
    } makeOverride makePure;
    withSelector: #ref addMethod: {:(ReferenceType)self :: ReferenceType |
        self
    } makeOverride makePure;
    withSelector: #tempRefFor: addMethod: {:(ReferenceType)self :addressSpace :: ReferenceLikeType |
        self baseType refFor: addressSpace
    } makeOverride makePure;
    withSelector: #tempRef addMethod: {:(ReferenceType)self :: ReferenceLikeType |
        self baseType ref
    } makeOverride makePure.

TemporaryReferenceType
    withSelector: #printOn: addMethod: {:(TemporaryReferenceType)self :(Stream)stream :: Void |
        stream print: self baseType.
        let: #suffix with: self addressSpace prettyTempReferenceSuffix.

        if: suffix ~~ nil then: {
            stream space; string: suffix
        } else: {
            stream nextPutAll: " tempRefFor: "; print: self addressSpace
        }.
    } makeOverride;
    withSelector: #tempRefFor: addMethod: {:(TemporaryReferenceType)self :addressSpace :: ReferenceLikeType |
        self baseType refFor: addressSpace
    } makeOverride makePure;
    withSelector: #tempRef addMethod: {:(TemporaryReferenceType)self :: ReferenceLikeType |
        self
    } makeOverride makePure.

Type
    withSelector: #applicationBoxDescriptor addMethod: {:(Type)self :: UIntPointer | 0uptr } makeVirtual;
    withSelector: #canonicalTypeForApplicationArgumentWithIndex: addMethod: {:(Type)self :(Size)index :: Type | AnyValue } makeVirtual;
    withSelector: #canonicalResultType addMethod: {:(Type)self :: Type | AnyValue } makeVirtual.

FunctionType
    withSelector: #hasFunctionFlags: addMethod: {:(FunctionType)self :(Bitflags)flag :: Boolean |
        (self functionFlags & flag) = flag
    };
    withSelector: #isVariadic addMethod: {:(FunctionType)self :: Boolean |
        self hasFunctionFlags: FunctionFlags::Variadic
    };
    withSelector: #isMemoized addMethod: {:(FunctionType)self :: Boolean |
        self hasFunctionFlags: FunctionFlags::Memoized
    };
    withSelector: #isTemplate addMethod: {:(FunctionType)self :: Boolean |
        self hasFunctionFlags: FunctionFlags::Template
    };
    withSelector: #isMemoizedTemplate addMethod: {:(FunctionType)self :: Boolean |
        self hasFunctionFlags: FunctionFlags::Memoized | FunctionFlags::Template
    };
    withSelector: #passingArgumentCount addMethod: {:(FunctionType)self :: Size |
        self subclassResponsibility
    } makeAbstract;
    withSelector: #applicationBoxDescriptor addMethod: {:(FunctionType)self :: UIntPointer |
        let: #descriptor mutableWith: 0uptr.
        let: #resultType with: self canonicalResultType.

        resultType isValueType && resultType isVoidType not ifTrue: {
            descriptor := 1uptr.
        }.

        let: #argumentCount with: self passingArgumentCount.
        let: #argumentIndex mutableWith: 0sz.
        while: (argumentIndex < argumentCount) do: {
            (self canonicalTypeForApplicationArgumentWithIndex: argumentIndex) isValueType ifTrue: {
                descriptor := descriptor | (1uptr << (argumentIndex asUIntPointer + 1uptr))
            }
        } continueWith: (argumentIndex := argumentIndex + 1sz).

        descriptor
    } makeOverride.

DependentFunctionType
    withSelector: #passingArgumentCount addMethod: {:(DependentFunctionType)self :: Size |
        ## FIXME: Implement this properly.
        self argumentNodes size
    } makeOverride;
    withSelector: #canonicalResultType addMethod: {:(DependentFunctionType)self :: Type |
        ## FIXME: Implement this properly.
        AnyValue
    } makeOverride;
    withSelector: #canonicalTypeForApplicationArgumentWithIndex: addMethod: {:(DependentFunctionType)self :(Size)index :: Type |
        ## FIXME: Implement this properly.
        AnyValue
    } makeOverride;
    withSelector: #printOn: addMethod: {:(DependentFunctionType)self :(Stream)stream :: Void |
        stream nextPutAll: "DependentFunctionType at "; print: self sourcePosition
    } makeOverride.

SimpleFunctionType
    withSelector: #passingArgumentCount addMethod: {:(SimpleFunctionType)self :: Size |
        self argumentTypes size
    } makeOverride;
    withSelector: #canonicalTypeForApplicationArgumentWithIndex: addMethod: {:(SimpleFunctionType)self :(Size)index :: Type |
        if: index < self argumentTypes size
        then: (self argumentTypes at: index)
        else: Untyped
    } makeOverride;
    withSelector: #canonicalResultType addMethod: {:(SimpleFunctionType)self :: Type |
        let: #resultType with: self resultType.
        if: resultType == nil then: Untyped else: resultType.
    } makeOverride;
    withSelector: #printOn: addMethod: {:(SimpleFunctionType)self :(Stream)stream :: Void |
        stream nextPut: '('c8.
        self argumentTypes doWithIndex: {:(Type)argumentType :(Size)index :: Void |
            index > 0sz ifTrue: (stream nextPutAll: ", ").
            stream print: argumentType
        }.
        self isVariadic ifTrue: {
            self argumentTypes isNotEmpty
                ifTrue: (stream nextPutAll: ", ...")
                ifFalse: (stream nextPutAll: "...")
        }.
        stream nextPutAll: ") => "; print: self resultType.
    } makeOverride.

## Primitive values printString and primitive function types
(
    UInt8,Int8,Char8,
    UInt16,Int16,Char16,
    UInt32,Int32,Char32,
    UInt64,Int64,
    Float32,Float64,
    Integer
) do: {:SelfType :: Void |
    let: #unaryFunctionType with: SelfType => SelfType.
    let: #binaryFunctionType with: (SelfType, SelfType) => SelfType.
    let: #binaryComparisonFunctionType with: (SelfType, SelfType) => Boolean.

    ## Unary selectors
    #(
        negated bitInvert
    ) do: {:selector :: Void |
        let: #method with: (SelfType >> selector).
        if: method ~~ nil then: (method __type__: unaryFunctionType)
    }.

    ## Binary selectors.
    #(
        + - * / %
        | & ^ << >>
    ) do: {:selector :: Void |
        let: #method with: (SelfType >> selector).
        if: method ~~ nil then: (method __type__: binaryFunctionType)
    }.

    ## Comparisons
    #(
        = ~= < <= >= >
    ) do: {:selector :: Void |
        (SelfType >> selector) __type__: binaryComparisonFunctionType
    }.

    SelfType
        withSelector: #printOn: addMethod: {:(SelfType)self :(Stream)stream :: Void |
            <keepSourceDefinition>
            stream nextPutAll: self printString
        } makeOverride makeFinal recompileAndOptimize.

    let: #setConversionTypeFunction with: {:method :targetType :: Void |
        if: method ~~ nil then: (method __type__: (SelfType => targetType))
    }.

    setConversionTypeFunction((SelfType >> #asChar8), Char8).
    setConversionTypeFunction((SelfType >> #asUInt8), UInt8).
    setConversionTypeFunction((SelfType >> #asInt8), Int8).

    setConversionTypeFunction((SelfType >> #asChar16), Char16).
    setConversionTypeFunction((SelfType >> #asUInt16), UInt16).
    setConversionTypeFunction((SelfType >> #asInt16), Int16).

    setConversionTypeFunction((SelfType >> #asChar32), Char32).
    setConversionTypeFunction((SelfType >> #asUInt32), UInt32).
    setConversionTypeFunction((SelfType >> #asInt32), Int32).

    setConversionTypeFunction((SelfType >> #asUInt64), UInt64).
    setConversionTypeFunction((SelfType >> #asInt64), Int64).

    setConversionTypeFunction((SelfType >> #asSize), Size).
    setConversionTypeFunction((SelfType >> #asIntPointer), IntPointer).
    setConversionTypeFunction((SelfType >> #asUIntPointer), UIntPointer).

    setConversionTypeFunction((SelfType >> #asFloat32), Float32).
    setConversionTypeFunction((SelfType >> #asFloat64), Float64).
}.

(Integer >> #i8) __type__: (Integer => Int8).
(Integer >> #u8) __type__: (Integer => UInt8).
(Integer >> #c8) __type__: (Integer => Char8).
(Integer >> #i16) __type__: (Integer => Int16).
(Integer >> #u16) __type__: (Integer => UInt16).
(Integer >> #c16) __type__: (Integer => Char16).
(Integer >> #i32) __type__: (Integer => Int32).
(Integer >> #u32) __type__: (Integer => UInt32).
(Integer >> #c32) __type__: (Integer => Char32).
(Integer >> #i64) __type__: (Integer => Int64).
(Integer >> #u64) __type__: (Integer => UInt64).
##(Integer >> #f32) __type__: (Integer => Float32).
##(Integer >> #f64) __type__: (Integer => Float64).

(Float32 >> #sqrt) __type__: (Float32 => Float32).
(Float32 >> #asIEEEFloat32Encoding) __type__: (Float32 => UInt32).
(UInt32 >> #asIEEEFloat32Decoded) __type__: (UInt32 => Float32).

(Float64 >> #sqrt) __type__: (Float32 => Float32).
(Float64 >> #asIEEEFloat64Encoding) __type__: (Float64 => UInt64).
(UInt64 >> #asIEEEFloat64Decoded) __type__: (UInt64 => Float64).

let: #UInt32HashMultiplicationConstant with: 1103515245u32.
let: #UInt32HashBitCount with: 32u32 - 5u32.
let: #UInt32HashBitMask with: (1u32 << UInt32HashBitCount) - 1u32.
let: #UInt32StoredIdentityHashBitCount with: 22u32.
let: #UInt32StoredIdentityHashBitMask with: (1u32 << UInt32StoredIdentityHashBitCount) - 1u32.

let: #UInt64HashMultiplicationConstant with: 1103515245u64.
let: #UInt64HashBitCount with: 64u64 - 5u64.
let: #UInt64HashBitMask with: (1u64 << UInt64HashBitCount) - 1u64.
let: #UInt64StoredIdentityHashBitCount with: 22u64.
let: #UInt64StoredIdentityHashBitMask with: (1u64 << UInt64StoredIdentityHashBitCount) - 1u64.

UInt32
    withSelector: #hashMultiply addMethod: {:(UInt32)self :: UInt32 |
        (self * UInt32HashMultiplicationConstant) & UInt32HashBitMask
    } makePure makeFinal makeAlwaysInline withEagerAnalysis;
    withSelector: #hashConcatenate: addMethod: {:(UInt32)self :(UInt32)next :: UInt32 |
        (self hashMultiply + next) & UInt32HashBitMask
    } makePure makeFinal makeAlwaysInline withEagerAnalysis.

UInt64
    withSelector: #hashMultiply addMethod: {:(UInt64)self :: UInt64 |
        (self * UInt64HashMultiplicationConstant) & UInt64HashBitMask
    } makePure makeFinal makeAlwaysInline withEagerAnalysis;
    withSelector: #hashConcatenate: addMethod: {:(UInt64)self :(UInt64)next :: UInt64 |
        (self hashMultiply + next) & UInt64HashBitMask
    } makePure makeFinal makeAlwaysInline withEagerAnalysis;
    withSelector: #storedIdentityHashMask addMethod: {:(UInt64)self :: UInt64 |
        self & UInt64StoredIdentityHashBitMask
    } makePure makeFinal makeAlwaysInline withEagerAnalysis.

FunctionDefinition
    withSelector: #validAnnotations addMethod: {:(FunctionDefinition)self :: Dictionary |
        let: #annotations with: self annotations.
        if: annotations == nil then: {
            self annotations: Dictionary new.
            self annotations
        } else: {
            annotations
        }
    };
    withSelector: #annotationAt:put: addMethod: {:(FunctionDefinition)self :key :value :: Void |
        self validAnnotations at: key put: value.
    };
    withSelector: #annotationAt:ifAbsent: addMethod: {:(FunctionDefinition)self :key :ifAbsentBlock |
        let: #annotations with: self annotations.
        if: annotations == nil then: {
            ifAbsentBlock()
        } else: {
            annotations at: key ifAbsent: ifAbsentBlock
        }
    };
    withSelector: #annotationAt:ifAbsentPut: addMethod: {:(FunctionDefinition)self :key :ifAbsentBlock |
        self validAnnotations at: key ifAbsentPut: ifAbsentBlock.
    };
    withSelector: #annotationAtOrNil: addMethod: {:(FunctionDefinition)self :key |
        let: #annotations with: self annotations.
        if: annotations == nil then: nil else: (annotations atOrNil: key)
    };
    withSelector: #importWithSymbol: addMethod: {:(FunctionDefinition)self :(Symbol)symbol :: Void |
        (self annotationAt: #importedSymbols ifAbsentPut: {| OrderedCollection new }) add: symbol
    };
    withSelector: #importedSymbols addMethod: {:(FunctionDefinition)self :: SequenceableCollection |
        self annotationAt: #importedSymbols ifAbsent: {| #() }.
    }.

Function
    withSelector: #validAnnotations addMethod: {:(Function)self :: Dictionary |
        let: #annotations with: self annotations.
        if: annotations == nil then: {
            self annotations: Dictionary new.
            self annotations
        } else: {
            annotations
        }
    };
    withSelector: #annotationAt:put: addMethod: {:(Function)self :key :value :: Void |
        self validAnnotations at: key put: value.
    };
    withSelector: #annotationAt:ifAbsent: addMethod: {:(Function)self :key :ifAbsentBlock |
        let: #annotations with: self annotations.
        if: annotations == nil then: {
            ifAbsentBlock()
        } else: {
            annotations at: key ifAbsent: ifAbsentBlock
        }
    };
    withSelector: #annotationAt:ifAbsentPut: addMethod: {:(Function)self :key :ifAbsentBlock |
        self validAnnotations at: key ifAbsentPut: ifAbsentBlock.
    };
    withSelector: #annotationAtOrNil: addMethod: {:(Function)self :key |
        let: #annotations with: self annotations.
        if: annotations == nil then: nil else: (annotations atOrNil: key)
    };
    withSelector: #importWithSymbol: addMethod: {:(Function)self :(Symbol)symbol :: Void |
        self definition importWithSymbol: symbol
    };
    withSelector: #exportWithSymbol: addMethod: {:(Function)self :(Symbol)symbol :: Void |
        (self annotationAt: #exportedSymbols ifAbsentPut: {| OrderedCollection new }) add: symbol
    };
    withSelector: #exportedSymbols addMethod: {:(Function)self :: SequenceableCollection |
        self annotationAt: #exportedSymbols ifAbsent: {| #() }.
    };
    withSelector: #timeToRunInNanoseconds addMethod: {:(Function)self :: Int64 |
        let: #startTime with: Time::Timestamp::nanosecondsNow().
        self().
        let: #endTime with: Time::Timestamp::nanosecondsNow().
        endTime - startTime
    } makeInline;
    withSelector: #timeToRunInMicroseconds addMethod: {:(Function)self :: Int64 |
        let: #startTime with: Time::Timestamp::microsecondsNow().
        self().
        let: #endTime with: Time::Timestamp::microsecondsNow().
        endTime - startTime
    } makeInline;
    withSelector: #printTimeToRunInMillisecondsWithTitle: addMethod: {:(Function)self :(String)title |
        printLine(title, "...").
        let: #startTime with: Time::Timestamp::microsecondsNow().
        let: #result with: self().
        let: #endTime with: Time::Timestamp::microsecondsNow().
        printLine(title, " took ", (endTime - startTime) asFloat32 * 0.001f32,  " ms").
        result
    } makeInline.

SourcePosition
    withSelector: #printOn: addMethod: {:(SourcePosition)self :(Stream)stream :: Void |
        let: #sourceCode with: self sourceCode.

        stream
            nextPutAll: (if: sourceCode == nil then: "unknown" else: (sourceCode directory FileSystem::joinPath: sourceCode name));
            nextPut: ':'c8;
            print: self startLine;
            nextPut: '.'c8;
            print: self startColumn;
            nextPut: '-'c8;
            print: self endLine;
            nextPut: '.'c8;
            print: self endColumn
    } makeOverride.

GeneratedSymbol
    withSelector: #printOn: addMethod: {:(GeneratedSymbol)self :(Stream)stream :: Void |
        stream print: self class; nextPut: '('c8; print: self value; nextPut: ')'c8
    } makeOverride;
    withSelector: #fullPrintOn: addMethod: {:(GeneratedSymbol)self :(Stream)stream :: Void |
        stream print: self class; nextPut: '('c8; print: self value; nextPut: ')'c8
    } makeOverride.


Metatype
    withSelector: #asCanonicalPendingInstanceType addMethod: {:(Metatype)self :: Type |
        let: #thisType with: self thisType.
        if: thisType ~~ nil then: thisType else: Type.
    } makePure makeOverride withEagerAnalysis.

Metatype __type__
    withSelector: #getOrCreateDependentApplicationValueForNode: addMethod: {:(Metatype __type__)self :(ASTNode)astNode | Type } makeVirtual.

Metaclass
    withSelector: #asCanonicalPendingInstanceType addMethod: {:(Metaclass)self :: Type |
        let: #thisType with: self thisType.
        if: thisType ~~ nil then: thisType else: Class.
    } makePure makeOverride withEagerAnalysis.

Metaclass class
    withSelector: #asCanonicalPendingInstanceType addMethod: {:(Metaclass class)self :: Type | Class } makeOverride withEagerAnalysis;
    withSelector: #getOrCreateDependentApplicationValueForNode: addMethod: {:(Metaclass class)self :(ASTNode)astNode |
        Class
    }.

Class
    withSelector: #subclassWithClassSlots: addMethod: {:(Class)self :(Array)classSlots :: Class |
        let: #metaclass with: Metaclass basicNew.
        let: #metaclassSuper with: self class.
        metaclass
            flags: TypeFlags::MetatypeRequiredFlags;
            supertype: metaclassSuper;
            slots: classSlots;
            totalSlotCount: metaclassSuper validTotalSlotCount + classSlots size;
            registerSlotsInDictionary;
            generatePublicAccessors;
            createBasicInitializeMethod.
        
        let: #class with: metaclass basicNew.
        class
            flags: TypeFlags::ClassDefaultFlags;
            supertype: self;
            slots: ();
            totalSlotCount: nil;
            registerInSupertype.
        metaclass thisClass: class.
        class
    };
    withSelector: #subclassWithClassSlots:slots: addMethod: {:(Class)self :(Array)classSlots :(Array)instanceSlots :: Class |
        (self subclassWithClassSlots: classSlots)
            slots: instanceSlots;
            totalSlotCount: self validTotalSlotCount + instanceSlots size;
            registerSlotsInDictionary;
            generatePublicAccessors;
            createBasicInitializeMethod;
            yourself
    };
    withSelector: #subclass:classSlots:slots: addMethod: {:(Class)self :(StringSymbol)name :(Array)classSlots :(Array)instanceSlots :: Class |
        let: #class with: (self subclassWithClassSlots: classSlots slots: instanceSlots).
        class name: name.
        class
    };
    withSelector: #subclass:slots: addMethod: {:(Class)self :(StringSymbol)name :(Array)instanceSlots :: Class |
        self subclass: name classSlots: () slots: instanceSlots
    }.


UInt32
    withSelector: #min: addMethod: {:(UInt32)a :(UInt32)b :: UInt32 |
        if: a <= b then: a else: b
    };
    withSelector: #max: addMethod: {:(UInt32)a :(UInt32)b :: UInt32 |
        if: a >= b then: a else: b
    };
    withSelector: #alignedTo: addMethod: {:(UInt32)value :(UInt32)alignment :: UInt32 |
        ((value + alignment) - 1u32) & alignment negated.
    };
    withSelector: #log2Floor addMethod: {:(UInt32)value :: UInt32 |
        value highBit - 1u32
    };
    withSelector: #log2Ceiling addMethod: {:(UInt32)value :: UInt32 |
        (value - 1u32) log2Floor + 1u32
    };
    withSelector: #asLargerPowerOfTwo addMethod: {:(UInt32)value :: UInt32 |
        1u32 << value log2Ceiling
    }.

Int32
    withSelector: #abs addMethod: {:(Int32)a :: Int32 |
        if: a >= 0i32 then: a else: a negated
    };
    withSelector: #min: addMethod: {:(Int32)a :(Int32)b :: Int32 |
        if: a <= b then: a else: b
    };
    withSelector: #max: addMethod: {:(Int32)a :(Int32)b :: Int32 |
        if: a >= b then: a else: b
    };
    withSelector: #alignedTo: addMethod: {:(Int32)value :(Int32)alignment :: Int32 |
        ((value + alignment) - 1i32) & alignment negated.
    }.

UInt64
    withSelector: #min: addMethod: {:(UInt64)a :(UInt64)b :: UInt64 |
        if: a <= b then: a else: b
    };
    withSelector: #max: addMethod: {:(UInt64)a :(UInt64)b :: UInt64 |
        if: a >= b then: a else: b
    };
    withSelector: #alignedTo: addMethod: {:(UInt64)value :(UInt64)alignment :: UInt64 |
        ((value + alignment) - 1u64) & alignment negated.
    };
    withSelector: #log2Floor addMethod: {:(UInt64)value :: UInt64 |
        value highBit - 1u64
    };
    withSelector: #log2Ceiling addMethod: {:(UInt64)value :: UInt64 |
        (value - 1u64) log2Floor + 1u64
    };
    withSelector: #asLargerPowerOfTwo addMethod: {:(UInt64)value :: UInt64 |
        1u64 << value log2Ceiling
    }.

Int64
    withSelector: #abs addMethod: {:(Int64)a :: Int64 |
        if: a >= 0i64 then: a else: a negated
    };
    withSelector: #min: addMethod: {:(Int64)a :(Int64)b :: Int64 |
        if: a <= b then: a else: b
    };
    withSelector: #max: addMethod: {:(Int64)a :(Int64)b :: Int64 |
        if: a >= b then: a else: b
    };
    withSelector: #alignedTo: addMethod: {:(Int64)value :(Int64)alignment :: Int64 |
        ((value + alignment) - 1i64) & alignment negated.
    }.

TypeSlot
    withSelector: #size addMethod: {:(TypeSlot)self :: Size |
        self type valueSize
    } makeFinal;
    withSelector: #alignment addMethod: {:(TypeSlot)self :: Size |
        self type valueAlignment
    } makeFinal.

GCLayout
    withSelector: #repetitions:strong:weak:fat: addClassMethod: {:(GCLayout class)self :(UInt32)repetitions :(Size)strongCount :(Size)weakCount :(Size)fatCount :: self |
        let: #result with: (self basicAllocate: (((4sz + strongCount) + weakCount) + fatCount) * 4sz).
        result
            uint32At: 0sz put: repetitions;
            uint32At: 4sz put: strongCount asUInt32;
            uint32At: 8sz put: weakCount asUInt32;
            uint32At: 12sz put: fatCount asUInt32.
        result
    };
    withSelector: #uint32At:put: addMethod: {:(GCLayout)self :(Size)index :(UInt32)value :: Void |
        (index + 4sz) > self __byteSize__ ifTrue: (self errorSubscriptBounds: index).
        self
            __uncheckedByteSlotAt__: index put: value asUInt8;
            __uncheckedByteSlotAt__: index + 1sz put: (value >> 8u32) asUInt8;
            __uncheckedByteSlotAt__: index + 2sz put: (value >> 16u32) asUInt8;
            __uncheckedByteSlotAt__: index + 3sz put: (value >> 24u32) asUInt8.
    } makeFinal makeAlwaysInline;
    withSelector: #at:put: addMethod: {:(GCLayout)self :(Size)index :(UInt32)value :: Void |
        self uint32At: (index *4sz) + 16sz put: value 
    } makeOverride makeFinal makeAlwaysInline.

GCLayoutBuilder
    withSelector: #initialize addMethod: {:(GCLayoutBuilder)self :: Void |
        self repetitions: 1u32.
        self strong: OrderedCollection new.
        self weak: OrderedCollection new.
        self fat: OrderedCollection new.
    } makeOverride;
    withSelector: #addStrong: addMethod: {:(GCLayoutBuilder)self :(Size)offset :: Void |
        self strong add: offset asUInt32
    };
    withSelector: #addWeak: addMethod: {:(GCLayoutBuilder)self :(Size)offset :: Void |
        self weak add: offset asUInt32
    };
    withSelector: #addFat: addMethod: {:(GCLayoutBuilder)self :(Size)offset :: Void |
        self fat add: offset asUInt32
    };
    withSelector: #finish addMethod: {:(GCLayoutBuilder)self :: GCLayout |
        let: #layout with: (GCLayout repetitions: self repetitions strong: self strong size weak: self weak size fat: self fat size).
        let: #destIndex mutableWith: 0sz.
        let: #block with: {:(UInt32)offset :: Void |
            layout at: destIndex put: offset.
            destIndex := destIndex + 1sz
        }.

        self strong do: block.
        self weak do: block.
        self fat do: block.

        layout.
    }.

Type
    withSelector: #minimalSize addMethod: {:(Type)self :: Size |
        0sz
    } makeVirtual;
    withSelector: #minimalAlignment addMethod: {:(Type)self :: Size |
        1sz
    } makeVirtual;
    withSelector: #computeLayout replaceMethod: {:(Type)self :: Void |
        self instanceSize: 0sz.
        self instanceAlignment: self minimalAlignment.

        let: #supertype with: self supertype.
        if: supertype ~~ nil then: {
            self instanceSize: supertype validInstanceSize.
            self instanceAlignment: (supertype validInstanceAlignment max: 1sz).
        }.

        self validSlots do: {:(TypeSlot)eachSlot :: Void |
            let: #slotSize with: eachSlot size.
            let: #slotAlignment with: eachSlot alignment.

            let: #slotOffset with: (self instanceSize alignedTo: slotAlignment).
            eachSlot offset: slotOffset.

            self instanceAlignment: (self instanceAlignment max: slotAlignment).
            self instanceSize: slotOffset + slotSize.
        }.

        self instanceSize: ((self instanceSize max: self minimalSize) alignedTo: self instanceAlignment).
    } makeVirtual;

    withSelector: #addValueOntoGCLayoutBuilder:offset: addMethod: {:(Type)self :(GCLayoutBuilder)builder :(Size)offset :: Void |
        builder addStrong: offset
    } makeVirtual;
    withSelector: #addSlotsOntoGCLayoutBuilder:offset: addMethod: {:(Type)self :(GCLayoutBuilder)builder :(Size)offset :: Void |
        let: #supertype with: self supertype.
        if: supertype ~~ nil then: {
            supertype addSlotsOntoGCLayoutBuilder: builder offset: offset
        }.

        self validSlots do: {:(TypeSlot)eachSlot :: Void |
            eachSlot type addValueOntoGCLayoutBuilder: builder offset: offset + eachSlot offset
        }.
    };
    withSelector: #computeGCLayout replaceMethod: {:(Type)self :: Void |
        if: self validSlots isEmpty then: {
            if: self supertype ~~ nil then: {
                self gcLayout: self supertype gcLayout.
                self assert: self gcLayout ~~ nil.
                return: void.
            }
        }.

        let: #builder with: GCLayoutBuilder new.
        self addSlotsOntoGCLayoutBuilder: builder offset: 0sz.
        self gcLayout: builder finish
    } makeVirtual;
    withSelector: #validInstanceSize addMethod: {:(Type)self :: Size |
        if: self instanceAlignment = 0sz then: (self ensureLayoutIsComputed).
        self instanceSize
    } makeFinal;
    withSelector: #validInstanceAlignment addMethod: {:(Type)self :: Size |
        if: self instanceAlignment = 0sz then: (self ensureLayoutIsComputed).
        self instanceAlignment
    } makeFinal;
    withSelector: #validVirtualTable addMethod: {:(Type)self :: VirtualTable |
        if: self virtualTable == nil then: (self ensureVirtualTableLayoutIsComputed).
        self virtualTable
    } makeFinal;
    withSelector: #valueAlignment addMethod: {:(Type)self :: Size |
        UIntPointer instanceAlignment
    } makeVirtual;
    withSelector: #valueSize addMethod: {:(Type)self :: Size |
        UIntPointer instanceSize
    } makeVirtual;
    withSelector: #alignedValueSize addMethod: {:(Type)self :: Size |
        self valueSize alignedTo: self valueAlignment
    } makeFinal;
    withSelector: #isPrimitiveNumberType addMethod: {:(Type)self :: Boolean | false } makeVirtual;
    withSelector: #isPrimitiveCharacterType addMethod: {:(Type)self :: Boolean | false } makeVirtual;
    withSelector: #isPrimitiveFloatType addMethod: {:(Type)self :: Boolean | false } makeVirtual;
    withSelector: #isPrimitiveIntegerType addMethod: {:(Type)self :: Boolean | false } makeVirtual;
    withSelector: #isPrimitiveUnsignedIntegerType addMethod: {:(Type)self :: Boolean | false } makeVirtual;
    withSelector: #isPrimitiveSignedIntegerType addMethod: {:(Type)self :: Boolean | false } makeVirtual;
    withSelector: #isPrimitiveVectorType addMethod: {:(Type)self :: Boolean | false } makeVirtual.

ValueType
    withSelector: #addValueOntoGCLayoutBuilder:offset: addMethod: {:(ValueType)self :(GCLayoutBuilder)builder :(Size)offset :: Void |
        self addSlotsOntoGCLayoutBuilder: builder offset: offset
    } makeOverride.

AddressSpace
    withSelector: #addValueOntoGCLayoutBuilder:offset: addMethod: {:(AddressSpace)self :(GCLayoutBuilder)builder :(Size)offset :: Void |
    } makeVirtual.

MemberAddressSpace
    withSelector: #addValueOntoGCLayoutBuilder:offset: addMethod: {:(MemberAddressSpace)self :(GCLayoutBuilder)builder :(Size)offset :: Void |
        builder addFat: offset
    } makeOverride.

PointerLikeType
    withSelector: #addValueOntoGCLayoutBuilder:offset: addMethod: {:(PointerLikeType)self :(GCLayoutBuilder)builder :(Size)offset :: Void |
        self addressSpace addValueOntoGCLayoutBuilder: builder offset: offset
    } makeOverride.

PrimitiveNumber __type__ withSelector: #isPrimitiveNumberType addMethod: {:(Type)self :: Boolean | true } makeOverride.
PrimitiveCharacter __type__ withSelector: #isPrimitiveCharacterType addMethod: {:(Type)self :: Boolean | true } makeOverride.
PrimitiveFloat __type__ withSelector: #isPrimitiveFloatType addMethod: {:(Type)self :: Boolean | true } makeOverride.
PrimitiveInteger __type__ withSelector: #isPrimitiveIntegerType addMethod: {:(Type)self :: Boolean | true } makeOverride.
PrimitiveSignedInteger __type__ withSelector: #isPrimitiveSignedIntegerType addMethod: {:(Type)self :: Boolean | true } makeOverride.
PrimitiveUnsignedInteger __type__ withSelector: #isPrimitiveUnsignedIntegerType addMethod: {:(Type)self :: Boolean | true } makeOverride.

Type
    validInstanceAlignment;
    validInstanceSize;
    withSelector: #basicAllocate replaceMethod: {:(Type)self :: self |
        <primitive: #basicAllocate>
        (RawTuple::basicAllocateWithType:instanceSize:alignment:slotCount:variableSize:isBytes:isWeak:)(
            self, self validInstanceSize, self validInstanceAlignment, self validTotalSlotCount, 0sz,
            self isBytes, self isWeak
        )
    } makeVirtual withEagerAnalysis;
    withSelector: #basicAllocate: replaceMethod: {:(Type)self :(Size)variableSize :: self |
        (RawTuple::basicAllocateWithType:instanceSize:alignment:slotCount:variableSize:isBytes:isWeak:)(
            self, self validInstanceSize, self validInstanceAlignment, self validTotalSlotCount, variableSize,
            self isBytes, self isWeak
        )
    } makeVirtual withEagerAnalysis;
    withSelector: #ensureAnalysis replaceMethod: {:(Type)self :: Void |
        (tuple: self withLookupStartingFrom: Type supertype) ensureAnalysis.
        self allValidSlots.
        self validBasicInitializeMethod.
        self ensureLayoutIsComputed.
        self ensureVirtualTableLayoutIsComputed.
    } makeVirtual withEagerAnalysis;

    ## Non recursive versions, more efficient with our current compiler.
    withSelector: #lookupSelector: replaceMethod: {:(Type)self :(Symbol)selector :: AnyValue |
        let: #position mutableWith: self.
        while: (position ~~ nil) do: {
            let: #method with: (position lookupLocalSelector: selector).
            if: method ~~ nil then: (return: method)
        } continueWith: (position := position __slotNamedAt__: #supertype).

        nil
    } withEagerAnalysis;
    withSelector: #isDirectSubtypeOf: replaceMethod: {:(Type)self :(Type)expectedParent :: Boolean |
        let: #currentType mutableWith: self.
        
        do: {
            if: expectedParent == currentType then: (return: true).
            currentType := currentType __slotNamedAt__: #supertype
        } while: (currentType ~~ nil).

        false
    } makePure withEagerAnalysis;
    withSelector: #isSubtypeOf: replaceMethod: {:(Type)self :(Type)expectedParent :: Boolean |
        let: #currentType mutableWith: self.
        
        do: {
            if: expectedParent == currentType then: (return: true).
            currentType := currentType __slotNamedAt__: #supertype
        } while: (currentType ~~ nil).

        false
    } makePure withEagerAnalysis;
    withSelector: #isDirectlyConversibleTo: addMethod: {:(Type)self :(Type)targetType :: Boolean |
        (targetType isNullable && self isUndefinedType) || (self isSubtypeOf: targetType)
    } makePure.

(Type >> #lookupLocalSelector:) makeInline. ## To speed-up method lookup.

PointerLikeType
    withSelector: #computeLayout addMethod: {:(PointerLikeType)self :: Void |
        self instanceSize: UIntPointer valueSize.
        self instanceAlignment: UIntPointer valueAlignment.
    } makeOverride;
    withSelector: #computeGCLayout addMethod: {:(PointerLikeType)self :: Void |
        self gcLayout: self supertype gcLayout
    } makeOverride;
    withSelector: #withStorage: addMethod: {:(PointerLikeType)self :storage :: self |
        let: #result with: (RawTuple::new(1sz)).
        (RawTuple::uncheckedSlotAt:put:)(result, 0sz, storage).
        (RawTuple::type:)(result, self).
        result
    };
    withSelector: #withBoxForValue: addMethod: {:(PointerLikeType)self :(Untyped)value :: self |
        self withStorage: (ValueBox with: value)
    };
    withSelector: #withEmptyBox addMethod: {:(PointerLikeType)self :: self |
        self withStorage: (ValueBox basicNew)
    };
    withSelector: #untypedWithStorage: addMethod: {:(PointerLikeType)self :storage :: Untyped |
        let: #result with: (RawTuple::new(1sz)).
        (RawTuple::uncheckedSlotAt:put:)(result, 0sz, storage).
        (RawTuple::type:)(result, self).
        result
    };
    withSelector: #untypedWithBoxForValue: addMethod: {:(PointerLikeType)self :(Untyped)value :: Untyped |
        self untypedWithStorage: (ValueBox with: value)
    }.

ValueType
    withSelector: #asReceiverType addMethod: {:(Type)self :: Type | self ref } makePure makeOverride;
    withSelector: #asResultType addMethod: {:(Type)self :: Type | self tempRef } makePure makeOverride;
    withSelector: #valueSize addMethod: {:(ValueType)self :: Size |
        self validInstanceSize
    } makeOverride;
    withSelector: #valueAlignment addMethod: {:(ValueType)self :: Size |
        self validInstanceAlignment
    } makeOverride;
    withSelector: #decayReferenceLikeForReceiverType: addMethod: {:(Type)self :(ReferenceLikeType)reference :: Type | reference } makeOverride.

PrimitiveValueType
    withSelector: #asReceiverType addMethod: {:(Type)self :: Type | self } makePure makeOverride;
    withSelector: #asResultType addMethod: {:(Type)self :: Type | self } makePure makeOverride;
    withSelector: #decayReferenceLikeForReceiverType: addMethod: {:(Type)self :(ReferenceLikeType)reference :: Type | self } makeOverride.

Environment
    withSelector: #setSymbol:value: addMethod: {:(Environment)self :(Symbol)symbol :value :: value __type__ |
        self setSymbol: symbol bindingWithValue: value.
        value recordBindingWithOwner: self andName: symbol.
        value
    };
    withSelector: #setPublicSymbol:value: addMethod: {:(Environment)self :(Symbol)symbol :value :: value __type__ |
        self setSymbol: symbol value: value
    };
    withSelector: #withSelector:addMacroMethod: addMethod: {:(Environment)self :(Symbol)symbol :method :: Void |
        self setSymbol: symbol value: method
    };
    withSelector: #withSelector:addMethod: addMethod: {:(Environment)self :(Symbol)symbol :method :: Void |
        self setSymbol: symbol value: method
    };
    withSelector: #withSelector:addOrReplaceMethod: addMethod: {:(Environment)self :(Symbol)symbol :method :: Void |
        self setSymbol: symbol value: method
    };
    withSelector: #withSelector:addFallbackMethod: addMethod: {:(Environment)self :(Symbol)symbol :method :: Void |
        self setSymbol: symbol value: method
    }.

VirtualTableLayout
    withSelector: #buildFor: addMethod: {:(VirtualTableLayout)self :(Type)newType :: Void |
        self type: newType.
        
        let: #supertype with: newType supertype.
        if: supertype ~~ nil then: {
            supertype ensureVirtualTableLayoutIsComputed.
            self setSupertypeLayout: supertype virtualTableLayout.
        } else: {
            self setSupertypeLayout: nil.
        }.

        let: #virtualMethodSelectorList with: self type virtualMethodSelectorList.
        if: virtualMethodSelectorList ~~ nil then: {
            self addSelectors: virtualMethodSelectorList
        }.
    };
    withSelector: #setSupertypeLayout: addMethod: {:(VirtualTableLayout)self :(VirtualTableLayout)newSupertypeLayout :: Void |
        self supertypeLayout: newSupertypeLayout.

        if: newSupertypeLayout ~~ nil then: {
            self baseIndex: newSupertypeLayout size
        } else: {
            self baseIndex: 0sz
        }.

        self size: self baseIndex.
    };
    withSelector: #includesSelectorRecursively: addMethod: {:(VirtualTableLayout)self :(Symbol)selector :: Boolean |
        let: #selectorToIndexTable with: self selectorToIndexTable.
        selectorToIndexTable isNotNil && (selectorToIndexTable includesKey: selector) ifTrue: {
            true
        } ifFalse: {
            let: #supertypeLayout with: self supertypeLayout.
            if: supertypeLayout ~~ nil then: {
                supertypeLayout includesSelectorRecursively: selector
            } else: {
                false
            }
        }.
    };
    withSelector: #addSelector: addMethod: {:(VirtualTableLayout)self :(Symbol)selector :: Void |
        (self includesSelectorRecursively: selector) ifFalse: {
            if: self selectorToIndexTable == nil then: {
                self selectorToIndexTable: MethodDictionary new.
                self newSelectors: OrderedCollection new.
            }.

            let: #index with: self selectorToIndexTable size.
            self selectorToIndexTable at: selector put: index.
            self newSelectors add: selector.

            self size: self size + 1sz
        }.
    };
    withSelector: #addSelectors: addMethod: {:(VirtualTableLayout)self :(Collection)selectors :: Void |
        selectors do: {:(Symbol)eachSelector :: Void |
            self addSelector: eachSelector
        }
    };
    withSelector: #buildVirtualTableFor:on: addMethod: {:(VirtualTableLayout)self :(Type)targetType :(VirtualTable)virtualTable :: Void |
        let: #newSelectors with: self newSelectors.
        let: #baseIndex with: self baseIndex.
        if: newSelectors ~~ nil then: {
            newSelectors doWithIndex: {:(Symbol)selector :(Size)index :: Void |
                let: #method with: (targetType lookupSelector: selector).
                self assert: method isNotNil.
                virtualTable at: baseIndex + index put: method
            }.
        }.

        let: #supertypeLayout with: self supertypeLayout.
        if: supertypeLayout ~~ nil then: {
            supertypeLayout buildVirtualTableFor: targetType on: virtualTable
        }.
    };
    withSelector: #buildVirtualTableFor: addMethod: {:(VirtualTableLayout)self :(Type)targetType :: VirtualTable |
        let: #virtualTable with: (VirtualTable basicAllocate: self size).
        virtualTable type: targetType.
        self buildVirtualTableFor: targetType on: virtualTable.
        virtualTable
    };
    withSelector: #indexOfSelectorOrNil: addMethod: {:(VirtualTableLayout)self :(Symbol)selector :: AnyValue |
        let: #selectorToIndexTable with: self selectorToIndexTable.
        if: selectorToIndexTable ~~ nil then: {
            let: #found with: (selectorToIndexTable atOrNil: selector).
            if: found ~~ nil then: {
                return: self baseIndex + found
            }
        }.

        let: #supertypeLayout with: self supertypeLayout.
        if: supertypeLayout ~~ nil then: {
            supertypeLayout indexOfSelectorOrNil: selector
        } else: {
            nil
        }
    }.

Type
    withSelector: #computeVirtualTableLayout replaceMethod: {:(Type)self :: Void |
        {
            let: #virtualTableLayout with: VirtualTableLayout new.
            virtualTableLayout buildFor: self.

            if: virtualTableLayout newSelectors isNil && self supertype isNotNil then: {
                self virtualTableLayout: self supertype virtualTableLayout.
            } else: {
                self virtualTableLayout: virtualTableLayout.
            }
        }.

        {
            let: #layout with: self virtualTableLayout.
            if: ((layout type == self) || self virtualMethodSelectorList isNotNil) || self supertype isNil then: {
                self virtualTable: (layout buildVirtualTableFor: self)
            } else: {
                self virtualTable: self supertype virtualTable
            }
        }.
    } makeVirtual.

BootstrapEnv::IntrinsicTypes do: {:(Type)each :: Void |
    each ensureAnalysis
}.
