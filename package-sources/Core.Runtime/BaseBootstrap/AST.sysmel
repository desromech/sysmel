ASTNode
    withSelector: #analyzeWithEnvironment: addMethod: {:(ASTNode)self :(AnalysisAndEvaluationEnvironment)environment :: ASTNode | self subclassResponsibility } makeAbstract;
    withSelector: #analyzeAndEvaluateWithEnvironment: addMethod: {:(ASTNode)self :(Environment)environment :: Untyped| self subclassResponsibility } makeAbstract;
    withSelector: #evaluateWithEnvironment: addMethod: {:(ASTNode)self :(FunctionActivationEnvironment)environment :: Untyped | self subclassResponsibility } makeAbstract;

    withSelector: #childrenDo: addMethod: {:(ASTNode)self :((ASTNode) => Void)aBlock :: Void | self subclassResponsibility } makeAbstract;
    withSelector: #withAllChildrenDo: addMethod: {:(ASTNode)self :((ASTNode) => Void)aBlock :: Void |
        aBlock(self).
        self childrenDo: {:(ASTNode)each :: Void |
            each withAllChildrenDo: aBlock
        }
    } makeAbstract;
    withSelector: #literalDependenciesDo: addMethod: {:(ASTNode)self :((Untyped, Boolean) => Void)aBlock :: Void | } makeVirtual;

    withSelector: #transformWith: addMethod: {:(ASTNode)self :aBlock :: Void | self subclassResponsibility } makeAbstract;
    withSelector: #transformedWith: addMethod: {:(ASTNode)self :aBlock :: self class | self copy transformWith: aBlock; yourself };
    
    withSelector: #hasPragmaNamed: addMethod: {:(ASTNode)self :selector :: Boolean | false } makeVirtual;
    withSelector: #hasLiteralValueEqualTo: addMethod: {:(ASTNode)self :expectedValue :: Boolean | false } makeVirtual;
    withSelector: #isLiteralPureFunctionNode addMethod: {:(ASTNode)self :: Boolean | false } makeVirtual;
    withSelector: #isAnonymousSymbolNode addMethod: {:(ASTNode)self :: Boolean | false } makeVirtual;

    withSelector: #isArgumentNode addMethod: {:(ASTNode)self :: Boolean | false } makeVirtual;
    withSelector: #isBinaryExpressionSequenceNode addMethod: {:(ASTNode)self :: Boolean | false } makeVirtual;
    withSelector: #isBreakNode addMethod: {:(ASTNode)self :: Boolean | false } makeVirtual;
    withSelector: #isCoerceValueNode addMethod: {:(ASTNode)self :: Boolean | false } makeVirtual;
    withSelector: #isContinueNode addMethod: {:(ASTNode)self :: Boolean | false } makeVirtual;
    withSelector: #isDownCastNode addMethod: {:(ASTNode)self :: Boolean | false } makeVirtual;
    withSelector: #isDoWhileContinueWithNode addMethod: {:(ASTNode)self :: Boolean | false } makeVirtual;
    withSelector: #isErrorNode addMethod: {:(ASTNode)self :: Boolean | false } makeVirtual;
    withSelector: #isFunctionApplicationNode addMethod: {:(ASTNode)self :: Boolean | false } makeVirtual;
    withSelector: #isLambdaNode addMethod: {:(ASTNode)self :: Boolean | false } makeVirtual;
    withSelector: #isLexicalBlockNode addMethod: {:(ASTNode)self :: Boolean | false } makeVirtual;
    withSelector: #isLiteralNode addMethod: {:(ASTNode)self :: Boolean | false } makeVirtual;
    withSelector: #isVariableDefinitionNode addMethod: {:(ASTNode)self :: Boolean | false } makeVirtual;
    withSelector: #isIdentifierReferenceNode addMethod: {:(ASTNode)self :: Boolean | false } makeVirtual;
    withSelector: #isIfNode addMethod: {:(ASTNode)self :: Boolean | false } makeVirtual;
    withSelector: #isMakeAssociationNode addMethod: {:(ASTNode)self :: Boolean | false } makeVirtual;
    withSelector: #isMakeArrayNode addMethod: {:(ASTNode)self :: Boolean | false } makeVirtual;
    withSelector: #isMakeByteArrayNode addMethod: {:(ASTNode)self :: Boolean | false } makeVirtual;
    withSelector: #isMakeDictionaryNode addMethod: {:(ASTNode)self :: Boolean | false } makeVirtual;
    withSelector: #isMessageSendNode addMethod: {:(ASTNode)self :: Boolean | false } makeVirtual;
    withSelector: #isMessageChainMessageNode addMethod: {:(ASTNode)self :: Boolean | false } makeVirtual;
    withSelector: #isMessageChainNode addMethod: {:(ASTNode)self :: Boolean | false } makeVirtual;
    withSelector: #isTupleSlotNamedAtNode addMethod: {:(ASTNode)self :: Boolean | false } makeVirtual;
    withSelector: #isTupleSlotNamedReferenceAtNode addMethod: {:(ASTNode)self :: Boolean | false } makeVirtual;
    withSelector: #isTupleSlotNamedAtPutNode addMethod: {:(ASTNode)self :: Boolean | false } makeVirtual;
    withSelector: #isTupleWithLookupStartingFromNode addMethod: {:(ASTNode)self :: Boolean | false } makeVirtual;
    withSelector: #isPragmaNode addMethod: {:(ASTNode)self :: Boolean | false } makeVirtual;
    withSelector: #isReturnNode addMethod: {:(ASTNode)self :: Boolean | false } makeVirtual;
    withSelector: #isSequenceNode addMethod: {:(ASTNode)self :: Boolean | false } makeVirtual;
    withSelector: #isUnexpandedApplicationNode addMethod: {:(ASTNode)self :: Boolean | false } makeVirtual;
    withSelector: #isUnexpandedSExpressionNode addMethod: {:(ASTNode)self :: Boolean | false } makeVirtual;
    withSelector: #isUseNamedSlotsOfNode addMethod: {:(ASTNode)self :: Boolean | false } makeVirtual;
    withSelector: #isQuasiQuoteNode addMethod: {:(ASTNode)self :: Boolean | false } makeVirtual;
    withSelector: #isQuasiUnquoteNode addMethod: {:(ASTNode)self :: Boolean | false } makeVirtual;
    withSelector: #isQuoteNode addMethod: {:(ASTNode)self :: Boolean | false } makeVirtual;
    withSelector: #isSpliceNode addMethod: {:(ASTNode)self :: Boolean | false } makeVirtual;
    withSelector: #isWhileContinueWithNode addMethod: {:(ASTNode)self :: Boolean | false } makeVirtual;
    
    withSelector: #literalFunctionPrimitiveName addMethod: {:(ASTNode)self :: Symbol | nil } makeVirtual;
    withSelector: #copyWithNewReceiverOrFunction: addMethod: {:(ASTNode)self :(ASTNode)newReceiverOrFunction :: ASTNode | self subclassResponsibility } makeVirtual.

ASTArgumentNode
    withSelector: #isArgumentNode addMethod: {:(ASTNode)self :: Boolean | true } makeOverride;

    withSelector: #childrenDo: addMethod: {:(ASTArgumentNode)self :aBlock :: Void |
        if: (self name isNotNil) then: aBlock(self name).
        if: (self type isNotNil) then: aBlock(self type).
    } makeOverride;
    withSelector: #transformWith: addMethod: {:(ASTArgumentNode)self :aBlock :: Void |
        if: (self name isNotNil) then: (self name: aBlock(self name)).
        if: (self type isNotNil) then: (self type: aBlock(self type)).
    } makeOverride.

ASTBinaryExpressionSequenceNode
    withSelector: #isBinaryExpressionSequenceNode addMethod: {:(ASTNode)self :: Boolean | true } makeOverride;

    withSelector: #asExpandedNodeWithEnvironment: addMethod: {:(ASTBinaryExpressionSequenceNode)self :(Environment)environment :: ASTNode |
        ## TODO: perform proper operator precedence parsing.
        let: #operands mutableWith: self operands.
        let: #receiver mutableWith: operands first.
        let: #nextOperandIndex mutableWith: 1sz.
        self operators do: {:(ASTNode)operator :: Void |
            let: #nextOperand with: (operands at: nextOperandIndex).
            nextOperandIndex := nextOperandIndex + 1sz.
            receiver := ASTMessageSendNode new
                sourcePosition: operator sourcePosition;
                receiver: receiver;
                selector: operator;
                arguments: (Array with: nextOperand);
                yourself
        }.

        receiver
    };
    withSelector: #analyzeWithEnvironment: addMethod: {:(ASTBinaryExpressionSequenceNode)self :(AnalysisAndEvaluationEnvironment)environment :: ASTNode |
        (self asExpandedNodeWithEnvironment: environment) analyzeWithEnvironment: environment
    } makeOverride;
    withSelector: #analyzeAndEvaluateWithEnvironment: addMethod: {:(ASTBinaryExpressionSequenceNode)self :(Environment)environment :: Untyped |
        (self asExpandedNodeWithEnvironment: environment) analyzeAndEvaluateWithEnvironment: environment
    } makeOverride;
    withSelector: #evaluateWithEnvironment: addMethod: {:(ASTBinaryExpressionSequenceNode)self :(FunctionActivationEnvironment)environment :: Untyped |
        self error: "This node should be expanded." 
    } makeOverride;

    withSelector: #childrenDo: addMethod: {:(ASTBinaryExpressionSequenceNode)self :aBlock :: Void |
        self operands do: aBlock.
        self operators do: aBlock.
    } makeOverride;
    withSelector: #transformWith: addMethod: {:(ASTBinaryExpressionSequenceNode)self :aBlock :: Void |
        self operands: (self operands collect: aBlock).
        self operators: (self operators collect: aBlock).
    } makeOverride.

ASTBreakNode
    withSelector: #isBreakNode addMethod: {:(ASTBreakNode)self :: Boolean | true } makeOverride;
    withSelector: #childrenDo: addMethod: {:(ASTBreakNode)self :aBlock :: Void |
    } makeOverride;
    withSelector: #transformWith: addMethod: {:(ASTBreakNode)self :aBlock :: Void |
    } makeOverride.

ASTCoerceValueNode
    withSelector: #isCoerceValueNode addMethod: {:(ASTNode)self :: Boolean | true } makeOverride;

    withSelector: #childrenDo: addMethod: {:(ASTCoerceValueNode)self :aBlock :: Void |
        if: (self typeExpression isNotNil) then: aBlock(self typeExpression).
        if: (self valueExpression isNotNil) then: aBlock(self valueExpression).
    } makeOverride;
    withSelector: #transformWith: addMethod: {:(ASTCoerceValueNode)self :aBlock :: Void |
        if: (self typeExpression isNotNil) then: (self typeExpression: aBlock(self typeExpression)).
        if: (self valueExpression isNotNil) then: (self valueExpression: aBlock(self valueExpression)).
    } makeOverride.

ASTContinueNode
    withSelector: #isContinueNode addMethod: {:(ASTContinueNode)self :: Boolean | true } makeOverride;
    withSelector: #childrenDo: addMethod: {:(ASTContinueNode)self :aBlock :: Void |
    } makeOverride;
    withSelector: #transformWith: addMethod: {:(ASTContinueNode)self :aBlock :: Void |
    } makeOverride.

ASTDownCastNode
    withSelector: #isDownCastNode addMethod: {:(ASTDownCastNode)self :: Boolean | true } makeOverride;

    withSelector: #childrenDo: addMethod: {:(ASTDownCastNode)self :aBlock :: Void |
        if: (self typeExpression isNotNil) then: aBlock(self typeExpression).
        if: (self valueExpression isNotNil) then: aBlock(self valueExpression).
    } makeOverride;
    withSelector: #transformWith: addMethod: {:(ASTDownCastNode)self :aBlock :: Void |
        if: (self typeExpression isNotNil) then: (self typeExpression: aBlock(self typeExpression)).
        if: (self valueExpression isNotNil) then: (self valueExpression: aBlock(self valueExpression)).
    } makeOverride.

ASTDoWhileContinueWithNode
    withSelector: #isDoWhileContinueWithNode addMethod: {:(ASTNode)self :: Boolean | true } makeOverride;

    withSelector: #childrenDo: addMethod: {:(ASTDoWhileContinueWithNode)self :aBlock :: Void |
        if: (self bodyExpression isNotNil) then: aBlock(self bodyExpression).
        if: (self conditionExpression isNotNil) then: aBlock(self conditionExpression).
        if: (self continueExpression isNotNil) then: aBlock(self continueExpression).
    } makeOverride;
    withSelector: #transformWith: addMethod: {:(ASTDoWhileContinueWithNode)self :aBlock :: Void |
        if: (self bodyExpression isNotNil) then: (self bodyExpression: aBlock(self bodyExpression)).
        if: (self conditionExpression isNotNil) then: (self conditionExpression: aBlock(self conditionExpression)).
        if: (self continueExpression isNotNil) then: (self continueExpression: aBlock(self continueExpression)).
    } makeOverride.

ASTErrorNode
    withSelector: #isErrorNode addMethod: {:(ASTNode)self :: Boolean | true } makeOverride;

    withSelector: #transformWith: addMethod: {:(ASTErrorNode)self :aBlock :: Void |
    } makeOverride.

ASTFunctionApplicationNode
    withSelector: #isFunctionApplicationNode addMethod: {:(ASTNode)self :: Boolean | true } makeOverride;

    withSelector: #initialize addMethod: {:(ASTFunctionApplicationNode)self :: Void |
        (tuple: self withLookupStartingFrom: ASTFunctionApplicationNode supertype) initialize.
        self applicationFlags: 0sz
    } makeOverride;
    withSelector: #hasApplicationFlag: addMethod: {:(ASTFunctionApplicationNode)self :(Bitflags)flag :: Boolean |
        (self applicationFlags & flag) ~= 0bflgs
    };
    withSelector: #isNoTypechecked addMethod: {:(ASTFunctionApplicationNode)self :: Boolean |
        self hasApplicationFlag: FunctionApplicationFlags::NoTypecheck
    };
    withSelector: #childrenDo: addMethod: {:(ASTFunctionApplicationNode)self :aBlock :: Void |
        if: (self functionExpression isNotNil) then: aBlock(self functionExpression).
        self arguments do: aBlock.
    } makeOverride;
    withSelector: #transformWith: addMethod: {:(ASTFunctionApplicationNode)self :aBlock :: Void |
        if: (self functionExpression isNotNil) then: (self functionExpression: aBlock(self functionExpression)).
        self arguments: (self arguments collect: aBlock).
    } makeOverride.

ASTLambdaNode
    withSelector: #isLambdaNode addMethod: {:(ASTLambdaNode)self :: Boolean | true } makeOverride;

    withSelector: #makeEagerIf: addMethod: {:(ASTLambdaNode)self :(Boolean)condition :: Void |
        if: condition then: {
            self hasLazyAnalysis: false
        }
    };

    withSelector: #childrenDo: addMethod: {:(ASTLambdaNode)self :aBlock :: Void |
        self arguments do: aBlock.
        if: (self resultType isNotNil) then: aBlock(self resultType).
        if: (self body isNotNil) then: aBlock(self body).
    } makeOverride;
    withSelector: #transformWith: addMethod: {:(ASTLambdaNode)self :aBlock :: Void |
        self arguments: (self arguments collect: aBlock).
        if: (self resultType isNotNil) then: (self resultType: aBlock(self resultType)).
        if: (self body isNotNil) then: (self body: aBlock(self body)).
    } makeOverride.

ASTLexicalBlockNode
    withSelector: #isLexicalBlockNode addMethod: {:(ASTNode)self :: Boolean | true } makeOverride;

    withSelector: #hasPragmaNamed: addMethod: {:(ASTLexicalBlockNode)self :selector :: Boolean |
        self body hasPragmaNamed: selector
    } makeOverride;
    withSelector: #childrenDo: addMethod: {:(ASTLexicalBlockNode)self :aBlock :: Void |
        if: (self body isNotNil) then: aBlock(self body).
    } makeOverride;
    withSelector: #transformWith: addMethod: {:(ASTLexicalBlockNode)self :aBlock :: Void |
        if: (self body isNotNil) then: (self body: aBlock(self body)).
    } makeOverride.

ASTLiteralNode
    withSelector: #isLiteralNode addMethod: {:(ASTNode)self :: Boolean | true } makeOverride;

    withSelector: #isLiteralNode addMethod: {:(ASTLiteralNode)self :: Boolean | true } makeOverride;
    withSelector: #hasLiteralValueEqualTo: addMethod: {:(ASTLiteralNode)self :expectedValue :: Boolean | self value = expectedValue } makeOverride;

    withSelector: #isAnonymousSymbolNode addMethod: {:(ASTLiteralNode)self :: Boolean | #_ = self value } makeOverride;

    withSelector: #hasPragmaNamed: addMethod: {:(ASTLiteralNode)self :selector :: Boolean |
        (self analyzedType == Pragma) && (self value selector == selector)
    } makeOverride;

    withSelector: #childrenDo: addMethod: {:(ASTLiteralNode)self :aBlock :: Void | } makeOverride;
    withSelector: #transformWith: addMethod: {:(ASTLiteralNode)self :aBlock :: Void | } makeOverride;
    withSelector: #literalDependenciesDo: addMethod: {:(ASTLiteralNode)self :((Untyped, Boolean) => Void)aBlock :: Void | aBlock(self value, false) } makeOverride;

    withSelector: #asIdentifierReferenceNode addMethod: {:(ASTLiteralNode)self :: ASTIdentifierReferenceNode |
        ASTIdentifierReferenceNode new
            sourcePosition: self sourcePosition;
            value: self value;
            yourself
    };
    withSelector: #isLiteralPureFunctionNode addMethod: {:(ASTLiteralNode)self :: Boolean |
        if: (self value __type__ lookupSelector: #isPure) ~~ nil
            then: (self value isPure)
            else: false
    } makeOverride;
    withSelector: #literalFunctionPrimitiveName addMethod: {:(ASTLiteralNode)self :: Symbol |
        if: (self value __type__ lookupSelector: #primitiveName) ~~ nil
            then: (self value ensureAnalysis; primitiveName)
            else: nil
    } makeOverride.

ASTVariableDefinitionNode
    withSelector: #isVariableDefinitionNode addMethod: {:(ASTNode)self :: Boolean | true } makeOverride;

    withSelector: #childrenDo: addMethod: {:(ASTVariableDefinitionNode)self :aBlock :: Void |
        if: (self nameExpression isNotNil) then: aBlock(self nameExpression).
        if: (self valueExpression isNotNil) then: aBlock(self valueExpression).
    } makeOverride;
    withSelector: #transformWith: addMethod: {:(ASTVariableDefinitionNode)self :aBlock :: Void |
        if: (self nameExpression isNotNil) then: (self nameExpression: aBlock(self nameExpression)).
        if: (self valueExpression isNotNil) then: (self valueExpression: aBlock(self valueExpression)).
    } makeOverride.

ASTIdentifierReferenceNode
    withSelector: #isIdentifierReferenceNode addMethod: {:(ASTNode)self :: Boolean | true } makeOverride;

    withSelector: #childrenDo: addMethod: {:(ASTIdentifierReferenceNode)self :aBlock :: Void | } makeOverride;
    withSelector: #transformWith: addMethod: {:(ASTIdentifierReferenceNode)self :aBlock :: Void | } makeOverride;
    withSelector: #asLiteralNode addMethod: {:(ASTIdentifierReferenceNode)self :: ASTLiteralNode |
        ASTLiteralNode new
            sourcePosition: self sourcePosition;
            value: self value;
            yourself
    }.

ASTIfNode
    withSelector: #isIfNode addMethod: {:(ASTNode)self :: Boolean | true } makeOverride;

    withSelector: #childrenDo: addMethod: {:(ASTIfNode)self :aBlock :: Void |
        if: (self conditionExpression isNotNil) then: aBlock(self conditionExpression).
        if: (self trueExpression isNotNil) then: aBlock(self trueExpression).
        if: (self falseExpression isNotNil) then: aBlock(self falseExpression).
    } makeOverride;
    withSelector: #transformWith: addMethod: {:(ASTIfNode)self :aBlock :: Void |
        if: (self conditionExpression isNotNil) then: (self conditionExpression: aBlock(self conditionExpression)).
        if: (self trueExpression isNotNil) then: (self trueExpression: aBlock(self trueExpression)).
        if: (self falseExpression isNotNil) then: (self falseExpression: aBlock(self falseExpression)).
    } makeOverride.

ASTMakeAssociationNode
    withSelector: #isMakeAssociationNode addMethod: {:(ASTNode)self :: Boolean | true } makeOverride;

    withSelector: #childrenDo: addMethod: {:(ASTMakeAssociationNode)self :aBlock :: Void |
        if: (self key isNotNil) then: aBlock(self key).
        if: (self value isNotNil) then: aBlock(self value).
    } makeOverride;
    withSelector: #transformWith: addMethod: {:(ASTMakeAssociationNode)self :aBlock :: Void |
        if: (self key isNotNil) then: (self key: aBlock(self key)).
        if: (self value isNotNil) then: (self value: aBlock(self value)).
    } makeOverride.

ASTMakeByteArrayNode
    withSelector: #isMakeByteArrayNode addMethod: {:(ASTNode)self :: Boolean | true } makeOverride;

    withSelector: #childrenDo: addMethod: {:(ASTMakeByteArrayNode)self :aBlock :: Void |
        self elements do: aBlock
    } makeOverride;
    withSelector: #transformWith: addMethod: {:(ASTMakeByteArrayNode)self :aBlock :: Void |
        self elements: (self elements collect: aBlock)
    } makeOverride.

ASTMakeDictionaryNode
    withSelector: #isMakeDictionaryNode addMethod: {:(ASTNode)self :: Boolean | true } makeOverride;

    withSelector: #childrenDo: addMethod: {:(ASTMakeDictionaryNode)self :aBlock :: Void |
        self elements do: aBlock
    } makeOverride;
    withSelector: #transformWith: addMethod: {:(ASTMakeDictionaryNode)self :aBlock :: Void |
        self elements: (self elements collect: aBlock)
    } makeOverride.

ASTMakeArrayNode
    withSelector: #isMakeArrayNode addMethod: {:(ASTNode)self :: Boolean | true } makeOverride;

    withSelector: #childrenDo: addMethod: {:(ASTMakeArrayNode)self :aBlock :: Void |
        self elements do: aBlock
    } makeOverride;
    withSelector: #transformWith: addMethod: {:(ASTMakeArrayNode)self :aBlock :: Void |
        self elements: (self elements collect: aBlock)
    } makeOverride.

ASTMessageSendNode
    withSelector: #isMessageSendNode addMethod: {:(ASTMessageSendNode)self :: Boolean | true } makeOverride;

    withSelector: #copyWithNewReceiverOrFunction: addMethod: {:(ASTMessageSendNode)self :(ASTNode)newReceiverOrFunction :: ASTNode |
        self copy
            receiver: newReceiverOrFunction;
            yourself
    } makeOverride;

    withSelector: #hasApplicationFlag: addMethod: {:(ASTMessageSendNode)self :(Bitflags)flag :: Boolean |
        (self applicationFlags & flag) ~= 0bflgs
    };
    withSelector: #isNoTypechecked addMethod: {:(ASTMessageSendNode)self :: Boolean |
        self hasApplicationFlag: FunctionApplicationFlags::NoTypecheck
    };
    withSelector: #literalDependenciesDo: addMethod: {:(ASTMessageSendNode)self :((Untyped, Boolean) => Void)aBlock :: Void |
        if: self boundMethod ~~ nil then: aBlock(self boundMethod, true)
    } makeVirtual;
    withSelector: #childrenDo: addMethod: {:(ASTMessageSendNode)self :aBlock :: Void |
        if: (self receiver isNotNil) then: aBlock(self receiver).
        if: (self receiverLookupType isNotNil) then: aBlock(self receiverLookupType).
        if: (self selector isNotNil) then: aBlock(self selector).
        self arguments do: aBlock
    } makeOverride;
    withSelector: #transformWith: addMethod: {:(ASTMessageSendNode)self :aBlock :: Void |
        if: (self receiver isNotNil) then: (self receiver: aBlock(self receiver)).
        if: (self receiverLookupType isNotNil) then: (self receiverLookupType: aBlock(self receiverLookupType)).
        if: (self selector isNotNil) then: (self selector: aBlock(self selector)).
        self arguments: (self arguments collect: aBlock)
    } makeOverride.

ASTMessageChainNode
    withSelector: #isMessageChainNode addMethod: {:(ASTNode)self :: Boolean | true } makeOverride;

    withSelector: #childrenDo: addMethod: {:(ASTMessageChainNode)self :aBlock :: Void |
        if: (self receiver isNotNil) then: aBlock(self receiver).
        if: (self receiverLookupType isNotNil) then: aBlock(self receiverLookupType).
        self messages do: aBlock
    } makeOverride;
    withSelector: #transformWith: addMethod: {:(ASTMessageChainNode)self :aBlock :: Void |
        if: (self receiver isNotNil) then: (self receiver: aBlock(self receiver)).
        if: (self receiverLookupType isNotNil) then: (self receiverLookupType: aBlock(self receiverLookupType)).
        self messages: (self messages collect: aBlock)
    } makeOverride.

ASTMessageChainMessageNode
    withSelector: #isMessageChainMessageNode addMethod: {:(ASTNode)self :: Boolean | true } makeOverride;

    withSelector: #asUnexpandedSExpression addMethod: {:(ASTMessageChainMessageNode)self :: ASTUnexpandedSExpressionNode |
        ASTUnexpandedSExpressionNode new
            sourcePosition: self sourcePosition;
            elements: (Array with: (self selector downCastTo: ASTLiteralNode) asIdentifierReferenceNode) -- self arguments;
            yourself
    };
    withSelector: #asMessageSendNodeWithReceiver: addMethod: {:(ASTMessageChainMessageNode)self :(ASTNode)receiver :: ASTMessageSendNode |
        ASTMessageSendNode new
            sourcePosition: self sourcePosition;
            receiver: receiver;
            selector: self selector;
            arguments: self arguments;
            yourself
    };
    withSelector: #asMessageSendNodeWithReceiver:receiverLookupType: addMethod: {:(ASTMessageChainMessageNode)self :(ASTNode)receiver :(ASTNode)receiverLookupType :: ASTMessageSendNode |
        ASTMessageSendNode new
            sourcePosition: self sourcePosition;
            receiver: receiver;
            receiverLookupType: receiverLookupType;
            selector: self selector;
            arguments: self arguments;
            yourself
    };
    withSelector: #childrenDo: addMethod: {:(ASTMessageChainMessageNode)self :aBlock :: Void |
        if: (self selector isNotNil) then: aBlock(self selector).
        self arguments do: aBlock
    } makeOverride;
    withSelector: #transformWith: addMethod: {:(ASTMessageChainMessageNode)self :aBlock :: Void |
        if: (self selector isNotNil) then: (self selector: aBlock(self selector)).
        self arguments: (self arguments collect: aBlock)
    } makeOverride.

ASTTupleSlotNamedAtNode
    withSelector: #isTupleSlotNamedAtNode addMethod: {:(ASTTupleSlotNamedAtNode)self :: Boolean | true } makeOverride;

    withSelector: #childrenDo: addMethod: {:(ASTTupleSlotNamedAtNode)self :aBlock :: Void |
        if: (self tupleExpression isNotNil) then: aBlock(self tupleExpression).
        if: (self nameExpression isNotNil) then: aBlock(self nameExpression).
    } makeOverride;
    withSelector: #transformWith: addMethod: {:(ASTTupleSlotNamedAtNode)self :aBlock :: Void |
        if: (self tupleExpression isNotNil) then: (self tupleExpression: aBlock(self tupleExpression)).
        if: (self nameExpression isNotNil) then: (self nameExpression: aBlock(self nameExpression)).
    } makeOverride.

ASTTupleSlotNamedReferenceAtNode
    withSelector: #isTupleSlotNamedReferenceAtNode addMethod: {:(ASTTupleSlotNamedReferenceAtNode)self :: Boolean | true } makeOverride;

    withSelector: #childrenDo: addMethod: {:(ASTTupleSlotNamedReferenceAtNode)self :aBlock :: Void |
        if: (self tupleExpression isNotNil) then: aBlock(self tupleExpression).
        if: (self nameExpression isNotNil) then: aBlock(self nameExpression).
    } makeOverride;
    withSelector: #transformWith: addMethod: {:(ASTTupleSlotNamedReferenceAtNode)self :aBlock :: Void |
        if: (self tupleExpression isNotNil) then: (self tupleExpression: aBlock(self tupleExpression)).
        if: (self nameExpression isNotNil) then: (self nameExpression: aBlock(self nameExpression)).
    } makeOverride.

ASTTupleSlotNamedAtPutNode
    withSelector: #isTupleSlotNamedAtPutNode addMethod: {:(ASTTupleSlotNamedAtPutNode)self :: Boolean | true } makeOverride;

    withSelector: #childrenDo: addMethod: {:(ASTTupleSlotNamedAtPutNode)self :aBlock :: Void |
        if: (self tupleExpression isNotNil) then: aBlock(self tupleExpression).
        if: (self nameExpression isNotNil) then: aBlock(self nameExpression).
        if: (self valueExpression isNotNil) then: aBlock(self valueExpression).
    } makeOverride;
    withSelector: #transformWith: addMethod: {:(ASTTupleSlotNamedAtPutNode)self :aBlock :: Void |
        if: (self tupleExpression isNotNil) then: (self tupleExpression: aBlock(self tupleExpression)).
        if: (self nameExpression isNotNil) then: (self nameExpression: aBlock(self nameExpression)).
        if: (self valueExpression isNotNil) then: aBlock(self valueExpression).
    } makeOverride.

ASTTupleWithLookupStartingFromNode
    withSelector: #isTupleWithLookupStartingFromNode addMethod: {:(ASTNode)self :: Boolean | true } makeOverride;

    withSelector: #childrenDo: addMethod: {:(ASTTupleWithLookupStartingFromNode)self :aBlock :: Void |
        if: (self tupleExpression isNotNil) then: aBlock(self tupleExpression).
        if: (self typeExpression isNotNil) then: aBlock(self typeExpression).
    } makeOverride;
    withSelector: #transformWith: addMethod: {:(ASTTupleWithLookupStartingFromNode)self :aBlock :: Void |
        if: (self tupleExpression isNotNil) then: (self tupleExpression: aBlock(self tupleExpression)).
        if: (self typeExpression isNotNil) then: (self typeExpression: aBlock(self typeExpression)).
    } makeOverride.

ASTPragmaNode
    withSelector: #isPragmaNode addMethod: {:(ASTNode)self :: Boolean | true } makeOverride;

    withSelector: #hasPragmaNamed: addMethod: {:(ASTPragmaNode)self :expectedSelector :: Boolean |
        let: #selector with: self selector.
        if: selector isNotNil
            then: (selector hasLiteralValueEqualTo: expectedSelector)
            else: false
    } makeOverride;
    withSelector: #childrenDo: addMethod: {:(ASTPragmaNode)self :aBlock :: Void |
        if: (self selector isNotNil) then: aBlock(self selector).
        self arguments do: aBlock
    } makeOverride;
    withSelector: #transformWith: addMethod: {:(ASTPragmaNode)self :aBlock :: Void |
        if: (self selector isNotNil) then: (self selector: aBlock(self selector)).
        self arguments: (self arguments collect: aBlock)
    } makeOverride.

ASTReturnNode
    withSelector: #isReturnNode addMethod: {:(ASTReturnNode)self :: Boolean | true } makeOverride;
    
    withSelector: #childrenDo: addMethod: {:(ASTReturnNode)self :aBlock :: Void |
        aBlock(self expression)
    } makeOverride;
    withSelector: #transformWith: addMethod: {:(ASTReturnNode)self :aBlock :: Void |
        self expression: aBlock(self expression)
    } makeOverride.

ASTSequenceNode
    withSelector: #initialize addMethod: {:(ASTSequenceNode)self :: Void |
        self pragmas: #().
        self expressions: #().
    } makeOverride;
    withSelector: #isSequenceNode addMethod: {:(ASTSequenceNode)self :: Boolean | true } makeOverride;

    withSelector: #hasPragmaNamed: addMethod: {:(ASTSequenceNode)self :selector :: Boolean |
        self pragmas anySatisfy: {:(ASTNode)pragma :: Boolean | pragma hasPragmaNamed: selector}
    } makeOverride;
    withSelector: #childrenDo: addMethod: {:(ASTSequenceNode)self :aBlock :: Void |
        self pragmas do: aBlock.
        self expressions do: aBlock.
    } makeOverride;
    withSelector: #transformWith: addMethod: {:(ASTSequenceNode)self :aBlock :: Void |
        self pragmas: (self pragmas collect: aBlock).
        self expressions: (self expressions collect: aBlock)
    } makeOverride.

ASTUnexpandedApplicationNode
    withSelector: #isUnexpandedApplicationNode addMethod: {:(ASTUnexpandedApplicationNode)self :: Boolean | true } makeOverride;
    withSelector: #copyWithNewReceiverOrFunction: addMethod: {:(ASTUnexpandedApplicationNode)self :(ASTNode)newReceiverOrFunction :: ASTNode |
        self copy
            functionOrMacroExpression: newReceiverOrFunction;
            yourself
    } makeOverride;

    withSelector: #childrenDo: addMethod: {:(ASTUnexpandedApplicationNode)self :aBlock :: Void |
        if: (self functionOrMacroExpression isNotNil) then: aBlock(self functionOrMacroExpression).
        self arguments do: aBlock
    } makeOverride;
    withSelector: #transformWith: addMethod: {:(ASTUnexpandedApplicationNode)self :aBlock :: Void |
        if: (self functionOrMacroExpression isNotNil) then: (self functionOrMacroExpression: aBlock(self functionOrMacroExpression)).
        self arguments: (self arguments collect: aBlock)
    } makeOverride.

ASTUnexpandedSExpressionNode
    withSelector: #isUnexpandedSExpressionNode addMethod: {:(ASTNode)self :: Boolean | true } makeOverride;

    withSelector: #childrenDo: addMethod: {:(ASTUnexpandedSExpressionNode)self :aBlock :: Void |
        self elements do: aBlock
    } makeOverride;
    withSelector: #transformWith: addMethod: {:(ASTUnexpandedSExpressionNode)self :aBlock :: Void |
        self elements: (self elements collect: aBlock)
    } makeOverride.

ASTUseNamedSlotsOfNode
    withSelector: #isUseNamedSlotsOfNode addMethod: {:(ASTUseNamedSlotsOfNode)self :: Boolean | true } makeOverride;

    withSelector: #childrenDo: addMethod: {:(ASTUseNamedSlotsOfNode)self :aBlock :: Void |
        aBlock(self tupleExpression).
    } makeOverride;
    withSelector: #transformWith: addMethod: {:(ASTUseNamedSlotsOfNode)self :aBlock :: Void |
        self tupleExpression: aBlock(self tupleExpression).
    } makeOverride.

ASTNode
    withSelector: #analyzeQuasiQuotedList:withEnvironment:parameterList: addMethod: {:(ASTNode)self :(Array)list :(AnalysisAndEvaluationEnvironment)environment :(OrderedCollection)parameterList :: Array |
        list collect: {:(ASTNode)each :: ASTNode | each analyzeQuasiQuoteOrSpliceWithEnvironment: environment parameterList: parameterList }
    };
    withSelector: #analyzeAndEvaluateQuasiQuotedList:withEnvironment: addMethod: {:(ASTNode)self :(Array)list :(Environment)environment :: Array |
        let: #result with: OrderedCollection new.
        list do: {:(ASTNode)each :: Void |
            each isSpliceNode ifTrue: {
                result addAll: ((each downCastTo: ASTSpliceNode) expression analyzeAndEvaluateWithEnvironment: environment)
            } ifFalse: {
                result add: (each analyzeAndEvaluateQuasiQuoteWithEnvironment: environment)
            }
        }.

        result asArray
    };

    withSelector: #analyzeQuasiQuoteOrSpliceWithEnvironment:parameterList: addMethod: {:(ASTNode)self :(AnalysisAndEvaluationEnvironment)environment :(OrderedCollection)parameterList :: ASTNode |
        self analyzeQuasiQuoteWithEnvironment: environment parameterList: parameterList
    } makeVirtual;

    withSelector: #analyzeQuasiQuoteWithEnvironment:parameterList: addMethod: {:(ASTNode)self :(AnalysisAndEvaluationEnvironment)environment :(OrderedCollection)parameterList :: ASTNode |
        self transformedWith: {:child | child analyzeQuasiQuoteWithEnvironment: environment parameterList: parameterList }
    } makeVirtual;
    withSelector: #analyzeAndEvaluateQuasiQuoteWithEnvironment: addMethod: {:(ASTNode)self :(Environment)environment :: ASTNode |
        self transformedWith: {:child | child analyzeAndEvaluateQuasiQuoteWithEnvironment: environment }
    } makeVirtual;
    withSelector: #evaluateQuasiQuoteWithParameters: addMethod: {:(ASTNode)self :(Array)parameters :: ASTNode |
        self transformedWith: {:child | child evaluateQuasiQuoteWithParameters: parameters }
    } makeVirtual;
    withSelector: #evaluateQuasiQuoteWithEnvironment: addMethod: {:(ASTNode)self :(Environment)environment :: ASTNode |
        self subclassResponsibility
    } makeAbstract.

let: #expandASTTemplateWithParameters with: {:(ASTNode)templateNode :(Array)templateParameters :: ASTNode |
    templateNode evaluateQuasiQuoteWithParameters: templateParameters
}.

ASTMakeArrayNode
    withSelector: #analyzeAndEvaluateQuasiQuoteWithEnvironment: addMethod: {:(ASTMakeArrayNode)self :(AnalysisAndEvaluationEnvironment)environment :(OrderedCollection)parameterList :: ASTNode |
        self copy
            elements: (self analyzeAndEvaluateQuasiQuotedList: self elements withEnvironment: environment);
            yourself
    } makeOverride;
    withSelector: #analyzeQuasiQuoteWithEnvironment:parameterList: addMethod: {:(ASTMakeArrayNode)self :(AnalysisAndEvaluationEnvironment)environment :(OrderedCollection)parameterList :: ASTNode |
        self copy
            elements: (self analyzeQuasiQuotedList: self elements withEnvironment: environment parameterList: parameterList);
            yourself
    } makeOverride.

ASTUnexpandedSExpressionNode
    withSelector: #analyzeAndEvaluateQuasiQuoteWithEnvironment: addMethod: {:(ASTUnexpandedSExpressionNode)self :(AnalysisAndEvaluationEnvironment)environment :(OrderedCollection)parameterList :: ASTNode |
        self copy
            elements: (self analyzeAndEvaluateQuasiQuotedList: self elements withEnvironment: environment);
            yourself
    } makeOverride;
    withSelector: #analyzeQuasiQuoteWithEnvironment:parameterList: addMethod: {:(ASTUnexpandedSExpressionNode)self :(AnalysisAndEvaluationEnvironment)environment :(OrderedCollection)parameterList :: ASTNode |
        self copy
            elements: (self analyzeQuasiQuotedList: self elements withEnvironment: environment parameterList: parameterList);
            yourself
    } makeOverride.

ASTQuasiQuoteNode
    withSelector: #isQuasiQuoteNode addMethod: {:(ASTNode)self :: Boolean | true } makeOverride;

    withSelector: #analyzeWithEnvironment: addMethod: {:(ASTQuasiQuoteNode)self :(AnalysisAndEvaluationEnvironment)environment :: ASTNode |
        let: #parameterList with: OrderedCollection new.
        let: #analyzedTemplate with: (self node analyzeQuasiQuoteWithEnvironment: environment parameterList: parameterList).
        let: #analyzedParameterList with: (ASTMakeArrayNode new
            sourcePosition: self sourcePosition;
            elements: parameterList asArray;
            yourself).
        let: #analyzedTemplateNode with: (ASTLiteralNode new
            sourcePosition: self node sourcePosition;
            analyzedType: analyzedTemplate __type__;
            value: analyzedTemplate;
            yourself).

        (ASTUnexpandedApplicationNode new
            sourcePosition: self sourcePosition;
            functionOrMacroExpression: (ASTLiteralNode new
                sourcePosition: self sourcePosition;
                analyzedType: expandASTTemplateWithParameters __type__;
                value: expandASTTemplateWithParameters;
                yourself);
            arguments: (Array with: analyzedTemplateNode with: analyzedParameterList);
            yourself) analyzeWithEnvironment: environment
    } makeOverride;
    withSelector: #analyzeAndEvaluateWithEnvironment: addMethod: {:(ASTQuasiQuoteNode)self :(Environment)environment :: Untyped|
        self node analyzeAndEvaluateQuasiQuoteWithEnvironment: environment
    } makeOverride;
    withSelector: #evaluateWithEnvironment: addMethod: {:(ASTQuasiQuoteNode)self :(FunctionActivationEnvironment)environment |
        self node evaluateQuasiQuoteWithEnvironment: environment
    } makeOverride;
    withSelector: #childrenDo: addMethod: {:(ASTQuasiQuoteNode)self :aBlock :: Void |
        if: (self node isNotNil) then: aBlock(self node)
    } makeOverride;
    withSelector: #transformWith: addMethod: {:(ASTQuasiQuoteNode)self :aBlock :: Void |
        if: (self node isNotNil) then: (self node: aBlock(self node))
    } makeOverride.

ASTQuasiUnquoteNode
    withSelector: #isQuasiUnquoteNode addMethod: {:(ASTNode)self :: Boolean | true } makeOverride;

    withSelector: #analyzeQuasiQuoteWithEnvironment:parameterList: addMethod: {:(ASTQuasiUnquoteNode)self :(AnalysisAndEvaluationEnvironment)environment :(OrderedCollection)parameterList :: ASTNode |
        let: #astTemplateParameterIndex with: parameterList size.
        parameterList add: self expression.
        self copy
            astTemplateParameterIndex: astTemplateParameterIndex;
            yourself
    } makeOverride;
    withSelector: #analyzeAndEvaluateQuasiQuoteWithEnvironment: addMethod: {:(ASTQuasiUnquoteNode)self :(Environment)environment |
        self expression analyzeAndEvaluateWithEnvironment: environment
    } makeOverride;
    withSelector: #evaluateQuasiQuoteWithParameters: addMethod: {:(ASTQuasiUnquoteNode)self :(Array)parameters :: ASTNode |
        parameters at: self astTemplateParameterIndex
    } makeOverride;
    withSelector: #childrenDo: addMethod: {:(ASTQuasiUnquoteNode)self :aBlock :: Void |
        if: (self expression isNotNil) then: aBlock(self expression)
    } makeOverride;
    withSelector: #transformWith: addMethod: {:(ASTQuasiUnquoteNode)self :aBlock :: Void |
        if: (self expression isNotNil) then: (self expression: aBlock(self expression))
    } makeOverride.

ASTQuoteNode
    withSelector: #isQuoteNode addMethod: {:(ASTNode)self :: Boolean | true } makeOverride;

    withSelector: #analyzeWithEnvironment: addMethod: {:(ASTQuoteNode)self :(AnalysisAndEvaluationEnvironment)environment :: ASTNode|
        ASTLiteralNode new
            sourcePosition: self sourcePosition;
            value: self node;
            analyzedType: self node __type__;
            yourself
    } makeOverride;
    withSelector: #analyzeAndEvaluateWithEnvironment: addMethod: {:(ASTQuoteNode)self :(Environment)environment :: Untyped | self node} makeOverride;
    withSelector: #evaluateWithEnvironment: addMethod: {:(ASTQuoteNode)self :(FunctionActivationEnvironment)environment | self node} makeOverride;
    withSelector: #childrenDo: addMethod: {:(ASTQuoteNode)self :aBlock :: Void |
        if: (self node isNotNil) then: aBlock(self node)
    } makeOverride;
    withSelector: #transformWith: addMethod: {:(ASTQuoteNode)self :aBlock :: Void |
        if: (self node isNotNil) then: (self node: aBlock(self node))
    } makeOverride.

ASTSpliceNode
    withSelector: #isSpliceNode addMethod: {:(ASTNode)self :: Boolean | true } makeOverride;

    withSelector: #analyzeWithEnvironment: addMethod: {:(ASTSpliceNode)self :(AnalysisAndEvaluationEnvironment)environment | self invalidLocationError } makeOverride;
    withSelector: #analyzeAndEvaluateWithEnvironment: addMethod: {:(ASTSpliceNode)self :(Environment)environment :: Untyped | self invalidLocationError } makeOverride;
    withSelector: #evaluateWithEnvironment: addMethod: {:(ASTSpliceNode)self :(FunctionActivationEnvironment)environment | self invalidLocationError } makeOverride;
    withSelector: #childrenDo: addMethod: {:(ASTSpliceNode)self :aBlock :: Void |
        if: (self expression isNotNil) then: aBlock(self expression)
    } makeOverride;
    withSelector: #transformWith: addMethod: {:(ASTSpliceNode)self :aBlock :: Void |
        if: (self expression isNotNil) then: (self expression: aBlock(self expression))
    } makeOverride;

    withSelector: #analyzeQuasiQuoteWithEnvironment:parameterList: addMethod: {:(ASTSpliceNode)self :(AnalysisAndEvaluationEnvironment)environment :(OrderedCollection)parameterList | self invalidLocationError } makeOverride;
    withSelector: #analyzeAndEvaluateQuasiQuoteWithEnvironment: addMethod: {:(ASTSpliceNode)self :(Environment)environment | self invalidLocationError } makeOverride;
    withSelector: #evaluateQuasiQuoteWithParameters: addMethod: {:(ASTSpliceNode)self :(Array)parameters | self invalidLocationError } makeOverride;

    withSelector: #analyzeQuasiQuoteOrSpliceWithEnvironment:parameterList: addMethod: {:(ASTSpliceNode)self :(AnalysisAndEvaluationEnvironment)environment :(OrderedCollection)parameterList :: ASTNode |
        let: #astTemplateParameterIndex with: parameterList size.
        parameterList add: self expression.
        self copy
            astTemplateParameterIndex: astTemplateParameterIndex;
            yourself
    } makeOverride;

    withSelector: #invalidLocationError addMethod: {:(ASTSpliceNode)self |
        self error: "Invalid location for a splice expression."
    }.

ASTWhileContinueWithNode
    withSelector: #isWhileContinueWithNode addMethod: {:(ASTNode)self :: Boolean | true } makeOverride;

    withSelector: #childrenDo: addMethod: {:(ASTWhileContinueWithNode)self :aBlock :: Void |
        if: (self conditionExpression isNotNil) then: aBlock(self conditionExpression).
        if: (self bodyExpression isNotNil) then: aBlock(self bodyExpression).
        if: (self continueExpression isNotNil) then: aBlock(self bodyExpression).
    } makeOverride;
    withSelector: #transformWith: addMethod: {:(ASTWhileContinueWithNode)self :aBlock :: Void |
        if: (self conditionExpression isNotNil) then: (self conditionExpression: aBlock(self conditionExpression)).
        if: (self bodyExpression isNotNil) then: (self bodyExpression: aBlock(self bodyExpression)).
        if: (self continueExpression isNotNil) then: (self continueExpression: aBlock(self continueExpression)).
    } makeOverride.