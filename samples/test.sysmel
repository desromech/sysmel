printLine("Hello World from Sysmel in Tuuvm").
printLine(Integer::+(42, 1)).

printLine(42 identityHash).
printLine(42 __type__).
printLine({}).
printLine({|}).
printLine({:x | x }).
printLine({:x :y | x + y}).
printLine({:x :y :: Int32 | x + y}).

printLine({:(Integer)x | x}(2)).
printLine({:(Integer)x :: Integer | x}(2)).

printLine(2 + 3).
printLine({:(Integer)x :(Integer)y | x + y }(2, 3)).
printLine({:(Integer)x :(Integer)y :: Integer | x + y }(2, 3)).

let: #x with: 3.
printLine(x).

printLine(42 + 1).

printLine(send(#+ , 42, 1)).

printLine(42).
printLine(42 printString).

let: #square with: {:(Int32)x :: Int32 | x*x}.
printLine(square).
printLine(square definition definitionBodyNode).
printLine(square definition sourcePosition).
printLine(square definition definitionBodyNode sourcePosition).

printLine(#[]).
printLine(#[1]).
printLine(#[1 . 2 . 3]).
printLine((Array, ArraySlice)).

printLine(`'42).
printLine(``42).
printLine(``(`,(ASTSequenceNode new))).

printLine(0.0).
printLine(1.5 + 2.25).
printLine(0.0f32).
printLine(1.5f32 + 2.25f32).

let testValue := 42.
printLine(testValue).

Object extend: {
    __Meta__ definition: {
        public method testClassMethod := {
            printLine(self, " testClassMethod")
        }.
    }.

    public method testMethod => Void := {
        let localVar := 42.
        printLine(self, " testMethod ", localVar).
    }.

    public method testMethodWithArgument: arg ::=> Void := {
        printLine(self, " testMethodWithArgument: ", arg).
    }.
}.

Object testClassMethod.
Object new testMethod.
Object new testMethodWithArgument: 42.
printLine(Object lookupSelector: #testMethod, " ", (Object lookupSelector: #testMethod) hasPragmaNamed: #testPragma).

public class TestClass superclass: Object; definition: {
    public field testField.
    public method myTestMethod => Int32
        := 42i32.

    public pure method square: x
        := x*x.

    public method returnTest := {
        return: 5.
        3
    }.
}.


printLine(TestClass).
printLine(TestClass new myTestMethod).
printLine(2, " ", TestClass new square: 2).
printLine(TestClass new returnTest).
printLine(TestClass validTotalSlotCount).
printLine(TestClass new testField).
printLine(TestClass new testField: 42; testField).

printLine((TestClass >> #myTestMethod) definition analyzedBodyNode value).

let: #theAnswer with: {:: Int32 | 42i32 }.
printLine(theAnswer, " ", theAnswer()).
printLine(theAnswer asSSAFunction fullPrintString).

printLine(square).
printLine(square asSSAFunction fullPrintString).

let: #min with: {:(Int32)x :(Int32)y :: Int32 |
    if: x < y then: x else: y
}.

let: #max with: {:(Int32)x :(Int32)y :: Int32 |
    if: x < y then: {x} else: {y}
}.

printLine(min).
printLine(min asSSAFunction fullPrintString).

printLine(max).
printLine(max asSSAFunction fullPrintString).

let: #withLocal with: {:(Int32)x :: Int32 |
    let y => Int32 := x.
    y + 2i32
}.

printLine(withLocal).
printLine(withLocal asSSAFunction fullPrintString).

let: #withLocal2 with: {:(Int32)x :: Int32 |
    let y := x.
    y + 2i32
}.
printLine(withLocal2).
printLine(withLocal2 asSSAFunction fullPrintString).


let: #withReturn with: {:(Int32)x :: Int32 |
    return: 2.
    4
}.
printLine(withReturn).
printLine(withReturn asSSAFunction fullPrintString).

let: #makePlusN with: {:(Int32)n :: Function |
    {:(Int32)x :: Int32 | x + n}
}.
printLine(makePlusN).
printLine(makePlusN asSSAFunction fullPrintString).

let: #sequenceableCollectionDo with: SequenceableCollection >> #do:.
printLine(sequenceableCollectionDo).
printLine(sequenceableCollectionDo asSSAFunction fullPrintString).
