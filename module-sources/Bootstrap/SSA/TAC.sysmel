let IgnoreNotYetImplementedErrors := true.

public class SSATACCompilationTarget superclass: SSACompilationTarget; definition: {
    public field tacCompilationTarget => TACCompilationTarget.

    public override method objectModel => ObjectModelVariant
        := tacCompilationTarget objectModel.

    public override method pointerSize => Size
        := tacCompilationTarget pointerSize.

    public override method pointerAlignment => Size
        := tacCompilationTarget pointerAlignment.
}.

public abstract class SSATACCodeGenerator superclass: Object; definition: {

}.

TACCompilationTarget extend: {
    public method asSSACompilationTarget => SSACompilationTarget
        := SSATACCompilationTarget new tacCompilationTarget: self; yourself.
}.

public final class SSAModuleTACCodeGenerator superclass: SSATACCodeGenerator; definition: {
    public field compilationTarget => TACCompilationTarget.
    public field targetModule => TACModule.
    public field globalValueDictionary => Dictionary.
    public field capturelessUncheckedEntryPointDictionary => Dictionary.
    public field uncheckedEntryPointDictionary => Dictionary.
    public field checkedEntryPointDictionary => Dictionary.

    private field uncheckedFunctionEntryPointTrampoline => TACProgramEntity.
    private field checkedFunctionEntryPointTrampoline => TACProgramEntity.

    public method initializeWithTarget: (theCompilationTarget: TACCompilationTarget) ::=> Void := {
        compilationTarget := theCompilationTarget.
        targetModule := TACModule new
            compilationTarget: compilationTarget;
            yourself.
        globalValueDictionary := Dictionary new.
        capturelessUncheckedEntryPointDictionary := Dictionary new.
        uncheckedEntryPointDictionary := Dictionary new.
        checkedEntryPointDictionary := Dictionary new.
    }.

    public method compileSSAModule: (module: SSAModule) ::=> TACModule := {
        ## Declare the values.
        module globalValues do: {:(SSAGlobalValue)each :: Void |
            each compileDirectTacTranslationWith: self
        }.

        ## Return the target module.
        targetModule
    }.

    public method finish => TACModule
        := targetModule.

    public method compileDirectFunction: (function: SSAFunction) ::=> Void := {
        (function isTargetDefinedPrimitive && function exportedSymbols isEmpty) ifTrue: {return: void}.

        function definition ifNotNil: {
            function isCaptureless ifTrue: {
                (self translateCapturelessUncheckedFunctionEntryPoint: function definition)
                    addExportedSymbols: function exportedSymbols
            } ifFalse: {
                self error: "TODO: Compile non-captureless function."
            }.
        }
    }.

    public method compileDirectFunctionDefinition: (functionDefinition: SSAFunctionDefinition) ::=> Void := {
        functionDefinition isTargetDefinedPrimitive ifTrue: {return: void}.

        functionDefinition isCaptureless ifTrue: {
            self translateCapturelessUncheckedFunctionEntryPoint: functionDefinition
        } ifFalse: {
            self translateUncheckedFunctionEntryPoint: functionDefinition
        }
    }.

    public method translateValue: (value: SSAValue) ::=> TACValue
        := globalValueDictionary at: value ifAbsent: {|
        value translateIntoTacValueWith: self
    }.

    public method translateFunction: (function: SSAFunction) ::=> TACValue
        := globalValueDictionary at: function ifAbsentPut: {|
            self compileFunction: function
        }.

    public method translateFunctionDefinition: (functionDefinition: SSAFunctionDefinition) ::=> TACValue
        := globalValueDictionary at: functionDefinition ifAbsentPut: {|
            self compileFunctionDefinition: functionDefinition
        }.

    public method compileFunction: (function: SSAFunction) ::=> TACValue := {
        let functionObject := TACGlobalVariable new
            type: Function;
            name: function name;
            yourself.
        targetModule addProgramEntity: functionObject.
        globalValueDictionary at: function put: functionObject.

        functionObject
    }.

    public method compileFunctionDefinition: (functionDefinition: SSAFunctionDefinition) ::=> TACValue := {
        let functionDefinitionObject := TACGlobalVariable new
            type: FunctionDefinition;
            name: functionDefinition name;
            yourself.
        targetModule addProgramEntity: functionDefinitionObject.
        globalValueDictionary at: functionDefinition put: functionDefinitionObject.

        functionDefinitionObject
    }.

    public method compileCapturelessUncheckedFunctionEntryPoint: (functionDefinition: SSAFunctionDefinition) ::=> TACProgramEntity := {
        let importedSymbols := functionDefinition importedSymbols.
        importedSymbols isEmpty ifTrue: {
            let entryPoint := TACFunction new
                compilationTarget: compilationTarget;
                callingConvention: compilationTarget defaultCallingConvention;
                name: functionDefinition name asCapturelessUncheckedEntryPointNameSymbol;
                debugSourcePosition: functionDefinition sourcePosition;
                debugSourceNode: functionDefinition sourceASTNode;
                debugSourceEnvironment: functionDefinition sourceEnvironment;
                sourceProgramEntity: functionDefinition sourceObject;
                yourself.
            targetModule addProgramEntity: entryPoint.
            capturelessUncheckedEntryPointDictionary at: functionDefinition put: entryPoint.

            SSAFunctionDefinitionTACCodeGenerator new
                moduleCodeGenerator: self;
                compileSSAFunctionDefinition: functionDefinition intoCapturelessEntryPoint: entryPoint.

            entryPoint
        } ifFalse: {
            let importedEntity := TACImportedFunction new
                name: importedSymbols first;
                compilationTarget: compilationTarget;
                alternativeSymbols: importedSymbols;
                yourself.
            targetModule addProgramEntity: importedEntity.
            capturelessUncheckedEntryPointDictionary at: functionDefinition put: importedEntity.

            importedEntity
        }.
    }.

    public method compileUncheckedFunctionEntryPoint: (functionDefinition: SSAFunctionDefinition) ::=> TACProgramEntity := {
        let entryPoint := TACFunction new
            compilationTarget: compilationTarget;
            callingConvention: compilationTarget defaultCallingConvention;
            name: functionDefinition name asUncheckedEntryPointNameSymbol;
            debugSourcePosition: functionDefinition sourcePosition;
            debugSourceNode: functionDefinition sourceASTNode;
            debugSourceEnvironment: functionDefinition sourceEnvironment;
            sourceProgramEntity: functionDefinition sourceObject;
            yourself.
        targetModule addProgramEntity: entryPoint.
        uncheckedEntryPointDictionary at: functionDefinition put: entryPoint.

        SSAFunctionDefinitionTACCodeGenerator new
            moduleCodeGenerator: self;
            compileSSAFunctionDefinition: functionDefinition intoUncheckedEntryPoint: entryPoint.

        entryPoint
    }.

    public method compileCheckedFunctionEntryPoint: (functionDefinition: SSAFunctionDefinition) ::=> TACProgramEntity := {
        let entryPoint := TACFunction new
            compilationTarget: compilationTarget;
            callingConvention: compilationTarget defaultCallingConvention;
            name: functionDefinition name asCheckedEntryPointNameSymbol;
            debugSourcePosition: functionDefinition sourcePosition;
            debugSourceNode: functionDefinition sourceASTNode;
            debugSourceEnvironment: functionDefinition sourceEnvironment;
            debugIsTrampoline: true;
            sourceProgramEntity: functionDefinition sourceObject;
            yourself.
        targetModule addProgramEntity: entryPoint.
        checkedEntryPointDictionary at: functionDefinition put: entryPoint.

        SSAFunctionDefinitionTACCodeGenerator new
            moduleCodeGenerator: self;
            compileSSAFunctionDefinition: functionDefinition checkedEntryPoint: entryPoint
            into: (functionDefinition isCaptureless
                ifTrue: (self translateCapturelessUncheckedFunctionEntryPoint: functionDefinition)
                ifFalse: (self translateUncheckedFunctionEntryPoint: functionDefinition))
            isCaptureless: functionDefinition isCaptureless.

        entryPoint
    }.

    public method setValue: (value: SSAValue) translationInto: (tacValue: TACValue) ::=> TACValue := {
        globalValueDictionary at: value put: tacValue.
        tacValue
    }.

    public method validUncheckedFunctionEntryPointTrampoline => TACProgramEntity := {
        uncheckedFunctionEntryPointTrampoline ifNil: {
            uncheckedFunctionEntryPointTrampoline := targetModule build: #uncheckedFunctionEntryPointTrampoline function: {:(TACFunctionBuilder)functionBuilder :: Void |
            }
        }.

        uncheckedFunctionEntryPointTrampoline
    }.

    public method validCheckedFunctionEntryPointTrampoline => TACProgramEntity := {
        checkedFunctionEntryPointTrampoline ifNil: {
            checkedFunctionEntryPointTrampoline := targetModule build: #checkedFunctionEntryPointTrampoline function: {:(TACFunctionBuilder)functionBuilder :: Void |
            }
        }.

        checkedFunctionEntryPointTrampoline
    }.

    public method shouldCompileFunctionDefinition: (definition: SSAFunctionDefinition) ::=> Boolean
        := definition ~~ nil.

    public method translateCapturelessUncheckedFunctionEntryPoint: (value: SSAValue) ::=> TACProgramEntity := {
        let functionDefinition := value asSSAFunctionDefinitionOrNil.
        functionDefinition ifNil: {
            self error: "Cannot generate captureless unchecked entry point for function without a definition " -- value printString
        }.

        capturelessUncheckedEntryPointDictionary at: functionDefinition ifAbsent: {:: TACProgramEntity |
            self compileCapturelessUncheckedFunctionEntryPoint: functionDefinition
        }
    }.

    public method translateUncheckedFunctionEntryPoint: (value: SSAValue) ::=> TACProgramEntity := {
        let functionDefinition := value asSSAFunctionDefinitionOrNil.
        (self shouldCompileFunctionDefinition: functionDefinition) ifTrue: {
            uncheckedEntryPointDictionary at: functionDefinition ifAbsent: {:: TACProgramEntity |
                self compileUncheckedFunctionEntryPoint: functionDefinition
            }
        } ifFalse: {
            self validUncheckedFunctionEntryPointTrampoline
        }
    }.

    public method translateCheckedFunctionEntryPoint: (value: SSAValue) ::=> TACProgramEntity := {
        let functionDefinition := value asSSAFunctionDefinitionOrNil.
        (self shouldCompileFunctionDefinition: functionDefinition) ifTrue: {
            checkedEntryPointDictionary at: functionDefinition ifAbsent: {:: TACProgramEntity |
                self compileCheckedFunctionEntryPoint: functionDefinition
            }
        } ifFalse: {
            self validCheckedFunctionEntryPointTrampoline
        }
    }.

    public method translateGenericObjectPointer: (object: Untyped) ::=> TACValue := {
        (compilationTarget objectModel isImmediateReference: object) ifTrue: {
            compilationTarget objectModel tacImmediateReferenceFor: object 
        } ifFalse: {
            TACGenericObjectPointerConstant new
                size: compilationTarget pointerSize;
                alignment: compilationTarget pointerAlignment;
                object: object;
                type: compilationTarget uintPointerType;
                yourself
        }.
    }.

    public method translateCStringConstant: (string: String) ::=> TACValue
        := TACStringLiteralPointerConstant new
            size: compilationTarget pointerSize;
            alignment: compilationTarget pointerAlignment;
            string: string;
            type: compilationTarget uintPointerType;
            nullTerminated: true;
            yourself.
}.

public final class SSAFunctionDefinitionTACCodeGenerator superclass: SSATACCodeGenerator; definition: {
    public field moduleCodeGenerator => SSAModuleTACCodeGenerator.
    public field ssaFunctionDefinition => SSAFunctionDefinition.
    public field tacFunction => TACFunction.
    public field functionBuilder => TACFunctionBuilder.
    public field blockBuilder => TACBlockBuilder.
    protected field isCapturelessEntryPoint => Boolean.
    protected field valueDictionary => Dictionary.
    public field localOnlyAllocaDictionary => Dictionary.
    public field functionArgument => TACValue.

    public override method initialize => Void := {
        valueDictionary := Dictionary new.
        localOnlyAllocaDictionary := Dictionary new.
    }.

    public method compilationTarget => TACCompilationTarget
        := moduleCodeGenerator compilationTarget.

    public method compileSSAFunctionDefinition: (ssaFunctionDefinition: SSAFunctionDefinition) intoCapturelessEntryPoint: (entryPoint: TACFunction) ::=> Void := {
        self ssaFunctionDefinition: ssaFunctionDefinition.
        isCapturelessEntryPoint := true.

        entryPoint build: {:(TACFunctionBuilder)functionBuilder :: Void |
            tacFunction := functionBuilder function.
            self functionBuilder: functionBuilder.
            moduleCodeGenerator uncheckedEntryPointDictionary at: ssaFunctionDefinition put: tacFunction.

            self compileDefinition.

            tacFunction
        }.
    }.

    public method compileSSAFunctionDefinition: (ssaFunctionDefinition: SSAFunctionDefinition) intoUncheckedEntryPoint: (entryPoint: TACFunction) ::=> Void := {
        self ssaFunctionDefinition: ssaFunctionDefinition.
        isCapturelessEntryPoint := false.

        entryPoint build: {:(TACFunctionBuilder)functionBuilder :: Void |
            tacFunction := functionBuilder function.
            self functionBuilder: functionBuilder.
            moduleCodeGenerator uncheckedEntryPointDictionary at: ssaFunctionDefinition put: tacFunction.

            self compileDefinition.

            tacFunction
        }.
    }.

    public method compileFunction: (ssaFunction: SSAFunction) exportedEntryPoint: (exportedEntryPoint: TACFunction) into: (uncheckedEntryPoint: TACValue) ::=> Void := {
        let arguments := ssaFunction definition arguments collect: {:(SSAFunctionArgument)argument :: TACValue |
            exportedEntryPoint newArgument: argument name withType: argument type sourceBinding: argument sourceBinding.
        }.

        exportedEntryPoint arguments: arguments.

        exportedEntryPoint build: {:(TACFunctionBuilder)functionBuilder :: Void |
            self functionBuilder: functionBuilder.
            functionBuilder basicBlock: #trampoline build: {:(TACBlockBuilder)asm :: Void |
                let closure := self translateValue: ssaFunction.
                let callArguments := (Array with: closure) -- arguments.

                let canonicalResultType := ssaFunction definition functionType canonicalResultType.
                let result := canonicalResultType makeTacTemporaryValueNamed: #result withFunctionBuilder: functionBuilder.
                canonicalResultType emitTacCall: uncheckedEntryPoint convention: moduleCodeGenerator compilationTarget defaultCallingConvention
                    withArguments: callArguments into: result withBlockBuilder: asm.

                canonicalResultType emitTacReturn: result withBlockBuilder: asm
            }.
        }.
    }.

    public method compileSSAFunctionDefinition: (ssaFunctionDefinition: SSAFunctionDefinition) checkedEntryPoint: (checkedEntryPoint: TACFunction) into: (uncheckedEntryPoint: TACProgramEntity) isCaptureless: (isCaptureless: Boolean) ::=> Void := {
        let tacArguments := OrderedCollection new.
        functionArgument := checkedEntryPoint newArgument: #closure withType: Function.
        tacArguments add: functionArgument.

        let uncheckedArguments := ssaFunctionDefinition arguments collect: {:(SSAFunctionArgument)argument :: TACValue |
            let tacArgument := checkedEntryPoint newArgument: argument name withType: Untyped sourceBinding: argument sourceBinding.
            tacArguments add: tacArgument.
            tacArgument
        }.

        checkedEntryPoint arguments: tacArguments asArray.

        functionBuilder basicBlock: #wrapper build: {:(TACBlockBuilder)asm :: Void |
            let checkedAndConvertedArguments := ssaFunctionDefinition arguments collectWithIndex: {:(SSAFunctionArgument)argument :(Size)index :: TACValue |
                let tacArgument => TACValue := tacArguments at: index + 1sz.
                argument type emitTacCheckAndUnbox: tacArgument withBlockBuilder: asm
            }.

            let canonicalResultType := ssaFunctionDefinition functionType canonicalResultType.
            let result := canonicalResultType makeTacTemporaryValueNamed: #result withFunctionBuilder: functionBuilder.
            isCaptureless ifTrue: {
                canonicalResultType emitTacCall: uncheckedEntryPoint convention: uncheckedEntryPoint callingConvention
                    withArguments: checkedAndConvertedArguments into: result withBlockBuilder: asm.
            } ifFalse: {
                canonicalResultType emitTacCall: uncheckedEntryPoint convention: uncheckedEntryPoint callingConvention
                    withArguments: (Array with: functionArgument) -- checkedAndConvertedArguments into: result withBlockBuilder: asm.
            }.

            let boxedResult := canonicalResultType emitTacBox: result withBlockBuilder: asm.
            asm returnPointer: boxedResult
        }.
    }.

    public method compileDefinition => Void := {
        ssaFunctionDefinition importedSymbols size > 0sz ifTrue: {
            return: void.
        }.

        ## SSA must be destroyed before compiling.
        SSADestroySSAFunctionPass runIn: ssaFunctionDefinition.

        self declareArguments.

        self compilePrimitiveFunctionBody ifFalse: {
            self
                declareCaptures;
                declareValues;
                compileBasicBlocks.
        }.

        tacFunction performBasicOptimizations.
    }.

    public method declareArguments => Void := {
        let tacArguments := OrderedCollection new.
        isCapturelessEntryPoint ifFalse: {
            functionArgument := tacFunction newArgument: #closure withType: Function.
            tacArguments add: functionArgument.
        }.
        
        ssaFunctionDefinition arguments do: {:(SSAFunctionArgument)argument :: Void |
            let tacArgument := tacFunction newArgument: argument name withType: argument type sourceBinding: argument sourceBinding.
            valueDictionary at: argument put: tacArgument.
            tacArguments add: tacArgument.
        }.

        tacFunction arguments: tacArguments asArray.
    }.

    public method directArguments => Array
        := isCapturelessEntryPoint
            ifTrue: tacFunction arguments
            ifFalse: tacFunction arguments allButFirst.

    public method declareCaptures => Void := {
        let tacCaptures := OrderedCollection new.
        ssaFunctionDefinition captures do: {:(SSAFunctionCapture)capture :: Void |
            let tacCapture := tacFunction newCapture: capture name withType: capture type.
            valueDictionary at: capture put: tacCapture.
            tacCaptures add: tacCapture.
        }.

        tacFunction captures: tacCaptures asArray.
    }.

    public method declareValues => Void := {
        ssaFunctionDefinition basicBlocksDo: {:(SSABasicBlock)eachBlock :: Void |
            let tacBlock := TACBasicBlock new
                name: eachBlock name;
                debugSourcePosition: eachBlock sourcePosition;
                debugSourceNode: eachBlock sourceASTNode;
                debugSourceEnvironment: eachBlock sourceEnvironment;
                yourself.

            tacFunction addBasicBlock: tacBlock.
            valueDictionary at: eachBlock put: tacBlock.

            eachBlock instructionsDo: {:(SSAInstruction)each :: Void |
                functionBuilder useDebugInfoOfSSAValue: each.
                let tacValue := each makeTacValueForResultWith: self.
                valueDictionary at: each put: tacValue.
            }
        }
    }.

    public method compileBasicBlocks => Void := {
        ssaFunctionDefinition basicBlocksDo: {:(SSABasicBlock)eachBlock :: Void |
            let tacBlock := valueDictionary at: eachBlock.
            self compileBasicBlock: eachBlock into: tacBlock
        }.
    }.

    public method compileBasicBlock: (ssaBasicBlock: SSABasicBlock) into: (tacBlock: TACBasicBlock) ::=> Void := {
        blockBuilder := TACBlockBuilder new
            block: tacBlock;
            function: tacFunction;
            yourself.
        ssaBasicBlock instructionsDo: {:(SSAInstruction)eachInstruction :: Void |
            functionBuilder useDebugInfoOfSSAValue: eachInstruction.
            blockBuilder useDebugInfoOfSSAValue: eachInstruction.
            eachInstruction compileIntoTacValue: (valueDictionary at: eachInstruction) with: self
        }
    }.

    public method translateValue: (value: SSAValue) ::=> TACValue
        := valueDictionary at: value ifAbsent: {|
            moduleCodeGenerator translateValue: value
        }.
    
    public method translateBoxedValue: (value: SSAValue) ::=> TACValue
        := self translateValue: value.

    public method translateCapturelessUncheckedFunctionEntryPoint: (value: SSAValue) ::=> TACValue
        := moduleCodeGenerator translateCapturelessUncheckedFunctionEntryPoint: value.

    public method translateUncheckedFunctionEntryPoint: (value: SSAValue) ::=> TACValue
        := moduleCodeGenerator translateUncheckedFunctionEntryPoint: value.

    public method translateCheckedFunctionEntryPoint: (value: SSAValue) ::=> TACValue
        := moduleCodeGenerator translateCheckedFunctionEntryPoint: value.

    public method notYetImplementedError: (error: String) ::=> Void := {
        IgnoreNotYetImplementedErrors ifTrue: {
            blockBuilder trap
        } ifFalse: {
            self error: "SSA->TAC NotYetImplemented: " -- error
        }.
    }.

}.

TACFunctionBuilder extend: {
    public method useDebugInfoOfSSAValue: (value: SSAValue) ::=> Void := {
        debugSourcePosition := value sourcePosition.
        debugSourceNode := value sourceASTNode.
        debugSourceEnvironment := value sourceEnvironment.
    }
}.

TACBlockBuilder extend: {
    public method useDebugInfoOfSSAValue: (value: SSAValue) ::=> Void := {
        debugSourcePosition := value sourcePosition.
        debugSourceNode := value sourceASTNode.
        debugSourceEnvironment := value sourceEnvironment.
    }
}.

Type extend: {
    public virtual method emitTacCheckAndUnbox: (value: TACValue) withBlockBuilder: (builder: TACBlockBuilder) ::=> TACValue := {
        ## TODO: Emit a type check call.
        value
    }.

    public virtual method emitTacBox: (value: TACValue) withBlockBuilder: (builder: TACBlockBuilder) ::=> TACValue := {
        value
    }.

    public virtual method emitTacReturn: (value: TACValue) withBlockBuilder: (builder: TACBlockBuilder) ::=> Void := {
        builder returnPointer: value.
    }.

    public virtual method emitTacCall: (function: TACValue) convention: (callingConvention: TACCallingConvention) withArguments: (arguments: Array) into: (result: TACValue) withBlockBuilder: (builder: TACBlockBuilder) ::=> Void := {
        builder callPointer: function convention: callingConvention arguments: arguments result: result
    }.

    public virtual method makeTacTemporaryValueNamed: (name: Symbol) withFunctionBuilder: (functionBuilder: TACFunctionBuilder) ::=> TACValue
        := functionBuilder newTemporary: name withType: self.

    public virtual method translateSSALiteralConstant: (constant: SSALiteralConstant) intoTacWith: (codegen: SSAModuleTACCodeGenerator) ::=> TACValue
        := codegen translateGenericObjectPointer: constant value.

    public virtual method translateUndefinedConstant: (constant: SSAUndefinedConstant) intoTacWith: (codegen: SSAModuleTACCodeGenerator) ::=> TACValue
        := codegen compilationTarget pointerSize = 4sz ifTrue: 0u32 asTacConstant ifFalse: 0u64 asTacConstant.

    public virtual method translateSSALiteralConstant: (constant: SSALiteralConstant) pointerType: (pointerType: PointerLikeType) storage: storage base: base offset: (offset: IntPointer) intoTacWith: (codegen: SSAModuleTACCodeGenerator) ::=> TACValue
        := codegen translateGenericObjectPointer: constant value.

    public virtual method emitTacMove: (sourceValue: TACValue) into: (targetValue: TACValue) withBlockBuilder: (builder: TACBlockBuilder) ::=> Void := {
        builder movePointer: sourceValue into: targetValue
    }.

    public virtual method emitTacLoadFromPointer: (pointer: TACValue) constantOffset: (constantOffset: Int64) into: (result: TACValue) withBlockBuilder: (builder: TACBlockBuilder) ::=> Void := {
        builder loadPointer: pointer constantOffset: constantOffset into: result
    }.

    public virtual method emitTacStore: (value: TACValue) intoPointer: (pointer: TACValue) constantOffset: (constantOffset: Int64) withBlockBuilder: (builder: TACBlockBuilder) ::=> Void := {
        builder storePointer: value into: pointer constantOffset: constantOffset
    }.
}.

ObjectModelVariant extend: {
    public abstract method tacImmediateReferenceFor: (object: Untyped) ::=> TACValue
        := self subclassResponsibility.
}.

ObjectModelVariant32 extend: {
    public override method tacImmediateReferenceFor: (object: Untyped) ::=> TACValue
        := (RawTuple::type(object) encodeImmediateReference32: object) asTacConstant.
}.

ObjectModelVariant64 extend: {
    public override method tacImmediateReferenceFor: (object: Untyped) ::=> TACValue
        := (RawTuple::type(object) encodeImmediateReference64: object) asTacConstant.
}.

String class extend: {
    public override method translateSSALiteralConstant: (constant: SSALiteralConstant) pointerType: (pointerType: PointerLikeType) storage: storage base: base offset: (offset: IntPointer) intoTacWith: (codegen: SSAModuleTACCodeGenerator) ::=> TACValue := {
        if: (pointerType baseType == Char8 const) && (base == nil) && (offset = 0iptr) then: {
            codegen translateCStringConstant: storage
        } else: {
            super translateSSALiteralConstant: constant pointerType: pointerType storage: storage base: base offset: offset intoTacWith: codegen
        }.
    }.
}.

ValueType extend: {
    public override method emitTacCall: (function: TACValue) convention: (callingConvention: TACCallingConvention) withArguments: (arguments: Array) into: (result: TACValue) withBlockBuilder: (builder: TACBlockBuilder) ::=> Void := {
        builder callStruct: function convention: callingConvention arguments: arguments result: result
    }.

    public override method emitTacReturn: (value: TACValue) withBlockBuilder: (builder: TACBlockBuilder) ::=> Void := {
        builder returnStruct: value
    }.

    public override method emitTacMove: (sourceValue: TACValue) into: (targetValue: TACValue) withBlockBuilder: (builder: TACBlockBuilder) ::=> Void := {
        builder moveStruct: sourceValue into: targetValue
    }.

    public override method emitTacLoadFromPointer: (pointer: TACValue) constantOffset: (constantOffset: Int64) into: (result: TACValue) withBlockBuilder: (builder: TACBlockBuilder) ::=> Void := {
        builder loadStruct: pointer constantOffset: constantOffset into: result
    }.

    public override method emitTacStore: (value: TACValue) intoPointer: (pointer: TACValue) constantOffset: (constantOffset: Int64) withBlockBuilder: (builder: TACBlockBuilder) ::=> Void := {
        builder storeStruct: value into: pointer constantOffset: constantOffset
    }.
}.

PointerLikeType extend: {
    public override method translateSSALiteralConstant: (constant: SSALiteralConstant) intoTacWith: (codegen: SSAModuleTACCodeGenerator) ::=> TACValue := {
        let value => Untyped := constant value.
        let isBytes := RawTuple::isBytes(value).
        let pointerSize => Size := RawTuple::size(value).

        if: isBytes then: {
            self error: "TODO: Translate pointer integer value."
        } else: {
            let storage := (if: pointerSize >= 1sz then: (RawTuple::slotAt:)(value, 0sz) else: nil).
            let base := (if: pointerSize >= 2sz then: (RawTuple::slotAt:)(value, 1sz) else: nil).
            let offset := (if: pointerSize >= 3sz then: (RawTuple::slotAt:)(value, 2sz) else: 0iptr).
            storage __type__ translateSSALiteralConstant: constant pointerType: self storage: storage base: base offset: offset intoTacWith: codegen
        }
    }.

    public override method emitTacCall: (function: TACValue) convention: (callingConvention: TACCallingConvention) withArguments: (arguments: Array) into: (result: TACValue) withBlockBuilder: (builder: TACBlockBuilder) ::=> Void := {
        builder callPointer: function convention: callingConvention arguments: arguments result: result
    }.

    public override method emitTacReturn: (value: TACValue) withBlockBuilder: (builder: TACBlockBuilder) ::=> Void := {
        builder returnPointer: value
    }.

    public override method emitTacMove: (sourceValue: TACValue) into: (targetValue: TACValue) withBlockBuilder: (builder: TACBlockBuilder) ::=> Void := {
        builder movePointer: sourceValue into: targetValue
    }.

    public override method emitTacLoadFromPointer: (pointer: TACValue) constantOffset: (constantOffset: Int64) into: (result: TACValue) withBlockBuilder: (builder: TACBlockBuilder) ::=> Void := {
        builder loadPointer: pointer constantOffset: constantOffset into: result
    }.

    public override method emitTacStore: (value: TACValue) intoPointer: (pointer: TACValue) constantOffset: (constantOffset: Int64) withBlockBuilder: (builder: TACBlockBuilder) ::=> Void := {
        builder storePointer: value into: pointer constantOffset: constantOffset
    }.
}.

Char8 __type__ extend: {
    public override method emitTacCall: (function: TACValue) convention: (callingConvention: TACCallingConvention) withArguments: (arguments: Array) into: (result: TACValue) withBlockBuilder: (builder: TACBlockBuilder) ::=> Void := {
        builder callInt32: function convention: callingConvention arguments: arguments result: result
    }.

    public override method emitTacReturn: (value: TACValue) withBlockBuilder: (builder: TACBlockBuilder) ::=> Void := {
        builder returnInt32: value
    }.

    public override method emitTacMove: (sourceValue: TACValue) into: (targetValue: TACValue) withBlockBuilder: (builder: TACBlockBuilder) ::=> Void := {
        builder moveInt8: sourceValue into: targetValue
    }.

    public override method emitTacLoadFromPointer: (pointer: TACValue) constantOffset: (constantOffset: Int64) into: (result: TACValue) withBlockBuilder: (builder: TACBlockBuilder) ::=> Void := {
        builder loadUInt8: pointer constantOffset: constantOffset into: result
    }.

    public override method emitTacStore: (value: TACValue) intoPointer: (pointer: TACValue) constantOffset: (constantOffset: Int64) withBlockBuilder: (builder: TACBlockBuilder) ::=> Void := {
        builder storeInt8: value into: pointer constantOffset: constantOffset
    }.

    public override method translateUndefinedConstant: (constant: SSAUndefinedConstant) intoTacWith: (codegen: SSAModuleTACCodeGenerator) ::=> TACValue
        := 0u8 asTacConstant.

    public override method translateSSALiteralConstant: (constant: SSALiteralConstant) intoTacWith: (codegen: SSAModuleTACCodeGenerator) ::=> TACValue
        := constant value asUInt8 asTacConstant.
}.

Int8 __type__ extend: {
    public override method emitTacCall: (function: TACValue) convention: (callingConvention: TACCallingConvention) withArguments: (arguments: Array) into: (result: TACValue) withBlockBuilder: (builder: TACBlockBuilder) ::=> Void := {
        builder callInt8: function convention: callingConvention arguments: arguments result: result
    }.

    public override method emitTacReturn: (value: TACValue) withBlockBuilder: (builder: TACBlockBuilder) ::=> Void := {
        builder returnInt8: value
    }.

    public override method emitTacMove: (sourceValue: TACValue) into: (targetValue: TACValue) withBlockBuilder: (builder: TACBlockBuilder) ::=> Void := {
        builder moveInt8: sourceValue into: targetValue
    }.

    public override method emitTacLoadFromPointer: (pointer: TACValue) constantOffset: (constantOffset: Int64) into: (result: TACValue) withBlockBuilder: (builder: TACBlockBuilder) ::=> Void := {
        builder loadInt8: pointer constantOffset: constantOffset into: result
    }.

    public override method emitTacStore: (value: TACValue) intoPointer: (pointer: TACValue) constantOffset: (constantOffset: Int64) withBlockBuilder: (builder: TACBlockBuilder) ::=> Void := {
        builder storeInt8: value into: pointer constantOffset: constantOffset
    }.

    public override method translateUndefinedConstant: (constant: SSAUndefinedConstant) intoTacWith: (codegen: SSAModuleTACCodeGenerator) ::=> TACValue
        := 0i8 asTacConstant.

    public override method translateSSALiteralConstant: (constant: SSALiteralConstant) intoTacWith: (codegen: SSAModuleTACCodeGenerator) ::=> TACValue
        := constant value asTacConstant.
}.

UInt8 __type__ extend: {
    public override method emitTacCall: (function: TACValue) convention: (callingConvention: TACCallingConvention) withArguments: (arguments: Array) into: (result: TACValue) withBlockBuilder: (builder: TACBlockBuilder) ::=> Void := {
        builder callInt8: function convention: callingConvention arguments: arguments result: result
    }.

    public override method emitTacReturn: (value: TACValue) withBlockBuilder: (builder: TACBlockBuilder) ::=> Void := {
        builder returnInt8: value
    }.

    public override method emitTacMove: (sourceValue: TACValue) into: (targetValue: TACValue) withBlockBuilder: (builder: TACBlockBuilder) ::=> Void := {
        builder moveInt8: sourceValue into: targetValue
    }.

    public override method emitTacLoadFromPointer: (pointer: TACValue) constantOffset: (constantOffset: Int64) into: (result: TACValue) withBlockBuilder: (builder: TACBlockBuilder) ::=> Void := {
        builder loadUInt8: pointer constantOffset: constantOffset into: result
    }.

    public override method emitTacStore: (value: TACValue) intoPointer: (pointer: TACValue) constantOffset: (constantOffset: Int64) withBlockBuilder: (builder: TACBlockBuilder) ::=> Void := {
        builder storeInt8: value into: pointer constantOffset: constantOffset
    }.

    public override method translateUndefinedConstant: (constant: SSAUndefinedConstant) intoTacWith: (codegen: SSAModuleTACCodeGenerator) ::=> TACValue
        := 0u8 asTacConstant.

    public override method translateSSALiteralConstant: (constant: SSALiteralConstant) intoTacWith: (codegen: SSAModuleTACCodeGenerator) ::=> TACValue
        := constant value asTacConstant.
}.

Boolean __type__ extend: {
    public override method emitTacCall: (function: TACValue) convention: (callingConvention: TACCallingConvention) withArguments: (arguments: Array) into: (result: TACValue) withBlockBuilder: (builder: TACBlockBuilder) ::=> Void := {
        builder callInt8: function convention: callingConvention arguments: arguments result: result
    }.

    public override method emitTacReturn: (value: TACValue) withBlockBuilder: (builder: TACBlockBuilder) ::=> Void := {
        builder returnInt8: value
    }.

    public override method emitTacMove: (sourceValue: TACValue) into: (targetValue: TACValue) withBlockBuilder: (builder: TACBlockBuilder) ::=> Void := {
        builder moveInt8: sourceValue into: targetValue
    }.

    public override method emitTacLoadFromPointer: (pointer: TACValue) constantOffset: (constantOffset: Int64) into: (result: TACValue) withBlockBuilder: (builder: TACBlockBuilder) ::=> Void := {
        builder loadUInt8: pointer constantOffset: constantOffset into: result
    }.

    public override method emitTacStore: (value: TACValue) intoPointer: (pointer: TACValue) constantOffset: (constantOffset: Int64) withBlockBuilder: (builder: TACBlockBuilder) ::=> Void := {
        builder storeInt8: value into: pointer constantOffset: constantOffset
    }.

    public override method translateUndefinedConstant: (constant: SSAUndefinedConstant) intoTacWith: (codegen: SSAModuleTACCodeGenerator) ::=> TACValue
        := 0u8 asTacConstant.
}.

False __type__ extend: {
    public override method translateSSALiteralConstant: (constant: SSALiteralConstant) intoTacWith: (codegen: SSAModuleTACCodeGenerator) ::=> TACValue
        := 0u8 asTacConstant.

}.

True __type__ extend: {
    public override method translateSSALiteralConstant: (constant: SSALiteralConstant) intoTacWith: (codegen: SSAModuleTACCodeGenerator) ::=> TACValue
        := 1u8 asTacConstant.
}.

Char16 __type__ extend: {
    public override method emitTacCall: (function: TACValue) convention: (callingConvention: TACCallingConvention) withArguments: (arguments: Array) into: (result: TACValue) withBlockBuilder: (builder: TACBlockBuilder) ::=> Void := {
        builder callInt16: function convention: callingConvention arguments: arguments result: result
    }.

    public override method emitTacReturn: (value: TACValue) withBlockBuilder: (builder: TACBlockBuilder) ::=> Void := {
        builder returnInt16: value
    }.

    public override method emitTacMove: (sourceValue: TACValue) into: (targetValue: TACValue) withBlockBuilder: (builder: TACBlockBuilder) ::=> Void := {
        builder moveInt16: sourceValue into: targetValue
    }.

    public override method emitTacLoadFromPointer: (pointer: TACValue) constantOffset: (constantOffset: Int64) into: (result: TACValue) withBlockBuilder: (builder: TACBlockBuilder) ::=> Void := {
        builder loadUInt16: pointer constantOffset: constantOffset into: result
    }.

    public override method emitTacStore: (value: TACValue) intoPointer: (pointer: TACValue) constantOffset: (constantOffset: Int64) withBlockBuilder: (builder: TACBlockBuilder) ::=> Void := {
        builder storeInt16: value into: pointer constantOffset: constantOffset
    }.

    public override method translateSSALiteralConstant: (constant: SSALiteralConstant) intoTacWith: (codegen: SSAModuleTACCodeGenerator) ::=> TACValue
        := constant value asUInt16 asTacConstant.

    public override method translateUndefinedConstant: (constant: SSAUndefinedConstant) intoTacWith: (codegen: SSAModuleTACCodeGenerator) ::=> TACValue
        := 0u16 asTacConstant.
}.

Int16 __type__ extend: {
    public override method emitTacCall: (function: TACValue) convention: (callingConvention: TACCallingConvention) withArguments: (arguments: Array) into: (result: TACValue) withBlockBuilder: (builder: TACBlockBuilder) ::=> Void := {
        builder callInt16: function convention: callingConvention arguments: arguments result: result
    }.

    public override method emitTacReturn: (value: TACValue) withBlockBuilder: (builder: TACBlockBuilder) ::=> Void := {
        builder returnInt16: value
    }.

    public override method emitTacMove: (sourceValue: TACValue) into: (targetValue: TACValue) withBlockBuilder: (builder: TACBlockBuilder) ::=> Void := {
        builder moveInt16: sourceValue into: targetValue
    }.

    public override method emitTacLoadFromPointer: (pointer: TACValue) constantOffset: (constantOffset: Int64) into: (result: TACValue) withBlockBuilder: (builder: TACBlockBuilder) ::=> Void := {
        builder loadInt16: pointer constantOffset: constantOffset into: result
    }.

    public override method emitTacStore: (value: TACValue) intoPointer: (pointer: TACValue) constantOffset: (constantOffset: Int64) withBlockBuilder: (builder: TACBlockBuilder) ::=> Void := {
        builder storeInt16: value into: pointer constantOffset: constantOffset
    }.

    public override method translateSSALiteralConstant: (constant: SSALiteralConstant) intoTacWith: (codegen: SSAModuleTACCodeGenerator) ::=> TACValue
        := constant value asTacConstant.

    public override method translateUndefinedConstant: (constant: SSAUndefinedConstant) intoTacWith: (codegen: SSAModuleTACCodeGenerator) ::=> TACValue
        := 0i16 asTacConstant.
}.

UInt16 __type__ extend: {
    public override method emitTacCall: (function: TACValue) convention: (callingConvention: TACCallingConvention) withArguments: (arguments: Array) into: (result: TACValue) withBlockBuilder: (builder: TACBlockBuilder) ::=> Void := {
        builder callInt16: function convention: callingConvention arguments: arguments result: result
    }.

    public override method emitTacReturn: (value: TACValue) withBlockBuilder: (builder: TACBlockBuilder) ::=> Void := {
        builder returnInt16: value
    }.

    public override method emitTacMove: (sourceValue: TACValue) into: (targetValue: TACValue) withBlockBuilder: (builder: TACBlockBuilder) ::=> Void := {
        builder moveInt16: sourceValue into: targetValue
    }.

    public override method emitTacLoadFromPointer: (pointer: TACValue) constantOffset: (constantOffset: Int64) into: (result: TACValue) withBlockBuilder: (builder: TACBlockBuilder) ::=> Void := {
        builder loadUInt16: pointer constantOffset: constantOffset into: result
    }.

    public override method emitTacStore: (value: TACValue) intoPointer: (pointer: TACValue) constantOffset: (constantOffset: Int64) withBlockBuilder: (builder: TACBlockBuilder) ::=> Void := {
        builder storeInt16: value into: pointer constantOffset: constantOffset
    }.

    public override method translateSSALiteralConstant: (constant: SSALiteralConstant) intoTacWith: (codegen: SSAModuleTACCodeGenerator) ::=> TACValue
        := constant value asTacConstant.

    public override method translateUndefinedConstant: (constant: SSAUndefinedConstant) intoTacWith: (codegen: SSAModuleTACCodeGenerator) ::=> TACValue
        := 0u16 asTacConstant.
}.

Char32 __type__ extend: {
    public override method emitTacCall: (function: TACValue) convention: (callingConvention: TACCallingConvention) withArguments: (arguments: Array) into: (result: TACValue) withBlockBuilder: (builder: TACBlockBuilder) ::=> Void := {
        builder callInt32: function convention: callingConvention arguments: arguments result: result
    }.

    public override method emitTacReturn: (value: TACValue) withBlockBuilder: (builder: TACBlockBuilder) ::=> Void := {
        builder returnInt32: value
    }.

    public override method emitTacMove: (sourceValue: TACValue) into: (targetValue: TACValue) withBlockBuilder: (builder: TACBlockBuilder) ::=> Void := {
        builder moveInt32: sourceValue into: targetValue
    }.

    public override method emitTacLoadFromPointer: (pointer: TACValue) constantOffset: (constantOffset: Int64) into: (result: TACValue) withBlockBuilder: (builder: TACBlockBuilder) ::=> Void := {
        builder loadUInt32: pointer constantOffset: constantOffset into: result
    }.

    public override method emitTacStore: (value: TACValue) intoPointer: (pointer: TACValue) constantOffset: (constantOffset: Int64) withBlockBuilder: (builder: TACBlockBuilder) ::=> Void := {
        builder storeInt32: value into: pointer constantOffset: constantOffset
    }.

    public override method translateSSALiteralConstant: (constant: SSALiteralConstant) intoTacWith: (codegen: SSAModuleTACCodeGenerator) ::=> TACValue
        := constant value asUInt32 asTacConstant.

    public override method translateUndefinedConstant: (constant: SSAUndefinedConstant) intoTacWith: (codegen: SSAModuleTACCodeGenerator) ::=> TACValue
        := 0u32 asTacConstant.
}.

Int32 __type__ extend: {
    public override method emitTacCall: (function: TACValue) convention: (callingConvention: TACCallingConvention) withArguments: (arguments: Array) into: (result: TACValue) withBlockBuilder: (builder: TACBlockBuilder) ::=> Void := {
        builder callInt32: function convention: callingConvention arguments: arguments result: result
    }.

    public override method emitTacReturn: (value: TACValue) withBlockBuilder: (builder: TACBlockBuilder) ::=> Void := {
        builder returnInt32: value
    }.

    public override method emitTacMove: (sourceValue: TACValue) into: (targetValue: TACValue) withBlockBuilder: (builder: TACBlockBuilder) ::=> Void := {
        builder moveInt32: sourceValue into: targetValue
    }.

    public override method emitTacLoadFromPointer: (pointer: TACValue) constantOffset: (constantOffset: Int64) into: (result: TACValue) withBlockBuilder: (builder: TACBlockBuilder) ::=> Void := {
        builder loadInt32: pointer constantOffset: constantOffset into: result
    }.

    public override method emitTacStore: (value: TACValue) intoPointer: (pointer: TACValue) constantOffset: (constantOffset: Int64) withBlockBuilder: (builder: TACBlockBuilder) ::=> Void := {
        builder storeInt32: value into: pointer constantOffset: constantOffset
    }.

    public override method translateSSALiteralConstant: (constant: SSALiteralConstant) intoTacWith: (codegen: SSAModuleTACCodeGenerator) ::=> TACValue
        := constant value asTacConstant.

    public override method translateUndefinedConstant: (constant: SSAUndefinedConstant) intoTacWith: (codegen: SSAModuleTACCodeGenerator) ::=> TACValue
        := 0i32 asTacConstant.
}.

UInt32 __type__ extend: {
    public override method emitTacCall: (function: TACValue) convention: (callingConvention: TACCallingConvention) withArguments: (arguments: Array) into: (result: TACValue) withBlockBuilder: (builder: TACBlockBuilder) ::=> Void := {
        builder callInt32: function convention: callingConvention arguments: arguments result: result
    }.

    public override method emitTacReturn: (value: TACValue) withBlockBuilder: (builder: TACBlockBuilder) ::=> Void := {
        builder returnInt32: value
    }.

    public override method emitTacMove: (sourceValue: TACValue) into: (targetValue: TACValue) withBlockBuilder: (builder: TACBlockBuilder) ::=> Void := {
        builder moveInt32: sourceValue into: targetValue
    }.

    public override method emitTacLoadFromPointer: (pointer: TACValue) constantOffset: (constantOffset: Int64) into: (result: TACValue) withBlockBuilder: (builder: TACBlockBuilder) ::=> Void := {
        builder loadUInt32: pointer constantOffset: constantOffset into: result
    }.

    public override method emitTacStore: (value: TACValue) intoPointer: (pointer: TACValue) constantOffset: (constantOffset: Int64) withBlockBuilder: (builder: TACBlockBuilder) ::=> Void := {
        builder storeInt32: value into: pointer constantOffset: constantOffset
    }.

    public override method translateSSALiteralConstant: (constant: SSALiteralConstant) intoTacWith: (codegen: SSAModuleTACCodeGenerator) ::=> TACValue
        := constant value asTacConstant.

    public override method translateUndefinedConstant: (constant: SSAUndefinedConstant) intoTacWith: (codegen: SSAModuleTACCodeGenerator) ::=> TACValue
        := 0u32 asTacConstant.
}.

Int64 __type__ extend: {
    public override method emitTacCall: (function: TACValue) convention: (callingConvention: TACCallingConvention) withArguments: (arguments: Array) into: (result: TACValue) withBlockBuilder: (builder: TACBlockBuilder) ::=> Void := {
        builder callInt64: function convention: callingConvention arguments: arguments result: result
    }.

    public override method emitTacReturn: (value: TACValue) withBlockBuilder: (builder: TACBlockBuilder) ::=> Void := {
        builder returnInt64: value
    }.

    public override method emitTacMove: (sourceValue: TACValue) into: (targetValue: TACValue) withBlockBuilder: (builder: TACBlockBuilder) ::=> Void := {
        builder moveInt64: sourceValue into: targetValue
    }.

    public override method emitTacLoadFromPointer: (pointer: TACValue) constantOffset: (constantOffset: Int64) into: (result: TACValue) withBlockBuilder: (builder: TACBlockBuilder) ::=> Void := {
        builder loadInt64: pointer constantOffset: constantOffset into: result
    }.

    public override method emitTacStore: (value: TACValue) intoPointer: (pointer: TACValue) constantOffset: (constantOffset: Int64) withBlockBuilder: (builder: TACBlockBuilder) ::=> Void := {
        builder storeInt64: value into: pointer constantOffset: constantOffset
    }.

    public override method translateSSALiteralConstant: (constant: SSALiteralConstant) intoTacWith: (codegen: SSAModuleTACCodeGenerator) ::=> TACValue
        := constant value asTacConstant.

    public override method translateUndefinedConstant: (constant: SSAUndefinedConstant) intoTacWith: (codegen: SSAModuleTACCodeGenerator) ::=> TACValue
        := 0i64 asTacConstant.
}.

UInt64 __type__ extend: {
    public override method emitTacCall: (function: TACValue) convention: (callingConvention: TACCallingConvention) withArguments: (arguments: Array) into: (result: TACValue) withBlockBuilder: (builder: TACBlockBuilder) ::=> Void := {
        builder callInt64: function convention: callingConvention arguments: arguments result: result
    }.

    public override method emitTacReturn: (value: TACValue) withBlockBuilder: (builder: TACBlockBuilder) ::=> Void := {
        builder returnInt64: value
    }.

    public override method emitTacMove: (sourceValue: TACValue) into: (targetValue: TACValue) withBlockBuilder: (builder: TACBlockBuilder) ::=> Void := {
        builder moveInt64: sourceValue into: targetValue
    }.

    public override method emitTacLoadFromPointer: (pointer: TACValue) constantOffset: (constantOffset: Int64) into: (result: TACValue) withBlockBuilder: (builder: TACBlockBuilder) ::=> Void := {
        builder loadUInt64: pointer constantOffset: constantOffset into: result
    }.

    public override method emitTacStore: (value: TACValue) intoPointer: (pointer: TACValue) constantOffset: (constantOffset: Int64) withBlockBuilder: (builder: TACBlockBuilder) ::=> Void := {
        builder storeInt64: value into: pointer constantOffset: constantOffset
    }.

    public override method translateSSALiteralConstant: (constant: SSALiteralConstant) intoTacWith: (codegen: SSAModuleTACCodeGenerator) ::=> TACValue
        := constant value asTacConstant.

    public override method translateUndefinedConstant: (constant: SSAUndefinedConstant) intoTacWith: (codegen: SSAModuleTACCodeGenerator) ::=> TACValue
        := 0u32 asTacConstant.
}.

Float32 __type__ extend: {
    public override method emitTacCall: (function: TACValue) convention: (callingConvention: TACCallingConvention) withArguments: (arguments: Array) into: (result: TACValue) withBlockBuilder: (builder: TACBlockBuilder) ::=> Void := {
        builder callFloat32: function convention: callingConvention arguments: arguments result: result
    }.

    public override method emitTacReturn: (value: TACValue) withBlockBuilder: (builder: TACBlockBuilder) ::=> Void := {
        builder returnFloat32: value
    }.

    public override method emitTacMove: (sourceValue: TACValue) into: (targetValue: TACValue) withBlockBuilder: (builder: TACBlockBuilder) ::=> Void := {
        builder moveFloat32: sourceValue into: targetValue
    }.

    public override method emitTacLoadFromPointer: (pointer: TACValue) constantOffset: (constantOffset: Int64) into: (result: TACValue) withBlockBuilder: (builder: TACBlockBuilder) ::=> Void := {
        builder loadFloat32: pointer constantOffset: constantOffset into: result
    }.

    public override method emitTacStore: (value: TACValue) intoPointer: (pointer: TACValue) constantOffset: (constantOffset: Int64) withBlockBuilder: (builder: TACBlockBuilder) ::=> Void := {
        builder storeFloat32: value into: pointer constantOffset: constantOffset
    }.

    public override method translateSSALiteralConstant: (constant: SSALiteralConstant) intoTacWith: (codegen: SSAModuleTACCodeGenerator) ::=> TACValue
        := constant value asTacConstant.

    public override method translateUndefinedConstant: (constant: SSAUndefinedConstant) intoTacWith: (codegen: SSAModuleTACCodeGenerator) ::=> TACValue
        := 0.0f32 asTacConstant.
}.

Float64 __type__ extend: {
    public override method emitTacCall: (function: TACValue) convention: (callingConvention: TACCallingConvention) withArguments: (arguments: Array) into: (result: TACValue) withBlockBuilder: (builder: TACBlockBuilder) ::=> Void := {
        builder callFloat64: function convention: callingConvention arguments: arguments result: result
    }.

    public override method emitTacReturn: (value: TACValue) withBlockBuilder: (builder: TACBlockBuilder) ::=> Void := {
        builder returnFloat64: value
    }.

    public override method emitTacMove: (sourceValue: TACValue) into: (targetValue: TACValue) withBlockBuilder: (builder: TACBlockBuilder) ::=> Void := {
        builder moveFloat64: sourceValue into: targetValue
    }.

    public override method emitTacLoadFromPointer: (pointer: TACValue) constantOffset: (constantOffset: Int64) into: (result: TACValue) withBlockBuilder: (builder: TACBlockBuilder) ::=> Void := {
        builder loadFloat64: pointer constantOffset: constantOffset into: result
    }.

    public override method emitTacStore: (value: TACValue) intoPointer: (pointer: TACValue) constantOffset: (constantOffset: Int64) withBlockBuilder: (builder: TACBlockBuilder) ::=> Void := {
        builder storeFloat64: value into: pointer constantOffset: constantOffset
    }.

    public override method translateSSALiteralConstant: (constant: SSALiteralConstant) intoTacWith: (codegen: SSAModuleTACCodeGenerator) ::=> TACValue
        := constant value asTacConstant.

    public override method translateUndefinedConstant: (constant: SSAUndefinedConstant) intoTacWith: (codegen: SSAModuleTACCodeGenerator) ::=> TACValue
        := 0.0 asTacConstant.
}.

Void __type__ extend: {
    public override method emitTacCall: (function: TACValue) convention: (callingConvention: TACCallingConvention) withArguments: (arguments: Array) into: (result: TACValue) withBlockBuilder: (builder: TACBlockBuilder) ::=> Void := {
        builder callVoid: function convention: callingConvention arguments: arguments
    }.

    public override method emitTacReturn: (value: TACValue) withBlockBuilder: (builder: TACBlockBuilder) ::=> Void := {
        builder returnVoid
    }.

    public override method emitTacMove: (sourceValue: TACValue) into: (targetValue: TACValue) withBlockBuilder: (builder: TACBlockBuilder) ::=> Void := {
    }.

    public override method emitTacLoadFromPointer: (pointer: TACValue) constantOffset: (constantOffset: Int64) into: (result: TACValue) withBlockBuilder: (builder: TACBlockBuilder) ::=> Void := {
    }.

    public override method emitTacStore: (value: TACValue) intoPointer: (pointer: TACValue) constantOffset: (constantOffset: Int64) withBlockBuilder: (builder: TACBlockBuilder) ::=> Void := {
    }.

    public override method makeTacTemporaryValueNamed: (name: Symbol) withFunctionBuilder: (functionBuilder: TACFunctionBuilder) ::=> TACValue
        := nil.
}.

SSAValue extend: {
    public abstract method translateIntoTacValueWith: (codegen: SSAModuleTACCodeGenerator) ::=> TACValue
        := self subclassResponsibility.
}.

SSALiteralConstant extend: {
    public override method translateIntoTacValueWith: (codegen: SSAModuleTACCodeGenerator) ::=> TACValue
        := codegen setValue: self translationInto: (type translateSSALiteralConstant: self intoTacWith: codegen).
}.

SSAUndefinedConstant extend: {
    public override method translateIntoTacValueWith: (codegen: SSAModuleTACCodeGenerator) ::=> TACValue
        := codegen setValue: self translationInto: (type translateUndefinedConstant: self intoTacWith: codegen).
}.

SSAGlobalValue extend: {
    public virtual method compileDirectTacTranslationWith: (codegen: SSAModuleTACCodeGenerator) ::=> Void := {}.
}.

SSAFunction extend: {
    public override method translateIntoTacValueWith: (codegen: SSAModuleTACCodeGenerator) ::=> TACValue
        := codegen translateGenericObjectPointer: self sourceObject.

    public override method compileDirectTacTranslationWith: (codegen: SSAModuleTACCodeGenerator) ::=> Void := {
        codegen compileDirectFunction: self
    }.
}.

SSAFunctionDefinition extend: {
    public override method translateIntoTacValueWith: (codegen: SSAModuleTACCodeGenerator) ::=> TACValue
        := codegen translateGenericObjectPointer: self sourceObject.

    public override method compileDirectTacTranslationWith: (codegen: SSAModuleTACCodeGenerator) ::=> Void := {
        codegen compileDirectFunctionDefinition: self
    }.
}.

SSAInstruction extend: {
    public virtual method makeTacValueForResultWith: (codegen: SSAFunctionDefinitionTACCodeGenerator) ::=> TACValue
        := type makeTacTemporaryValueNamed: self name withFunctionBuilder: codegen functionBuilder.

    public abstract method compileIntoTacValue: (tacValue: TACValue) with: (codegen: SSAFunctionDefinitionTACCodeGenerator) ::=> Void
        := self subclassResponsibility.
}.

SSAAllocaInstruction extend: {
    public override method makeTacValueForResultWith: (codegen: SSAFunctionDefinitionTACCodeGenerator) ::=> TACValue := {
        self isLocalOnlyAlloca ifTrue: {
            let baseType := (self type downCastTo: PointerLikeType) baseType.
            let localVariable := baseType makeTacTemporaryValueNamed: self name withFunctionBuilder: codegen functionBuilder.
            codegen localOnlyAllocaDictionary at: self put: localVariable.
            nil
        } ifFalse: {
            super makeTacValueForResultWith: codegen
        }.
    }.

    public override method compileIntoTacValue: (tacValue: TACValue) with: (codegen: SSAFunctionDefinitionTACCodeGenerator) ::=> Void := {
        tacValue ifNotNil: {
            codegen notYetImplementedError: "Generate non-local alloca"
        }
    }.
}.

SSABranchInstruction extend: {
    public override method compileIntoTacValue: (tacValue: TACValue) with: (codegen: SSAFunctionDefinitionTACCodeGenerator) ::=> Void := {
        let destination := codegen translateValue: self destination.
        codegen blockBuilder branch: destination
    }.
}.

SSAConditionalBranchInstruction extend: {
    public override method compileIntoTacValue: (tacValue: TACValue) with: (codegen: SSAFunctionDefinitionTACCodeGenerator) ::=> Void := {
        let condition := codegen translateValue: self condition.
        let trueDestination := codegen translateValue: self trueDestination.
        let falseDestination := codegen translateValue: self falseDestination.
        codegen blockBuilder when: condition branchIfTrue: trueDestination branchIfFalse: falseDestination
    }.
}.

let translateUnaryPrimitiveInto := {:(TACOperation)operation :: ((Array, TACValue, SSAFunctionDefinitionTACCodeGenerator) => Boolean) |
    {:(Array)arguments :(TACValue)result :(SSAFunctionDefinitionTACCodeGenerator)codegen :: Boolean |
        let operand := codegen translateValue: arguments first.
        codegen blockBuilder operation: operation with: operand result: result.
        true
    }
}.

let translateBinaryPrimitiveInto := {:(TACOperation)operation :: ((Array, TACValue, SSAFunctionDefinitionTACCodeGenerator) => Boolean) |
    {:(Array)arguments :(TACValue)result :(SSAFunctionDefinitionTACCodeGenerator)codegen :: Boolean |
        let left := codegen translateValue: arguments first.
        let right := codegen translateValue: arguments second.
        codegen blockBuilder operation: operation with: left with: right result: result.
        true
    }
}.

public global SSATacPrimitiveCallGenerationTable := #{
    ## Pointer primitive
    #PointerLikeType::reinterpretCast : {:(Array)arguments :(TACValue)result :(SSAFunctionDefinitionTACCodeGenerator)codegen :: Boolean |
        codegen blockBuilder movePointer: (codegen translateValue: arguments first) into: result.
        true
    }.
    #PointerLikeType::reinterpretCastTo: : {:(Array)arguments :(TACValue)result :(SSAFunctionDefinitionTACCodeGenerator)codegen :: Boolean |
        codegen blockBuilder movePointer: (codegen translateValue: arguments first) into: result.
        true
    }.

    ## Identity equals/not-equals
    #== : {:(Array)arguments :(TACValue)result :(SSAFunctionDefinitionTACCodeGenerator)codegen :: Boolean |
        codegen blockBuilder pointerEquals: (codegen translateValue: arguments first) with: (codegen translateValue: arguments second) into: result.
        true
    }.
    #~~ : {:(Array)arguments :(TACValue)result :(SSAFunctionDefinitionTACCodeGenerator)codegen :: Boolean |
        codegen blockBuilder pointerNotEquals: (codegen translateValue: arguments first) with: (codegen translateValue: arguments second) into: result.
        true
    }.

    ## Char8 primitives
    #Char8::negated : translateUnaryPrimitiveInto(TAC::Operation::Int8Negate).
    #Char8::bitInvert : translateUnaryPrimitiveInto(TAC::Operation::Int8BitNot).

    #Char8::+ : translateBinaryPrimitiveInto(TAC::Operation::Int8Add).
    #Char8::- : translateBinaryPrimitiveInto(TAC::Operation::Int8Sub).
    #Char8::* : translateBinaryPrimitiveInto(TAC::Operation::Int8Mul).
    #Char8::/ : translateBinaryPrimitiveInto(TAC::Operation::Int8UDiv).
    #Char8::% : translateBinaryPrimitiveInto(TAC::Operation::Int8URem).

    #Char8::& : translateBinaryPrimitiveInto(TAC::Operation::Int8BitAnd).
    #Char8::| : translateBinaryPrimitiveInto(TAC::Operation::Int8BitOr).
    #Char8::^ : translateBinaryPrimitiveInto(TAC::Operation::Int8BitXor).
    #Char8::<< : translateBinaryPrimitiveInto(TAC::Operation::Int8LogicalShiftLeft).
    #Char8::>> : translateBinaryPrimitiveInto(TAC::Operation::Int8LogicalShiftRight).

    #Char8::= : translateBinaryPrimitiveInto(TAC::Operation::Int8Equals).
    #Char8::~= : translateBinaryPrimitiveInto(TAC::Operation::Int8NotEquals).
    #Char8::<=> : translateBinaryPrimitiveInto(TAC::Operation::Int8Compare).
    #Char8::< : translateBinaryPrimitiveInto(TAC::Operation::UInt8LessThan).
    #Char8::<= : translateBinaryPrimitiveInto(TAC::Operation::UInt8LessOrEquals).
    #Char8::> : translateBinaryPrimitiveInto(TAC::Operation::UInt8GreaterThan).
    #Char8::>= : translateBinaryPrimitiveInto(TAC::Operation::UInt8GreaterOrEquals).

    #Char8::asChar8 : translateUnaryPrimitiveInto(TAC::Operation::MoveInt8).
    #Char8::asInt8 : translateUnaryPrimitiveInto(TAC::Operation::MoveInt8).
    #Char8::asUInt8 : translateUnaryPrimitiveInto(TAC::Operation::MoveInt8).
    #Char8::asChar16 : translateUnaryPrimitiveInto(TAC::Operation::ZeroExtendInt8ToInt16).
    #Char8::asInt16 : translateUnaryPrimitiveInto(TAC::Operation::ZeroExtendInt8ToInt16).
    #Char8::asUInt16 : translateUnaryPrimitiveInto(TAC::Operation::ZeroExtendInt8ToInt16).
    #Char8::asChar32 : translateUnaryPrimitiveInto(TAC::Operation::ZeroExtendInt8ToInt32).
    #Char8::asInt32 : translateUnaryPrimitiveInto(TAC::Operation::ZeroExtendInt8ToInt32).
    #Char8::asUInt32 : translateUnaryPrimitiveInto(TAC::Operation::ZeroExtendInt8ToInt32).
    #Char8::asInt64 : translateUnaryPrimitiveInto(TAC::Operation::ZeroExtendInt8ToInt64).
    #Char8::asUInt64 : translateUnaryPrimitiveInto(TAC::Operation::ZeroExtendInt8ToInt64).
    #Char8::asFloat32 : translateUnaryPrimitiveInto(TAC::Operation::UInt8ToFloat32).
    #Char8::asFloat64 : translateUnaryPrimitiveInto(TAC::Operation::UInt8ToFloat64).

    ## UInt8 primitives
    #UInt8::negated : translateUnaryPrimitiveInto(TAC::Operation::Int8Negate).
    #UInt8::bitInvert : translateUnaryPrimitiveInto(TAC::Operation::Int8BitNot).

    #UInt8::+ : translateBinaryPrimitiveInto(TAC::Operation::Int8Add).
    #UInt8::- : translateBinaryPrimitiveInto(TAC::Operation::Int8Sub).
    #UInt8::* : translateBinaryPrimitiveInto(TAC::Operation::Int8Mul).
    #UInt8::/ : translateBinaryPrimitiveInto(TAC::Operation::Int8UDiv).
    #UInt8::% : translateBinaryPrimitiveInto(TAC::Operation::Int8URem).

    #UInt8::& : translateBinaryPrimitiveInto(TAC::Operation::Int8BitAnd).
    #UInt8::| : translateBinaryPrimitiveInto(TAC::Operation::Int8BitOr).
    #UInt8::^ : translateBinaryPrimitiveInto(TAC::Operation::Int8BitXor).
    #UInt8::<< : translateBinaryPrimitiveInto(TAC::Operation::Int8LogicalShiftLeft).
    #UInt8::>> : translateBinaryPrimitiveInto(TAC::Operation::Int8LogicalShiftRight).

    #UInt8::= : translateBinaryPrimitiveInto(TAC::Operation::Int8Equals).
    #UInt8::~= : translateBinaryPrimitiveInto(TAC::Operation::Int8NotEquals).
    #UInt8::<=> : translateBinaryPrimitiveInto(TAC::Operation::Int8Compare).
    #UInt8::< : translateBinaryPrimitiveInto(TAC::Operation::UInt8LessThan).
    #UInt8::<= : translateBinaryPrimitiveInto(TAC::Operation::UInt8LessOrEquals).
    #UInt8::> : translateBinaryPrimitiveInto(TAC::Operation::UInt8GreaterThan).
    #UInt8::>= : translateBinaryPrimitiveInto(TAC::Operation::UInt8GreaterOrEquals).

    #UInt8::asChar8 : translateUnaryPrimitiveInto(TAC::Operation::MoveInt8).
    #UInt8::asInt8 : translateUnaryPrimitiveInto(TAC::Operation::MoveInt8).
    #UInt8::asUInt8 : translateUnaryPrimitiveInto(TAC::Operation::MoveInt8).
    #UInt8::asChar16 : translateUnaryPrimitiveInto(TAC::Operation::ZeroExtendInt8ToInt16).
    #UInt8::asInt16 : translateUnaryPrimitiveInto(TAC::Operation::ZeroExtendInt8ToInt16).
    #UInt8::asUInt16 : translateUnaryPrimitiveInto(TAC::Operation::ZeroExtendInt8ToInt16).
    #UInt8::asChar32 : translateUnaryPrimitiveInto(TAC::Operation::ZeroExtendInt8ToInt32).
    #UInt8::asInt32 : translateUnaryPrimitiveInto(TAC::Operation::ZeroExtendInt8ToInt32).
    #UInt8::asUInt32 : translateUnaryPrimitiveInto(TAC::Operation::ZeroExtendInt8ToInt32).
    #UInt8::asInt64 : translateUnaryPrimitiveInto(TAC::Operation::ZeroExtendInt8ToInt64).
    #UInt8::asUInt64 : translateUnaryPrimitiveInto(TAC::Operation::ZeroExtendInt8ToInt64).
    #UInt8::asFloat32 : translateUnaryPrimitiveInto(TAC::Operation::UInt8ToFloat32).
    #UInt8::asFloat64 : translateUnaryPrimitiveInto(TAC::Operation::UInt8ToFloat64).

    ## Int8 primitives
    #Int8::negated : translateUnaryPrimitiveInto(TAC::Operation::Int8Negate).
    #Int8::bitInvert : translateUnaryPrimitiveInto(TAC::Operation::Int8BitNot).

    #Int8::+ : translateBinaryPrimitiveInto(TAC::Operation::Int8Add).
    #Int8::- : translateBinaryPrimitiveInto(TAC::Operation::Int8Sub).
    #Int8::* : translateBinaryPrimitiveInto(TAC::Operation::Int8Mul).
    #Int8::/ : translateBinaryPrimitiveInto(TAC::Operation::Int8SDiv).
    #Int8::% : translateBinaryPrimitiveInto(TAC::Operation::Int8SRem).

    #Int8::& : translateBinaryPrimitiveInto(TAC::Operation::Int8BitAnd).
    #Int8::| : translateBinaryPrimitiveInto(TAC::Operation::Int8BitOr).
    #Int8::^ : translateBinaryPrimitiveInto(TAC::Operation::Int8BitXor).
    #Int8::<< : translateBinaryPrimitiveInto(TAC::Operation::Int8LogicalShiftLeft).
    #Int8::>> : translateBinaryPrimitiveInto(TAC::Operation::Int8ArithmeticShiftRight).

    #Int8::= : translateBinaryPrimitiveInto(TAC::Operation::Int8Equals).
    #Int8::~= : translateBinaryPrimitiveInto(TAC::Operation::Int8NotEquals).
    #Int8::<=> : translateBinaryPrimitiveInto(TAC::Operation::Int8Compare).
    #Int8::< : translateBinaryPrimitiveInto(TAC::Operation::Int8LessThan).
    #Int8::<= : translateBinaryPrimitiveInto(TAC::Operation::Int8LessOrEquals).
    #Int8::> : translateBinaryPrimitiveInto(TAC::Operation::Int8GreaterThan).
    #Int8::>= : translateBinaryPrimitiveInto(TAC::Operation::Int8GreaterOrEquals).

    #Int8::asChar8 : translateUnaryPrimitiveInto(TAC::Operation::MoveInt8).
    #Int8::asInt8 : translateUnaryPrimitiveInto(TAC::Operation::MoveInt8).
    #Int8::asUInt8 : translateUnaryPrimitiveInto(TAC::Operation::MoveInt8).
    #Int8::asChar16 : translateUnaryPrimitiveInto(TAC::Operation::ZeroExtendInt8ToInt16).
    #Int8::asInt16 : translateUnaryPrimitiveInto(TAC::Operation::SignExtendInt8ToInt16).
    #Int8::asUInt16 : translateUnaryPrimitiveInto(TAC::Operation::ZeroExtendInt8ToInt16).
    #Int8::asChar32 : translateUnaryPrimitiveInto(TAC::Operation::ZeroExtendInt8ToInt32).
    #Int8::asInt32 : translateUnaryPrimitiveInto(TAC::Operation::SignExtendInt8ToInt32).
    #Int8::asUInt32 : translateUnaryPrimitiveInto(TAC::Operation::ZeroExtendInt8ToInt32).
    #Int8::asInt64 : translateUnaryPrimitiveInto(TAC::Operation::SignExtendInt8ToInt64).
    #Int8::asUInt64 : translateUnaryPrimitiveInto(TAC::Operation::ZeroExtendInt8ToInt64).
    #Int8::asFloat32 : translateUnaryPrimitiveInto(TAC::Operation::Int8ToFloat32).
    #Int8::asFloat64 : translateUnaryPrimitiveInto(TAC::Operation::Int8ToFloat64).

    ## Char16 primitives
    #Char16::negated : translateUnaryPrimitiveInto(TAC::Operation::Int16Negate).
    #Char16::bitInvert : translateUnaryPrimitiveInto(TAC::Operation::Int16BitNot).

    #Char16::+ : translateBinaryPrimitiveInto(TAC::Operation::Int16Add).
    #Char16::- : translateBinaryPrimitiveInto(TAC::Operation::Int16Sub).
    #Char16::* : translateBinaryPrimitiveInto(TAC::Operation::Int16Mul).
    #Char16::/ : translateBinaryPrimitiveInto(TAC::Operation::Int16UDiv).
    #Char16::% : translateBinaryPrimitiveInto(TAC::Operation::Int16URem).

    #Char16::& : translateBinaryPrimitiveInto(TAC::Operation::Int16BitAnd).
    #Char16::| : translateBinaryPrimitiveInto(TAC::Operation::Int16BitOr).
    #Char16::^ : translateBinaryPrimitiveInto(TAC::Operation::Int16BitXor).
    #Char16::<< : translateBinaryPrimitiveInto(TAC::Operation::Int16LogicalShiftLeft).
    #Char16::>> : translateBinaryPrimitiveInto(TAC::Operation::Int16LogicalShiftRight).

    #Char16::= : translateBinaryPrimitiveInto(TAC::Operation::Int16Equals).
    #Char16::~= : translateBinaryPrimitiveInto(TAC::Operation::Int16NotEquals).
    #Char16::<=> : translateBinaryPrimitiveInto(TAC::Operation::Int16Compare).
    #Char16::< : translateBinaryPrimitiveInto(TAC::Operation::UInt16LessThan).
    #Char16::<= : translateBinaryPrimitiveInto(TAC::Operation::UInt16LessOrEquals).
    #Char16::> : translateBinaryPrimitiveInto(TAC::Operation::UInt16GreaterThan).
    #Char16::>= : translateBinaryPrimitiveInto(TAC::Operation::UInt16GreaterOrEquals).

    #Char16::asChar8 : translateUnaryPrimitiveInto(TAC::Operation::TruncateInt16ToInt8).
    #Char16::asInt8 : translateUnaryPrimitiveInto(TAC::Operation::TruncateInt16ToInt8).
    #Char16::asUInt8 : translateUnaryPrimitiveInto(TAC::Operation::TruncateInt16ToInt8).
    #Char16::asChar16 : translateUnaryPrimitiveInto(TAC::Operation::MoveInt16).
    #Char16::asInt16 : translateUnaryPrimitiveInto(TAC::Operation::MoveInt16).
    #Char16::asUInt16 : translateUnaryPrimitiveInto(TAC::Operation::MoveInt16).
    #Char16::asChar32 : translateUnaryPrimitiveInto(TAC::Operation::ZeroExtendInt16ToInt32).
    #Char16::asInt32 : translateUnaryPrimitiveInto(TAC::Operation::ZeroExtendInt16ToInt32).
    #Char16::asUInt32 : translateUnaryPrimitiveInto(TAC::Operation::ZeroExtendInt16ToInt32).
    #Char16::asInt64 : translateUnaryPrimitiveInto(TAC::Operation::ZeroExtendInt16ToInt64).
    #Char16::asUInt64 : translateUnaryPrimitiveInto(TAC::Operation::ZeroExtendInt16ToInt64).
    #Char16::asFloat32 : translateUnaryPrimitiveInto(TAC::Operation::UInt16ToFloat32).
    #Char16::asFloat64 : translateUnaryPrimitiveInto(TAC::Operation::UInt16ToFloat64).

    ## UInt16 primitives
    #UInt16::negated : translateUnaryPrimitiveInto(TAC::Operation::Int16Negate).
    #UInt16::bitInvert : translateUnaryPrimitiveInto(TAC::Operation::Int16BitNot).

    #UInt16::+ : translateBinaryPrimitiveInto(TAC::Operation::Int16Add).
    #UInt16::- : translateBinaryPrimitiveInto(TAC::Operation::Int16Sub).
    #UInt16::* : translateBinaryPrimitiveInto(TAC::Operation::Int16Mul).
    #UInt16::/ : translateBinaryPrimitiveInto(TAC::Operation::Int16UDiv).
    #UInt16::% : translateBinaryPrimitiveInto(TAC::Operation::Int16URem).

    #UInt16::& : translateBinaryPrimitiveInto(TAC::Operation::Int16BitAnd).
    #UInt16::| : translateBinaryPrimitiveInto(TAC::Operation::Int16BitOr).
    #UInt16::^ : translateBinaryPrimitiveInto(TAC::Operation::Int16BitXor).
    #UInt16::<< : translateBinaryPrimitiveInto(TAC::Operation::Int16LogicalShiftLeft).
    #UInt16::>> : translateBinaryPrimitiveInto(TAC::Operation::Int16LogicalShiftRight).

    #UInt16::= : translateBinaryPrimitiveInto(TAC::Operation::Int16Equals).
    #UInt16::~= : translateBinaryPrimitiveInto(TAC::Operation::Int16NotEquals).
    #UInt16::<=> : translateBinaryPrimitiveInto(TAC::Operation::Int16Compare).
    #UInt16::< : translateBinaryPrimitiveInto(TAC::Operation::UInt16LessThan).
    #UInt16::<= : translateBinaryPrimitiveInto(TAC::Operation::UInt16LessOrEquals).
    #UInt16::> : translateBinaryPrimitiveInto(TAC::Operation::UInt16GreaterThan).
    #UInt16::>= : translateBinaryPrimitiveInto(TAC::Operation::UInt16GreaterOrEquals).

    #UInt16::asChar8 : translateUnaryPrimitiveInto(TAC::Operation::TruncateInt16ToInt8).
    #UInt16::asInt8 : translateUnaryPrimitiveInto(TAC::Operation::TruncateInt16ToInt8).
    #UInt16::asUInt8 : translateUnaryPrimitiveInto(TAC::Operation::TruncateInt16ToInt8).
    #UInt16::asChar16 : translateUnaryPrimitiveInto(TAC::Operation::MoveInt16).
    #UInt16::asInt16 : translateUnaryPrimitiveInto(TAC::Operation::MoveInt16).
    #UInt16::asUInt16 : translateUnaryPrimitiveInto(TAC::Operation::MoveInt16).
    #UInt16::asChar32 : translateUnaryPrimitiveInto(TAC::Operation::ZeroExtendInt16ToInt32).
    #UInt16::asInt32 : translateUnaryPrimitiveInto(TAC::Operation::ZeroExtendInt16ToInt32).
    #UInt16::asUInt32 : translateUnaryPrimitiveInto(TAC::Operation::ZeroExtendInt16ToInt32).
    #UInt16::asInt64 : translateUnaryPrimitiveInto(TAC::Operation::ZeroExtendInt16ToInt64).
    #UInt16::asUInt64 : translateUnaryPrimitiveInto(TAC::Operation::ZeroExtendInt16ToInt64).
    #UInt16::asFloat32 : translateUnaryPrimitiveInto(TAC::Operation::UInt16ToFloat32).
    #UInt16::asFloat64 : translateUnaryPrimitiveInto(TAC::Operation::UInt16ToFloat64).

    ## Int16 primitives
    #Int16::negated : translateUnaryPrimitiveInto(TAC::Operation::Int16Negate).
    #Int16::bitInvert : translateUnaryPrimitiveInto(TAC::Operation::Int16BitNot).

    #Int16::+ : translateBinaryPrimitiveInto(TAC::Operation::Int16Add).
    #Int16::- : translateBinaryPrimitiveInto(TAC::Operation::Int16Sub).
    #Int16::* : translateBinaryPrimitiveInto(TAC::Operation::Int16Mul).
    #Int16::/ : translateBinaryPrimitiveInto(TAC::Operation::Int16SDiv).
    #Int16::% : translateBinaryPrimitiveInto(TAC::Operation::Int16SRem).

    #Int16::& : translateBinaryPrimitiveInto(TAC::Operation::Int16BitAnd).
    #Int16::| : translateBinaryPrimitiveInto(TAC::Operation::Int16BitOr).
    #Int16::^ : translateBinaryPrimitiveInto(TAC::Operation::Int16BitXor).
    #Int16::<< : translateBinaryPrimitiveInto(TAC::Operation::Int16LogicalShiftLeft).
    #Int16::>> : translateBinaryPrimitiveInto(TAC::Operation::Int16ArithmeticShiftRight).

    #Int16::= : translateBinaryPrimitiveInto(TAC::Operation::Int16Equals).
    #Int16::~= : translateBinaryPrimitiveInto(TAC::Operation::Int16NotEquals).
    #Int16::<=> : translateBinaryPrimitiveInto(TAC::Operation::Int16Compare).
    #Int16::< : translateBinaryPrimitiveInto(TAC::Operation::Int16LessThan).
    #Int16::<= : translateBinaryPrimitiveInto(TAC::Operation::Int16LessOrEquals).
    #Int16::> : translateBinaryPrimitiveInto(TAC::Operation::Int16GreaterThan).
    #Int16::>= : translateBinaryPrimitiveInto(TAC::Operation::Int16GreaterOrEquals).

    #Int16::asChar8 : translateUnaryPrimitiveInto(TAC::Operation::TruncateInt16ToInt8).
    #Int16::asInt8 : translateUnaryPrimitiveInto(TAC::Operation::TruncateInt16ToInt8).
    #Int16::asUInt8 : translateUnaryPrimitiveInto(TAC::Operation::TruncateInt16ToInt8).
    #Int16::asChar16 : translateUnaryPrimitiveInto(TAC::Operation::MoveInt16).
    #Int16::asInt16 : translateUnaryPrimitiveInto(TAC::Operation::MoveInt16).
    #Int16::asUInt16 : translateUnaryPrimitiveInto(TAC::Operation::MoveInt16).
    #Int16::asChar32 : translateUnaryPrimitiveInto(TAC::Operation::ZeroExtendInt16ToInt32).
    #Int16::asInt32 : translateUnaryPrimitiveInto(TAC::Operation::SignExtendInt16ToInt32).
    #Int16::asUInt32 : translateUnaryPrimitiveInto(TAC::Operation::ZeroExtendInt16ToInt32).
    #Int16::asInt64 : translateUnaryPrimitiveInto(TAC::Operation::SignExtendInt16ToInt64).
    #Int16::asUInt64 : translateUnaryPrimitiveInto(TAC::Operation::ZeroExtendInt16ToInt64).
    #Int16::asFloat32 : translateUnaryPrimitiveInto(TAC::Operation::Int16ToFloat32).
    #Int16::asFloat64 : translateUnaryPrimitiveInto(TAC::Operation::Int16ToFloat64).

    ## Char32 primitives
    #Char32::negated : translateUnaryPrimitiveInto(TAC::Operation::Int32Negate).
    #Char32::bitInvert : translateUnaryPrimitiveInto(TAC::Operation::Int32BitNot).

    #Char32::+ : translateBinaryPrimitiveInto(TAC::Operation::Int32Add).
    #Char32::- : translateBinaryPrimitiveInto(TAC::Operation::Int32Sub).
    #Char32::* : translateBinaryPrimitiveInto(TAC::Operation::Int32Mul).
    #Char32::/ : translateBinaryPrimitiveInto(TAC::Operation::Int32UDiv).
    #Char32::% : translateBinaryPrimitiveInto(TAC::Operation::Int32URem).

    #Char32::& : translateBinaryPrimitiveInto(TAC::Operation::Int32BitAnd).
    #Char32::| : translateBinaryPrimitiveInto(TAC::Operation::Int32BitOr).
    #Char32::^ : translateBinaryPrimitiveInto(TAC::Operation::Int32BitXor).
    #Char32::<< : translateBinaryPrimitiveInto(TAC::Operation::Int32LogicalShiftLeft).
    #Char32::>> : translateBinaryPrimitiveInto(TAC::Operation::Int32LogicalShiftRight).

    #Char32::= : translateBinaryPrimitiveInto(TAC::Operation::Int32Equals).
    #Char32::~= : translateBinaryPrimitiveInto(TAC::Operation::Int32NotEquals).
    #Char32::<=> : translateBinaryPrimitiveInto(TAC::Operation::Int32Compare).
    #Char32::< : translateBinaryPrimitiveInto(TAC::Operation::UInt32LessThan).
    #Char32::<= : translateBinaryPrimitiveInto(TAC::Operation::UInt32LessOrEquals).
    #Char32::> : translateBinaryPrimitiveInto(TAC::Operation::UInt32GreaterThan).
    #Char32::>= : translateBinaryPrimitiveInto(TAC::Operation::UInt32GreaterOrEquals).

    #Char32::asChar8 : translateUnaryPrimitiveInto(TAC::Operation::TruncateInt32ToInt8).
    #Char32::asInt8 : translateUnaryPrimitiveInto(TAC::Operation::TruncateInt32ToInt8).
    #Char32::asUInt8 : translateUnaryPrimitiveInto(TAC::Operation::TruncateInt32ToInt8).
    #Char32::asChar16 : translateUnaryPrimitiveInto(TAC::Operation::TruncateInt32ToInt16).
    #Char32::asInt16 : translateUnaryPrimitiveInto(TAC::Operation::TruncateInt32ToInt16).
    #Char32::asUInt16 : translateUnaryPrimitiveInto(TAC::Operation::TruncateInt32ToInt16).
    #Char32::asChar32 : translateUnaryPrimitiveInto(TAC::Operation::MoveInt32).
    #Char32::asInt32 : translateUnaryPrimitiveInto(TAC::Operation::MoveInt32).
    #Char32::asUInt32 : translateUnaryPrimitiveInto(TAC::Operation::MoveInt32).
    #Char32::asInt64 : translateUnaryPrimitiveInto(TAC::Operation::ZeroExtendInt32ToInt64).
    #Char32::asUInt64 : translateUnaryPrimitiveInto(TAC::Operation::ZeroExtendInt32ToInt64).
    #Char32::asFloat32 : translateUnaryPrimitiveInto(TAC::Operation::UInt32ToFloat32).
    #Char32::asFloat64 : translateUnaryPrimitiveInto(TAC::Operation::UInt32ToFloat64).

    ## UInt32 primitives
    #UInt32::negated : translateUnaryPrimitiveInto(TAC::Operation::Int32Negate).
    #UInt32::bitInvert : translateUnaryPrimitiveInto(TAC::Operation::Int32BitNot).

    #UInt32::+ : translateBinaryPrimitiveInto(TAC::Operation::Int32Add).
    #UInt32::- : translateBinaryPrimitiveInto(TAC::Operation::Int32Sub).
    #UInt32::* : translateBinaryPrimitiveInto(TAC::Operation::Int32Mul).
    #UInt32::/ : translateBinaryPrimitiveInto(TAC::Operation::Int32UDiv).
    #UInt32::% : translateBinaryPrimitiveInto(TAC::Operation::Int32URem).

    #UInt32::& : translateBinaryPrimitiveInto(TAC::Operation::Int32BitAnd).
    #UInt32::| : translateBinaryPrimitiveInto(TAC::Operation::Int32BitOr).
    #UInt32::^ : translateBinaryPrimitiveInto(TAC::Operation::Int32BitXor).
    #UInt32::<< : translateBinaryPrimitiveInto(TAC::Operation::Int32LogicalShiftLeft).
    #UInt32::>> : translateBinaryPrimitiveInto(TAC::Operation::Int32LogicalShiftRight).

    #UInt32::= : translateBinaryPrimitiveInto(TAC::Operation::Int32Equals).
    #UInt32::~= : translateBinaryPrimitiveInto(TAC::Operation::Int32NotEquals).
    #UInt32::<=> : translateBinaryPrimitiveInto(TAC::Operation::Int32Compare).
    #UInt32::< : translateBinaryPrimitiveInto(TAC::Operation::UInt32LessThan).
    #UInt32::<= : translateBinaryPrimitiveInto(TAC::Operation::UInt32LessOrEquals).
    #UInt32::> : translateBinaryPrimitiveInto(TAC::Operation::UInt32GreaterThan).
    #UInt32::>= : translateBinaryPrimitiveInto(TAC::Operation::UInt32GreaterOrEquals).

    #UInt32::asChar8 : translateUnaryPrimitiveInto(TAC::Operation::TruncateInt32ToInt8).
    #UInt32::asInt8 : translateUnaryPrimitiveInto(TAC::Operation::TruncateInt32ToInt8).
    #UInt32::asUInt8 : translateUnaryPrimitiveInto(TAC::Operation::TruncateInt32ToInt8).
    #UInt32::asChar16 : translateUnaryPrimitiveInto(TAC::Operation::TruncateInt32ToInt16).
    #UInt32::asInt16 : translateUnaryPrimitiveInto(TAC::Operation::TruncateInt32ToInt16).
    #UInt32::asUInt16 : translateUnaryPrimitiveInto(TAC::Operation::TruncateInt32ToInt16).
    #UInt32::asChar32 : translateUnaryPrimitiveInto(TAC::Operation::MoveInt32).
    #UInt32::asInt32 : translateUnaryPrimitiveInto(TAC::Operation::MoveInt32).
    #UInt32::asUInt32 : translateUnaryPrimitiveInto(TAC::Operation::MoveInt32).
    #UInt32::asInt64 : translateUnaryPrimitiveInto(TAC::Operation::ZeroExtendInt32ToInt64).
    #UInt32::asUInt64 : translateUnaryPrimitiveInto(TAC::Operation::ZeroExtendInt32ToInt64).
    #UInt32::asFloat32 : translateUnaryPrimitiveInto(TAC::Operation::UInt32ToFloat32).
    #UInt32::asFloat64 : translateUnaryPrimitiveInto(TAC::Operation::UInt32ToFloat64).
    #UInt32::asIEEEFloat32Decoded : translateUnaryPrimitiveInto(TAC::Operation::IEEEUInt32ToFloat32). 

    ## Int32 primitives
    #Int32::negated : translateUnaryPrimitiveInto(TAC::Operation::Int32Negate).
    #Int32::bitInvert : translateUnaryPrimitiveInto(TAC::Operation::Int32BitNot).

    #Int32::+ : translateBinaryPrimitiveInto(TAC::Operation::Int32Add).
    #Int32::- : translateBinaryPrimitiveInto(TAC::Operation::Int32Sub).
    #Int32::* : translateBinaryPrimitiveInto(TAC::Operation::Int32Mul).
    #Int32::/ : translateBinaryPrimitiveInto(TAC::Operation::Int32SDiv).
    #Int32::% : translateBinaryPrimitiveInto(TAC::Operation::Int32SRem).

    #Int32::& : translateBinaryPrimitiveInto(TAC::Operation::Int32BitAnd).
    #Int32::| : translateBinaryPrimitiveInto(TAC::Operation::Int32BitOr).
    #Int32::^ : translateBinaryPrimitiveInto(TAC::Operation::Int32BitXor).
    #Int32::<< : translateBinaryPrimitiveInto(TAC::Operation::Int32LogicalShiftLeft).
    #Int32::>> : translateBinaryPrimitiveInto(TAC::Operation::Int32ArithmeticShiftRight).

    #Int32::= : translateBinaryPrimitiveInto(TAC::Operation::Int32Equals).
    #Int32::~= : translateBinaryPrimitiveInto(TAC::Operation::Int32NotEquals).
    #Int32::<=> : translateBinaryPrimitiveInto(TAC::Operation::Int32Compare).
    #Int32::< : translateBinaryPrimitiveInto(TAC::Operation::Int32LessThan).
    #Int32::<= : translateBinaryPrimitiveInto(TAC::Operation::Int32LessOrEquals).
    #Int32::> : translateBinaryPrimitiveInto(TAC::Operation::Int32GreaterThan).
    #Int32::>= : translateBinaryPrimitiveInto(TAC::Operation::Int32GreaterOrEquals).

    #Int32::asChar8 : translateUnaryPrimitiveInto(TAC::Operation::TruncateInt32ToInt8).
    #Int32::asInt8 : translateUnaryPrimitiveInto(TAC::Operation::TruncateInt32ToInt8).
    #Int32::asUInt8 : translateUnaryPrimitiveInto(TAC::Operation::TruncateInt32ToInt8).
    #Int32::asChar16 : translateUnaryPrimitiveInto(TAC::Operation::TruncateInt32ToInt16).
    #Int32::asInt16 : translateUnaryPrimitiveInto(TAC::Operation::TruncateInt32ToInt16).
    #Int32::asUInt16 : translateUnaryPrimitiveInto(TAC::Operation::TruncateInt32ToInt16).
    #Int32::asChar32 : translateUnaryPrimitiveInto(TAC::Operation::MoveInt32).
    #Int32::asInt32 : translateUnaryPrimitiveInto(TAC::Operation::MoveInt32).
    #Int32::asUInt32 : translateUnaryPrimitiveInto(TAC::Operation::MoveInt32).
    #Int32::asInt64 : translateUnaryPrimitiveInto(TAC::Operation::SignExtendInt32ToInt64).
    #Int32::asUInt64 : translateUnaryPrimitiveInto(TAC::Operation::ZeroExtendInt32ToInt64).
    #Int32::asFloat32 : translateUnaryPrimitiveInto(TAC::Operation::Int32ToFloat32).
    #Int32::asFloat64 : translateUnaryPrimitiveInto(TAC::Operation::Int32ToFloat64).

    ## Int64 primitives
    #Int64::negated : translateUnaryPrimitiveInto(TAC::Operation::Int64Negate).
    #Int64::bitInvert : translateUnaryPrimitiveInto(TAC::Operation::Int64BitNot).

    #Int64::+ : translateBinaryPrimitiveInto(TAC::Operation::Int64Add).
    #Int64::- : translateBinaryPrimitiveInto(TAC::Operation::Int64Sub).
    #Int64::* : translateBinaryPrimitiveInto(TAC::Operation::Int64Mul).
    #Int64::/ : translateBinaryPrimitiveInto(TAC::Operation::Int64SDiv).
    #Int64::% : translateBinaryPrimitiveInto(TAC::Operation::Int64SRem).

    #Int64::& : translateBinaryPrimitiveInto(TAC::Operation::Int64BitAnd).
    #Int64::| : translateBinaryPrimitiveInto(TAC::Operation::Int64BitOr).
    #Int64::^ : translateBinaryPrimitiveInto(TAC::Operation::Int64BitXor).
    #Int64::<< : translateBinaryPrimitiveInto(TAC::Operation::Int64LogicalShiftLeft).
    #Int64::>> : translateBinaryPrimitiveInto(TAC::Operation::Int64ArithmeticShiftRight).

    #Int64::= : translateBinaryPrimitiveInto(TAC::Operation::Int64Equals).
    #Int64::~= : translateBinaryPrimitiveInto(TAC::Operation::Int64NotEquals).
    #Int64::<=> : translateBinaryPrimitiveInto(TAC::Operation::Int64Compare).
    #Int64::< : translateBinaryPrimitiveInto(TAC::Operation::Int64LessThan).
    #Int64::<= : translateBinaryPrimitiveInto(TAC::Operation::Int64LessOrEquals).
    #Int64::> : translateBinaryPrimitiveInto(TAC::Operation::Int64GreaterThan).
    #Int64::>= : translateBinaryPrimitiveInto(TAC::Operation::Int64GreaterOrEquals).

    #Int64::asChar8 : translateUnaryPrimitiveInto(TAC::Operation::TruncateInt64ToInt8).
    #Int64::asInt8 : translateUnaryPrimitiveInto(TAC::Operation::TruncateInt64ToInt8).
    #Int64::asUInt8 : translateUnaryPrimitiveInto(TAC::Operation::TruncateInt64ToInt8).
    #Int64::asChar16 : translateUnaryPrimitiveInto(TAC::Operation::TruncateInt64ToInt16).
    #Int64::asInt16 : translateUnaryPrimitiveInto(TAC::Operation::TruncateInt64ToInt16).
    #Int64::asUInt16 : translateUnaryPrimitiveInto(TAC::Operation::TruncateInt64ToInt16).
    #Int64::asChar32 : translateUnaryPrimitiveInto(TAC::Operation::TruncateInt64ToInt32).
    #Int64::asInt32 : translateUnaryPrimitiveInto(TAC::Operation::TruncateInt64ToInt32).
    #Int64::asUInt32 : translateUnaryPrimitiveInto(TAC::Operation::TruncateInt64ToInt32).
    #Int64::asInt64 : translateUnaryPrimitiveInto(TAC::Operation::MoveInt64).
    #Int64::asUInt64 : translateUnaryPrimitiveInto(TAC::Operation::MoveInt64).
    #Int64::asFloat32 : translateUnaryPrimitiveInto(TAC::Operation::Int64ToFloat32).
    #Int64::asFloat64 : translateUnaryPrimitiveInto(TAC::Operation::Int64ToFloat64).

    ## UInt64 primitives
    #UInt64::negated : translateUnaryPrimitiveInto(TAC::Operation::Int64Negate).
    #UInt64::bitInvert : translateUnaryPrimitiveInto(TAC::Operation::Int64BitNot).

    #UInt64::+ : translateBinaryPrimitiveInto(TAC::Operation::Int64Add).
    #UInt64::- : translateBinaryPrimitiveInto(TAC::Operation::Int64Sub).
    #UInt64::* : translateBinaryPrimitiveInto(TAC::Operation::Int64Mul).
    #UInt64::/ : translateBinaryPrimitiveInto(TAC::Operation::Int64UDiv).
    #UInt64::% : translateBinaryPrimitiveInto(TAC::Operation::Int64URem).

    #UInt64::& : translateBinaryPrimitiveInto(TAC::Operation::Int64BitAnd).
    #UInt64::| : translateBinaryPrimitiveInto(TAC::Operation::Int64BitOr).
    #UInt64::^ : translateBinaryPrimitiveInto(TAC::Operation::Int64BitXor).
    #UInt64::<< : translateBinaryPrimitiveInto(TAC::Operation::Int64LogicalShiftLeft).
    #UInt64::>> : translateBinaryPrimitiveInto(TAC::Operation::Int64LogicalShiftRight).

    #UInt64::= : translateBinaryPrimitiveInto(TAC::Operation::Int64Equals).
    #UInt64::~= : translateBinaryPrimitiveInto(TAC::Operation::Int64NotEquals).
    #UInt64::<=> : translateBinaryPrimitiveInto(TAC::Operation::Int64Compare).
    #UInt64::< : translateBinaryPrimitiveInto(TAC::Operation::UInt64LessThan).
    #UInt64::<= : translateBinaryPrimitiveInto(TAC::Operation::UInt64LessOrEquals).
    #UInt64::> : translateBinaryPrimitiveInto(TAC::Operation::UInt64GreaterThan).
    #UInt64::>= : translateBinaryPrimitiveInto(TAC::Operation::UInt64GreaterOrEquals).

    #UInt64::asChar8 : translateUnaryPrimitiveInto(TAC::Operation::TruncateInt64ToInt8).
    #UInt64::asInt8 : translateUnaryPrimitiveInto(TAC::Operation::TruncateInt64ToInt8).
    #UInt64::asUInt8 : translateUnaryPrimitiveInto(TAC::Operation::TruncateInt64ToInt8).
    #UInt64::asChar16 : translateUnaryPrimitiveInto(TAC::Operation::TruncateInt64ToInt16).
    #UInt64::asInt16 : translateUnaryPrimitiveInto(TAC::Operation::TruncateInt64ToInt16).
    #UInt64::asUInt16 : translateUnaryPrimitiveInto(TAC::Operation::TruncateInt64ToInt16).
    #UInt64::asChar32 : translateUnaryPrimitiveInto(TAC::Operation::TruncateInt64ToInt32).
    #UInt64::asInt32 : translateUnaryPrimitiveInto(TAC::Operation::TruncateInt64ToInt32).
    #UInt64::asUInt32 : translateUnaryPrimitiveInto(TAC::Operation::TruncateInt64ToInt32).
    #UInt64::asInt64 : translateUnaryPrimitiveInto(TAC::Operation::MoveInt64).
    #UInt64::asUInt64 : translateUnaryPrimitiveInto(TAC::Operation::MoveInt64).
    #UInt64::asFloat32 : translateUnaryPrimitiveInto(TAC::Operation::UInt64ToFloat32).
    #UInt64::asFloat64 : translateUnaryPrimitiveInto(TAC::Operation::UInt64ToFloat64).
    #UInt64::asIEEEFloat64Decoded : translateUnaryPrimitiveInto(TAC::Operation::IEEEUInt64ToFloat64). 

    ## Float32 primitives
    #Float32::negated : translateUnaryPrimitiveInto(TAC::Operation::Float32Negate).
    #Float32::sqrt : translateUnaryPrimitiveInto(TAC::Operation::Float32Sqrt).

    #Float32::+ : translateBinaryPrimitiveInto(TAC::Operation::Float32Add).
    #Float32::- : translateBinaryPrimitiveInto(TAC::Operation::Float32Sub).
    #Float32::* : translateBinaryPrimitiveInto(TAC::Operation::Float32Mul).
    #Float32::/ : translateBinaryPrimitiveInto(TAC::Operation::Float32Div).

    #Float32::= : translateBinaryPrimitiveInto(TAC::Operation::Float32UnorderedEquals).
    #Float32::~= : translateBinaryPrimitiveInto(TAC::Operation::Float32UnorderedNotEquals).
    #Float32::<=> : translateBinaryPrimitiveInto(TAC::Operation::Float32UnorderedCompare).
    #Float32::< : translateBinaryPrimitiveInto(TAC::Operation::Float32UnorderedLessThan).
    #Float32::<= : translateBinaryPrimitiveInto(TAC::Operation::Float32UnorderedLessOrEquals).
    #Float32::> : translateBinaryPrimitiveInto(TAC::Operation::Float32UnorderedGreaterThan).
    #Float32::>= : translateBinaryPrimitiveInto(TAC::Operation::Float32UnorderedGreaterOrEquals).

    #Float32::asChar8 : translateUnaryPrimitiveInto(TAC::Operation::Float32ToUInt8).
    #Float32::asInt8 : translateUnaryPrimitiveInto(TAC::Operation::Float32ToInt8).
    #Float32::asUInt8 : translateUnaryPrimitiveInto(TAC::Operation::Float32ToUInt8).
    #Float32::asChar16 : translateUnaryPrimitiveInto(TAC::Operation::Float32ToUInt16).
    #Float32::asInt16 : translateUnaryPrimitiveInto(TAC::Operation::Float32ToInt16).
    #Float32::asUInt16 : translateUnaryPrimitiveInto(TAC::Operation::Float32ToUInt16).
    #Float32::asChar32 : translateUnaryPrimitiveInto(TAC::Operation::Float32ToUInt32).
    #Float32::asInt32 : translateUnaryPrimitiveInto(TAC::Operation::Float32ToInt32).
    #Float32::asUInt32 : translateUnaryPrimitiveInto(TAC::Operation::Float32ToUInt32).
    #Float32::asInt64 : translateUnaryPrimitiveInto(TAC::Operation::Float32ToInt64).
    #Float32::asUInt64 : translateUnaryPrimitiveInto(TAC::Operation::Float32ToUInt64).
    #Float32::asFloat32 : translateUnaryPrimitiveInto(TAC::Operation::MoveFloat32).
    #Float32::asFloat64 : translateUnaryPrimitiveInto(TAC::Operation::Float32ToFloat64).
    #Float32::asIEEEFloat32Encoding : translateUnaryPrimitiveInto(TAC::Operation::Float32ToIEEEUInt32). 

    ## Float64 primitives
    #Float64::negated : translateUnaryPrimitiveInto(TAC::Operation::Float64Negate).
    #Float64::sqrt : translateUnaryPrimitiveInto(TAC::Operation::Float64Sqrt).

    #Float64::+ : translateBinaryPrimitiveInto(TAC::Operation::Float64Add).
    #Float64::- : translateBinaryPrimitiveInto(TAC::Operation::Float64Sub).
    #Float64::* : translateBinaryPrimitiveInto(TAC::Operation::Float64Mul).
    #Float64::/ : translateBinaryPrimitiveInto(TAC::Operation::Float64Div).

    #Float64::= : translateBinaryPrimitiveInto(TAC::Operation::Float64UnorderedEquals).
    #Float64::~= : translateBinaryPrimitiveInto(TAC::Operation::Float64UnorderedNotEquals).
    #Float64::<=> : translateBinaryPrimitiveInto(TAC::Operation::Float64UnorderedCompare).
    #Float64::< : translateBinaryPrimitiveInto(TAC::Operation::Float64UnorderedLessThan).
    #Float64::<= : translateBinaryPrimitiveInto(TAC::Operation::Float64UnorderedLessOrEquals).
    #Float64::> : translateBinaryPrimitiveInto(TAC::Operation::Float64UnorderedGreaterThan).
    #Float64::>= : translateBinaryPrimitiveInto(TAC::Operation::Float64UnorderedGreaterOrEquals).

    #Float64::asChar8 : translateUnaryPrimitiveInto(TAC::Operation::Float64ToUInt8).
    #Float64::asInt8 : translateUnaryPrimitiveInto(TAC::Operation::Float64ToInt8).
    #Float64::asUInt8 : translateUnaryPrimitiveInto(TAC::Operation::Float64ToUInt8).
    #Float64::asChar16 : translateUnaryPrimitiveInto(TAC::Operation::Float64ToUInt16).
    #Float64::asInt16 : translateUnaryPrimitiveInto(TAC::Operation::Float64ToInt16).
    #Float64::asUInt16 : translateUnaryPrimitiveInto(TAC::Operation::Float64ToUInt16).
    #Float64::asChar32 : translateUnaryPrimitiveInto(TAC::Operation::Float64ToUInt32).
    #Float64::asInt32 : translateUnaryPrimitiveInto(TAC::Operation::Float64ToInt32).
    #Float64::asUInt32 : translateUnaryPrimitiveInto(TAC::Operation::Float64ToUInt32).
    #Float64::asInt64 : translateUnaryPrimitiveInto(TAC::Operation::Float64ToInt64).
    #Float64::asUInt64 : translateUnaryPrimitiveInto(TAC::Operation::Float64ToUInt64).
    #Float64::asFloat32 : translateUnaryPrimitiveInto(TAC::Operation::MoveFloat64).
    #Float64::asFloat64 : translateUnaryPrimitiveInto(TAC::Operation::Float64ToFloat32).
    #Float64::asIEEEFloat64Encoding : translateUnaryPrimitiveInto(TAC::Operation::Float64ToIEEEUInt64). 
}.

SSAFunctionDefinitionTACCodeGenerator extend: {
    public method compilePrimitiveFunctionBody => Boolean := {
        ## Attempt to use the primitive generator first.
        let primitiveGenerator := SSATacPrimitiveCallGenerationTable atOrNil: ssaFunctionDefinition primitiveName.
        let hasGeneratedPrimitive mutable => Boolean := false.
        primitiveGenerator ifNotNil: {
            functionBuilder basicBlock: #primitive build: {:(TACBlockBuilder)asm :: Void |
                self blockBuilder: asm.
                let canonicalResultType := ssaFunctionDefinition functionType canonicalResultType.
                let result := canonicalResultType makeTacTemporaryValueNamed: #result withFunctionBuilder: functionBuilder.
                hasGeneratedPrimitive := primitiveGenerator(ssaFunctionDefinition arguments, result, self).
                canonicalResultType emitTacReturn: result withBlockBuilder: asm
            }.
        }.

        hasGeneratedPrimitive
    }.

    public method compileCall: (calledFunction: SSAValue) withArguments: (arguments: Array) unchecked: (isUnchecked: Boolean) into: (tacValue: TACValue) type: (resultType: Type)::=> Void := {
        ## Attempt to use the primitive generator first.
        let primitiveGenerator := SSATacPrimitiveCallGenerationTable atOrNil: calledFunction primitiveName.
        primitiveGenerator ifNotNil: {
            primitiveGenerator(arguments, tacValue, self) ifTrue: {
                return: void
            }
        }.

        isUnchecked ifTrue: {
            calledFunction isCaptureless ifTrue: {
                let entryPoint := self translateCapturelessUncheckedFunctionEntryPoint: calledFunction.
                let tacArguments := arguments collect: {:(SSAValue)eachArgument :: TACValue | self translateValue: eachArgument}.
                resultType
                    emitTacCall: entryPoint convention: self tacFunction compilationTarget defaultCallingConvention
                    withArguments: tacArguments into: tacValue
                    withBlockBuilder: self blockBuilder

            } ifFalse: {
                let tacCalledFunction := self translateValue: calledFunction.
                let entryPoint := self translateUncheckedFunctionEntryPoint: calledFunction.
                let tacArguments := arguments collect: {:(SSAValue)eachArgument :: TACValue | self translateValue: eachArgument}.
                resultType
                    emitTacCall: entryPoint convention: self tacFunction compilationTarget defaultCallingConvention
                    withArguments: (Array with: tacCalledFunction) -- tacArguments into: tacValue
                    withBlockBuilder: self blockBuilder
            }.
        } ifFalse: {
            let tacCalledFunction := self translateBoxedValue: calledFunction.
            let entryPoint := self translateCheckedFunctionEntryPoint: calledFunction.
            let tacArguments := arguments collect: {:(SSAValue)eachArgument :: TACValue | self translateBoxedValue: eachArgument}.
            AnyValue
                emitTacCall: entryPoint convention: self tacFunction compilationTarget defaultCallingConvention
                withArguments: (Array with: tacCalledFunction) -- tacArguments into: tacValue
                withBlockBuilder: self blockBuilder
        }.
    }.
}.

SSACallInstruction extend: {
    public override method compileIntoTacValue: (tacValue: TACValue) with: (codegen: SSAFunctionDefinitionTACCodeGenerator) ::=> Void := {
        codegen compileCall: calledFunction withArguments: arguments unchecked: isUnchecked into: tacValue type: self type
    }.
}.

SSABitcastInstruction extend: {
    public override method compileIntoTacValue: (tacValue: TACValue) with: (codegen: SSAFunctionDefinitionTACCodeGenerator) ::=> Void := {
        ## FIXME: Add support for non-pointer values.
        codegen blockBuilder movePointer: (codegen translateValue: self value) into: tacValue
    }.
}.

SSACoerceValueInstruction extend: {
    public override method compileIntoTacValue: (tacValue: TACValue) with: (codegen: SSAFunctionDefinitionTACCodeGenerator) ::=> Void := {
        ## TODO: Add a target typecheck.
        self value type isValueType && self type isValueType ifTrue: {
            codegen notYetImplementedError: "Implement unboxing generation on SSACoerceValueInstruction"
        } ifFalse: {
            codegen blockBuilder movePointer: (codegen translateValue: self value) into: tacValue
        }.
    }.
}.

SSADownCastInstruction extend: {
    public override method compileIntoTacValue: (tacValue: TACValue) with: (codegen: SSAFunctionDefinitionTACCodeGenerator) ::=> Void := {
        ## TODO: Add a target typecheck.
        self value type isValueType && self type isValueType ifTrue: {
            codegen notYetImplementedError: "Implement unboxing generation on downcast"
        } ifFalse: {
            codegen blockBuilder movePointer: (codegen translateValue: self value) into: tacValue
        }.
    }.
}.

SSALoadInstruction extend: {
    public override method compileIntoTacValue: (tacValue: TACValue) with: (codegen: SSAFunctionDefinitionTACCodeGenerator) ::=> Void := {
        (codegen localOnlyAllocaDictionary atOrNil: self storage) ifNotNil: {:(TACValue)localOnlyAlloca :: Void | 
            self type emitTacMove: localOnlyAlloca into: tacValue withBlockBuilder: codegen blockBuilder
        } ifNil: {
            self type emitTacLoadFromPointer: (codegen translateValue: self storage) constantOffset: 0i64 into: tacValue withBlockBuilder: codegen blockBuilder
        }
    }.
}.

SSAMakeArrayInstruction extend: {
    public override method compileIntoTacValue: (tacValue: TACValue) with: (codegen: SSAFunctionDefinitionTACCodeGenerator) ::=> Void := {
       codegen notYetImplementedError: "Make array"
    }.
}.

SSAMakeAssociationInstruction extend: {
    public override method compileIntoTacValue: (tacValue: TACValue) with: (codegen: SSAFunctionDefinitionTACCodeGenerator) ::=> Void := {
       codegen notYetImplementedError: "Make association"
    }.
}.

SSAMakeByteArrayInstruction extend: {
    public override method compileIntoTacValue: (tacValue: TACValue) with: (codegen: SSAFunctionDefinitionTACCodeGenerator) ::=> Void := {
       codegen notYetImplementedError: "Make byte array"
    }.
}.

SSAMakeClosureInstruction extend: {
    public override method compileIntoTacValue: (tacValue: TACValue) with: (codegen: SSAFunctionDefinitionTACCodeGenerator) ::=> Void := {
        codegen notYetImplementedError: "Make closure"
    }.
}.

SSAMakeDictionaryInstruction extend: {
    public override method compileIntoTacValue: (tacValue: TACValue) with: (codegen: SSAFunctionDefinitionTACCodeGenerator) ::=> Void := {
       codegen notYetImplementedError: "Make dictionary"
    }.
}.

SSASendInstruction extend: {
    public override method compileIntoTacValue: (tacValue: TACValue) with: (codegen: SSAFunctionDefinitionTACCodeGenerator) ::=> Void := {
        codegen notYetImplementedError: "Send"
    }.
}.

SSASetDebugValueForBindingInstruction extend: {
    public override method compileIntoTacValue: (tacValue: TACValue) with: (codegen: SSAFunctionDefinitionTACCodeGenerator) ::=> Void := {
        (codegen localOnlyAllocaDictionary atOrNil: self value) ifNotNil: {:(TACValue)localOnlyAlloca :: Void | 
            codegen blockBuilder debugSetMutableBinding: self binding value: localOnlyAlloca
        } ifNil: {
            codegen blockBuilder debugSetBinding: self binding value: (codegen translateValue: self value)
        }.
    }.
}.

SSAStoreInstruction extend: {
    public override method compileIntoTacValue: (tacValue: TACValue) with: (codegen: SSAFunctionDefinitionTACCodeGenerator) ::=> Void := {
        (codegen localOnlyAllocaDictionary atOrNil: self storage) ifNotNil: {:(TACValue)localOnlyAlloca :: Void | 
            self value type emitTacMove: (codegen translateValue: self value) into: localOnlyAlloca withBlockBuilder: codegen blockBuilder
        } ifNil: {
            self value type emitTacStore: (codegen translateValue: self value) intoPointer: (codegen translateValue: self storage) constantOffset: 0i64 withBlockBuilder: codegen blockBuilder
        }
    }.
}.

SSAPointerElementAtInstruction extend: {
    public override method compileIntoTacValue: (tacValue: TACValue) with: (codegen: SSAFunctionDefinitionTACCodeGenerator) ::=> Void := {
        let pointerValue := codegen translateValue: self pointer.
        let indexValue := codegen translateValue: self index.
        let elementSize := (self pointer type downCastTo: PointerLikeType) baseType alignedValueSize.
        codegen blockBuilder loadEffectiveAddress: pointerValue index: indexValue constantScale: elementSize asInt64 into: tacValue
    }.
}.

SSATypeSlotReferenceAtInstruction extend: {
    public override method compileIntoTacValue: (tacValue: TACValue) with: (codegen: SSAFunctionDefinitionTACCodeGenerator) ::=> Void := {
        let pointerValue := codegen translateValue: self tuple.
        let headerSize := (self tuple type ifNil: AnyValue) objectHeaderSizeForObjectModel: codegen compilationTarget objectModel.
        codegen blockBuilder addPointer: pointerValue constantOffset: headerSize asInt64 + self typeSlot validOffset asInt64 into: tacValue
    }.
}.

SSATypeSlotAtInstruction extend: {
    public override method compileIntoTacValue: (tacValue: TACValue) with: (codegen: SSAFunctionDefinitionTACCodeGenerator) ::=> Void := {
        let headerSize := (self tuple type ifNil: AnyValue) objectHeaderSizeForObjectModel: codegen compilationTarget objectModel.
        self type emitTacLoadFromPointer: (codegen translateValue: self tuple) constantOffset: headerSize asInt64 + self typeSlot validOffset asInt64 into: tacValue withBlockBuilder: codegen blockBuilder
    }.
}.

SSATypeSlotAtPutInstruction extend: {
    public override method compileIntoTacValue: (tacValue: TACValue) with: (codegen: SSAFunctionDefinitionTACCodeGenerator) ::=> Void := {
        let headerSize := (self tuple type ifNil: AnyValue) objectHeaderSizeForObjectModel: codegen compilationTarget objectModel.
        self value type emitTacStore: (codegen translateValue: self value) intoPointer: (codegen translateValue: self tuple) constantOffset: headerSize asInt64 + self typeSlot validOffset asInt64 withBlockBuilder: codegen blockBuilder
    }.
}.

SSAReturnInstruction extend: {
    public override method compileIntoTacValue: (tacValue: TACValue) with: (codegen: SSAFunctionDefinitionTACCodeGenerator) ::=> Void := {
        self value type emitTacReturn: (codegen translateValue: self value) withBlockBuilder: codegen blockBuilder
    }.
}.

SSAUnreachableInstruction extend: {
    public override method compileIntoTacValue: (tacValue: TACValue) with: (codegen: SSAFunctionDefinitionTACCodeGenerator) ::=> Void := {
        codegen blockBuilder trap
    }.
}.

SSAModule extend: {
    public method asTACModuleFor: (target: TACCompilationTarget) ::=> TACModule
        := SSAModuleTACCodeGenerator new
            initializeWithTarget: target;
            compileSSAModule: self;
            finish
}.
