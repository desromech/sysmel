public class SSAValue superclass: Object.
public class SSAConstant superclass: SSAValue.
public class SSAFunction superclass: SSAConstant.
public class SSAFunctionDefinition superclass: SSAConstant.
public class SSAFunctionLocalValue superclass: SSAValue.
public final class SSAFunctionArgument superclass: SSAFunctionLocalValue.
public final class SSAFunctionCapture superclass: SSAFunctionLocalValue.
public class SSABasicBlock superclass: SSAFunctionLocalValue.
public class SSAInstruction superclass: SSAFunctionLocalValue.
public final class SSAInstructionBuilder superclass: Object.

SSAValue definition: {
    public field type => Type.
    public field sourcePosition => SourcePosition.
    public field sourceASTNode => ASTNode.
    public field sourceEnvironment => Environment.
    public field users => WeakArrayList.

    public method isConstant => Boolean := false.
    public method isLiteralConstant => Boolean := false.
    public method isFunction => Boolean := false.
    public method isFunctionLocalValue => Boolean := false.
    public method isBasicBlock => Boolean := false.
    
    public method isInstruction => Boolean := false.
    public method isPhiInstruction => Boolean := false.
    public method isLoadInstruction => Boolean := false.
    public method isStoreInstruction => Boolean := false.
    public method isTerminatorInstruction => Boolean := false.

    public method primitiveName => Symbol := nil.

    public method usedValuesDo: aBlock ::=> Void := {}.

    public method usersDo: aBlock ::=> Void := {
        self users ifNotNil: {:users | users do: aBlock }
    }.

    public method replaceWith: (replacement: SSAValue) ::=> Void := {
        self users do: {:(SSAValue)user :: Void |
            user replaceUsedValue: self with: replacement.
            replacement registerUser: user
        }.

        self usedValuesDo: {:(SSAValue)usedValue :: Void |
            usedValue unregisterUser: self
        }.
    }.

    public method replaceUsedValue: replacedValue with: replacement ::=> Void := {}.
    public method replaceUsedValuesWith: (replacementDictionary: Dictionary) ::=> Void := {}.

    public method registerInUsedValues => Void := {
        self usedValuesDo: {:(SSAValue)each :: Void | each registerUser: self }
    }.

    public method registerUser: (user: SSAValue) ::=> Void := {
        self users ifNil: {
            self users: WeakArrayList new
        }.

        self users add: user
    }.

    public method unregisterUser: (user: SSAValue) ::=> Void := {
        self users ifNotNil: {:userList :: Void |
            userList removeAllOcurrencesOf: self
        }.
    }.

    public method postCopy => Void := {
        self users: nil
    }.
}.

SSAConstant definition: {
    public method isConstant => Boolean := true.
}.

public class SSALiteralConstant superclass: SSAConstant; definition: {
    public field value.

    public method isLiteralConstant => Boolean := true.

    public method primitiveName => Symbol := {
        let value := self value.

        if: (value __type__ isSubtypeOf: Function)
        then: value primitiveName
        else: nil
    }.

    public method printOn: (stream: Stream) ::=> Void
        := stream nextPutAll: "Literal("; print: self value; nextPutAll: " => "; print: self type; nextPut: ')'.
}.

SSAFunction definition: {
    public field name.
    public field captures => Array.
    public field definition => SSAValue.

    public method initialize => Void := {
        super initialize.
        self captures: #().
    }.

    public method printOn: (stream: Stream) ::=> Void := {
        stream nextPut: '@'.
        self name ifNil: {
            stream print: self sourcePosition.
        } ifNotNil: {:name :: Void |
            stream print: self name
        }
    }.

    public method fullPrintOn: (stream: Stream) ::=> Void := {
        stream print: self.
        stream nextPutAll: " captures [".
        self captures doWithIndex: {:(SSAValue)capture :(Size)index :: Void |
            index > 0sz ifTrue: (stream nextPutAll: ", ").
            stream print: capture
        }.

        stream nextPut: ']'.
        self definition ifNotNil: {:(SSAValue)definition :: Void |
            stream nextPutAll: " definition ".
            stream fullPrint: definition
        }
    }.
}.

SSAFunctionDefinition definition: {
    public field name.
    public field arguments => Array.
    public field captures => Array.

    public field firstBasicBlock => SSABasicBlock.
    public field lastBasicBlock => SSABasicBlock.

    public method isFunction => Boolean := true.

    public method addBasicBlock: (basicBlock: SSABasicBlock) before: (position: SSABasicBlock) ::=> Void := {
        self assert: basicBlock parent isNil.

        let before := position ifNotNil: position previousBlock ifNil: self lastBasicBlock.
        let after := position.

        before ifNotNil: {
            before nextBlock: basicBlock.
            basicBlock previousBlock: before.
        } ifNil: {
            self firstBasicBlock: basicBlock
        }.

        after ifNotNil: {
            after previousBlock: basicBlock.
            basicBlock nextBlock: after
        } ifNil: {
            self lastBasicBlock: basicBlock
        }.

        basicBlock parent: self
    }.

    public method addBasicBlock: (basicBlock: SSABasicBlock) after: (position: SSABasicBlock) ::=> Void := {
        self assert: basicBlock parent isNil.

        let before := position .
        let after := position ifNotNil: position nextBlock ifNil: self firstBasicBlock.

        before ifNotNil: {
            before nextBlock: basicBlock.
            basicBlock previousBlock: before.
        } ifNil: {
            self firstBasicBlock: basicBlock
        }.

        after ifNotNil: {
            after previousBlock: basicBlock.
            basicBlock nextBlock: after
        } ifNil: {
            self lastBasicBlock: basicBlock
        }.

        basicBlock parent: self
    }.

    public method addBasicBlock: (basicBlock: SSABasicBlock) ::=> Void
        := self addBasicBlock: basicBlock before: nil.

    public method addFirstBasicBlock: (basicBlock: SSABasicBlock) ::=> Void
        := self addBasicBlock: basicBlock after: nil.

    public method basicBlocksDo: aBlock ::=> Void := {
        let position mutable := self firstBasicBlock.
        while: position isNotNil do: (
            aBlock(position)
        ) continueWith: (position := position nextBlock)
    }.

    public method localValuesDo: aBlock ::=> Void := {
        self arguments do: aBlock.
        self captures do: aBlock.
        self basicBlocksDo: {:basicBlock :: Void |
            aBlock(basicBlock).
            basicBlock instructionsDo: aBlock
        }.
    }.

    public method allLocalValues ::=> Array := {
        let result := ArrayList new.
        self localValuesDo: {:(SSAFunctionLocalValue)localValue :: Void |
            result add: localValue
        }.
        result asArray
    }.

    public method enumerateLocalValueIndices => Void := {
        let index mutable := 0sz.
        self localValuesDo: {:localValue :: Void |
            localValue localValueIndex: index.
            index := index + 1sz
        }
    }.

    public method removeBasicBlock: (basicBlock: SSABasicBlock) ::=> Void := {
        self assert: basicBlock parent == self.

        let previousBlock := basicBlock previousBlock.
        let nextBlock := basicBlock nextBlock.

        previousBlock ifNotNil: {
            previousBlock nextBlock: nextBlock
        } ifNil: {
            self firstBlock: nextBlock
        }.

        nextBlock ifNotNil: {
            nextBlock previousBlock: previousBlock
        } ifNil: {
            self lastBlock: previousBlock
        }.

        basicBlock
            parent: nil;
            previousBlock: nil;
            nextBlock: nil
    }.

    public method postCopy => Void := {
        super postCopy.

        let oldLocalValues := self allLocalValues.

        self arguments: (self arguments collect: {:(SSAFunctionArgument)each | each copy}).
        self captures: (self captures collect: {:(SSAFunctionCapture)each | each copy}).

        let nextBasicBlockToAdd mutable => SSABasicBlock := self firstBasicBlock.
        self firstInstruction: nil.
        self lastInstruction: nil.

        while: nextBasicBlockToAdd ~~ nil do: {
            self addBasicBlock: nextBasicBlockToAdd copy
        } continueWith: (nextBasicBlockToAdd := nextBasicBlockToAdd nextBlock).

        ## Construct a replacement dictionary.
        let newLocalValues := self allLocalValues.
        self assert: oldLocalValues size = newLocalValues size.

        let replacementDictionary := Dictionary new.
        oldLocalValues doWithIndex: {:(SSAFunctionLocalValue)oldValue :(Size)index :: Void |
            let newValue := newLocalValues at: index.
            replacementDictionary at: oldValue put: newValue
        }.

        self localValuesDo: {:(SSAFunctionLocalValue)each :: Void |
            each
                replaceUsedValuesWith: replacementDictionary;
                registerInUsedValues
        }.
    }.

    public method printOn: (stream: Stream) ::=> Void := {
        stream nextPut: '%'.
        self name ifNotNil: {:name :: Void |
            stream print: self name
        }.

        self sourcePosition ifNotNil: {:sourcePosition :: Void |
            stream nextPutAll: "at "; print: sourcePosition
        }.
    }.

    public method fullPrintOn: (stream: Stream) ::=> Void := {
        self enumerateLocalValueIndices.
        self printOn: stream.
        
        stream nextPut: '('.
        self arguments doWithIndex: {:(SSAFunctionArgument)argument :(Size)index :: Void |
            index > 0sz ifTrue: (stream nextPutAll: ", ").
            stream print: argument
        }.
        stream nextPut: ')'.
        stream nextPut: '['.
        self captures doWithIndex: {:(SSAFunctionCapture)capture :(Size)index :: Void |
            index > 0sz ifTrue: (stream nextPutAll: ", ").
            stream print: capture
        }.
        stream nextPut: ']'.

        stream nextPutAll: " := {"; nl.
        self basicBlocksDo: {:(SSABasicBlock)basicBlock :: Void |
            basicBlock fullPrintOn: stream
        }.
        stream nextPutAll: "}"; nl.
    }.
}.

SSAFunctionLocalValue definition: {
    public field name.
    public field localValueIndex => Size.

    public method initialize => Void := {
        super initialize.
        self localValueIndex: 0sz
    }.

    public method isFunctionLocalValue => Boolean := true.

    public method printOn: (stream: Stream) ::=> Void := {
        stream nextPut: '$'; print: self localValueIndex.

        self name ifNotNil: {:name |
            stream nextPut: ':'; nextPutAll: self name.
        }.
        self type ifNotNil: {:type |
            stream nextPutAll: " => "; print: self type.
        }.
    }.
}.

SSABasicBlock definition: {
    public field parent => SSAFunctionDefinition.

    public field previousBlock => SSABasicBlock.
    public field nextBlock => SSABasicBlock.

    public field firstInstruction => SSAInstruction.
    public field lastInstruction => SSAInstruction.

    public method isBasicBlock => Boolean := true.

    public method addInstruction: (instruction: SSAInstruction) before: (position: SSAInstruction) ::=> Void := {
        self assert: instruction parent isNil.

        let before := position ifNotNil: position previousInstruction ifNil: self lastInstruction.
        let after := position.

        before ifNotNil: {
            before nextInstruction: instruction.
            instruction previousInstruction: before.
        } ifNil: {
            self firstInstruction: instruction
        }.

        after ifNotNil: {
            after previousInstruction: instruction.
            instruction nextInstruction: after
        } ifNil: {
            self lastInstruction: instruction
        }.

        instruction parent: self
    }.

    public method addInstruction: (instruction: SSAInstruction) after: (position: SSAInstruction) ::=> Void := {
        self assert: instruction parent isNil.

        let before := position .
        let after := position ifNotNil: position nextInstruction ifNil: self firstInstruction.

        before ifNotNil: {
            before nextInstruction: instruction.
            instruction previousInstruction: before.
        } ifNil: {
            self firstInstruction: instruction
        }.

        after ifNotNil: {
            after previousInstruction: instruction.
            instruction nextInstruction: after
        } ifNil: {
            self lastInstruction: instruction
        }.

        instruction parent: self
    }.

    public method addInstruction: (instruction: SSAInstruction) ::=> Void
        := self addInstruction: instruction before: nil.

    public method addFirstInstruction: (instruction: SSAInstruction) ::=> Void
        := self addInstruction: instruction after: nil.

    public method instructionsDo: aBlock ::=> Void := {
        let position mutable := self firstInstruction.
        while: position isNotNil do: (
            aBlock(position)
        ) continueWith: (position := position nextInstruction)
    }.

    public method removeInstruction: (instruction: SSAInstruction) ::=> Void := {
        self assert: instruction parent == self.

        let previousInstruction := instruction previousInstruction.
        let nextInstruction := instruction nextInstruction.

        previousInstruction ifNotNil: {
            previousInstruction nextInstruction: nextInstruction
        } ifNil: {
            self firstInstruction: nextInstruction
        }.

        nextInstruction ifNotNil: {
            nextInstruction previousInstruction: previousInstruction
        } ifNil: {
            self lastInstruction: previousInstruction
        }.

        instruction
            parent: nil;
            previousInstruction: nil;
            nextInstruction: nil
    }.

    public method postCopy => Void := {
        super postCopy.
        self parent: nil.

        let nextInstructionToAdd mutable => SSAInstruction := self firstInstruction.
        self firstInstruction: nil.
        self lastInstruction: nil.

        while: nextInstructionToAdd ~~ nil do: {
            self addInstruction: nextInstructionToAdd copy
        } continueWith: (nextInstructionToAdd := nextInstructionToAdd nextInstruction)
    }.

    public method replaceWith: (replacement: SSAValue) ::=> Void := {
        super replaceWith: replacement.
        self parent ifNotNil: {:parent :: Void | parent removeBasicBlock: self }
    }.

    public method fullPrintOn: (stream: Stream) ::=> Void := {
        self printOn: stream.
        stream nextPutAll: ":"; nl.
        self instructionsDo: {:(SSAInstruction)instruction :: Void |
            stream nextPutAll: "    ".
            instruction fullPrintOn: stream.
            stream nl.
        }.
    }.
}.

SSAInstruction definition: {
    public field parent => SSABasicBlock.

    public field previousInstruction => SSAInstruction.
    public field nextInstruction => SSAInstruction.

    public method parentFunction => SSAFunctionDefinition
        := self parent ifNil: nil ifNotNil: {:(SSABasicBlock)parentBlock | parentBlock parent }.

    public method isInstruction => Boolean := true.

    public method postCopy => Void := {
        super postCopy.
        self parent: nil.
        self previousInstruction: nil.
        self nextInstruction: nil.
    }.

    public method replaceWith: (replacement: SSAValue) ::=> Void := {
        super replaceWith: replacement.
        self parent ifNotNil: {:parent :: Void | parent removeInstruction: self }
    }.
}.

public final class SSAAllocaInstruction superclass: SSAInstruction; definition: {
    public field valueType => SSAValue.

    public method fullPrintOn: (stream: Stream) ::=> Void
        := stream print: self; nextPutAll: " := alloca: "; print: self valueType.

    public method usedValuesDo: aBlock ::=> Void := {
        aBlock(self valueType)
    }.

    public method replaceUsedValue: replacedValue with: replacement ::=> Void := {
        if: self valueType = replacedValue then: (self valueType: replacement)
    }.

    public method replaceUsedValuesWith: (replacementDictionary: Dictionary) ::=> Void := {
        replacementDictionary at: self valueType isPresent: {:(SSAValue)replacement :: Void | self valueType: replacement}.
    }.
}.

public final class SSABranchInstruction superclass: SSAInstruction; definition: {
    public field destination => SSABasicBlock.

    public method isTerminatorInstruction => Boolean := true.

    public method fullPrintOn: (stream: Stream) ::=> Void
        := stream nextPutAll: "branch: "; print: self destination.

    public method usedValuesDo: aBlock ::=> Void := {
        aBlock(self destination).
    }.

    public method replaceUsedValue: replacedValue with: replacement ::=> Void := {
        if: self destination = replacedValue then: (self destination: replacement)
    }.

    public method replaceUsedValuesWith: (replacementDictionary: Dictionary) ::=> Void := {
        replacementDictionary at: self destination isPresent: {:(SSAValue)replacement :: Void | self destination: replacement}.
    }.
}.

public final class SSACallInstruction superclass: SSAInstruction; definition: {
    public field calledFunction => SSAValue.
    public field arguments => Array.

    public method fullPrintOn: (stream: Stream) ::=> Void := {
        stream
            print: self; nextPutAll: " := ";
            nextPutAll: "call "; print: self calledFunction.
        self arguments do: {:(SSAValue)argument :: Void |
            stream nextPutAll: ", ".
            stream print: argument
        }
    }.

    public method usedValuesDo: aBlock ::=> Void := {
        aBlock(self calledFunction).
        self arguments do: aBlock
    }.

    public method replaceUsedValue: replacedValue with: replacement ::=> Void := {
        if: self calledFunction = replacedValue then: (self calledFunction: replacement).
        self arguments replaceAll: replacedValue with: replacement
    }.

    public method replaceUsedValuesWith: (replacementDictionary: Dictionary) ::=> Void := {
        replacementDictionary at: self calledFunction isPresent: {:(SSAValue)replacement :: Void | self calledFunction: replacement}.
        self arguments replaceAllWithDictionary: replacementDictionary
    }.
}.

public final class SSACoerceValueInstruction superclass: SSAInstruction; definition: {
    public field value => SSAValue.
    public field targetType => SSAValue.

    public method fullPrintOn: (stream: Stream) ::=> Void
        := stream print: self; nextPutAll: " := coerceValue: "; print: self value;
            nextPut: ' '; print: self targetType.

    public method usedValuesDo: aBlock ::=> Void := {
        aBlock(self value).
        aBlock(self targetType).
    }.

    public method replaceUsedValue: replacedValue with: replacement ::=> Void := {
        if: self value = replacedValue then: (self value: replacement).
        if: self targetType = replacedValue then: (self targetType: replacement).
    }.

    public method replaceUsedValuesWith: (replacementDictionary: Dictionary) ::=> Void := {
        replacementDictionary at: self value isPresent: {:(SSAValue)replacement :: Void | self value: replacement}.
        replacementDictionary at: self targetType isPresent: {:(SSAValue)replacement :: Void | self targetType: replacement}.
    }.
}.

public final class SSAConditionalBranchInstruction superclass: SSAInstruction; definition: {
    public field condition => SSAValue.
    public field trueDestination => SSABasicBlock.
    public field falseDestination => SSABasicBlock.

    public method isTerminatorInstruction => Boolean := true.

    public method fullPrintOn: (stream: Stream) ::=> Void
        := stream nextPutAll: "condBranch: "; print: self condition;
            nextPut: ' '; print: self trueDestination;
            nextPut: ' '; print: self falseDestination.

    public method usedValuesDo: aBlock ::=> Void := {
        aBlock(self condition).
        aBlock(self trueDestination).
        aBlock(self falseDestination).
    }.

    public method replaceUsedValue: replacedValue with: replacement ::=> Void := {
        if: self condition = replacedValue then: (self condition: replacement).
        if: self trueDestination = replacedValue then: (self trueDestination: replacement).
        if: self falseDestination = replacedValue then: (self falseDestination: replacement).
    }.

    public method replaceUsedValuesWith: (replacementDictionary: Dictionary) ::=> Void := {
        replacementDictionary at: self condition isPresent: {:(SSAValue)replacement :: Void | self condition: replacement}.
        replacementDictionary at: self trueDestination isPresent: {:(SSAValue)replacement :: Void | self trueDestination: replacement}.
        replacementDictionary at: self falseDestination isPresent: {:(SSAValue)replacement :: Void | self falseDestination: replacement}.
    }.
}.

public final class SSALoadInstruction superclass: SSAInstruction; definition: {
    public field storage => SSAValue.

    public method isLoadInstruction => Boolean := true.

    public method fullPrintOn: (stream: Stream) ::=> Void := {
        stream print: self; nextPutAll: " := load "; print: self storage
    }.

    public method usedValuesDo: aBlock ::=> Void := {
        aBlock(self storage).
    }.

    public method replaceUsedValue: replacedValue with: replacement ::=> Void := {
        if: self storage = replacedValue then: (self storage: replacement).
    }.

    public method replaceUsedValuesWith: (replacementDictionary: Dictionary) ::=> Void := {
        replacementDictionary at: self storage isPresent: {:(SSAValue)replacement :: Void | self storage: replacement}.
    }.
}.

public final class SSAMakeClosureInstruction superclass: SSAInstruction; definition: {
    public field functionDefinition => SSAValue.
    public field captures => Array.

    public method fullPrintOn: (stream: Stream) ::=> Void := {
        stream print: self; nextPutAll: " := makeClosure "; print: self functionDefinition.
        self captures do: {:(SSAValue)capture :: Void |
            stream nextPutAll: ", "; print: capture
        }
    }.

    public method usedValuesDo: aBlock ::=> Void := {
        aBlock(self functionDefinition).
        self captures do: aBlock
    }.

    public method replaceUsedValue: replacedValue with: replacement ::=> Void := {
        if: self functionDefinition = replacedValue then: (self functionDefinition: replacement).
        self captures replaceAll: replacedValue with: replacement
    }.

    public method replaceUsedValuesWith: (replacementDictionary: Dictionary) ::=> Void := {
        replacementDictionary at: self functionDefinition isPresent: {:(SSAValue)replacement :: Void | self functionDefinition: replacement}.
        self captures replaceAllWithDictionary: replacementDictionary
    }.
}.

public final class SSAPhiInstruction superclass: SSAInstruction; definition: {
    public field incomingValuesAndBlocks => ArrayList.

    public method isPhiInstruction => Boolean := true.

    public method initialize => Void := {
        self initialize.
        self incomingValuesAndBlocks: ArrayList new.
    }.

    public method fullPrintOn: (stream: Stream) ::=> Void := {
        stream print: self; nextPutAll: " := phi ["; nl.
        self incomingValuesAndBlocks do: {:(Association)blockAndValue :: Void |
            stream nextPutAll: "        "; print: blockAndValue value; nextPutAll: " from "; print: blockAndValue key; nl 
        }.

        stream nextPutAll: "    ]"
    }.

    public method addValue: (value: SSAValue) incomingFrom: (block: SSABasicBlock) ::=> Void := {
        self incomingValuesAndBlocks add: (Association new key: block; value: value; yourself).
    }.

    public method usedValuesDo: aBlock ::=> Void := {
        self incomingValuesAndBlocks do: {:(Association)association :: Void |
            aBlock(association key).
            aBlock(association value).
        }
    }.

    public method replaceUsedValue: replacedValue with: replacement ::=> Void := {
        self incomingValues replaceAll: replacedValue with: replacement.
        self incomingBlocks replaceAll: replacedValue with: replacement
    }.

    public method replaceUsedValuesWith: (replacementDictionary: Dictionary) ::=> Void := {
        self incomingValues replaceAllWithDictionary: replacementDictionary
        self incomingBlocks replaceAllWithDictionary: replacementDictionary
    }.
}.

public final class SSAReturnInstruction superclass: SSAInstruction; definition: {
    public field value => SSAValue.

    public method isTerminatorInstruction => Boolean := true.

    public method fullPrintOn: (stream: Stream) ::=> Void
        := stream nextPutAll: "return: "; print: self value.

    public method usedValuesDo: aBlock ::=> Void := {
        aBlock(self value)
    }.

    public method replaceUsedValue: replacedValue with: replacement ::=> Void := {
        if: self value = replacedValue then: (self value: replacement)
    }.

    public method replaceUsedValuesWith: (replacementDictionary: Dictionary) ::=> Void := {
        replacementDictionary at: self value isPresent: {:(SSAValue)replacement :: Void | self value: replacement}.
    }.
}.

public final class SSASendInstruction superclass: SSAInstruction; definition: {
    public field receiver => SSAValue.
    public field receiverLookupType => SSAValue.
    public field selector => SSAValue.
    public field arguments => Array.

    public method fullPrintOn: (stream: Stream) ::=> Void := {
        stream
            print: self; nextPutAll: " := ";
            nextPutAll: "send "; print: self receiver.
        self receiverLookupType ifNotNil: {:(SSAValue)receiverLookupType :: Void |
            stream nextPutAll: " lookupFrom: "; print: self receiverLookupType.
        }.

        stream nextPutAll: ", "; print: self selector.

        self arguments doWithIndex: {:(SSAValue)argument :(Size)index :: Void |
            index = 0sz
                ifTrue: (stream nextPut: ' ')
                ifFalse: (stream nextPutAll: ", ").
            stream print: argument
        }
    }.

    public method usedValuesDo: aBlock ::=> Void := {
        aBlock(self receiver).
        if: self receiverLookupType ~~ nil then: aBlock(self receiverLookupType).
        aBlock(self selector).
        self arguments do: aBlock
    }.

    public method replaceUsedValue: replacedValue with: replacement ::=> Void := {
        if: self receiver = replacedValue then: (self receiver: replacement).
        if: self receiverLookupType = replacedValue then: (self receiverLookupType: replacement).
        if: self selector = replacedValue then: (self selector: replacement).
        self arguments replaceAll: replacedValue with: replacement
    }.

    public method replaceUsedValuesWith: (replacementDictionary: Dictionary) ::=> Void := {
        replacementDictionary at: self receiver isPresent: {:(SSAValue)replacement :: Void | self receiver: replacement}.
        replacementDictionary at: self receiverLookupType isPresent: {:(SSAValue)replacement :: Void | self receiverLookupType: replacement}.
        replacementDictionary at: self selector isPresent: {:(SSAValue)replacement :: Void | self selector: replacement}.
        self arguments replaceAllWithDictionary: replacementDictionary
    }.
}.

public final class SSAStoreInstruction superclass: SSAInstruction; definition: {
    public field storage => SSAValue.
    public field value => SSAValue.

    public method isStoreInstruction => Boolean := true.

    public method fullPrintOn: (stream: Stream) ::=> Void := {
        stream nextPutAll: "store "; print: self value; nextPutAll: " in "; print: self storage
    }.

    public method usedValuesDo: aBlock ::=> Void := {
        aBlock(self storage).
        aBlock(self value).
    }.

    public method replaceUsedValue: replacedValue with: replacement ::=> Void := {
        if: self storage = replacedValue then: (self storage: replacement).
        if: self value = replacedValue then: (self value: replacement).
    }.

    public method replaceUsedValuesWith: (replacementDictionary: Dictionary) ::=> Void := {
        replacementDictionary at: self storage isPresent: {:(SSAValue)replacement :: Void | self storage: replacement}.
        replacementDictionary at: self value isPresent: {:(SSAValue)replacement :: Void | self value: replacement}.
    }.
}.

public final class SSAUnreachableInstruction superclass: SSAInstruction; definition: {
    public method isUnreachableInstruction => Boolean := true.

    public method fullPrintOn: (stream: Stream) ::=> Void
        := stream nextPutAll: "unreachable".
}.

SSAInstructionBuilder definition: {
    public field sourcePosition => SourcePosition.
    public field sourceASTNode => ASTNode.
    public field sourceEnvironment => Environment.

    public field function => SSAFunctionDefinition.
    public field basicBlock => SSABasicBlock.

    __Meta__ definition: {
        public method for: (function: SSAFunctionDefinition)
            := self new function: function; yourself.
    }.

    public method newBasicBlockNamed: name ::=> SSABasicBlock := {
        let newBasicBlock := SSABasicBlock new
            name: name;
            sourcePosition: self sourcePosition;
            sourceASTNode: self sourceASTNode;
            sourceEnvironment: self sourceEnvironment;
            yourself.
        newBasicBlock
    }.

    public method beginBasicBlock: (newBasicBlock: SSABasicBlock) ::=> SSABasicBlock := {
        self basicBlock: newBasicBlock.
        self function addBasicBlock: newBasicBlock.
        newBasicBlock
    }.

    public method beginBasicBlockNamed: name ::=> SSABasicBlock
        := self beginBasicBlock: (self newBasicBlockNamed: name).

    public method addInstruction: (instruction: SSAInstruction) ::=> instruction __type__ := {
        instruction
            sourcePosition: self sourcePosition;
            sourceASTNode: self sourceASTNode;
            sourceEnvironment: self sourceEnvironment.
        self basicBlock addInstruction: instruction.
        instruction
    }.

    public method withSourcePosition: (sourcePosition: SourcePosition) do: aBlock := {
        let oldPosition := self sourcePosition.
        self sourcePosition: sourcePosition.
        let result := aBlock().
        self sourcePosition: oldPosition.
        result
    }.

    public method withSourceASTNode: (sourceASTNode: ASTNode) do: aBlock := {
        let oldSourceASTNode := self sourceASTNode.
        self sourceASTNode: sourceASTNode.
        let result := self withSourcePosition: sourceASTNode sourcePosition do: aBlock.
        self sourceASTNode: oldSourceASTNode.
        result
    }.

    public method withSourceEnvironment: (sourceEnvironment: Environment) do: aBlock := {
        let oldSourceEnvironment := self sourceEnvironment.
        self sourceEnvironment: sourceEnvironment.
        let result := aBlock().
        self sourceEnvironment: oldSourceEnvironment.
        result
    }.

    public method alloca: (valueType: SSAValue) type: (type: Type) ::=> SSAAllocaInstruction
        := self addInstruction: (SSAAllocaInstruction new
            valueType: valueType;
            type: type;
            registerInUsedValues;
            yourself).

    public method branch: (destination: SSAValue) ::=> SSABranchInstruction
        := self addInstruction: (SSABranchInstruction new
            destination: destination;
            type: Void;
            registerInUsedValues;
            yourself).

    public method call: (calledFunction: SSAValue) arguments: (arguments: Array) resultType: (resultType: Type) ::=> SSACallInstruction
        := self addInstruction: (SSACallInstruction new
            calledFunction: calledFunction;
            arguments: arguments;
            type: resultType;
            registerInUsedValues;
            yourself).

    public method call: (receiver: SSAValue) selector: (selector: SSAValue) arguments: (arguments: Array) ::=> SSASendInstruction
        := self call: receiver selector: selector arguments: arguments resultType: nil.

    public method coerceValue: (value: SSAValue) into: (targetType: SSAValue) type: (type: Type) ::=> SSAValue := {
        (targetType == nil) || (targetType isLiteralConstant && (value type == targetType value)) ifTrue: {
            value
        } ifFalse: {
            self addInstruction: (SSACoerceValueInstruction new
                value: value;
                targetType: targetType;
                type: type;
            registerInUsedValues;
                yourself)
        }.
    }.

    public method conditionalBranch: (condition: SSAValue) trueDestination: (trueDestination: SSABasicBlock) falseDestination: (falseDestination: SSABasicBlock) ::=> SSAConditionalBranchInstruction
        := self addInstruction: (SSAConditionalBranchInstruction new
            condition: condition;
            trueDestination: trueDestination;
            falseDestination: falseDestination;
            type: Void;
            registerInUsedValues;
            yourself).

    public method literal: value type: (type: Type) ::=> SSALiteralConstant
        := SSALiteralConstant new
            sourcePosition: self sourcePosition;
            sourceASTNode: self sourceASTNode;
            sourceEnvironment: self sourceEnvironment;
            value: value;
            type: type;
            yourself.

    public method literal: value ::=> SSALiteralConstant
        := self literal: value type: value __type__.

    public method load: (storage: SSAValue) type: (type: Type) ::=> SSALoadInstruction
        := self addInstruction: (SSALoadInstruction new
            storage: storage;
            type: type;
            registerInUsedValues;
            yourself).

    public method makeClosure: (functionDefinition: SSAValue) captures: (captures: Array) type: (type: Type) ::=> SSAMakeClosureInstruction
        := self addInstruction: (SSAMakeClosureInstruction new
            functionDefinition: functionDefinition;
            captures: captures;
            type: type;
            registerInUsedValues;
            yourself).

    public method phi: (type: Type) ::=> SSAPhiInstruction
        := self addInstruction: (SSAPhiInstruction new
            type: type;
            registerInUsedValues;
            yourself).

    public method return: (value: SSAValue) ::=> SSAReturnInstruction
        := self addInstruction: (SSAReturnInstruction new
            value: value;
            registerInUsedValues;
            yourself).

    public method returnVoid ::=> SSAReturnInstruction
        := self return: (self literal: void).

    public method send: (receiver: SSAValue) receiverLookupType: (receiverLookupType: SSAValue) selector: (selector: SSAValue) arguments: (arguments: Array) resultType: (resultType: Type) ::=> SSASendInstruction
        := self addInstruction: (SSASendInstruction new
            receiver: receiver;
            receiverLookupType: receiverLookupType;
            selector: selector;
            arguments: arguments;
            type: resultType;
            registerInUsedValues;
            yourself).

    public method send: (receiver: SSAValue) selector: (selector: SSAValue) arguments: (arguments: Array) resultType: (resultType: Type) ::=> SSASendInstruction
        := self send: receiver receiverLookupType: nil selector: selector arguments: arguments resultType: resultType.

    public method send: (receiver: SSAValue) selector: (selector: SSAValue) arguments: (arguments: Array) ::=> SSASendInstruction
        := self send: receiver receiverLookupType: nil selector: selector arguments: arguments resultType: nil.

    public method store: (value: SSAValue) in: (storage: SSAValue) ::=> SSAStoreInstruction
        := self addInstruction: (SSAStoreInstruction new
            value: value;
            storage: storage;
            registerInUsedValues;
            yourself).

    public method lastInstruction => SSAInstruction
        := self basicBlock ifNotNil: {:basicBlock :: SSAInstruction | basicBlock lastInstruction }.

    public method isLastTerminator => Boolean
        := self lastInstruction
            ifNil: false
            ifNotNil: {:instruction :: Boolean | instruction isTerminatorInstruction }.
}.
