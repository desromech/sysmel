public class SSAValue superclass: Object.
public class SSAConstant superclass: SSAValue.
public class SSAFunction superclass: SSAConstant.
public class SSAFunctionDefinition superclass: SSAConstant.
public class SSAFunctionLocalValue superclass: SSAValue.
public final class SSAFunctionArgument superclass: SSAFunctionLocalValue.
public final class SSAFunctionCapture superclass: SSAFunctionLocalValue.
public class SSABasicBlock superclass: SSAFunctionLocalValue.
public class SSAInstruction superclass: SSAFunctionLocalValue.
public final class SSAPhiInstruction superclass: SSAInstruction.
public final class SSAInstructionBuilder superclass: Object.

SSAValue definition: {
    public field type => Type.
    public field sourcePosition => SourcePosition.
    public field sourceASTNode => ASTNode.
    public field sourceEnvironment => Environment.
    private field users => WeakArrayList.

    public method isConstant => Boolean := false.
    public method isLiteralConstant => Boolean := false.
    public method isUndefinedConstant => Boolean := false.

    public method isFunction => Boolean := false.
    public method isFunctionLocalValue => Boolean := false.
    public method isBasicBlock => Boolean := false.
    
    public method isInstruction => Boolean := false.
    public method isAllocaInstruction => Boolean := false.
    public method isPhiInstruction => Boolean := false.
    public method isLoadInstruction => Boolean := false.
    public method isStoreInstruction => Boolean := false.
    public method isTerminatorInstruction => Boolean := false.

    public method primitiveName => Symbol := nil.

    public method usedValuesDo: aBlock ::=> Void := {}.

    public method usersDo: aBlock ::=> Void := {
        users ifNotNil: {:users | users do: aBlock }
    }.

    public method replaceWith: (replacement: SSAValue) ::=> Void := {
        users do: {:(SSAValue)user :: Void |
            user replaceUsedValue: self with: replacement.
            replacement registerUser: user
        }.

        self usedValuesDo: {:(SSAValue)usedValue :: Void |
            usedValue unregisterUser: self
        }.
    }.

    public method replaceUsedValue: replacedValue with: replacement ::=> Void := {}.
    public method replaceUsedValuesWith: (replacementDictionary: Dictionary) ::=> Void := {}.

    public method registerInUsedValues => Void := {
        self usedValuesDo: {:(SSAValue)each :: Void | each registerUser: self }
    }.

    public method registerUser: (user: SSAValue) ::=> Void := {
        users ifNil: {
            users := WeakArrayList new
        }.

        users add: user
    }.

    public method unregisterUser: (user: SSAValue) ::=> Void := {
        users ifNotNil: {:userList :: Void |
            userList removeAllOcurrencesOf: self
        }.
    }.

    public method postCopy => Void := {
        users := nil
    }.
}.

SSAConstant definition: {
    public method isConstant => Boolean := true.
}.

public final class SSAUndefinedConstant superclass: SSAConstant; definition: {
    public method isUndefinedConstant => Boolean := true.

    public method printOn: (stream: Stream) ::=> Void
        := stream nextPutAll: "undefined "; print: self type.
}.

public final class SSALiteralConstant superclass: SSAConstant; definition: {
    public field value.

    public method isLiteralConstant => Boolean := true.

    public method primitiveName => Symbol := {
        let value := self value.

        if: (value __type__ isSubtypeOf: Function)
        then: value primitiveName
        else: nil
    }.

    public method printOn: (stream: Stream) ::=> Void
        := stream nextPutAll: "Literal("; print: self value; nextPutAll: " => "; print: self type; nextPut: ')'.
}.

SSAFunction definition: {
    public field name => Symbol.
    public field captures => Array.
    public field definition => SSAFunctionDefinition.

    public method initialize => Void := {
        super initialize.
        captures := #().
    }.

    public method printOn: (stream: Stream) ::=> Void := {
        stream nextPut: '@'.
        name ifNil: {
            stream print: sourcePosition.
        } ifNotNil: {:name :: Void |
            stream print: name
        }
    }.

    public method fullPrintOn: (stream: Stream) ::=> Void := {
        stream print: self.
        stream nextPutAll: " captures [".
        captures doWithIndex: {:(SSAValue)capture :(Size)index :: Void |
            index > 0sz ifTrue: (stream nextPutAll: ", ").
            stream print: capture
        }.

        stream nextPut: ']'.
        definition ifNotNil: {:(SSAValue)definition :: Void |
            stream nextPutAll: " definition ".
            stream fullPrint: definition
        }
    }.
}.

SSAFunctionDefinition definition: {
    public field name => Symbol.
    public field arguments => Array.
    public field captures => Array.

    public field firstBasicBlock => SSABasicBlock.
    public field lastBasicBlock => SSABasicBlock.

    public method isFunction => Boolean := true.

    public method addBasicBlock: (basicBlock: SSABasicBlock) before: (position: SSABasicBlock) ::=> Void := {
        self assert: basicBlock parent isNil.

        let before := position ifNotNil: position previousBlock ifNil: self lastBasicBlock.
        let after := position.

        before ifNotNil: {
            before nextBlock: basicBlock.
            basicBlock previousBlock: before.
        } ifNil: {
            firstBasicBlock := basicBlock
        }.

        after ifNotNil: {
            after previousBlock: basicBlock.
            basicBlock nextBlock: after
        } ifNil: {
            lastBasicBlock := basicBlock
        }.

        basicBlock parent: self
    }.

    public method addBasicBlock: (basicBlock: SSABasicBlock) after: (position: SSABasicBlock) ::=> Void := {
        self assert: basicBlock parent isNil.

        let before := position .
        let after := position ifNotNil: position nextBlock ifNil: self firstBasicBlock.

        before ifNotNil: {
            before nextBlock: basicBlock.
            basicBlock previousBlock: before.
        } ifNil: {
            firstBasicBlock := basicBlock
        }.

        after ifNotNil: {
            after previousBlock: basicBlock.
            basicBlock nextBlock: after
        } ifNil: {
            lastBasicBlock := basicBlock
        }.

        basicBlock parent: self
    }.

    public method addBasicBlock: (basicBlock: SSABasicBlock) ::=> Void
        := self addBasicBlock: basicBlock before: nil.

    public method addFirstBasicBlock: (basicBlock: SSABasicBlock) ::=> Void
        := self addBasicBlock: basicBlock after: nil.

    public method basicBlocksDo: aBlock ::=> Void := {
        let position mutable := firstBasicBlock.
        while: position isNotNil do: {
            let nextPosition := position nextBlock.
            aBlock(position).
            position := nextPosition
        }
    }.

    public method localValuesDo: aBlock ::=> Void := {
        arguments do: aBlock.
        captures do: aBlock.
        self basicBlocksDo: {:basicBlock :: Void |
            aBlock(basicBlock).
            basicBlock instructionsDo: aBlock
        }.
    }.

    public method allLocalValues ::=> Array := {
        let result := ArrayList new.
        self localValuesDo: {:(SSAFunctionLocalValue)localValue :: Void |
            result add: localValue
        }.
        result asArray
    }.

    public method enumerateLocalValueIndices => Void := {
        let index mutable := 0sz.
        self localValuesDo: {:localValue :: Void |
            localValue localValueIndex: index.
            index := index + 1sz
        }
    }.

    public method computeControlFlowAndNormalizeBasicBlocks => Void := {
        self basicBlocksDo: {:(SSABasicBlock)basicBlock :: Void |
            basicBlock
                computeSuccessors;
                resetPredecessors;
                markWhite.
        }.

        self firstBasicBlock ifNotNil: {:(SSABasicBlock)entryBlock :: Void |
            self traverseBasicBlockForLiveness: entryBlock from: nil
        }.

        self basicBlocksDo: {:(SSABasicBlock)eachBasicBlock :: Void |
            if: eachBasicBlock isBlack then: {
                eachBasicBlock normalizePhiInstructions
            } else: {
                self assert: eachBasicBlock isWhite.
                self removeBasicBlock: eachBasicBlock
            }
        }.

        self basicBlocksDo: {:(SSABasicBlock)eachBasicBlock :: Void |
            eachBasicBlock fixCriticalEdges
        }.
    }.

    public method traverseBasicBlockForLiveness: (basicBlock: SSABasicBlock) from: (predecessor: SSABasicBlock) ::=> Void := {
        predecessor ifNotNil: {
            basicBlock addPredecessor: predecessor isBackEdge: basicBlock isGray.
        }.

        if: basicBlock isWhite then: {
            basicBlock markGray.
            basicBlock successors do: {:(SSABasicBlock)eachSuccessor :: Void|
                self traverseBasicBlockForLiveness: eachSuccessor from: basicBlock
            }.

            basicBlock markBlack.
        }.
    }.

    public method removeBasicBlock: (basicBlock: SSABasicBlock) ::=> Void := {
        self assert: basicBlock parent == self.

        let previousBlock := basicBlock previousBlock.
        let nextBlock := basicBlock nextBlock.

        previousBlock ifNotNil: {
            previousBlock nextBlock: nextBlock
        } ifNil: {
            self firstBasicBlock: nextBlock
        }.

        nextBlock ifNotNil: {
            nextBlock previousBlock: previousBlock
        } ifNil: {
            self lastBasicBlock: previousBlock
        }.

        basicBlock
            parent: nil;
            previousBlock: nil;
            nextBlock: nil
    }.

    public method postCopy => Void := {
        super postCopy.

        let oldLocalValues := self allLocalValues.

        self arguments: (self arguments collect: {:(SSAFunctionArgument)each | each copy}).
        self captures: (self captures collect: {:(SSAFunctionCapture)each | each copy}).

        let nextBasicBlockToAdd mutable := firstBasicBlock.
        firstBasicBlock := nil.
        lastBasicBlock := nil.

        while: nextBasicBlockToAdd ~~ nil do: {
            self addBasicBlock: nextBasicBlockToAdd copy
        } continueWith: (nextBasicBlockToAdd := nextBasicBlockToAdd nextBlock).

        ## Construct a replacement dictionary.
        let newLocalValues := self allLocalValues.
        self assert: oldLocalValues size = newLocalValues size.

        let replacementDictionary := Dictionary new.
        oldLocalValues doWithIndex: {:(SSAFunctionLocalValue)oldValue :(Size)index :: Void |
            let newValue := newLocalValues at: index.
            replacementDictionary at: oldValue put: newValue
        }.

        self localValuesDo: {:(SSAFunctionLocalValue)each :: Void |
            each
                replaceUsedValuesWith: replacementDictionary;
                registerInUsedValues
        }.
    }.

    public method printOn: (stream: Stream) ::=> Void := {
        stream nextPut: '%'.
        self name ifNotNil: {:name :: Void |
            stream print: self name
        }.

        self sourcePosition ifNotNil: {:sourcePosition :: Void |
            self name ifNotNil: (stream space).
            stream nextPutAll: "at "; print: sourcePosition
        }.
    }.

    public method fullPrintOn: (stream: Stream) ::=> Void := {
        self enumerateLocalValueIndices.
        self printOn: stream.
        
        stream nextPut: '('.
        self arguments doWithIndex: {:(SSAFunctionArgument)argument :(Size)index :: Void |
            index > 0sz ifTrue: (stream nextPutAll: ", ").
            stream print: argument
        }.
        stream nextPut: ')'.
        stream nextPut: '['.
        self captures doWithIndex: {:(SSAFunctionCapture)capture :(Size)index :: Void |
            index > 0sz ifTrue: (stream nextPutAll: ", ").
            stream print: capture
        }.
        stream nextPut: ']'.

        stream nextPutAll: " := {"; nl.
        self basicBlocksDo: {:(SSABasicBlock)basicBlock :: Void |
            basicBlock fullPrintOn: stream
        }.
        stream nextPutAll: "}"; nl.
    }.

    public method computeBasicBlockPredecessors => Void := {
        self basicBlocksDo: {:(SSABasicBlock)each :: Void |
        }.
    }.
}.

SSAFunctionLocalValue definition: {
    public field name.
    public field localValueIndex => Size.

    public method initialize => Void := {
        super initialize.
        self localValueIndex: 0sz
    }.

    public method isFunctionLocalValue => Boolean := true.

    public method printOn: (stream: Stream) ::=> Void := {
        stream nextPut: '$'; print: self localValueIndex.

        self name ifNotNil: {:name |
            stream nextPut: ':'; nextPutAll: self name.
        }.
        self type ifNotNil: {:type |
            stream nextPutAll: " => "; print: self type.
        }.
    }.
}.

SSABasicBlock definition: {
    public field parent => SSAFunctionDefinition.

    public field previousBlock => SSABasicBlock.
    public field nextBlock => SSABasicBlock.

    public field firstInstruction => SSAInstruction.
    public field lastInstruction => SSAInstruction.

    public field traversalColor => UInt8.
    public field predecessors => ArrayList.
    public field predecessorKinds => ArrayList.
    public field successors => Array.

    public method isBasicBlock => Boolean := true.

    public method markWhite => Void := {
        self traversalColor: 0u8
    }.

    public method isWhite => Boolean := self traversalColor == 0u8.

    public method markGray => Void := {
        self traversalColor: 1u8
    }.

    public method isGray => Boolean := self traversalColor == 1u8.

    public method markBlack => Void := {
        self traversalColor: 2u8
    }.

    public method isBlack => Boolean := self traversalColor == 2u8.

    public method resetPredecessors => Void := {
        self predecessors: ArrayList new.
        self predecessorKinds: ArrayList new.
    }.

    public method addPredecessor: (predecessor: SSABasicBlock) isBackEdge: (isBackEdge: Boolean) ::=> Void := {
        self predecessors add: predecessor.
        self predecessorKinds add: isBackEdge.
    }.

    public method addInstruction: (instruction: SSAInstruction) before: (position: SSAInstruction) ::=> Void := {
        self assert: instruction parent isNil.

        let before := position ifNotNil: position previousInstruction ifNil: lastInstruction.
        let after := position.

        before ifNotNil: {
            before nextInstruction: instruction.
            instruction previousInstruction: before.
        } ifNil: {
            firstInstruction := instruction
        }.

        after ifNotNil: {
            after previousInstruction: instruction.
            instruction nextInstruction: after
        } ifNil: {
            lastInstruction := instruction
        }.

        instruction parent: self
    }.

    public method addInstruction: (instruction: SSAInstruction) after: (position: SSAInstruction) ::=> Void := {
        self assert: instruction parent isNil.

        let before := position .
        let after := position ifNotNil: position nextInstruction ifNil: firstInstruction.

        before ifNotNil: {
            before nextInstruction: instruction.
            instruction previousInstruction: before.
        } ifNil: {
            firstInstruction := instruction
        }.

        after ifNotNil: {
            after previousInstruction: instruction.
            instruction nextInstruction: after
        } ifNil: {
            lastInstruction := instruction
        }.

        instruction parent: self
    }.

    public method addInstruction: (instruction: SSAInstruction) ::=> Void
        := self addInstruction: instruction before: nil.

    public method addFirstInstruction: (instruction: SSAInstruction) ::=> Void
        := self addInstruction: instruction after: nil.

    public method instructionsDo: aBlock ::=> Void := {
        let position mutable := firstInstruction.
        while: position isNotNil do: {
            let nextPosition := position nextInstruction.
            aBlock(position).
            position := nextPosition
        }
    }.

    public method firstAllocaInstructionsDo: aBlock ::=> Void := {
        let position mutable := firstInstruction.
        while: position isNotNil && position isAllocaInstruction do: {
            let nextPosition := position nextInstruction.
            aBlock(position).
            position := nextPosition
        }
    }.

    public method findAllocaInsertionPoint => SSAInstruction := {
        let position mutable := firstInstruction.
        while: position isNotNil && position isAllocaInstruction do: (
            position := position nextInstruction
        ).

        position
    }.

    public method findPhiLoadInsertionPoint => SSAInstruction := {
        let position mutable := firstInstruction.
        while: position isNotNil && position isPhiInstruction do: (
            position := position nextInstruction
        ).

        position
    }.

    public method phiInstructionsDo: aBlock ::=> Void := {
        let position mutable := firstInstruction.
        while: position isNotNil && position isPhiInstruction do: {
            let nextPosition := position nextInstruction.
            aBlock(position).
            position := nextPosition
        }
    }.

    public method normalizePhiInstructions => Void := {
        let predecessors := self predecessors.
        self phiInstructionsDo: {:(SSAPhiInstruction)phi :: Void |
            let newIncomingBlocksAndValues := predecessors collect: {:(SSABasicBlock)eachRequiredPredecessor :: Association |
                (phi findIncomingBlockAndValueFor: eachRequiredPredecessor)
                    ifNotNil: {:(Association)found | found }
                    ifNil: { eachRequiredPredecessor -> (SSAUndefinedConstant new type: phi type; yourself) }.
            } as: Array.

            phi incomingBlocksAndValues: newIncomingBlocksAndValues
        }.
    }.

    public method fixCriticalEdges => Void := {
        ## We require at least two predecessors in order for having a critical edge.
        if: self predecessors size > 1sz then: {
            self predecessors doWithIndex: {:(SSABasicBlock)predecessor :(Size)predecessorIndex :: Void |
                if: predecessor successors size > 1sz then: {
                    self fixCriticalEdge: predecessor index: predecessorIndex.
                }
            }
        }.
    }.

    public method fixCriticalEdge: (incomingBlock: SSABasicBlock) index: (incomingBlockIndex: Size) ::=> Void := {
        self assert: self predecessors size > 1sz.
        self assert: incomingBlock successors size > 1sz.
        self assert: incomingBlock lastInstruction isTerminatorInstruction.

        let builder := SSAInstructionBuilder new
            function: incomingBlock parent;
            useSourceInformationOfValue: incomingBlock lastInstruction;
            yourself.
        
        let intermediateBlock := builder newBasicBlockNamed: #criticalEdge.
        intermediateBlock
            traversalColor: incomingBlock traversalColor;
            successors: (Array with: self);
            resetPredecessors;
            addPredecessor: incomingBlock isBackEdge: (self predecessorKinds at: incomingBlockIndex).

        incomingBlock parent addBasicBlock: intermediateBlock after: incomingBlock.
        builder
            beginInsertingInBasicBlock: intermediateBlock;
            branch: self.
        
        incomingBlock lastInstruction replaceDestination: self with: intermediateBlock.
        incomingBlock replaceSuccessor: self with: incomingBlock.
        self predecessors at: incomingBlockIndex put: intermediateBlock.

        self phiInstructionsDo: {:(SSAPhiInstruction)each :: Void |
            each replaceIncomingBlock: incomingBlock with: intermediateBlock
        }
    }.

    public method removeInstruction: (instruction: SSAInstruction) ::=> Void := {
        self assert: instruction parent == self.

        let previousInstruction := instruction previousInstruction.
        let nextInstruction := instruction nextInstruction.

        previousInstruction ifNotNil: {
            previousInstruction nextInstruction: nextInstruction
        } ifNil: {
            firstInstruction := nextInstruction
        }.

        nextInstruction ifNotNil: {
            nextInstruction previousInstruction: previousInstruction
        } ifNil: {
            lastInstruction := previousInstruction
        }.

        instruction
            parent: nil;
            previousInstruction: nil;
            nextInstruction: nil
    }.

    public method replaceSuccessor: (oldSuccessor: SSABasicBlock) with: (newSuccessor: SSABasicBlock) ::=> Void := {
        self successors doWithIndex: {:(SSABasicBlock)eachSuccessor :(Size)index :: Void |
            if: eachSuccessor = oldSuccessor then: (self successors at: index put: newSuccessor)
        }
    }.

    public method computeSuccessors => Void := {
        self successors: self lastInstruction successors
    }.

    public method postCopy => Void := {
        super postCopy.
        self parent: nil.

        let nextInstructionToAdd mutable => SSAInstruction := self firstInstruction.
        self firstInstruction: nil.
        self lastInstruction: nil.

        while: nextInstructionToAdd ~~ nil do: {
            self addInstruction: nextInstructionToAdd copy
        } continueWith: (nextInstructionToAdd := nextInstructionToAdd nextInstruction)
    }.

    public method replaceWith: (replacement: SSAValue) ::=> Void := {
        super replaceWith: replacement.
        self parent ifNotNil: {:parent :: Void | parent removeBasicBlock: self }
    }.

    public method fullPrintOn: (stream: Stream) ::=> Void := {
        self printOn: stream.
        stream nextPutAll: ":".
        if: (self predecessors ~~ nil) && self predecessors isNotEmpty then: {
            stream nextPutAll: " ## Predecessors".
            self predecessors do: {:(SSABasicBlock)each :: Void |
                stream nextPut: ' '; print: each
            }
        }.

        stream nl.
        self instructionsDo: {:(SSAInstruction)instruction :: Void |
            stream nextPutAll: "    ".
            instruction fullPrintOn: stream.
            stream nl.
        }.
    }.
}.

SSAInstruction definition: {
    public field parent => SSABasicBlock.

    public field previousInstruction => SSAInstruction.
    public field nextInstruction => SSAInstruction.

    public method parentFunction => SSAFunctionDefinition
        := self parent ifNil: nil ifNotNil: {:(SSABasicBlock)parentBlock | parentBlock parent }.

    public method isInstruction => Boolean := true.

    public method postCopy => Void := {
        super postCopy.
        parent := nil.
        previousInstruction := nil.
        nextInstruction := nil.
    }.

    public method replaceWith: (replacement: SSAValue) ::=> Void := {
        super replaceWith: replacement.
        parent ifNotNil: {parent removeInstruction: self }
    }.

    public method replaceDestination: (oldDestination: SSABasicBlock) with: (newDestination: SSABasicBlock) ::=> Void
        := self error: "Not a branch instruction.".

    public method successors => Array
        := self error: "Non terminator instruction is present at the end of a basic block " -- self fullPrintString
}.

public final class SSAAllocaInstruction superclass: SSAInstruction; definition: {
    public field valueType => SSAValue.

    public method isAllocaInstruction => Boolean := true.

    public method fullPrintOn: (stream: Stream) ::=> Void
        := stream print: self; nextPutAll: " := alloca: "; print: self valueType.

    public method usedValuesDo: aBlock ::=> Void := {
        aBlock(self valueType)
    }.

    public method replaceUsedValue: replacedValue with: replacement ::=> Void := {
        if: self valueType = replacedValue then: (self valueType: replacement)
    }.

    public method replaceUsedValuesWith: (replacementDictionary: Dictionary) ::=> Void := {
        replacementDictionary at: self valueType ifPresent: {:(SSAValue)replacement :: Void | self valueType: replacement}.
    }.
}.

public final class SSABranchInstruction superclass: SSAInstruction; definition: {
    public field destination => SSABasicBlock.

    public method isTerminatorInstruction => Boolean := true.

    public method successors => Array
        := Array with: self destination.

    public method fullPrintOn: (stream: Stream) ::=> Void
        := stream nextPutAll: "branch: "; print: self destination.

    public method usedValuesDo: aBlock ::=> Void := {
        aBlock(self destination).
    }.

    public method replaceUsedValue: replacedValue with: replacement ::=> Void := {
        if: self destination = replacedValue then: (self destination: replacement)
    }.

    public method replaceDestination: (oldDestination: SSABasicBlock) with: (newDestination: SSABasicBlock) ::=> Void := {
        if: self destination = oldDestination then: (self destination: newDestination)
    }.

    public method replaceUsedValuesWith: (replacementDictionary: Dictionary) ::=> Void := {
        replacementDictionary at: self destination ifPresent: {:(SSABasicBlock)replacement :: Void | self destination: replacement}.
    }.
}.

public final class SSACallInstruction superclass: SSAInstruction; definition: {
    public field calledFunction => SSAValue.
    public field arguments => Array.
    public field isUnchecked => Boolean.

    public method fullPrintOn: (stream: Stream) ::=> Void := {
        stream
            print: self; nextPutAll: " := ";
            nextPutAll: "call "; print: self calledFunction.
        self arguments do: {:(SSAValue)argument :: Void |
            stream nextPutAll: ", ".
            stream print: argument
        }
    }.

    public method usedValuesDo: aBlock ::=> Void := {
        aBlock(self calledFunction).
        arguments do: aBlock
    }.

    public method replaceUsedValue: replacedValue with: replacement ::=> Void := {
        if: calledFunction = replacedValue then: (calledFunction := replacement).
        arguments replaceAll: replacedValue with: replacement
    }.

    public method replaceUsedValuesWith: (replacementDictionary: Dictionary) ::=> Void := {
        replacementDictionary at: self calledFunction ifPresent: {:(SSAValue)replacement :: Void | self calledFunction: replacement}.
        arguments replaceAllWithDictionary: replacementDictionary
    }.
}.

public final class SSACoerceValueInstruction superclass: SSAInstruction; definition: {
    public field value => SSAValue.
    public field targetType => SSAValue.

    public method fullPrintOn: (stream: Stream) ::=> Void
        := stream print: self; nextPutAll: " := coerceValue: "; print: self value;
            nextPut: ' '; print: self targetType.

    public method usedValuesDo: aBlock ::=> Void := {
        aBlock(self value).
        aBlock(self targetType).
    }.

    public method replaceUsedValue: replacedValue with: replacement ::=> Void := {
        if: self value = replacedValue then: (self value: replacement).
        if: self targetType = replacedValue then: (self targetType: replacement).
    }.

    public method replaceUsedValuesWith: (replacementDictionary: Dictionary) ::=> Void := {
        replacementDictionary at: self value ifPresent: {:(SSAValue)replacement :: Void | self value: replacement}.
        replacementDictionary at: self targetType ifPresent: {:(SSAValue)replacement :: Void | self targetType: replacement}.
    }.
}.

public final class SSAConditionalBranchInstruction superclass: SSAInstruction; definition: {
    public field condition => SSAValue.
    public field trueDestination => SSABasicBlock.
    public field falseDestination => SSABasicBlock.

    public method isTerminatorInstruction => Boolean := true.

    public method successors => Array
        := Array with: self trueDestination with: self falseDestination.

    public method fullPrintOn: (stream: Stream) ::=> Void
        := stream nextPutAll: "condBranch: "; print: self condition;
            nextPut: ' '; print: self trueDestination;
            nextPut: ' '; print: self falseDestination.

    public method usedValuesDo: aBlock ::=> Void := {
        aBlock(self condition).
        aBlock(self trueDestination).
        aBlock(self falseDestination).
    }.

    public method replaceUsedValue: replacedValue with: replacement ::=> Void := {
        if: self condition = replacedValue then: (self condition: replacement).
        if: self trueDestination = replacedValue then: (self trueDestination: replacement).
        if: self falseDestination = replacedValue then: (self falseDestination: replacement).
    }.

    public method replaceUsedValuesWith: (replacementDictionary: Dictionary) ::=> Void := {
        replacementDictionary at: self condition ifPresent: {:(SSAValue)replacement :: Void | self condition: replacement}.
        replacementDictionary at: self trueDestination ifPresent: {:(SSABasicBlock)replacement :: Void | self trueDestination: replacement}.
        replacementDictionary at: self falseDestination ifPresent: {:(SSABasicBlock)replacement :: Void | self falseDestination: replacement}.
    }.

    public method replaceDestination: (oldDestination: SSABasicBlock) with: (newDestination: SSABasicBlock) ::=> Void := {
        if: self trueDestination = oldDestination then: (self trueDestination: newDestination).
        if: self falseDestination = oldDestination then: (self falseDestination: newDestination)
    }.
}.

public final class SSALoadInstruction superclass: SSAInstruction; definition: {
    public field storage => SSAValue.

    public method isLoadInstruction => Boolean := true.

    public method fullPrintOn: (stream: Stream) ::=> Void := {
        stream print: self; nextPutAll: " := load "; print: self storage
    }.

    public method usedValuesDo: aBlock ::=> Void := {
        aBlock(self storage).
    }.

    public method replaceUsedValue: replacedValue with: replacement ::=> Void := {
        if: self storage = replacedValue then: (self storage: replacement).
    }.

    public method replaceUsedValuesWith: (replacementDictionary: Dictionary) ::=> Void := {
        replacementDictionary at: self storage ifPresent: {:(SSAValue)replacement :: Void | self storage: replacement}.
    }.
}.

public final class SSAMakeClosureInstruction superclass: SSAInstruction; definition: {
    public field functionDefinition => SSAValue.
    public field captures => Array.

    public method fullPrintOn: (stream: Stream) ::=> Void := {
        stream print: self; nextPutAll: " := makeClosure "; print: self functionDefinition.
        self captures do: {:(SSAValue)capture :: Void |
            stream nextPutAll: ", "; print: capture
        }
    }.

    public method usedValuesDo: aBlock ::=> Void := {
        aBlock(self functionDefinition).
        self captures do: aBlock
    }.

    public method replaceUsedValue: replacedValue with: replacement ::=> Void := {
        if: self functionDefinition = replacedValue then: (self functionDefinition: replacement).
        self captures replaceAll: replacedValue with: replacement
    }.

    public method replaceUsedValuesWith: (replacementDictionary: Dictionary) ::=> Void := {
        replacementDictionary at: self functionDefinition ifPresent: {:(SSAValue)replacement :: Void | self functionDefinition: replacement}.
        self captures replaceAllWithDictionary: replacementDictionary
    }.
}.

SSAPhiInstruction definition: {
    public field incomingBlocksAndValues => Array.

    public method isPhiInstruction => Boolean := true.

    public method initialize => Void := {
        super initialize.
        self incomingBlocksAndValues: #().
    }.

    public method fullPrintOn: (stream: Stream) ::=> Void := {
        stream print: self; nextPutAll: " := phi ["; nl.
        self incomingBlocksAndValues do: {:(Association)blockAndValue :: Void |
            stream nextPutAll: "        "; print: blockAndValue value; nextPutAll: " from "; print: blockAndValue key; nl 
        }.

        stream nextPutAll: "    ]"
    }.

    public method addValue: (value: SSAValue) incomingFrom: (block: SSABasicBlock) ::=> Void := {
        self incomingBlocksAndValues: self incomingBlocksAndValues -- (Array with: block -> value).
    }.

    public method findIncomingBlockAndValueFor: (expectedBlock: SSABasicBlock) ::=> Association
        := self incomingBlocksAndValues detect: {:(Association)each | each key = expectedBlock } ifNone: {: nil}.

    public method incomingBlocksAndValuesDo: aBlock ::=> Void := {
        self incomingBlocksAndValues do: {:(Association)blockAndValue :: Void |
            aBlock(blockAndValue key, blockAndValue value)
        }
    }.

    public method usedValuesDo: aBlock ::=> Void := {
        self incomingBlocksAndValues do: {:(Association)association :: Void |
            aBlock(association key).
            aBlock(association value).
        }
    }.

    public method replaceUsedValue: replacedValue with: replacement ::=> Void := {
        self incomingBlocksAndValues do: {:(Association)association :: Void |
            if: association key = replacedValue then: (association key: replacement).
            if: association value = replacedValue then: (association value: replacement).
        }
    }.

    public method replaceUsedValuesWith: (replacementDictionary: Dictionary) ::=> Void := {
        self incomingBlocksAndValues do: {:(Association)association :: Void |
            replacementDictionary at: association key ifPresent: {:(SSAValue)replacement :: Void | association key: replacement}.
            replacementDictionary at: association value ifPresent: {:(SSAValue)replacement :: Void | association value: replacement}.
        }
    }.

    public method replaceIncomingBlock: (oldIncomingBlock: SSABasicBlock) with: (newIncomingBlock: SSABasicBlock) ::=> Void := {
        self incomingBlocksAndValues do: {:(Association)association :: Void |
            if: association key = oldIncomingBlock then: (association key: newIncomingBlock).
        }
    }.
}.

public final class SSAReturnInstruction superclass: SSAInstruction; definition: {
    public field value => SSAValue.

    public method isTerminatorInstruction => Boolean := true.

    public method successors => Array
        := #().

    public method fullPrintOn: (stream: Stream) ::=> Void
        := stream nextPutAll: "return: "; print: self value.

    public method usedValuesDo: aBlock ::=> Void := {
        aBlock(self value)
    }.

    public method replaceUsedValue: replacedValue with: replacement ::=> Void := {
        if: self value = replacedValue then: (self value: replacement)
    }.

    public method replaceUsedValuesWith: (replacementDictionary: Dictionary) ::=> Void := {
        replacementDictionary at: self value ifPresent: {:(SSAValue)replacement :: Void | self value: replacement}.
    }.
}.

public final class SSASendInstruction superclass: SSAInstruction; definition: {
    public field receiver => SSAValue.
    public field receiverLookupType => SSAValue.
    public field selector => SSAValue.
    public field arguments => Array.

    public method fullPrintOn: (stream: Stream) ::=> Void := {
        stream
            print: self; nextPutAll: " := ";
            nextPutAll: "send "; print: self receiver.
        self receiverLookupType ifNotNil: {:(SSAValue)receiverLookupType :: Void |
            stream nextPutAll: " lookupFrom: "; print: self receiverLookupType.
        }.

        stream nextPutAll: ", "; print: self selector.

        self arguments doWithIndex: {:(SSAValue)argument :(Size)index :: Void |
            index = 0sz
                ifTrue: (stream nextPut: ' ')
                ifFalse: (stream nextPutAll: ", ").
            stream print: argument
        }
    }.

    public method usedValuesDo: aBlock ::=> Void := {
        aBlock(self receiver).
        if: self receiverLookupType ~~ nil then: aBlock(self receiverLookupType).
        aBlock(self selector).
        self arguments do: aBlock
    }.

    public method replaceUsedValue: replacedValue with: replacement ::=> Void := {
        if: self receiver = replacedValue then: (self receiver: replacement).
        if: self receiverLookupType = replacedValue then: (self receiverLookupType: replacement).
        if: self selector = replacedValue then: (self selector: replacement).
        self arguments replaceAll: replacedValue with: replacement
    }.

    public method replaceUsedValuesWith: (replacementDictionary: Dictionary) ::=> Void := {
        replacementDictionary at: self receiver ifPresent: {:(SSAValue)replacement :: Void | self receiver: replacement}.
        replacementDictionary at: self receiverLookupType ifPresent: {:(SSAValue)replacement :: Void | self receiverLookupType: replacement}.
        replacementDictionary at: self selector ifPresent: {:(SSAValue)replacement :: Void | self selector: replacement}.
        self arguments replaceAllWithDictionary: replacementDictionary
    }.
}.

public final class SSAStoreInstruction superclass: SSAInstruction; definition: {
    public field storage => SSAValue.
    public field value => SSAValue.

    public method isStoreInstruction => Boolean := true.

    public method fullPrintOn: (stream: Stream) ::=> Void := {
        stream nextPutAll: "store "; print: self value; nextPutAll: " in "; print: self storage
    }.

    public method usedValuesDo: aBlock ::=> Void := {
        aBlock(self storage).
        aBlock(self value).
    }.

    public method replaceUsedValue: replacedValue with: replacement ::=> Void := {
        if: self storage = replacedValue then: (self storage: replacement).
        if: self value = replacedValue then: (self value: replacement).
    }.

    public method replaceUsedValuesWith: (replacementDictionary: Dictionary) ::=> Void := {
        replacementDictionary at: self storage ifPresent: {:(SSAValue)replacement :: Void | self storage: replacement}.
        replacementDictionary at: self value ifPresent: {:(SSAValue)replacement :: Void | self value: replacement}.
    }.
}.

public final class SSAUnreachableInstruction superclass: SSAInstruction; definition: {
    public method isUnreachableInstruction => Boolean := true.

    public method isTerminatorInstruction => Boolean := true.

    public method successors => Array
        := #().

    public method fullPrintOn: (stream: Stream) ::=> Void
        := stream nextPutAll: "unreachable".
}.

SSAInstructionBuilder definition: {
    public field sourcePosition => SourcePosition.
    public field sourceASTNode => ASTNode.
    public field sourceEnvironment => Environment.

    public field function => SSAFunctionDefinition.
    public field basicBlock => SSABasicBlock.
    public field insertionPoint => SSAInstruction.

    __Meta__ definition: {
        public method for: (function: SSAFunctionDefinition)
            := self new function: function; yourself.
    }.

    public method newBasicBlockNamed: name ::=> SSABasicBlock := {
        let newBasicBlock := SSABasicBlock new
            name: name;
            sourcePosition: self sourcePosition;
            sourceASTNode: self sourceASTNode;
            sourceEnvironment: self sourceEnvironment;
            yourself.
        newBasicBlock
    }.

    public method beginBasicBlock: (newBasicBlock: SSABasicBlock) ::=> SSABasicBlock := {
        self basicBlock: newBasicBlock.
        self insertionPoint: nil.
        self function addBasicBlock: newBasicBlock.
        newBasicBlock
    }.

    public method beginInsertingInBasicBlock: (newBasicBlock: SSABasicBlock) ::=> SSABasicBlock := {
        self function: newBasicBlock parent.
        self basicBlock: newBasicBlock.
        self insertionPoint: nil.
        newBasicBlock
    }.

    public method beginBasicBlockNamed: name ::=> SSABasicBlock
        := self beginBasicBlock: (self newBasicBlockNamed: name).

    public method addInstruction: (instruction: SSAInstruction) ::=> instruction __type__ := {
        instruction
            sourcePosition: self sourcePosition;
            sourceASTNode: self sourceASTNode;
            sourceEnvironment: self sourceEnvironment.
        self basicBlock addInstruction: instruction before: self insertionPoint.
        instruction
    }.

    public method useSourceInformationOfValue: (value: SSAValue) ::=> Void := {
        self sourcePosition: value sourcePosition.
        self sourceASTNode: value sourceASTNode.
        self sourceEnvironment: value sourceEnvironment.
    }.

    public method withSourcePosition: (sourcePosition: SourcePosition) do: aBlock := {
        let oldPosition := self sourcePosition.
        self sourcePosition: sourcePosition.
        let result := aBlock().
        self sourcePosition: oldPosition.
        result
    }.

    public method withSourceASTNode: (sourceASTNode: ASTNode) do: aBlock := {
        let oldSourceASTNode := self sourceASTNode.
        self sourceASTNode: sourceASTNode.
        let result := self withSourcePosition: sourceASTNode sourcePosition do: aBlock.
        self sourceASTNode: oldSourceASTNode.
        result
    }.

    public method withSourceEnvironment: (sourceEnvironment: Environment) do: aBlock := {
        let oldSourceEnvironment := self sourceEnvironment.
        self sourceEnvironment: sourceEnvironment.
        let result := aBlock().
        self sourceEnvironment: oldSourceEnvironment.
        result
    }.

    public method alloca: (valueType: SSAValue) type: (type: Type) ::=> SSAAllocaInstruction
        := self addInstruction: (SSAAllocaInstruction new
            valueType: valueType;
            type: type;
            registerInUsedValues;
            yourself).

    public method branch: (destination: SSABasicBlock) ::=> SSABranchInstruction
        := self addInstruction: (SSABranchInstruction new
            destination: destination;
            type: Void;
            registerInUsedValues;
            yourself).

    public method call: (calledFunction: SSAValue) arguments: (arguments: Array) resultType: (resultType: Type) ::=> SSACallInstruction
        := self addInstruction: (SSACallInstruction new
            calledFunction: calledFunction;
            arguments: arguments;
            type: resultType;
            registerInUsedValues;
            yourself).

    public method call: (receiver: SSAValue) arguments: (arguments: Array) ::=> SSACallInstruction
        := self call: receiver arguments: arguments resultType: nil.

    public method coerceValue: (value: SSAValue) into: (targetType: SSAValue) type: (type: Type) ::=> SSAValue := {
        (targetType == nil) || (targetType isLiteralConstant && (value type == (targetType downCastTo: SSALiteralConstant) value)) ifTrue: {
            value
        } ifFalse: {
            self addInstruction: (SSACoerceValueInstruction new
                value: value;
                targetType: targetType;
                type: type;
            registerInUsedValues;
                yourself)
        }.
    }.

    public method conditionalBranch: (condition: SSAValue) trueDestination: (trueDestination: SSABasicBlock) falseDestination: (falseDestination: SSABasicBlock) ::=> SSAConditionalBranchInstruction
        := self addInstruction: (SSAConditionalBranchInstruction new
            condition: condition;
            trueDestination: trueDestination;
            falseDestination: falseDestination;
            type: Void;
            registerInUsedValues;
            yourself).

    public method literal: value type: (type: Type) ::=> SSALiteralConstant
        := SSALiteralConstant new
            sourcePosition: self sourcePosition;
            sourceASTNode: self sourceASTNode;
            sourceEnvironment: self sourceEnvironment;
            value: value;
            type: type;
            yourself.

    public method literal: value ::=> SSALiteralConstant
        := self literal: value type: value __type__.

    public method load: (storage: SSAValue) type: (type: Type) ::=> SSALoadInstruction
        := self addInstruction: (SSALoadInstruction new
            storage: storage;
            type: type;
            registerInUsedValues;
            yourself).

    public method makeClosure: (functionDefinition: SSAValue) captures: (captures: Array) type: (type: Type) ::=> SSAMakeClosureInstruction
        := self addInstruction: (SSAMakeClosureInstruction new
            functionDefinition: functionDefinition;
            captures: captures;
            type: type;
            registerInUsedValues;
            yourself).

    public method phi: (type: Type) ::=> SSAPhiInstruction
        := self addInstruction: (SSAPhiInstruction new
            type: type;
            registerInUsedValues;
            yourself).

    public method return: (value: SSAValue) ::=> SSAReturnInstruction
        := self addInstruction: (SSAReturnInstruction new
            type: Void;
            value: value;
            registerInUsedValues;
            yourself).

    public method returnVoid ::=> SSAReturnInstruction
        := self return: (self literal: void).

    public method send: (receiver: SSAValue) receiverLookupType: (receiverLookupType: SSAValue) selector: (selector: SSAValue) arguments: (arguments: Array) resultType: (resultType: Type) ::=> SSASendInstruction
        := self addInstruction: (SSASendInstruction new
            receiver: receiver;
            receiverLookupType: receiverLookupType;
            selector: selector;
            arguments: arguments;
            type: resultType;
            registerInUsedValues;
            yourself).

    public method send: (receiver: SSAValue) selector: (selector: SSAValue) arguments: (arguments: Array) resultType: (resultType: Type) ::=> SSASendInstruction
        := self send: receiver receiverLookupType: nil selector: selector arguments: arguments resultType: resultType.

    public method send: (receiver: SSAValue) selector: (selector: SSAValue) arguments: (arguments: Array) ::=> SSASendInstruction
        := self send: receiver receiverLookupType: nil selector: selector arguments: arguments resultType: nil.

    public method store: (value: SSAValue) in: (storage: SSAValue) ::=> SSAStoreInstruction
        := self addInstruction: (SSAStoreInstruction new
            value: value;
            storage: storage;
            registerInUsedValues;
            yourself).

    public method lastInstruction => SSAInstruction
        := self basicBlock ifNotNil: {:basicBlock :: SSAInstruction | basicBlock lastInstruction }.

    public method isLastTerminator => Boolean
        := self lastInstruction
            ifNil: false
            ifNotNil: {:instruction :: Boolean | instruction isTerminatorInstruction }.
}.
