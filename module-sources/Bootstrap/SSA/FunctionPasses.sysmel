public class SSAFunctionPass superclass: Object; definition: {
    __Meta__ definition:{
        public method runIn: (function: SSAFunctionDefinition) ::=> SSAFunctionPass
            := self new runIn: function; yourself
    }.

    public abstract method runIn: (function: SSAFunctionDefinition) ::=> Void
        := self subclassResponsibility.
}.

SSAFunction extend: {
    public method runPasses: passes ::=> Void := {
        self definition ifNotNil: {:definition |
            definition runPasses: passes
        }.
    }.
}.

SSAFunctionDefinition extend: {
    public method runPasses: passes ::=> Void := {
        passes do: {:(SSAFunctionPass)each :: Void | each runIn: self }
    }.
}.

## Promote alloca
public class SSAPromoteAllocaPass superclass: SSAFunctionPass; definition: {
    public override method runIn: (function: SSAFunctionDefinition) ::=> Void := {
        printLine("TODO: SSAPromoteAllocaPass")
    }.
}.

## Destroy SSA pass. This pass destroys the phi nodes by inserting alloca instructions.
public class SSADestroySSAFunctionPass superclass: SSAFunctionPass; definition: {
    public override method runIn: (function: SSAFunctionDefinition) ::=> Void := {
        function firstBasicBlock ifNil: (return: void).
        function
            computeControlFlowAndNormalizeBasicBlocks.

        let allocaBuilder := SSAInstructionBuilder new
            beginInsertingInBasicBlock: function firstBasicBlock;
            insertionPoint: function firstBasicBlock findAllocaInsertionPoint;
            yourself.

        let storeBuilder := SSAInstructionBuilder new.
        let loadBuilder := SSAInstructionBuilder new.

        function basicBlocksDo: {:(SSABasicBlock)basicBlock :: Void |
            loadBuilder 
                beginInsertingInBasicBlock: basicBlock;
                insertionPoint: basicBlock findPhiLoadInsertionPoint;
                yourself.

            basicBlock phiInstructionsDo: {:(SSAPhiInstruction)phi :: Void |
                allocaBuilder useSourceInformationOfValue: phi.

                let valueType := phi type.
                let pointerType := PointerTypeTemplate(valueType, nil).
                
                let temporary := allocaBuilder alloca: (allocaBuilder literal: valueType) type: pointerType.
                phi incomingBlocksAndValuesDo: {:(SSABasicBlock)incomingBlock :(SSAValue)incomingValue :: Void |
                    storeBuilder
                        beginInsertingInBasicBlock: incomingBlock;
                        insertionPoint: incomingBlock lastInstruction;
                        useSourceInformationOfValue: phi;
                        store: incomingValue in: temporary
                }.

                let load := loadBuilder
                    useSourceInformationOfValue: phi;
                    load: temporary type: valueType.
                phi replaceWith: load.
            }
        }.
    }.
}.
