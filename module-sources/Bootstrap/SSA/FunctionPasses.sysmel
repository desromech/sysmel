public class SSATransformationPass superclass: Object; definition: {
    __Meta__ definition:{
        public method runInModule: (module: SSAModule) ::=> self
            := self new runInModule: module; yourself.

        public method runInFunctionDefinition: (function: SSAFunctionDefinition) ::=> self
            := self new runInFunctionDefinition: function; yourself.
    }.

    public abstract method runInModule: (module: SSAModule) ::=> Void
        := self subclassResponsibility.

    public abstract method runInFunctionDefinition: (function: SSAFunctionDefinition) ::=> Void
        := self subclassResponsibility.
}.

public class SSAFunctionDefinitionPass superclass: SSATransformationPass; definition: {
    public override method runInModule: (module: SSAModule) ::=> Void := {
        module globalValues do: {:(SSAGlobalValue)each :: Void |
            each isFunctionDefinition ifTrue: {
                self runInFunctionDefinition: (each downCastTo: SSAFunctionDefinition)
            }
        }
    }.
}.

SSAModule extend: {
    public method runPasses: passes ::=> Void := {
        passes do: {:(SSATransformationPass)each :: Void | each runInModule: self }
    }.
}.

SSAFunctionDefinition extend: {
    public method runPasses: passes ::=> Void := {
        passes do: {:(SSATransformationPass)each :: Void | each runInFunctionDefinition: self }
    }.
}.

## Promote alloca
public class SSAPromoteAllocaPass superclass: SSAFunctionDefinitionPass; definition: {
    public override method runInFunctionDefinition: (function: SSAFunctionDefinition) ::=> Void := {
        printLine("TODO: SSAPromoteAllocaPass")
    }.
}.

## Destroy SSA pass. This pass destroys the phi nodes by inserting alloca instructions.
public class SSADestroySSAFunctionPass superclass: SSAFunctionDefinitionPass; definition: {
    public override method runInFunctionDefinition: (function: SSAFunctionDefinition) ::=> Void := {
        function firstBasicBlock ifNil: (return: void).
        function
            computeControlFlowAndNormalizeBasicBlocks;
            fixCriticalEdges.

        let allocaBuilder := SSAInstructionBuilder new
            beginInsertingInBasicBlock: function firstBasicBlock;
            insertionPoint: function firstBasicBlock findAllocaInsertionPoint;
            yourself.

        let storeBuilder := SSAInstructionBuilder new.
        let loadBuilder := SSAInstructionBuilder new.

        function basicBlocksDo: {:(SSABasicBlock)basicBlock :: Void |
            loadBuilder 
                beginInsertingInBasicBlock: basicBlock;
                insertionPoint: basicBlock findPhiLoadInsertionPoint;
                yourself.

            basicBlock phiInstructionsDo: {:(SSAPhiInstruction)phi :: Void |
                allocaBuilder useSourceInformationOfValue: phi.

                let valueType := phi type.
                let pointerType := PointerTypeTemplate(valueType, nil).
                
                let temporary := allocaBuilder alloca: (allocaBuilder literal: valueType) type: pointerType.
                phi incomingBlocksAndValuesDo: {:(SSABasicBlock)incomingBlock :(SSAValue)incomingValue :: Void |
                    storeBuilder
                        beginInsertingInBasicBlock: incomingBlock;
                        insertionPoint: incomingBlock lastInstruction;
                        useSourceInformationOfValue: phi;
                        store: incomingValue in: temporary
                }.

                let load := loadBuilder
                    useSourceInformationOfValue: phi;
                    load: temporary type: valueType.
                phi replaceWith: load.
            }
        }.
    }.
}.
