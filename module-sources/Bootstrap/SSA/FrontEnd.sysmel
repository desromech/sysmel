public final class SSAModuleCompilationContext superclass: Object; definition: {
    public field compilationTarget => SSACompilationTarget.
    public field ssaModule => SSAModule.
    public field exclusiveCompilationMode => Boolean.

    protected field translatedValueDictionary => IdentityDictionary.

    __Meta__ extend: {
        public method forTarget: (compilationTarget: SSACompilationTarget) ::=> self
            := self new
                initializeWithTarget: compilationTarget;
                yourself.

        public method forDefaultTarget => self
            := self forTarget: SSACompilationTarget default.
    }.

    public method initializeWithTarget: (theCompilationTarget: SSACompilationTarget) ::=> Void := {
        compilationTarget := theCompilationTarget.
        ssaModule := SSAModule new.
        translatedValueDictionary := IdentityDictionary new.
    }.

    public method compileFunctions: (functions: SequenceableCollection) definitions: (functionDefinitions: SequenceableCollection) ::=> Void := {
        let ssaFunctionDefinitions := functionDefinitions collect: {:(FunctionDefinition)eachFunctionDefinition :: SSAFunctionDefinition |
            self declareFunctionDefinition: eachFunctionDefinition
        }.

        functions do: {:(Function)eachFunction :: Void |
            self declareFunction: eachFunction
        }.

        ssaFunctionDefinitions doWithIndex: {:(SSAFunctionDefinition)eachSSAFunctionDefinition :(Size)index :: Void |
            let eachFunctionDefinition => FunctionDefinition := functionDefinitions at: index.
            self compileFunctionDefinition: eachFunctionDefinition into: eachSSAFunctionDefinition
        }.
    }.

    public method exportMainEntryPointFunction: (entryPointFunction: Function) ::=> Void := {
        let ssaEntryPointFunction => SSAFunction := translatedValueDictionary atOrNil: entryPointFunction.
        ssaEntryPointFunction ifNil: {return: void}.

        ssaEntryPointFunction exportedSymbols: ssaEntryPointFunction exportedSymbols -- (Array with: #main).
    }.

    public method generateArgumentForNode: (argumentNode: ASTArgumentNode) ::=> SSAFunctionArgument := {
        let binding := argumentNode binding.
        self assert: binding isNotNil.

        SSAFunctionArgument new
            name: binding name;
            type: binding type;
            sourceBinding: binding;
            yourself
    }.

    public method generateCaptureForBinding: (captureBinding: SymbolCaptureBinding) ::=> SSAFunctionCapture := {
        SSAFunctionCapture new
            name: captureBinding name;
            type: captureBinding type;
            sourceBinding: captureBinding;
            yourself
    }.

    public method declareFunctionDefinition: (functionDefinition: FunctionDefinition) ::=> SSAFunctionDefinition := {
        functionDefinition ensureAnalysis.
        let translatedValue := SSAFunctionDefinition new
            sourceObject: functionDefinition;
            name: functionDefinition programEntityQualifiedNameSymbol;
            functionType: functionDefinition analyzedType;
            importedSymbols: functionDefinition importedSymbols asArray;
            primitiveName: functionDefinition analyzedPrimitiveName;
            sourcePosition: functionDefinition sourcePosition;
            arguments: (functionDefinition analyzedArgumentNodes collect: {:(ASTArgumentNode)argumentNode :: SSAFunctionArgument |
                self generateArgumentForNode: argumentNode
            }) asArray;
            captures: (functionDefinition analyzedCaptures collect: {:(SymbolCaptureBinding)captureBinding :: SSAFunctionCapture |
                self generateCaptureForBinding: captureBinding
            }) asArray;
            yourself.

        ssaModule addGlobalValue: translatedValue.
        translatedValueDictionary at: functionDefinition put: translatedValue.
        translatedValue
    }.

    public method compileFunctionDefinition: (functionDefinition: FunctionDefinition) into: (ssaFunctionDefinition: SSAFunctionDefinition) ::=> Void := {
        SSAFunctionCompilationContext new
            moduleCompilationContext: self;
            compileFunctionDefinition: functionDefinition into: ssaFunctionDefinition.
    }.

    public method declareFunction: (function: Function) ::=> SSAFunction := {
        function ensureAnalysis.
        let translatedValue := SSAFunction new
            sourceObject: function;
            name: function programEntityQualifiedNameSymbol;
            primitiveName: function primitiveName;
            exportedSymbols: function exportedSymbols asArray;
            yourself.

        ssaModule addGlobalValue: translatedValue.
        translatedValueDictionary at: function put: translatedValue.

        function definition ifNotNil: {
            translatedValue definition: (self translateFunctionDefinition: function definition).
        }.
        
        translatedValue
    }.

    public method translateFunction: (function: Function) withBuilder: (builder: SSAInstructionBuilder) ::=> SSAValue := {
        translatedValueDictionary at: function ifAbsent: { :: SSAValue |
            exclusiveCompilationMode ifTrue: {
                builder literal: function type: function class
            } ifFalse: {
                self declareFunction: function
            }
        }
    }.

    public method ensureFunctionWithDefinitionIsTranslated: (function: Function) ::=> Void := {
        let definition := function definition.
        self assert: definition isNotNil.
        translatedValueDictionary at: definition ifAbsent: {|
            let ssaDefinition := self declareFunctionDefinition: definition.
            translatedValueDictionary at: function ifAbsent: {|
                self declareFunction: function.
            }.

            self compileFunctionDefinition: definition into: ssaDefinition
        }.
    }.

    public method translateFunction: (function: Function) ::=> SSAValue
        := self translateFunction: function withBuilder: nil.

    public method translateFunctionDefinition: (functionDefinition: FunctionDefinition) withBuilder: (builder: SSAInstructionBuilder) ::=> SSAFunctionDefinition := {
        functionDefinition ensureAnalysis.
        translatedValueDictionary at: functionDefinition ifAbsent: { :: SSAValue |
            exclusiveCompilationMode ifTrue: {
                builder ifNotNil: (builder literal: functionDefinition type: functionDefinition class)
            } ifFalse: {
                let ssaFunctionDefinition := self declareFunctionDefinition: functionDefinition.
                self compileFunctionDefinition: functionDefinition into: ssaFunctionDefinition.
                ssaFunctionDefinition
            }
        }
    }.

    public method translateFunctionDefinition: (functionDefinition: FunctionDefinition) ::=> SSAFunctionDefinition
        := self translateFunctionDefinition: functionDefinition withBuilder: nil.

    public method finish => SSAModule := {
        ssaModule
    }.

    public method recordMakeArrayInstruction: (instruction: SSAMakeArrayInstruction) ::=> Void
        := self ensureFunctionWithDefinitionIsTranslated: ObjectModel::makeArrayWithSize.

    public method recordMakeAssociationInstruction: (instruction: SSAMakeAssociationInstruction) ::=> Void
        := self ensureFunctionWithDefinitionIsTranslated: ObjectModel::makeAssociation.

    public method recordMakeByteArrayInstruction: (instruction: SSAMakeByteArrayInstruction) ::=> Void
        := self ensureFunctionWithDefinitionIsTranslated: ObjectModel::makeByteArrayWithSize.

    public method recordMakeClosureInstruction: (instruction: SSAMakeClosureInstruction) ::=> Void
        := self ensureFunctionWithDefinitionIsTranslated: ObjectModel::makeClosure.

    public method recordMakeDictionaryInstruction: (instruction: SSAMakeDictionaryInstruction) ::=> Void := {
        self ensureFunctionWithDefinitionIsTranslated: ObjectModel::makeDictionaryWithCapacity.
        self ensureFunctionWithDefinitionIsTranslated: ObjectModel::Dictionary::add.
    }.

    public method recordCallInstruction: (instruction: SSACallInstruction) ::=> Void := {
        instruction isUnchecked ifFalse: {
            instruction arguments size < ObjectModel::CheckedFunctionApplicationTrampolines size ifTrue: {
                self ensureFunctionWithDefinitionIsTranslated: (ObjectModel::CheckedFunctionApplicationTrampolines at: instruction arguments size)
            }.
        }.
    }.

    public method recordSendInstruction: (instruction: SSASendInstruction) ::=> Void := {
        instruction receiverLookupType ifNil: {
            self ensureFunctionWithDefinitionIsTranslated: (ObjectModel::SendTrampolines at: instruction arguments size)
        } ifNotNil: {
            self ensureFunctionWithDefinitionIsTranslated: (ObjectModel::SendWithReceiverTypeTrampolines at: instruction arguments size)
        }
    }.
}.

public final class SSAFunctionCompilationContext superclass: Object; definition: {
    public field moduleCompilationContext => SSAModuleCompilationContext.
    public field functionDefinition => FunctionDefinition.
    public field ssaFunction => SSAFunctionDefinition.
    public field builder => SSAInstructionBuilder.
    protected field bindingDictionary => IdentityDictionary.

    public field breakDestination => SSABasicBlock.
    public field continueDestination => SSABasicBlock.

    public override method initialize => Void := {
        super initialize.
        bindingDictionary := IdentityDictionary new.
    }.

    public method setValue: (value: SSAValue) forBinding: (binding: SymbolBinding) ::=> Void := {
        self assert: binding isNotNil.
        bindingDictionary at: binding put: value.
    }.

    public method compileFunctionDefinition: (functionDefinition: FunctionDefinition) into: (ssaFunction: SSAFunctionDefinition) ::=> Void := {
        functionDefinition ensureAnalysis.
        self functionDefinition: functionDefinition.
        self ssaFunction: ssaFunction.

        ssaFunction arguments do: {:(SSAFunctionArgument)eachArgument :: Void |
            eachArgument sourceBinding ifNotNil: {
                self setValue: eachArgument forBinding: eachArgument sourceBinding
            }
        }.
        ssaFunction captures do: {:(SSAFunctionArgument)eachCapture :: Void |
            eachCapture sourceBinding ifNotNil: {
                self setValue: eachCapture forBinding: eachCapture sourceBinding
            }
        }.

        functionDefinition importedSymbols size = 0sz ifTrue: {
            functionDefinition analyzedBodyNode ifNotNil: {:bodyNode |
                self builder: (SSAInstructionBuilder new
                    sourcePosition: bodyNode sourcePosition;
                    function: ssaFunction;
                    beginBasicBlockNamed: #entry;
                    yourself).
                
                let resultValue := bodyNode generateSSAValueWith: self.
                self builder isLastTerminator ifFalse: (self builder return: resultValue).
            }.
        }.
    }.

    public method getValueForLocalBinding: (localBinding: SymbolAnalysisBinding) ::=> SSAValue
        := bindingDictionary at: localBinding.

    public method functionDefinitionValueFor: (functionDefinition: FunctionDefinition) ::=> SSAValue
        := self builder literal: functionDefinition.

    public method withBreakDestination: (breakDestination: SSABasicBlock) continueDestination: (continueDestination: SSABasicBlock) do: aBlock := {
        let oldBreakDestination := self breakDestination.
        let oldContinueDestination := self continueDestination.

        self
            breakDestination: breakDestination;
            continueDestination: continueDestination.
        
        let result := aBlock().

        self
            breakDestination: oldBreakDestination;
            continueDestination: oldContinueDestination.

        result
    }.

    public method recordMakeArrayInstruction: (instruction: SSAMakeArrayInstruction) ::=> Void
        := moduleCompilationContext recordMakeArrayInstruction: instruction.

    public method recordMakeAssociationInstruction: (instruction: SSAMakeAssociationInstruction) ::=> Void
        := moduleCompilationContext recordMakeAssociationInstruction: instruction.

    public method recordMakeByteArrayInstruction: (instruction: SSAMakeByteArrayInstruction) ::=> Void
        := moduleCompilationContext recordMakeByteArrayInstruction: instruction.

    public method recordMakeClosureInstruction: (instruction: SSAMakeClosureInstruction) ::=> Void
        := moduleCompilationContext recordMakeClosureInstruction: instruction.

    public method recordMakeDictionaryInstruction: (instruction: SSAMakeDictionaryInstruction) ::=> Void
        := moduleCompilationContext recordMakeDictionaryInstruction: instruction.

    public method recordCallInstruction: (instruction: SSACallInstruction) ::=> Void
        := moduleCompilationContext recordCallInstruction: instruction.

    public method recordSendInstruction: (instruction: SSASendInstruction) ::=> Void
        := moduleCompilationContext recordSendInstruction: instruction.
}.

ASTNode extend: {
    public method generateSSAValueWith: (context: SSAFunctionCompilationContext) ::=> SSAValue
        := context builder withSourceASTNode: self do: {:: SSAValue |
            self doGenerateSSAValueWith: context
    }.

    public abstract method doGenerateSSAValueWith: (context: SSAFunctionCompilationContext) ::=> SSAValue
        := self subclassResponsibility.
}.

ASTBreakNode extend: {
    public override method doGenerateSSAValueWith: (context: SSAFunctionCompilationContext) ::=> SSAValue := {
        context breakDestination ifNil: (self error: "Invalid break at this location.").
        context builder branch: context breakDestination.
        context builder literal: void
    }.
}.

ASTCoerceValueNode extend: {
    public override method doGenerateSSAValueWith: (context: SSAFunctionCompilationContext) ::=> SSAValue := {
        let type := self typeExpression generateSSAValueWith: context.
        let value := self valueExpression generateSSAValueWith: context.
        context builder coerceValue: value into: type type: self analyzedType
    }.        
}.

ASTContinueNode extend: {
    public override method doGenerateSSAValueWith: (context: SSAFunctionCompilationContext) ::=> SSAValue := {
        context continueDestination ifNil: (self error: "Invalid continue at this location.").
        context builder branch: context continueDestination.
        context builder literal: void
    }.
}.

ASTDownCastNode extend: {
    public override method doGenerateSSAValueWith: (context: SSAFunctionCompilationContext) ::=> SSAValue := {
        let type := self typeExpression generateSSAValueWith: context.
        let value := self valueExpression generateSSAValueWith: context.
        context builder downCast: value into: type type: self analyzedType
    }.        
}.

let primitiveFunctionGenerators := #{
    #PointerType::reinterpretCastTo: : {:(ASTFunctionApplicationNode)self :(SSAFunctionCompilationContext)context :: SSAValue |
        let pointer := self arguments first generateSSAValueWith: context.
        let targetType := self arguments second generateSSAValueWith: context.
        context builder bitcast: pointer into: targetType type: self analyzedType
    }.
    #UIntPointer::reinterpretCastTo: : {:(ASTFunctionApplicationNode)self :(SSAFunctionCompilationContext)context :: SSAValue |
        let pointer := self arguments first generateSSAValueWith: context.
        let targetType := self arguments second generateSSAValueWith: context.
        context builder bitcast: pointer into: targetType type: self analyzedType
    }.
    #IntPointer::reinterpretCastTo: : {:(ASTFunctionApplicationNode)self :(SSAFunctionCompilationContext)context :: SSAValue |
        let pointer := self arguments first generateSSAValueWith: context.
        let targetType := self arguments second generateSSAValueWith: context.
        context builder bitcast: pointer into: targetType type: self analyzedType
    }.

    #PointerLikeType::reinterpretCast : {:(ASTFunctionApplicationNode)self :(SSAFunctionCompilationContext)context :: SSAValue |
        let pointer := self arguments first generateSSAValueWith: context.
        let targetType := self analyzedType.
        context builder bitcast: pointer into: (context builder literal: targetType) type: targetType
    }.

    #PointerLikeType::at: : {:(ASTFunctionApplicationNode)self :(SSAFunctionCompilationContext)context :: SSAValue |
        let pointer := self arguments first generateSSAValueWith: context.
        let index := self arguments second generateSSAValueWith: context.
        context builder pointer: pointer elementAt: index type: self analyzedType
    }.

    #PointerLikeType::load : {:(ASTFunctionApplicationNode)self :(SSAFunctionCompilationContext)context :: SSAValue |
        let reference := self arguments first generateSSAValueWith: context.
        context builder load: reference type: self analyzedType
    }.
    #PointerLikeType::store: : {:(ASTFunctionApplicationNode)self :(SSAFunctionCompilationContext)context :: SSAValue |
        let reference := self arguments first generateSSAValueWith: context.
        let value := self arguments second generateSSAValueWith: context.
        context builder store: value in: reference.
        reference
    }.
    #Void::fromAnyValue : {:(ASTFunctionApplicationNode)self :(SSAFunctionCompilationContext)context :: SSAValue |
        self arguments do: {:(ASTNode)each :: Void | each generateSSAValueWith: context }.
        context builder literal: void
    }.
    #yourself : {:(ASTFunctionApplicationNode)self :(SSAFunctionCompilationContext)context :: SSAValue |
        self arguments first generateSSAValueWith: context
    }.
    #RawTuple::typeSlotAt: : {:(ASTFunctionApplicationNode)self :(SSAFunctionCompilationContext)context :: SSAValue |

        self arguments second isLiteralNode ifTrue: {
            let tuple := self arguments first generateSSAValueWith: context.
            let typeSlot => TypeSlot := self arguments second value.
            
            context builder tuple: tuple typedSlotAt: typeSlot.
        } ifFalse: {
            nil
        }.
    }.
    #RawTuple::typeSlotAt:put: : {:(ASTFunctionApplicationNode)self :(SSAFunctionCompilationContext)context :: SSAValue |
        self arguments second isLiteralNode ifTrue: {
            let tuple := self arguments first generateSSAValueWith: context.
            let typeSlot => TypeSlot := self arguments second value.
            let value := self arguments third generateSSAValueWith: context.
            
            context builder tuple: tuple typedSlotAt: typeSlot put: value.
        } ifFalse: {
            nil
        }.
    }.
    #RawTuple::refTypeSlotAt: : {:(ASTFunctionApplicationNode)self :(SSAFunctionCompilationContext)context :: SSAValue |
        self arguments second isLiteralNode ifTrue: {
            let tuple := self arguments first generateSSAValueWith: context.
            let typeSlot => TypeSlot := self arguments second value.
            
            context builder tuple: tuple typedSlotAt: typeSlot.
        } ifFalse: {
            nil
        }.
    }.
    #RawTuple::refTypeSlotAt:put: : {:(ASTFunctionApplicationNode)self :(SSAFunctionCompilationContext)context :: SSAValue |
        self arguments second isLiteralNode ifTrue: {
            let tuple := self arguments first generateSSAValueWith: context.
            let typeSlot => TypeSlot := self arguments second value.
            let value := self arguments third generateSSAValueWith: context.
            
            context builder tuple: tuple typedSlotAt: typeSlot put: value.
        } ifFalse: {
            nil
        }.
    }.
}.

ASTFunctionApplicationNode extend: {
    public override method doGenerateSSAValueWith: (context: SSAFunctionCompilationContext) ::=> SSAValue := {
        let primitiveGenerator := primitiveFunctionGenerators atOrNil: self functionExpression literalFunctionPrimitiveName.
        (primitiveGenerator ifNotNil: {
            primitiveGenerator(self, context)
        }) ifNil: {
            let functionExpression := self functionExpression generateSSAValueWith: context.
            let callInstruction := context builder call: functionExpression
                arguments: (self arguments collect: {:(ASTNode)each :: SSAValue | each generateSSAValueWith: context }) asArray
                resultType: self analyzedType.
            callInstruction isUnchecked: self isNoTypechecked.
            context recordCallInstruction: callInstruction.
            callInstruction
        }.
    }.
}.

ASTLexicalBlockNode extend: {
    public override method doGenerateSSAValueWith: (context: SSAFunctionCompilationContext) ::=> SSAValue
        := context builder withSourceEnvironment: self bodyEnvironment do: {:: SSAValue | self body generateSSAValueWith: context }.
}.

Type extend: {
    public virtual method translateASTLiteralNode: (literalNode: ASTLiteralNode) intoSSAValueWith: (context: SSAFunctionCompilationContext) ::=> SSAValue
        := context builder literal: literalNode value type: literalNode analyzedType.
}.

FunctionType extend: {
    public override method translateASTLiteralNode: (literalNode: ASTLiteralNode) intoSSAValueWith: (context: SSAFunctionCompilationContext) ::=> SSAValue
        := context moduleCompilationContext translateFunction: literalNode value withBuilder: context builder.
}.

FunctionDefinition class extend: {
    public override method translateASTLiteralNode: (literalNode: ASTLiteralNode) intoSSAValueWith: (context: SSAFunctionCompilationContext) ::=> SSAValue
        := context moduleCompilationContext translateFunctionDefinition: literalNode value withBuilder: context builder.
}.

ASTLiteralNode extend: {
    public override method doGenerateSSAValueWith: (context: SSAFunctionCompilationContext) ::=> SSAValue
        := self analyzedType translateASTLiteralNode: self intoSSAValueWith: context.
}.

ASTLambdaNode extend: {
    public override method doGenerateSSAValueWith: (context: SSAFunctionCompilationContext) ::=> SSAValue := {
        let functionDefinition := self functionDefinition.
        functionDefinition ensureAnalysis.

        let functionDefinitionValue := context functionDefinitionValueFor: functionDefinition.

        let captures := functionDefinition analyzedCaptures collect: {:(SymbolCaptureBinding)capture :: SSAValue |
            context getValueForLocalBinding: capture sourceBinding
        }.

        let instruction := context builder makeClosure: functionDefinitionValue captures: captures type: self analyzedType.
        context recordMakeClosureInstruction: instruction.
        instruction
    }.
}.

ASTLocalDefinitionNode extend: {
    public override method doGenerateSSAValueWith: (context: SSAFunctionCompilationContext) ::=> SSAValue := {
        let builder := context builder.

        let value := self valueExpression generateSSAValueWith: context.

        self isMutable ifTrue: {
            let localVariable := builder alloca: (builder literal: self analyzedValueType) type: self analyzedType.
            builder store: value in: localVariable.
            context setValue: localVariable forBinding: self binding.
            context builder setDebugValue: localVariable forBinding: self binding.
            localVariable
        } ifFalse: {
            context setValue: value forBinding: self binding.
            context builder setDebugValue: value forBinding: self binding.
            value
        }
    }.
}.

SymbolAnalysisBinding extend: {
    public virtual method generateSSAValueWith: (context: SSAFunctionCompilationContext) ::=> SSAValue
        := context getValueForLocalBinding: self.
}.

SymbolTupleSlotBinding extend: {
    public override method generateSSAValueWith: (context: SSAFunctionCompilationContext) ::=> SSAValue := {
        let tupleValue := tupleBinding generateSSAValueWith: context.
        context builder tuple: tupleValue typedSlotReferenceAt: typeSlot.
    }
}.

ASTIdentifierReferenceNode extend: {
    public override method doGenerateSSAValueWith: (context: SSAFunctionCompilationContext) ::=> SSAValue
        := self binding generateSSAValueWith: context.
}.

ASTIfNode extend: {
    public override method doGenerateSSAValueWith: (context: SSAFunctionCompilationContext) ::=> SSAValue := {
        let builder := context builder.

        ## Condition
        let condition := self conditionExpression
            ifNotNil: {:condition :: SSAValue | condition generateSSAValueWith: context}
            ifNil: (builder literal: false).
        
        let conditionBlock := builder basicBlock.
        let mergeBlock := builder newBasicBlockNamed: #ifMerge.

        let trueExpression := self trueExpression.
        let trueDestination := trueExpression
            ifNotNil: (builder newBasicBlockNamed: #ifTrue)
            ifNil: mergeBlock.

        let falseExpression := self falseExpression.
        let falseDestination := falseExpression
            ifNotNil: (builder newBasicBlockNamed: #ifFalse)
            ifNil: mergeBlock.

        builder conditionalBranch: condition trueDestination: trueDestination falseDestination: falseDestination.

        ## True branch
        let trueResult mutable => SSAValue := nil.
        let trueResultBlock mutable := conditionBlock.
        let trueResultIsTerminator mutable => Boolean := false.

        trueExpression ifNotNil: {
            builder beginBasicBlock: trueDestination.
            trueResult := trueExpression generateSSAValueWith: context.
            trueResultBlock := builder basicBlock.

            let isTerminator := builder isLastTerminator.
            trueResultIsTerminator := isTerminator.
            isTerminator
                ifTrue: (trueResult := builder literal: void)
                ifFalse: (builder branch: mergeBlock)
        } ifNil: {
            trueResult := builder literal: void
        }.

        ## False branch
        let falseResult mutable => SSAValue := nil.
        let falseResultBlock mutable := conditionBlock.
        let falseResultIsTerminator mutable => Boolean := false.
        falseExpression ifNotNil: {
            builder beginBasicBlock: falseDestination.
            falseResult := falseExpression generateSSAValueWith: context.
            falseResultBlock := builder basicBlock.

            let isTerminator := builder isLastTerminator.
            falseResultIsTerminator := isTerminator.
            isTerminator
                ifTrue: (falseResult := builder literal: void)
                ifFalse: (builder branch: mergeBlock)
        } ifNil: {
            falseResult := builder literal: void
        }.

        ## Merge
        builder beginBasicBlock: mergeBlock.
        if: (self analyzedType isSubtypeOf: Void) || (trueResultIsTerminator && falseResultIsTerminator) then: {
            builder literal: void
        } else: {
            trueResultIsTerminator ifTrue: (
                falseResult
            ) ifFalse: (
                falseResultIsTerminator ifTrue: (
                    trueResult
                ) ifFalse: (
                    (builder phi: self analyzedType)
                        addValue: trueResult incomingFrom: trueResultBlock;
                        addValue: falseResult incomingFrom: falseResultBlock;
                        yourself
                )
            ).
        }
    }
}.

ASTDoWhileContinueWithNode extend: {
    public override method doGenerateSSAValueWith: (context: SSAFunctionCompilationContext) ::=> SSAValue := {
        let builder := context builder.

        let conditionExpression := self conditionExpression.
        let bodyExpression := self bodyExpression.
        let continueExpression := self continueExpression.

        let entryBlock := builder newBasicBlockNamed: #doWhileBody.
        let conditionBlock := builder newBasicBlockNamed: #doWhileCondition.
        let continueBlock := continueExpression
            ifNil: (entryBlock)
            ifNotNil: (builder newBasicBlockNamed: #doWhileContinue).
        let mergeBlock := builder newBasicBlockNamed: #doWhileMerge.

        builder
            branch: entryBlock;
            beginBasicBlock: entryBlock.

        ## Emit the body.
        bodyExpression ifNotNil: {
            context withBreakDestination: mergeBlock continueDestination: continueBlock do: {:: Void |
                bodyExpression generateSSAValueWith: context.
                builder isLastTerminator ifFalse: {
                    builder branch: conditionBlock
                }.
            }
        }.

        ## Emit the condition.
        builder beginBasicBlock: conditionBlock.
        conditionExpression ifNil: {
            builder branch: continueBlock
        } ifNotNil: {
            let condition := conditionExpression generateSSAValueWith: context.
            builder isLastTerminator ifFalse: {
                builder conditionalBranch: condition trueDestination: continueBlock falseDestination: mergeBlock
            }
        }.

        ## Emit the optional continue expression.
        continueExpression ifNotNil: {
            builder beginBasicBlock: continueBlock.
            continueExpression generateSSAValueWith: context.
            builder isLastTerminator ifFalse: {
                builder branch: entryBlock
            }.
        }.

        builder beginBasicBlock: mergeBlock.
        builder literal: void
    }
}.

ASTWhileContinueWithNode extend: {
    public override method doGenerateSSAValueWith: (context: SSAFunctionCompilationContext) ::=> SSAValue := {
        let builder := context builder.

        let conditionExpression := self conditionExpression.
        let bodyExpression := self bodyExpression.
        let continueExpression := self continueExpression.

        let entryBlock := builder newBasicBlockNamed: #whileEntry.
        let bodyBlock := builder newBasicBlockNamed: #whileBody.
        let continueBlock := continueExpression
            ifNil: (entryBlock)
            ifNotNil: (builder newBasicBlockNamed: #whileContinue).
        let mergeBlock := builder newBasicBlockNamed: #whileMerge.

        builder
            branch: entryBlock;
            beginBasicBlock: entryBlock.

        ## Emit the condition.
        conditionExpression ifNil: {
            builder branch: bodyBlock
        } ifNotNil: {
            let condition := conditionExpression generateSSAValueWith: context.
            builder isLastTerminator ifFalse: {
                builder conditionalBranch: condition trueDestination: bodyBlock falseDestination: mergeBlock
            }
        }.

        ## Emit the body.
        builder beginBasicBlock: bodyBlock.
        bodyExpression ifNotNil: {
            context withBreakDestination: mergeBlock continueDestination: continueBlock do: {:: Void |
                bodyExpression generateSSAValueWith: context.
                builder isLastTerminator ifFalse: {
                    builder branch: continueBlock
                }.
            }
        }.

        ## Emit the optional continue expression.
        continueExpression ifNotNil: {
            builder beginBasicBlock: continueBlock.
            continueExpression generateSSAValueWith: context.
            builder isLastTerminator ifFalse: {
                builder branch: entryBlock
            }.
        }.

        builder beginBasicBlock: mergeBlock.
        builder literal: void
    }
}.

ASTMakeArrayNode extend: {
    public override method doGenerateSSAValueWith: (context: SSAFunctionCompilationContext) ::=> SSAValue := {
        let instruction := context builder makeArray: (self elements collect: {:(ASTNode)each :: SSAValue | each generateSSAValueWith: context }).
        instruction isMakeArrayInstruction ifTrue: {
            context recordMakeArrayInstruction: (instruction downCastTo: SSAMakeArrayInstruction).
        }.
        instruction
    }.
}.

ASTMakeAssociationNode extend: {
    public override method doGenerateSSAValueWith: (context: SSAFunctionCompilationContext) ::=> SSAValue := {
        let instruction := context builder makeAssociationWithKey: (self key generateSSAValueWith: context)
            value: (self value
                ifNotNil: (self value generateSSAValueWith: context)
                ifNil: (context builder literal: nil)).
        context recordMakeAssociationInstruction: instruction.
        instruction
    }.
}.

ASTMakeByteArrayNode extend: {
    public override method doGenerateSSAValueWith: (context: SSAFunctionCompilationContext) ::=> SSAValue :={
        let instruction := context builder makeByteArray: (self elements collect: {:(ASTNode)each :: SSAValue | each generateSSAValueWith: context }).
        instruction isMakeByteArrayInstruction ifTrue: {
            context recordMakeByteArrayInstruction: (instruction downCastTo: SSAMakeByteArrayInstruction).
        }.
        instruction
    }.
}.

ASTMakeDictionaryNode extend: {
    public override method doGenerateSSAValueWith: (context: SSAFunctionCompilationContext) ::=> SSAValue := {
        let instruction := context builder makeDictionary: (self elements collect: {:(ASTNode)each :: SSAValue | each generateSSAValueWith: context }).
        context recordMakeDictionaryInstruction: instruction.
        instruction
    }.
}.

ASTMessageSendNode extend: {
    public override method doGenerateSSAValueWith: (context: SSAFunctionCompilationContext) ::=> SSAValue := {
        let sendInstruction := context builder send: (self receiver generateSSAValueWith: context)
            receiverLookupType: (self receiverLookupType ifNotNil: {:(ASTNode)lookupTypeExpression :: SSAValue | lookupTypeExpression generateSSAValueWith: context })
            selector: (self selector generateSSAValueWith: context)
            arguments: (self arguments collect: {:(ASTNode)each :: SSAValue | each generateSSAValueWith: context }) asArray
            resultType: self analyzedType.
        sendInstruction isUnchecked: self isNoTypechecked.
        context recordSendInstruction: sendInstruction.
        sendInstruction
    }.
}.

ASTReturnNode extend: {
    public override method doGenerateSSAValueWith: (context: SSAFunctionCompilationContext) ::=> SSAValue
        := context builder return: (self expression generateSSAValueWith: context)
}.

ASTSequenceNode extend: {
    public override method doGenerateSSAValueWith: (context: SSAFunctionCompilationContext) ::=> SSAValue := {
        let result mutable => SSAValue := context builder literal: void.
        self expressions do: {:(ASTNode)expression :: Void |
            context builder isLastTerminator ifFalse: {
                result := expression generateSSAValueWith: context
            }
        }.

        result
    }
}.

ASTTupleSlotNamedAtNode extend: {
    public override method doGenerateSSAValueWith: (context: SSAFunctionCompilationContext) ::=> SSAValue := {
        context builder tuple: (self tupleExpression generateSSAValueWith: context) typedSlotAt: self boundSlot.
    }.
}.

ASTTupleSlotNamedReferenceAtNode extend: {
    public override method doGenerateSSAValueWith: (context: SSAFunctionCompilationContext) ::=> SSAValue := {
        context builder tuple: (self tupleExpression generateSSAValueWith: context) typedSlotReferenceAt: self boundSlot.
    }.
}.

ASTTupleSlotNamedAtPutNode extend: {
    public override method doGenerateSSAValueWith: (context: SSAFunctionCompilationContext) ::=> SSAValue := {
        context builder tuple: (self tupleExpression generateSSAValueWith: context) typedSlotAt: self boundSlot put: (self valueExpression generateSSAValueWith: context).
    }.
}.

ASTUseNamedSlotsOfNode extend: {
    public override method doGenerateSSAValueWith: (context: SSAFunctionCompilationContext) ::=> SSAValue := {
        context setValue: (self tupleExpression generateSSAValueWith: context) forBinding: self binding.
        context builder literal: void.
    }.
}.

FunctionDefinition extend: {
    public method asSSAModuleForTarget: (compilationTarget: SSACompilationTarget) ::=> SSAModule
        := (SSAModuleCompilationContext forTarget: compilationTarget)
            translateFunctionDefinition: self;
            finish.

    public method asSSAModule => SSAModule
        := SSAModuleCompilationContext forDefaultTarget
            translateFunctionDefinition: self;
            finish.
}.

Function extend: {
    public method asSSAModuleForTarget: (compilationTarget: SSACompilationTarget) ::=> SSAModule
        := (SSAModuleCompilationContext forTarget: compilationTarget)
            translateFunction: self;
            finish.

    public method asSSAModule => SSAModule
        := SSAModuleCompilationContext forDefaultTarget
            translateFunction: self;
            finish.
}.
