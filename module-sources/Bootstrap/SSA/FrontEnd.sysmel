public final class SSAModuleCompilationContext superclass: Object; definition: {
    public field compilationTarget => SSACompilationTarget.
    public field ssaModule => SSAModule.
    public field usedModules => OrderedCollection.
    public field exclusiveCompilationMode => Boolean.

    protected field translatedValueDictionary => IdentityDictionary.

    __Meta__ extend: {
        public method forTarget: (compilationTarget: SSACompilationTarget) ::=> self
            := self new
                initializeWithTarget: compilationTarget;
                yourself.

        public method forDefaultTarget => self
            := self forTarget: SSACompilationTarget default.
    }.

    public method initializeWithTarget: (theCompilationTarget: SSACompilationTarget) ::=> Void := {
        compilationTarget := theCompilationTarget.
        ssaModule := SSAModule new.
        translatedValueDictionary := IdentityDictionary new.
        usedModules := OrderedCollection new.
    }.

    public method addUsedModule: (usedModule: SSAModule) ::=> Void := {
        usedModules add: usedModule.
    }.

    public method findValueInUsedModule: value ::=> SSAValue := {
        let i mutable := 0sz.
        while: (i < usedModules size) do: {
            let module := usedModules at: i.
            let moduleValue := module getGlobalValueOrNilFor: value.
            moduleValue ifNotNil: {
                return: moduleValue 
            }
        } continueWith: (i := i + 1sz).
        nil
    }.

    public method compileFunctions: (functions: SequenceableCollection) definitions: (functionDefinitions: SequenceableCollection) ::=> Void := {
        let ssaFunctionDefinitions := functionDefinitions collect: {:(FunctionDefinition)eachFunctionDefinition :: SSAFunctionDefinition |
            self declareFunctionDefinition: eachFunctionDefinition
        }.

        functions do: {:(Function)eachFunction :: Void |
            self declareFunction: eachFunction
        }.

        ssaFunctionDefinitions doWithIndex: {:(SSAFunctionDefinition)eachSSAFunctionDefinition :(Size)index :: Void |
            let eachFunctionDefinition => FunctionDefinition := functionDefinitions at: index.
            self compileFunctionDefinition: eachFunctionDefinition into: eachSSAFunctionDefinition
        }.
    }.

    public method compileFunctionDefinition: (functionDefinition: FunctionDefinition) ::=> Void := {
        let ssaFunctionDefinition := self declareFunctionDefinition: functionDefinition.
        self compileFunctionDefinition: functionDefinition into: ssaFunctionDefinition
    }.

    public method exportMainEntryPointFunction: (entryPointFunction: Function) ::=> Void := {
        let ssaEntryPointFunction => SSAFunction := translatedValueDictionary atOrNil: entryPointFunction.
        ssaEntryPointFunction ifNil: {return: void}.

        ssaEntryPointFunction exportedSymbols: ssaEntryPointFunction exportedSymbols -- (Array with: #main).
    }.

    public method generateArgumentForNode: (argumentNode: ASTArgumentNode) ::=> SSAFunctionArgument := {
        let binding := argumentNode binding.
        self assert: binding isNotNil.

        SSAFunctionArgument new
            name: binding name;
            type: binding type;
            sourceBinding: binding;
            yourself
    }.

    public method generateCaptureForBinding: (captureBinding: SymbolCaptureBinding) ::=> SSAFunctionCapture := {
        SSAFunctionCapture new
            name: captureBinding name;
            type: captureBinding type;
            sourceBinding: captureBinding;
            yourself
    }.

    public method declareFunctionDefinition: (functionDefinition: FunctionDefinition) ::=> SSAFunctionDefinition := {
        functionDefinition ensureAnalysis.
        let translatedValue := SSAFunctionDefinition new
            type: FunctionDefinition;
            sourceObject: functionDefinition;
            name: functionDefinition programEntityQualifiedNameSymbol;
            functionType: functionDefinition analyzedType;
            importedSymbols: functionDefinition importedSymbols asArray;
            primitiveName: functionDefinition analyzedPrimitiveName;
            sourcePosition: functionDefinition sourcePosition;
            arguments: (functionDefinition analyzedArgumentNodes collect: {:(ASTArgumentNode)argumentNode :: SSAFunctionArgument |
                self generateArgumentForNode: argumentNode
            }) asArray;
            captures: (functionDefinition analyzedCaptures collect: {:(SymbolCaptureBinding)captureBinding :: SSAFunctionCapture |
                self generateCaptureForBinding: captureBinding
            }) asArray;
            yourself.

        ssaModule addGlobalValue: translatedValue.
        translatedValueDictionary at: functionDefinition put: translatedValue.
        translatedValue
    }.

    public method compileFunctionDefinition: (functionDefinition: FunctionDefinition) into: (ssaFunctionDefinition: SSAFunctionDefinition) ::=> Void := {
        SSAFunctionCompilationContext new
            moduleCompilationContext: self;
            compileFunctionDefinition: functionDefinition into: ssaFunctionDefinition.
    }.

    public method declareFunction: (function: Function) ::=> SSAFunction := {
        function ensureAnalysis.
        let translatedValue := SSAFunction new
            sourceObject: function;
            name: function programEntityQualifiedNameSymbol;
            primitiveName: function primitiveName;
            exportedSymbols: function exportedSymbols asArray;
            type: function __type__;
            yourself.

        ssaModule addGlobalValue: translatedValue.
        translatedValueDictionary at: function put: translatedValue.

        function definition ifNotNil: {
            translatedValue definition: (self translateFunctionDefinition: function definition).
        }.
        
        translatedValue
    }.

    public method translateFunction: (function: Function) withBuilder: (builder: SSAInstructionBuilder) ::=> SSAValue := {
        translatedValueDictionary at: function ifAbsent: { :: SSAValue |
            let importedValue := self findValueInUsedModule: function.
            importedValue ifNotNil: {
                translatedValueDictionary at: function put: importedValue.
                importedValue
            } ifNil: {
                exclusiveCompilationMode ifTrue: {
                    builder literal: function type: function class
                } ifFalse: {
                    self declareFunction: function
                }
            }.
        }
    }.

    public method translateFunction: (function: Function) ::=> SSAValue
        := self translateFunction: function withBuilder: nil.

    public method translateFunctionDefinition: (functionDefinition: FunctionDefinition) withBuilder: (builder: SSAInstructionBuilder) ::=> SSAFunctionDefinition := {
        functionDefinition ensureAnalysis.
        translatedValueDictionary at: functionDefinition ifAbsent: { :: SSAValue |
            let importedValue := self findValueInUsedModule: functionDefinition.
            importedValue ifNotNil: {
                translatedValueDictionary at: functionDefinition put: importedValue.
                importedValue downCastTo: SSAFunctionDefinition
            } ifNil: {
                exclusiveCompilationMode ifTrue: {
                    builder ifNotNil: (builder literal: functionDefinition type: functionDefinition class)
                } ifFalse: {
                    let ssaFunctionDefinition := self declareFunctionDefinition: functionDefinition.
                    self compileFunctionDefinition: functionDefinition into: ssaFunctionDefinition.
                    ssaFunctionDefinition
                }
            }
        }
    }.

    public method translateFunctionDefinition: (functionDefinition: FunctionDefinition) ::=> SSAFunctionDefinition
        := self translateFunctionDefinition: functionDefinition withBuilder: nil.

    public method finish => SSAModule := {
        ssaModule
    }.
}.

public final class SSAFunctionCompilationContext superclass: Object.

let primitiveFunctionContentGenerator := #{
    #ObjectModel::isLogical : {:(SSAFunctionCompilationContext)context :: SSAValue |
        context builder literal: context compilationTarget hasLogicalObjectModel
    }.
    #ObjectModel::isNative : {:(SSAFunctionCompilationContext)context :: SSAValue |
        context builder literal: context compilationTarget hasNativeObjectModel
    }.
}.

SSAFunctionCompilationContext definition: {
    public field moduleCompilationContext => SSAModuleCompilationContext.
    public field functionDefinition => FunctionDefinition.
    public field ssaFunction => SSAFunctionDefinition.
    public field builder => SSAInstructionBuilder.
    protected field bindingDictionary => IdentityDictionary.

    public field breakDestination => SSABasicBlock.
    public field continueDestination => SSABasicBlock.

    public method compilationTarget => SSACompilationTarget
        := moduleCompilationContext compilationTarget.

    public override method initialize => Void := {
        super initialize.
        bindingDictionary := IdentityDictionary new.
    }.

    public method setValue: (value: SSAValue) forBinding: (binding: SymbolBinding) ::=> Void := {
        self assert: binding isNotNil.
        bindingDictionary at: binding put: value.
    }.

    public method compileFunctionDefinition: (functionDefinition: FunctionDefinition) into: (ssaFunction: SSAFunctionDefinition) ::=> Void := {
        functionDefinition ensureAnalysis.
        self functionDefinition: functionDefinition.
        self ssaFunction: ssaFunction.

        ssaFunction arguments do: {:(SSAFunctionArgument)eachArgument :: Void |
            eachArgument sourceBinding ifNotNil: {
                self setValue: eachArgument forBinding: eachArgument sourceBinding
            }
        }.
        ssaFunction captures do: {:(SSAFunctionCapture)eachCapture :: Void |
            eachCapture sourceBinding ifNotNil: {
                self setValue: eachCapture forBinding: eachCapture sourceBinding
            }
        }.

        functionDefinition importedSymbols size = 0sz ifTrue: {
            functionDefinition analyzedBodyNode ifNotNil: {:bodyNode |
                self builder: (SSAInstructionBuilder new
                    sourcePosition: bodyNode sourcePosition;
                    function: ssaFunction;
                    beginBasicBlockNamed: #entry;
                    yourself).

                let primitiveGenerator := primitiveFunctionContentGenerator atOrNil: functionDefinition analyzedPrimitiveName.
                let resultValue := primitiveGenerator ifNotNil: {
                    primitiveGenerator(self)
                } ifNil: {
                    bodyNode generateSSAValueWith: self.
                }.
                self builder isLastTerminator ifFalse: (self builder return: resultValue).
            }.
        }.
    }.

    public method getValueForLocalBinding: (localBinding: SymbolAnalysisBinding) ::=> SSAValue
        := bindingDictionary at: localBinding.

    public method functionDefinitionValueFor: (functionDefinition: FunctionDefinition) ::=> SSAValue
        := self builder literal: functionDefinition.

    public method withBreakDestination: (breakDestination: SSABasicBlock) continueDestination: (continueDestination: SSABasicBlock) do: aBlock := {
        let oldBreakDestination := self breakDestination.
        let oldContinueDestination := self continueDestination.

        self
            breakDestination: breakDestination;
            continueDestination: continueDestination.
        
        let result := aBlock().

        self
            breakDestination: oldBreakDestination;
            continueDestination: oldContinueDestination.

        result
    }.
}.

ASTNode extend: {
    public method generateSSAValueWith: (context: SSAFunctionCompilationContext) ::=> SSAValue
        := context builder withSourceASTNode: self do: {:: SSAValue |
            self doGenerateSSAValueWith: context
    }.

    public abstract method doGenerateSSAValueWith: (context: SSAFunctionCompilationContext) ::=> SSAValue
        := self subclassResponsibility.
}.

ASTBreakNode extend: {
    public override method doGenerateSSAValueWith: (context: SSAFunctionCompilationContext) ::=> SSAValue := {
        context breakDestination ifNil: (self error: "Invalid break at this location.").
        context builder branch: context breakDestination.
        context builder literal: void
    }.
}.

ASTCoerceValueNode extend: {
    public override method doGenerateSSAValueWith: (context: SSAFunctionCompilationContext) ::=> SSAValue := {
        let type := self typeExpression generateSSAValueWith: context.
        let value := self valueExpression generateSSAValueWith: context.
        context builder coerceValue: value into: type type: self analyzedType
    }.        
}.

ASTContinueNode extend: {
    public override method doGenerateSSAValueWith: (context: SSAFunctionCompilationContext) ::=> SSAValue := {
        context continueDestination ifNil: (self error: "Invalid continue at this location.").
        context builder branch: context continueDestination.
        context builder literal: void
    }.
}.

ASTDownCastNode extend: {
    public override method doGenerateSSAValueWith: (context: SSAFunctionCompilationContext) ::=> SSAValue := {
        let type := self typeExpression generateSSAValueWith: context.
        let value := self valueExpression generateSSAValueWith: context.
        context builder downCast: value into: type type: self analyzedType
    }.        
}.

let primitiveFunctionGenerators := #{
    #PointerType::reinterpretCastTo: : {:(ASTFunctionApplicationNode)self :(SSAFunctionCompilationContext)context :: SSAValue |
        let pointer := self arguments first generateSSAValueWith: context.
        let targetType := self arguments second generateSSAValueWith: context.
        context builder bitcast: pointer into: targetType type: self analyzedType
    }.
    #UIntPointer::reinterpretCastTo: : {:(ASTFunctionApplicationNode)self :(SSAFunctionCompilationContext)context :: SSAValue |
        let pointer := self arguments first generateSSAValueWith: context.
        let targetType := self arguments second generateSSAValueWith: context.
        context builder bitcast: pointer into: targetType type: self analyzedType
    }.
    #IntPointer::reinterpretCastTo: : {:(ASTFunctionApplicationNode)self :(SSAFunctionCompilationContext)context :: SSAValue |
        let pointer := self arguments first generateSSAValueWith: context.
        let targetType := self arguments second generateSSAValueWith: context.
        context builder bitcast: pointer into: targetType type: self analyzedType
    }.

    #PointerLikeType::reinterpretCast : {:(ASTFunctionApplicationNode)self :(SSAFunctionCompilationContext)context :: SSAValue |
        let pointer := self arguments first generateSSAValueWith: context.
        let targetType := self analyzedType.
        context builder bitcast: pointer into: (context builder literal: targetType) type: targetType
    }.

    #PointerLikeType::at: : {:(ASTFunctionApplicationNode)self :(SSAFunctionCompilationContext)context :: SSAValue |
        let pointer := self arguments first generateSSAValueWith: context.
        let index := self arguments second generateSSAValueWith: context.
        context builder pointer: pointer elementAt: index type: self analyzedType
    }.

    #PointerLikeType::load : {:(ASTFunctionApplicationNode)self :(SSAFunctionCompilationContext)context :: SSAValue |
        let reference := self arguments first generateSSAValueWith: context.
        self analyzedType isTemporaryReferenceType ifTrue: {
            let valueType := (self analyzedType downCastTo: ReferenceLikeType) baseType.
            let temporary := context builder alloca: (context builder literal: valueType) type: self analyzedType.
            context builder store: (context builder load: reference type: valueType) in: temporary.
            temporary
        } ifFalse: {
            context builder load: reference type: self analyzedType
        }.
    }.
    #PointerLikeType::store: : {:(ASTFunctionApplicationNode)self :(SSAFunctionCompilationContext)context :: SSAValue |
        let reference := self arguments first generateSSAValueWith: context.
        let value := self arguments second generateSSAValueWith: context.
        context builder store: value in: reference.
        reference
    }.

    #FixedArray::at: : {:(ASTFunctionApplicationNode)self :(SSAFunctionCompilationContext)context :: SSAValue |
        let reference := self arguments first generateSSAValueWith: context.
        let index := self arguments second generateSSAValueWith: context.
        let referenceType => PointerLikeType := self arguments first analyzedType.
        let fixedArrayType := referenceType baseType downCastTo: FixedArrayType.
        let elementReferenceType := fixedArrayType elementType refFor: referenceType addressSpace.
        let elementReference := context builder reference: reference elementAt: index type: elementReferenceType.
        context builder load: elementReference type: self analyzedType
    }.
    #FixedArray::at:put: : {:(ASTFunctionApplicationNode)self :(SSAFunctionCompilationContext)context :: SSAValue |
        let reference := self arguments first generateSSAValueWith: context.
        let index := self arguments second generateSSAValueWith: context.
        let value := self arguments third generateSSAValueWith: context.
        let referenceType => PointerLikeType := self arguments first analyzedType.
        let fixedArrayType := referenceType baseType downCastTo: FixedArrayType.
        let elementReferenceType := fixedArrayType elementType refFor: referenceType addressSpace.
        let elementReference := context builder reference: reference elementAt: index type: elementReferenceType.
        context builder
            store: value in: elementReference;
            literal: void
    }.
    #FixedArray::refAt: : {:(ASTFunctionApplicationNode)self :(SSAFunctionCompilationContext)context :: SSAValue |
        let reference := self arguments first generateSSAValueWith: context.
        let index := self arguments second generateSSAValueWith: context.
        context builder reference: reference elementAt: index type: self analyzedType
    }.

    #Void::fromAnyValue : {:(ASTFunctionApplicationNode)self :(SSAFunctionCompilationContext)context :: SSAValue |
        self arguments do: {:(ASTNode)each :: Void | each generateSSAValueWith: context }.
        context builder literal: void
    }.
    #yourself : {:(ASTFunctionApplicationNode)self :(SSAFunctionCompilationContext)context :: SSAValue |
        self arguments first generateSSAValueWith: context
    }.
    #RawTuple::typeSlotAt: : {:(ASTFunctionApplicationNode)self :(SSAFunctionCompilationContext)context :: SSAValue |

        self arguments second isLiteralNode ifTrue: {
            let tuple := self arguments first generateSSAValueWith: context.
            let typeSlot => TypeSlot := self arguments second value.
            
            context builder tuple: tuple typedSlotAt: typeSlot.
        } ifFalse: {
            nil
        }.
    }.
    #RawTuple::typeSlotAt:put: : {:(ASTFunctionApplicationNode)self :(SSAFunctionCompilationContext)context :: SSAValue |
        self arguments second isLiteralNode ifTrue: {
            let tuple := self arguments first generateSSAValueWith: context.
            let typeSlot => TypeSlot := self arguments second value.
            let value := self arguments third generateSSAValueWith: context.
            
            context builder tuple: tuple typedSlotAt: typeSlot put: value.
        } ifFalse: {
            nil
        }.
    }.
    #RawTuple::refTypeSlotAt: : {:(ASTFunctionApplicationNode)self :(SSAFunctionCompilationContext)context :: SSAValue |
        self arguments second isLiteralNode ifTrue: {
            let tuple := self arguments first generateSSAValueWith: context.
            let typeSlot => TypeSlot := self arguments second value.
            
            context builder tuple: tuple typedSlotAt: typeSlot.
        } ifFalse: {
            nil
        }.
    }.
    #RawTuple::refTypeSlotAt:put: : {:(ASTFunctionApplicationNode)self :(SSAFunctionCompilationContext)context :: SSAValue |
        self arguments second isLiteralNode ifTrue: {
            let tuple := self arguments first generateSSAValueWith: context.
            let typeSlot => TypeSlot := self arguments second value.
            let value := self arguments third generateSSAValueWith: context.
            
            context builder tuple: tuple typedSlotAt: typeSlot put: value.
        } ifFalse: {
            nil
        }.
    }.

    #ObjectModel::isLogical : {:(ASTFunctionApplicationNode)self :(SSAFunctionCompilationContext)context :: SSAValue |
        context builder literal: context compilationTarget hasLogicalObjectModel
    }.
    #ObjectModel::isNative : {:(ASTFunctionApplicationNode)self :(SSAFunctionCompilationContext)context :: SSAValue |
        context builder literal: context compilationTarget hasNativeObjectModel
    }.
}.

ASTFunctionApplicationNode extend: {
    public override method doGenerateSSAValueWith: (context: SSAFunctionCompilationContext) ::=> SSAValue := {
        let primitiveGenerator := primitiveFunctionGenerators atOrNil: self functionExpression literalFunctionPrimitiveName.
        (primitiveGenerator ifNotNil: {
            primitiveGenerator(self, context)
        }) ifNil: {
            let functionExpression := self functionExpression generateSSAValueWith: context.
            let callInstruction := context builder call: functionExpression
                arguments: (self arguments collect: {:(ASTNode)each :: SSAValue | each generateSSAValueWith: context }) asArray
                resultType: self analyzedType.
            
            callInstruction isUnchecked: self isNoTypechecked.

            (callInstruction type isSubtypeOf: ControlFlowEscapeType) ifTrue: {
                context builder
                    unreachable;
                    literal: void
            } ifFalse: {
                (callInstruction type isSubtypeOf: Void)
                    ifTrue: (context builder literal: void)
                    ifFalse: callInstruction
            }
        }.
    }.
}.

ASTLexicalBlockNode extend: {
    public override method doGenerateSSAValueWith: (context: SSAFunctionCompilationContext) ::=> SSAValue
        := context builder withSourceEnvironment: self bodyEnvironment do: {:: SSAValue | self body generateSSAValueWith: context }.
}.

Type extend: {
    public virtual method translateASTLiteralNode: (literalNode: ASTLiteralNode) intoSSAValueWith: (context: SSAFunctionCompilationContext) ::=> SSAValue
        := context builder literal: literalNode value type: literalNode analyzedType.
}.

FunctionType extend: {
    public override method translateASTLiteralNode: (literalNode: ASTLiteralNode) intoSSAValueWith: (context: SSAFunctionCompilationContext) ::=> SSAValue
        := context moduleCompilationContext translateFunction: literalNode value withBuilder: context builder.
}.

FunctionDefinition class extend: {
    public override method translateASTLiteralNode: (literalNode: ASTLiteralNode) intoSSAValueWith: (context: SSAFunctionCompilationContext) ::=> SSAValue
        := context moduleCompilationContext translateFunctionDefinition: literalNode value withBuilder: context builder.
}.

ASTLiteralNode extend: {
    public override method doGenerateSSAValueWith: (context: SSAFunctionCompilationContext) ::=> SSAValue
        := self analyzedType translateASTLiteralNode: self intoSSAValueWith: context.
}.

ASTLambdaNode extend: {
    public override method doGenerateSSAValueWith: (context: SSAFunctionCompilationContext) ::=> SSAValue := {
        let functionDefinition := self functionDefinition.
        functionDefinition ensureAnalysis.

        let functionDefinitionValue := context functionDefinitionValueFor: functionDefinition.

        let captures := functionDefinition analyzedCaptures collect: {:(SymbolCaptureBinding)capture :: SSAValue |
            context getValueForLocalBinding: capture sourceBinding
        }.

        context builder makeClosure: functionDefinitionValue captures: captures type: self analyzedType
    }.
}.

ASTLocalDefinitionNode extend: {
    public override method doGenerateSSAValueWith: (context: SSAFunctionCompilationContext) ::=> SSAValue := {
        let builder := context builder.

        let value := self valueExpression generateSSAValueWith: context.

        self isMutable ifTrue: {
            let localVariable := builder alloca: (builder literal: self analyzedValueType) type: self analyzedType.
            builder store: value in: localVariable.
            context setValue: localVariable forBinding: self binding.
            context builder setDebugValue: localVariable forBinding: self binding.
            localVariable
        } ifFalse: {
            context setValue: value forBinding: self binding.
            context builder setDebugValue: value forBinding: self binding.
            value
        }
    }.
}.

SymbolAnalysisBinding extend: {
    public virtual method generateSSAValueWith: (context: SSAFunctionCompilationContext) ::=> SSAValue
        := context getValueForLocalBinding: self.
}.

SymbolTupleSlotBinding extend: {
    public override method generateSSAValueWith: (context: SSAFunctionCompilationContext) ::=> SSAValue := {
        let tupleValue := tupleBinding generateSSAValueWith: context.
        context builder tuple: tupleValue typedSlotReferenceAt: typeSlot.
    }
}.

ASTIdentifierReferenceNode extend: {
    public override method doGenerateSSAValueWith: (context: SSAFunctionCompilationContext) ::=> SSAValue
        := self binding generateSSAValueWith: context.
}.

ASTIfNode extend: {
    public override method doGenerateSSAValueWith: (context: SSAFunctionCompilationContext) ::=> SSAValue := {
        let builder := context builder.

        ## Condition
        let condition := conditionExpression
            ifNotNil: (conditionExpression generateSSAValueWith: context)
            ifNil: (builder literal: false).

        ## Optimize out true constant literal.
        condition isLiteralConstantTrue ifTrue: {
            return: (trueExpression ifNotNil: {
                trueExpression generateSSAValueWith: context
            } ifNil: {
                builder literal: void
            })
        }.

        ## Optimize out false constant literal.
        condition isLiteralConstantFalse ifTrue: {
            return: (falseExpression ifNotNil: {
                falseExpression generateSSAValueWith: context
            } ifNil: {
                builder literal: void
            })
        }.
        
        let conditionBlock := builder basicBlock.
        let mergeBlock := builder newBasicBlockNamed: #ifMerge.

        let trueExpression := self trueExpression.
        let trueDestination := trueExpression
            ifNotNil: (builder newBasicBlockNamed: #ifTrue)
            ifNil: mergeBlock.

        let falseExpression := self falseExpression.
        let falseDestination := falseExpression
            ifNotNil: (builder newBasicBlockNamed: #ifFalse)
            ifNil: mergeBlock.

        builder conditionalBranch: condition trueDestination: trueDestination falseDestination: falseDestination.

        ## True branch
        let trueResult mutable => SSAValue := nil.
        let trueResultBlock mutable := conditionBlock.
        let trueResultIsTerminator mutable := false.

        trueExpression ifNotNil: {
            builder beginBasicBlock: trueDestination.
            trueResult := trueExpression generateSSAValueWith: context.
            trueResultBlock := builder basicBlock.

            let isTerminator := builder isLastTerminator.
            trueResultIsTerminator := isTerminator.
            isTerminator
                ifTrue: (trueResult := builder literal: void)
                ifFalse: (builder branch: mergeBlock)
        } ifNil: {
            trueResult := builder literal: void
        }.

        ## False branch
        let falseResult mutable => SSAValue := nil.
        let falseResultBlock mutable := conditionBlock.
        let falseResultIsTerminator mutable := false.
        falseExpression ifNotNil: {
            builder beginBasicBlock: falseDestination.
            falseResult := falseExpression generateSSAValueWith: context.
            falseResultBlock := builder basicBlock.

            let isTerminator := builder isLastTerminator.
            falseResultIsTerminator := isTerminator.
            isTerminator
                ifTrue: (falseResult := builder literal: void)
                ifFalse: (builder branch: mergeBlock)
        } ifNil: {
            falseResult := builder literal: void
        }.

        ## Merge
        builder beginBasicBlock: mergeBlock.
        if: (self analyzedType isSubtypeOf: Void) || (trueResultIsTerminator && falseResultIsTerminator) then: {
            builder literal: void
        } else: {
            trueResultIsTerminator ifTrue: (
                falseResult
            ) ifFalse: (
                falseResultIsTerminator ifTrue: (
                    trueResult
                ) ifFalse: (
                    (builder phi: self analyzedType)
                        addValue: trueResult incomingFrom: trueResultBlock;
                        addValue: falseResult incomingFrom: falseResultBlock;
                        yourself
                )
            ).
        }
    }
}.

ASTDoWhileContinueWithNode extend: {
    public override method doGenerateSSAValueWith: (context: SSAFunctionCompilationContext) ::=> SSAValue := {
        let builder := context builder.

        let conditionExpression := self conditionExpression.
        let bodyExpression := self bodyExpression.
        let continueExpression := self continueExpression.

        let entryBlock := builder newBasicBlockNamed: #doWhileBody.
        let conditionBlock := builder newBasicBlockNamed: #doWhileCondition.
        let continueBlock := continueExpression
            ifNil: (entryBlock)
            ifNotNil: (builder newBasicBlockNamed: #doWhileContinue).
        let mergeBlock := builder newBasicBlockNamed: #doWhileMerge.

        builder
            branch: entryBlock;
            beginBasicBlock: entryBlock.

        ## Emit the body.
        bodyExpression ifNotNil: {
            context withBreakDestination: mergeBlock continueDestination: continueBlock do: {:: Void |
                bodyExpression generateSSAValueWith: context.
                builder isLastTerminator ifFalse: {
                    builder branch: conditionBlock
                }.
            }
        }.

        ## Emit the condition.
        builder beginBasicBlock: conditionBlock.
        conditionExpression ifNil: {
            builder branch: continueBlock
        } ifNotNil: {
            let condition := conditionExpression generateSSAValueWith: context.
            builder isLastTerminator ifFalse: {
                builder conditionalBranch: condition trueDestination: continueBlock falseDestination: mergeBlock
            }
        }.

        ## Emit the optional continue expression.
        continueExpression ifNotNil: {
            builder beginBasicBlock: continueBlock.
            continueExpression generateSSAValueWith: context.
            builder isLastTerminator ifFalse: {
                builder branch: entryBlock
            }.
        }.

        builder beginBasicBlock: mergeBlock.
        builder literal: void
    }
}.

ASTWhileContinueWithNode extend: {
    public override method doGenerateSSAValueWith: (context: SSAFunctionCompilationContext) ::=> SSAValue := {
        let builder := context builder.

        let conditionExpression := self conditionExpression.
        let bodyExpression := self bodyExpression.
        let continueExpression := self continueExpression.

        let entryBlock := builder newBasicBlockNamed: #whileEntry.
        let bodyBlock := builder newBasicBlockNamed: #whileBody.
        let continueBlock := continueExpression
            ifNil: (entryBlock)
            ifNotNil: (builder newBasicBlockNamed: #whileContinue).
        let mergeBlock := builder newBasicBlockNamed: #whileMerge.

        builder
            branch: entryBlock;
            beginBasicBlock: entryBlock.

        ## Emit the condition.
        conditionExpression ifNil: {
            builder branch: bodyBlock
        } ifNotNil: {
            let condition := conditionExpression generateSSAValueWith: context.
            builder isLastTerminator ifFalse: {
                builder conditionalBranch: condition trueDestination: bodyBlock falseDestination: mergeBlock
            }
        }.

        ## Emit the body.
        builder beginBasicBlock: bodyBlock.
        bodyExpression ifNotNil: {
            context withBreakDestination: mergeBlock continueDestination: continueBlock do: {:: Void |
                bodyExpression generateSSAValueWith: context.
                builder isLastTerminator ifFalse: {
                    builder branch: continueBlock
                }.
            }
        }.

        ## Emit the optional continue expression.
        continueExpression ifNotNil: {
            builder beginBasicBlock: continueBlock.
            continueExpression generateSSAValueWith: context.
            builder isLastTerminator ifFalse: {
                builder branch: entryBlock
            }.
        }.

        builder beginBasicBlock: mergeBlock.
        builder literal: void
    }
}.

ASTMakeArrayNode extend: {
    public override method doGenerateSSAValueWith: (context: SSAFunctionCompilationContext) ::=> SSAValue
        := context builder makeArray: (self elements collect: {:(ASTNode)each :: SSAValue | each generateSSAValueWith: context }).
}.

ASTMakeAssociationNode extend: {
    public override method doGenerateSSAValueWith: (context: SSAFunctionCompilationContext) ::=> SSAValue
        := context builder makeAssociationWithKey: (self key generateSSAValueWith: context)
            value: (self value
                ifNotNil: (self value generateSSAValueWith: context)
                ifNil: (context builder literal: nil)).
}.

ASTMakeByteArrayNode extend: {
    public override method doGenerateSSAValueWith: (context: SSAFunctionCompilationContext) ::=> SSAValue
        := context builder makeByteArray: (self elements collect: {:(ASTNode)each :: SSAValue | each generateSSAValueWith: context }).
}.

ASTMakeDictionaryNode extend: {
    public override method doGenerateSSAValueWith: (context: SSAFunctionCompilationContext) ::=> SSAValue
        := context builder makeDictionary: (self elements collect: {:(ASTNode)each :: SSAValue | each generateSSAValueWith: context })
}.

ASTMessageSendNode extend: {
    public override method doGenerateSSAValueWith: (context: SSAFunctionCompilationContext) ::=> SSAValue := {
        let sendInstruction := context builder send: (self receiver generateSSAValueWith: context)
            receiverLookupType: (self receiverLookupType ifNotNil: {:(ASTNode)lookupTypeExpression :: SSAValue | lookupTypeExpression generateSSAValueWith: context })
            selector: (self selector generateSSAValueWith: context)
            arguments: (self arguments collect: {:(ASTNode)each :: SSAValue | each generateSSAValueWith: context }) asArray
            resultType: self analyzedType.

        sendInstruction isUnchecked: self isNoTypechecked.

        (sendInstruction type isSubtypeOf: ControlFlowEscapeType) ifTrue: {
            context builder
                unreachable;
                literal: void
        } ifFalse: {
            (sendInstruction type isSubtypeOf: Void)
                ifTrue: (context builder literal: void)
                ifFalse: sendInstruction
        }
    }
}.

ASTReturnNode extend: {
    public override method doGenerateSSAValueWith: (context: SSAFunctionCompilationContext) ::=> SSAValue
        := context builder return: (self expression generateSSAValueWith: context)
}.

ASTSequenceNode extend: {
    public override method doGenerateSSAValueWith: (context: SSAFunctionCompilationContext) ::=> SSAValue := {
        let voidLiteral :=  context builder literal: void.
        let result mutable => SSAValue := voidLiteral.
        self expressions do: {:(ASTNode)expression :: Void |
            context builder isLastTerminator ifTrue: {
                result := voidLiteral
            } ifFalse: {
                result := expression generateSSAValueWith: context
            }
        }.

        result
    }
}.

ASTTupleSlotNamedAtNode extend: {
    public override method doGenerateSSAValueWith: (context: SSAFunctionCompilationContext) ::=> SSAValue := {
        context builder tuple: (self tupleExpression generateSSAValueWith: context) typedSlotAt: self boundSlot.
    }.
}.

ASTTupleSlotNamedReferenceAtNode extend: {
    public override method doGenerateSSAValueWith: (context: SSAFunctionCompilationContext) ::=> SSAValue := {
        context builder tuple: (self tupleExpression generateSSAValueWith: context) typedSlotReferenceAt: self boundSlot.
    }.
}.

ASTTupleSlotNamedAtPutNode extend: {
    public override method doGenerateSSAValueWith: (context: SSAFunctionCompilationContext) ::=> SSAValue := {
        context builder tuple: (self tupleExpression generateSSAValueWith: context) typedSlotAt: self boundSlot put: (self valueExpression generateSSAValueWith: context).
    }.
}.

ASTUseNamedSlotsOfNode extend: {
    public override method doGenerateSSAValueWith: (context: SSAFunctionCompilationContext) ::=> SSAValue := {
        context setValue: (self tupleExpression generateSSAValueWith: context) forBinding: self binding.
        context builder literal: void.
    }.
}.

FunctionDefinition extend: {
    public method asSSAModuleForTarget: (compilationTarget: SSACompilationTarget) ::=> SSAModule
        := (SSAModuleCompilationContext forTarget: compilationTarget)
            exclusiveCompilationMode: true;
            compileFunctionDefinition: self;
            finish.

    public method asSSAModule => SSAModule
        := SSAModuleCompilationContext forDefaultTarget
            exclusiveCompilationMode: true;
            compileFunctionDefinition: self;
            finish.
}.

Function extend: {
    public method asSSAModuleForTarget: (compilationTarget: SSACompilationTarget) ::=> SSAModule
        := (SSAModuleCompilationContext forTarget: compilationTarget)
            exclusiveCompilationMode: true;
            declareFunction: self;
            compileFunctionDefinition: self definition;
            finish.

    public method asSSAModule => SSAModule
        := SSAModuleCompilationContext forDefaultTarget
            exclusiveCompilationMode: true;
            declareFunction: self;
            compileFunctionDefinition: self definition;
            finish.
}.
