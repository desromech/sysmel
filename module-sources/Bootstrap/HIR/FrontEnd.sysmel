public final class HIRModuleCompilationContext superclass: Object; definition: {
    public field compilationTarget => HIRCompilationTarget.
    public field hirModule => HIRModule.
    public field usedModules => OrderedCollection.
    public field exclusiveCompilationMode => Boolean.

    protected field translatedValueDictionary => IdentityDictionary.

    __Meta__ extend: {
        public method forTarget: (compilationTarget: HIRCompilationTarget) ::=> self
            := self new
                initializeWithTarget: compilationTarget;
                yourself.

        public method forDefaultTarget => self
            := self forTarget: HIRCompilationTarget default.
    }.

    public method initializeWithTarget: (theCompilationTarget: HIRCompilationTarget) ::=> Void := {
        compilationTarget := theCompilationTarget.
        hirModule := HIRModule new.
        translatedValueDictionary := IdentityDictionary new.
        usedModules := OrderedCollection new.
    }.

    public method addUsedModule: (usedModule: HIRModule) ::=> Void := {
        usedModules add: usedModule.
    }.

    public method findValueInUsedModule: value ::=> HIRValue := {
        let i mutable := 0sz.
        while: (i < usedModules size) do: {
            let module := usedModules at: i.
            let moduleValue := module getGlobalValueOrNilFor: value.
            moduleValue ifNotNil: {
                return: moduleValue 
            }
        } continueWith: (i := i + 1sz).
        nil
    }.

    public method compileFunctions: (functions: SequenceableCollection) definitions: (functionDefinitions: SequenceableCollection) ::=> Void := {
        let ssaFunctionDefinitions := functionDefinitions collect: {:(FunctionDefinition)eachFunctionDefinition :: HIRFunctionDefinition |
            self declareFunctionDefinition: eachFunctionDefinition
        }.

        functions do: {:(Function)eachFunction :: Void |
            self declareFunction: eachFunction
        }.

        ssaFunctionDefinitions doWithIndex: {:(HIRFunctionDefinition)eachHIRFunctionDefinition :(Size)index :: Void |
            let eachFunctionDefinition => FunctionDefinition := functionDefinitions at: index.
            self compileFunctionDefinition: eachFunctionDefinition into: eachHIRFunctionDefinition
        }.
    }.

    public method compileFunctionsWithDefinitions: (functions: SequenceableCollection) ::=> Void 
        := self compileFunctions: functions definitions: (functions collect: {:(Function)each :: FunctionDefinition | each definition}).

    public method compileFunctionDefinition: (functionDefinition: FunctionDefinition) ::=> Void := {
        let ssaFunctionDefinition := self declareFunctionDefinition: functionDefinition.
        self compileFunctionDefinition: functionDefinition into: ssaFunctionDefinition
    }.

    public method exportMainEntryPointFunction: (entryPointFunction: Function) ::=> Void := {
        let ssaEntryPointFunction => HIRFunction := translatedValueDictionary atOrNil: entryPointFunction.
        ssaEntryPointFunction ifNil: {return: void}.

        ssaEntryPointFunction exportedSymbols: ssaEntryPointFunction exportedSymbols -- (Array with: #main).
    }.

    public method generateArgumentForNode: (argumentNode: ASTArgumentNode) ::=> HIRFunctionArgument := {
        let binding := argumentNode binding.
        self assert: binding isNotNil.

        HIRFunctionArgument new
            name: binding name;
            type: binding type;
            sourceBinding: binding;
            yourself
    }.

    public method generateCaptureForBinding: (captureBinding: SymbolCaptureBinding) ::=> HIRFunctionCapture := {
        HIRFunctionCapture new
            name: captureBinding name;
            type: captureBinding type;
            sourceBinding: captureBinding;
            yourself
    }.

    public method declareFunctionDefinition: (functionDefinition: FunctionDefinition) ::=> HIRFunctionDefinition := {
        functionDefinition ensureAnalysis.
        ## HACK: Make sure this is properly done by the analysis section.
        functionDefinition boxDescriptor = 0uptr ifTrue: {
            functionDefinition boxDescriptor: functionDefinition analyzedType applicationBoxDescriptor
        }.

        let translatedValue := HIRFunctionDefinition new
            type: FunctionDefinition;
            sourceObject: functionDefinition;
            name: functionDefinition programEntityQualifiedNameSymbol;
            functionType: functionDefinition analyzedType;
            importedSymbols: functionDefinition importedSymbols asArray;
            primitiveName: functionDefinition analyzedPrimitiveName;
            sourcePosition: functionDefinition sourcePosition;
            isNoGC: functionDefinition isNoGC;
            arguments: (functionDefinition analyzedArgumentNodes collect: {:(ASTArgumentNode)argumentNode :: HIRFunctionArgument |
                self generateArgumentForNode: argumentNode
            }) asArray;
            captures: (functionDefinition analyzedCaptures collect: {:(SymbolCaptureBinding)captureBinding :: HIRFunctionCapture |
                self generateCaptureForBinding: captureBinding
            }) asArray;
            yourself.

        hirModule addGlobalValue: translatedValue.
        translatedValueDictionary at: functionDefinition put: translatedValue.
        translatedValue
    }.

    public method compileFunctionDefinition: (functionDefinition: FunctionDefinition) into: (ssaFunctionDefinition: HIRFunctionDefinition) ::=> Void := {
        HIRFunctionCompilationContext new
            moduleCompilationContext: self;
            compileFunctionDefinition: functionDefinition into: ssaFunctionDefinition.
    }.

    public method declareFunction: (function: Function) ::=> HIRFunction := {
        function ensureAnalysis.
        let translatedValue := HIRFunction new
            sourceObject: function;
            name: function programEntityQualifiedNameSymbol;
            primitiveName: function primitiveName;
            exportedSymbols: function exportedSymbols asArray;
            type: function __type__;
            yourself.

        hirModule addGlobalValue: translatedValue.
        translatedValueDictionary at: function put: translatedValue.

        function definition ifNotNil: {
            translatedValue definition: ((self translateFunctionDefinition: function definition) downCastTo: HIRFunctionDefinition).
        }.
        
        translatedValue
    }.

    public method translateFunction: (function: Function) withBuilder: (builder: HIRInstructionBuilder) ::=> HIRValue := {
        translatedValueDictionary at: function ifAbsent: { :: HIRValue |
            let importedValue := self findValueInUsedModule: function.
            importedValue ifNotNil: {
                translatedValueDictionary at: function put: importedValue.
                importedValue
            } ifNil: {
                exclusiveCompilationMode ifTrue: {
                    builder literal: function type: function class
                } ifFalse: {
                    self declareFunction: function
                }
            }.
        }
    }.

    public method translateFunction: (function: Function) ::=> HIRValue
        := self translateFunction: function withBuilder: nil.

    public method translateFunctionDefinition: (functionDefinition: FunctionDefinition) withBuilder: (builder: HIRInstructionBuilder) ::=> HIRValue := {
        functionDefinition ensureAnalysis.
        translatedValueDictionary at: functionDefinition ifAbsent: { :: HIRValue |
            let importedValue := self findValueInUsedModule: functionDefinition.
            importedValue ifNotNil: {
                translatedValueDictionary at: functionDefinition put: importedValue.
                importedValue downCastTo: HIRFunctionDefinition
            } ifNil: {
                exclusiveCompilationMode ifTrue: {
                    builder ifNotNil: (builder literal: functionDefinition type: functionDefinition class)
                } ifFalse: {
                    let ssaFunctionDefinition := self declareFunctionDefinition: functionDefinition.
                    self compileFunctionDefinition: functionDefinition into: ssaFunctionDefinition.
                    ssaFunctionDefinition
                }
            }
        }
    }.

    public method translateFunctionDefinition: (functionDefinition: FunctionDefinition) ::=> HIRValue
        := self translateFunctionDefinition: functionDefinition withBuilder: nil.

    public method declareGlobalVariableForSymbolValueBinding: (binding: SymbolValueBinding) ::=> HIRGlobalVariable := {
        let translatedValue := HIRGlobalVariable new
            sourceBinding: binding;
            referenceValue: binding value;
            name: binding programEntityQualifiedNameSymbol;
            type: binding type;
            valueType: binding valueType;
            isExternal: binding isExternal;
            isThreadLocal: binding isThreadLocal;
            yourself.

        hirModule addGlobalValue: translatedValue.
        translatedValueDictionary at: binding put: translatedValue.

        translatedValue
    }.

    public method getOrCreateGlobalVariableForSymbolValueBinding: (binding: SymbolValueBinding) ::=> HIRGlobalVariable := {
        self assert: binding isMutable.
        translatedValueDictionary at: binding ifAbsent: { :: HIRGlobalVariable |
            let importedValue := self findValueInUsedModule: binding.
            importedValue ifNotNil: {
                translatedValueDictionary at: binding put: importedValue.
                importedValue downCastTo: HIRGlobalVariable
            } ifNil: {
                self declareGlobalVariableForSymbolValueBinding: binding
            }
        }.
    }.

    public method finish => HIRModule := {
        hirModule
    }.
}.

public final class HIRFunctionCompilationContext superclass: Object.

let primitiveFunctionContentGenerator := #{
    #ObjectModel::isLogical : {:(HIRFunctionCompilationContext)context :: HIRValue |
        context builder literal: context compilationTarget hasLogicalObjectModel
    }.
    #ObjectModel::isNative : {:(HIRFunctionCompilationContext)context :: HIRValue |
        context builder literal: context compilationTarget hasNativeObjectModel
    }.
}.

HIRFunctionCompilationContext definition: {
    public field moduleCompilationContext => HIRModuleCompilationContext.
    public field functionDefinition => FunctionDefinition.
    public field ssaFunction => HIRFunctionDefinition.
    public field builder => HIRInstructionBuilder.
    protected field bindingDictionary => IdentityDictionary.

    public field breakDestination => HIRBasicBlock.
    public field continueDestination => HIRBasicBlock.

    public method compilationTarget => HIRCompilationTarget
        := moduleCompilationContext compilationTarget.

    public override method initialize => Void := {
        super initialize.
        bindingDictionary := IdentityDictionary new.
    }.

    public method setValue: (value: HIRValue) forBinding: (binding: SymbolBinding) ::=> Void := {
        self assert: binding isNotNil.
        bindingDictionary at: binding put: value.
    }.

    public method compileFunctionDefinition: (functionDefinition: FunctionDefinition) into: (ssaFunction: HIRFunctionDefinition) ::=> Void := {
        functionDefinition ensureAnalysis.
        self functionDefinition: functionDefinition.
        self ssaFunction: ssaFunction.

        ssaFunction arguments do: {:(HIRFunctionArgument)eachArgument :: Void |
            eachArgument sourceBinding ifNotNil: {
                self setValue: eachArgument forBinding: eachArgument sourceBinding
            }
        }.
        ssaFunction captures do: {:(HIRFunctionCapture)eachCapture :: Void |
            eachCapture sourceBinding ifNotNil: {
                self setValue: eachCapture forBinding: eachCapture sourceBinding
            }
        }.

        functionDefinition importedSymbols size = 0sz ifTrue: {
            functionDefinition analyzedBodyNode ifNotNil: {:bodyNode |
                self builder: (HIRInstructionBuilder new
                    sourcePosition: bodyNode sourcePosition;
                    function: ssaFunction;
                    beginBasicBlockNamed: #entry;
                    yourself).

                let primitiveGenerator := primitiveFunctionContentGenerator atOrNil: functionDefinition analyzedPrimitiveName.
                let resultValue := primitiveGenerator ifNotNil: {
                    primitiveGenerator(self)
                } ifNil: {
                    bodyNode generateHIRValueWith: self.
                }.
                self builder isLastTerminator ifFalse: (self builder return: resultValue).
            }.
        }.
    }.

    public method getValueForLocalBinding: (localBinding: SymbolAnalysisBinding) ::=> HIRValue
        := bindingDictionary at: localBinding.

    public method functionDefinitionValueFor: (functionDefinition: FunctionDefinition) ::=> HIRValue
        := self builder literal: functionDefinition.

    public method withBreakDestination: (breakDestination: HIRBasicBlock) continueDestination: (continueDestination: HIRBasicBlock) do: aBlock := {
        let oldBreakDestination := self breakDestination.
        let oldContinueDestination := self continueDestination.

        self
            breakDestination: breakDestination;
            continueDestination: continueDestination.
        
        let result := aBlock().

        self
            breakDestination: oldBreakDestination;
            continueDestination: oldContinueDestination.

        result
    }.
}.

ASTNode extend: {
    public method generateHIRValueWith: (context: HIRFunctionCompilationContext) ::=> HIRValue
        := context builder withSourceASTNode: self do: {:: HIRValue |
            self doGenerateHIRValueWith: context
    }.

    public abstract method doGenerateHIRValueWith: (context: HIRFunctionCompilationContext) ::=> HIRValue
        := self subclassResponsibility.
}.

ASTBreakNode extend: {
    public override method doGenerateHIRValueWith: (context: HIRFunctionCompilationContext) ::=> HIRValue := {
        context breakDestination ifNil: (self error: "Invalid break at this location.").
        context builder branch: context breakDestination.
        context builder literal: void
    }.
}.

ASTCoerceValueNode extend: {
    public override method doGenerateHIRValueWith: (context: HIRFunctionCompilationContext) ::=> HIRValue := {
        let type := self typeExpression generateHIRValueWith: context.
        let value := self valueExpression generateHIRValueWith: context.
        context builder coerceValue: value into: type type: self analyzedType
    }.        
}.

ASTContinueNode extend: {
    public override method doGenerateHIRValueWith: (context: HIRFunctionCompilationContext) ::=> HIRValue := {
        context continueDestination ifNil: (self error: "Invalid continue at this location.").
        context builder branch: context continueDestination.
        context builder literal: void
    }.
}.

ASTDownCastNode extend: {
    public override method doGenerateHIRValueWith: (context: HIRFunctionCompilationContext) ::=> HIRValue := {
        let type := self typeExpression generateHIRValueWith: context.
        let value := self valueExpression generateHIRValueWith: context.
        context builder unchecked: self isUnchecked downCast: value into: type type: self analyzedType
    }.        
}.

let primitiveFunctionGenerators := #{
    #basicAllocate : {:(ASTFunctionApplicationNode)self :(HIRFunctionCompilationContext)context :: HIRValue |
        let typeNode => ASTNode := self arguments first.
        typeNode isLiteralNode && (typeNode analyzedType isSubtypeOf: Type) ifFalse: {return: nil}.

        let type => Type := (typeNode downCastTo: ASTLiteralNode) value.
        type isValueType ifFalse: {return: nil}.
        
        self analyzedType == type ifTrue: {
            context builder literal: type defaultValue type: self analyzedType
        } ifFalse: {
            context builder alloca: (context builder literal: type) type: self analyzedType
        }
    }.

    #basicNew : {:(ASTFunctionApplicationNode)self :(HIRFunctionCompilationContext)context :: HIRValue |
        let typeNode => ASTNode := self arguments first.
        typeNode isLiteralNode && (typeNode analyzedType isSubtypeOf: Type) ifFalse: {return: nil}.

        let type => Type := (typeNode downCastTo: ASTLiteralNode) value.
        type isValueType ifFalse: {return: nil}.
        
        self analyzedType == type ifTrue: {
            context builder literal: type defaultValue type: self analyzedType
        } ifFalse: {
            let result := context builder alloca: (context builder literal: type) type: self analyzedType.

            ## Basic initialize.
            type needsNonDefaultBasicInitialization ifTrue: {
                let basicInitializeMethod := type validBasicInitializeMethod.
                basicInitializeMethod ifNotNil: {
                    context builder call: (context moduleCompilationContext translateFunction: basicInitializeMethod withBuilder: context builder)
                        arguments: (Array with: result)
                        resultType: Void.
                }
            }.

            result.
        }
    }.

    #new : {:(ASTFunctionApplicationNode)self :(HIRFunctionCompilationContext)context :: HIRValue |
        let typeNode => ASTNode := self arguments first.
        typeNode isLiteralNode && (typeNode analyzedType isSubtypeOf: Type) ifFalse: {return: nil}.

        let type => Type := (typeNode downCastTo: ASTLiteralNode) value.
        type isValueType ifFalse: {return: nil}.
        
        self analyzedType == type ifTrue: {
            context builder literal: type defaultValue type: self analyzedType
        } ifFalse: {
            let result := context builder alloca: (context builder literal: type) type: self analyzedType.

            ## Basic initialize.
            type needsNonDefaultBasicInitialization ifTrue: {
                let basicInitializeMethod := type validBasicInitializeMethod.
                basicInitializeMethod ifNotNil: {
                    context builder call: (context moduleCompilationContext translateFunction: basicInitializeMethod withBuilder: context builder)
                        arguments: (Array with: result)
                        resultType: Void.
                }
            }.

            ## Initialize.
            let initializeMethod := type lookupSelector: #initialize.
            initializeMethod isNotNil && (initializeMethod ~~ (AnyValue >> #initialize)) ifTrue: {
                context builder call: (context moduleCompilationContext translateFunction: initializeMethod withBuilder: context builder)
                    arguments: (Array with: result)
                    resultType: Void.
            }.

            result.
        }
    }.

    #PointerType::reinterpretCastTo: : {:(ASTFunctionApplicationNode)self :(HIRFunctionCompilationContext)context :: HIRValue |
        let pointer := self arguments first generateHIRValueWith: context.
        let targetType := self arguments second generateHIRValueWith: context.
        context builder pointerOrIntegerReinterpretCast: pointer into: targetType type: self analyzedType
    }.
    #UIntPointer::reinterpretCastTo: : {:(ASTFunctionApplicationNode)self :(HIRFunctionCompilationContext)context :: HIRValue |
        let pointer := self arguments first generateHIRValueWith: context.
        let targetType := self arguments second generateHIRValueWith: context.
        context builder pointerOrIntegerReinterpretCast: pointer into: targetType type: self analyzedType
    }.
    #IntPointer::reinterpretCastTo: : {:(ASTFunctionApplicationNode)self :(HIRFunctionCompilationContext)context :: HIRValue |
        let pointer := self arguments first generateHIRValueWith: context.
        let targetType := self arguments second generateHIRValueWith: context.
        context builder pointerOrIntegerReinterpretCast: pointer into: targetType type: self analyzedType
    }.

    #PointerLikeType::reinterpretCast : {:(ASTFunctionApplicationNode)self :(HIRFunctionCompilationContext)context :: HIRValue |
        let pointer := self arguments first generateHIRValueWith: context.
        let targetType := self analyzedType.
        context builder pointerOrIntegerReinterpretCast: pointer into: (context builder literal: targetType) type: targetType
    }.

    #PointerLikeType::at: : {:(ASTFunctionApplicationNode)self :(HIRFunctionCompilationContext)context :: HIRValue |
        let pointer := self arguments first generateHIRValueWith: context.
        let index := self arguments second generateHIRValueWith: context.
        context builder pointer: pointer elementAt: index type: self analyzedType
    }.

    #PointerLikeType::load : {:(ASTFunctionApplicationNode)self :(HIRFunctionCompilationContext)context :: HIRValue |
        let reference := self arguments first generateHIRValueWith: context.
        self analyzedType isTemporaryReferenceType ifTrue: {
            let valueType := (self analyzedType downCastTo: ReferenceLikeType) baseType.
            self assert: valueType isNotNil.
            let temporary := context builder alloca: (context builder literal: valueType) type: self analyzedType.
            context builder store: (context builder load: reference type: valueType) in: temporary.
            temporary
        } ifFalse: {
            context builder load: reference type: self analyzedType
        }.
    }.
    #PointerLikeType::store: : {:(ASTFunctionApplicationNode)self :(HIRFunctionCompilationContext)context :: HIRValue |
        let reference := self arguments first generateHIRValueWith: context.
        let value := self arguments second generateHIRValueWith: context.
        context builder store: value in: reference.
        reference
    }.

    #FixedArray::at: : {:(ASTFunctionApplicationNode)self :(HIRFunctionCompilationContext)context :: HIRValue |
        let reference := self arguments first generateHIRValueWith: context.
        let index := self arguments second generateHIRValueWith: context.
        let referenceType => PointerLikeType := self arguments first analyzedType.
        let fixedArrayType := referenceType baseType downCastTo: FixedArrayType.
        let elementReferenceType := fixedArrayType elementType refFor: referenceType addressSpace.
        let elementReference := context builder reference: reference elementAt: index type: elementReferenceType.
        context builder load: elementReference type: self analyzedType
    }.
    #FixedArray::at:put: : {:(ASTFunctionApplicationNode)self :(HIRFunctionCompilationContext)context :: HIRValue |
        let reference := self arguments first generateHIRValueWith: context.
        let index := self arguments second generateHIRValueWith: context.
        let value := self arguments third generateHIRValueWith: context.
        let referenceType => PointerLikeType := self arguments first analyzedType.
        let fixedArrayType := referenceType baseType downCastTo: FixedArrayType.
        let elementReferenceType := fixedArrayType elementType refFor: referenceType addressSpace.
        let elementReference := context builder reference: reference elementAt: index type: elementReferenceType.
        context builder
            store: value in: elementReference;
            literal: void
    }.
    #FixedArray::refAt: : {:(ASTFunctionApplicationNode)self :(HIRFunctionCompilationContext)context :: HIRValue |
        let reference := self arguments first generateHIRValueWith: context.
        let index := self arguments second generateHIRValueWith: context.
        context builder reference: reference elementAt: index type: self analyzedType
    }.

    #Void::fromAnyValue : {:(ASTFunctionApplicationNode)self :(HIRFunctionCompilationContext)context :: HIRValue |
        self arguments do: {:(ASTNode)each :: Void | each generateHIRValueWith: context }.
        context builder literal: void
    }.
    #yourself : {:(ASTFunctionApplicationNode)self :(HIRFunctionCompilationContext)context :: HIRValue |
        self arguments first generateHIRValueWith: context
    }.
    #RawTuple::typeSlotAt: : {:(ASTFunctionApplicationNode)self :(HIRFunctionCompilationContext)context :: HIRValue |
        self arguments second isLiteralNode ifTrue: {
            let tuple := self arguments first generateHIRValueWith: context.
            let typeSlot => TypeSlot := self arguments second value.
            
            context builder tuple: tuple typedSlotAt: typeSlot.
        } ifFalse: {
            nil
        }.
    }.
    #RawTuple::typeSlotAt:put: : {:(ASTFunctionApplicationNode)self :(HIRFunctionCompilationContext)context :: HIRValue |
        self arguments second isLiteralNode ifTrue: {
            let tuple := self arguments first generateHIRValueWith: context.
            let typeSlot => TypeSlot := self arguments second value.
            let value := self arguments third generateHIRValueWith: context.
            
            context builder tuple: tuple typedSlotAt: typeSlot put: value.
        } ifFalse: {
            nil
        }.
    }.
    #RawTuple::refTypeSlotAt: : {:(ASTFunctionApplicationNode)self :(HIRFunctionCompilationContext)context :: HIRValue |
        self arguments second isLiteralNode ifTrue: {
            let tuple := self arguments first generateHIRValueWith: context.
            let typeSlot => TypeSlot := self arguments second value.
            
            context builder tuple: tuple typedSlotAt: typeSlot.
        } ifFalse: {
            nil
        }.
    }.
    #RawTuple::refTypeSlotAt:put: : {:(ASTFunctionApplicationNode)self :(HIRFunctionCompilationContext)context :: HIRValue |
        self arguments second isLiteralNode ifTrue: {
            let tuple := self arguments first generateHIRValueWith: context.
            let typeSlot => TypeSlot := self arguments second value.
            let value := self arguments third generateHIRValueWith: context.
            
            context builder tuple: tuple typedSlotAt: typeSlot put: value.
        } ifFalse: {
            nil
        }.
    }.

    #ObjectModel::isLogical : {:(ASTFunctionApplicationNode)self :(HIRFunctionCompilationContext)context :: HIRValue |
        context builder literal: context compilationTarget hasLogicalObjectModel
    }.
    #ObjectModel::isNative : {:(ASTFunctionApplicationNode)self :(HIRFunctionCompilationContext)context :: HIRValue |
        context builder literal: context compilationTarget hasNativeObjectModel
    }.
}.

ASTFunctionApplicationNode extend: {
    public override method doGenerateHIRValueWith: (context: HIRFunctionCompilationContext) ::=> HIRValue := {
        let primitiveGenerator := primitiveFunctionGenerators atOrNil: self functionExpression literalFunctionPrimitiveName.
        (primitiveGenerator ifNotNil: {
            primitiveGenerator(self, context)
        }) ifNil: {
            let functionExpression := self functionExpression generateHIRValueWith: context.
            let callInstruction := context builder call: functionExpression
                arguments: (self arguments collect: {:(ASTNode)each :: HIRValue | each generateHIRValueWith: context }) asArray
                resultType: self analyzedType.
            
            callInstruction isUnchecked: self isNoTypechecked.

            (callInstruction type isSubtypeOf: ControlFlowEscapeType) ifTrue: {
                context builder
                    unreachable;
                    beginBasicBlockNamed: #deadCode;
                    literal: void
            } ifFalse: {
                callInstruction type isVoidType
                    ifTrue: (context builder literal: void)
                    ifFalse: callInstruction
            }
        }.
    }.
}.

ASTLexicalBlockNode extend: {
    public override method doGenerateHIRValueWith: (context: HIRFunctionCompilationContext) ::=> HIRValue
        := context builder withSourceEnvironment: self bodyEnvironment do: {:: HIRValue | self body generateHIRValueWith: context }.
}.

Type extend: {
    public virtual method translateASTLiteralNode: (literalNode: ASTLiteralNode) intoHIRValueWith: (context: HIRFunctionCompilationContext) ::=> HIRValue
        := context builder literal: literalNode value type: literalNode analyzedType.
}.

FunctionType extend: {
    public override method translateASTLiteralNode: (literalNode: ASTLiteralNode) intoHIRValueWith: (context: HIRFunctionCompilationContext) ::=> HIRValue
        := context moduleCompilationContext translateFunction: literalNode value withBuilder: context builder.
}.

FunctionDefinition class extend: {
    public override method translateASTLiteralNode: (literalNode: ASTLiteralNode) intoHIRValueWith: (context: HIRFunctionCompilationContext) ::=> HIRValue
        := context moduleCompilationContext translateFunctionDefinition: literalNode value withBuilder: context builder.
}.

ASTLiteralNode extend: {
    public override method doGenerateHIRValueWith: (context: HIRFunctionCompilationContext) ::=> HIRValue
        := self analyzedType translateASTLiteralNode: self intoHIRValueWith: context.
}.

ASTLambdaNode extend: {
    public override method doGenerateHIRValueWith: (context: HIRFunctionCompilationContext) ::=> HIRValue := {
        let functionDefinition := self functionDefinition.
        functionDefinition ensureAnalysis.

        let functionDefinitionValue := context functionDefinitionValueFor: functionDefinition.

        let captures := functionDefinition analyzedCaptures collect: {:(SymbolCaptureBinding)capture :: HIRValue |
            context getValueForLocalBinding: capture sourceBinding
        }.

        context builder makeClosure: functionDefinitionValue captures: captures type: self analyzedType
    }.
}.

ASTVariableDefinitionNode extend: {
    public override method doGenerateHIRValueWith: (context: HIRFunctionCompilationContext) ::=> HIRValue := {
        let builder := context builder.

        let value := self valueExpression generateHIRValueWith: context.

        self isMutable ifTrue: {
            self assert: self analyzedValueType isNotNil.
            let localVariable := builder alloca: (builder literal: self analyzedValueType) type: self analyzedType.
            builder store: value in: localVariable.
            context setValue: localVariable forBinding: self binding.
            self binding hasValidNameForDebugging ifTrue: {
                context builder setDebugValue: localVariable forBinding: self binding.
            }.
            localVariable
        } ifFalse: {
            context setValue: value forBinding: self binding.
            self binding hasValidNameForDebugging ifTrue: {
                context builder setDebugValue: value forBinding: self binding.
            }.
            value
        }
    }.
}.

SymbolBinding extend: {
    public abstract method generateHIRValueWith: (context: HIRFunctionCompilationContext) ::=> HIRValue
        := self subclassResponsibility.
}.

SymbolAnalysisBinding extend: {
    public override method generateHIRValueWith: (context: HIRFunctionCompilationContext) ::=> HIRValue
        := context getValueForLocalBinding: self.
}.

SymbolValueBinding extend: {
    public override method generateHIRValueWith: (context: HIRFunctionCompilationContext) ::=> HIRValue := {
        isMutable ifTrue: {
            context moduleCompilationContext getOrCreateGlobalVariableForSymbolValueBinding: self
        } ifFalse: {
            context builder literal: (self __slotNamedAt__: #value)
        }
    }.
}.

SymbolTupleSlotBinding extend: {
    public override method generateHIRValueWith: (context: HIRFunctionCompilationContext) ::=> HIRValue := {
        let tupleValue := tupleBinding generateHIRValueWith: context.
        context builder tuple: tupleValue typedSlotReferenceAt: typeSlot.
    }
}.

ASTIdentifierReferenceNode extend: {
    public override method doGenerateHIRValueWith: (context: HIRFunctionCompilationContext) ::=> HIRValue
        := self binding generateHIRValueWith: context.
}.

ASTIfNode extend: {
    public override method doGenerateHIRValueWith: (context: HIRFunctionCompilationContext) ::=> HIRValue := {
        let builder := context builder.

        ## Condition
        let condition := conditionExpression
            ifNotNil: (conditionExpression generateHIRValueWith: context)
            ifNil: (builder literal: false).

        ## Optimize out true constant literal.
        condition isLiteralConstantTrue ifTrue: {
            return: (trueExpression ifNotNil: {
                trueExpression generateHIRValueWith: context
            } ifNil: {
                builder literal: void
            })
        }.

        ## Optimize out false constant literal.
        condition isLiteralConstantFalse ifTrue: {
            return: (falseExpression ifNotNil: {
                falseExpression generateHIRValueWith: context
            } ifNil: {
                builder literal: void
            })
        }.
        
        let conditionBlock := builder basicBlock.
        let mergeBlock := builder newBasicBlockNamed: #ifMerge.

        let trueExpression := self trueExpression.
        let trueDestination := trueExpression
            ifNotNil: (builder newBasicBlockNamed: #ifTrue)
            ifNil: mergeBlock.

        let falseExpression := self falseExpression.
        let falseDestination := falseExpression
            ifNotNil: (builder newBasicBlockNamed: #ifFalse)
            ifNil: mergeBlock.

        builder conditionalBranch: condition trueDestination: trueDestination falseDestination: falseDestination.

        ## True branch
        let trueResult mutable => HIRValue := nil.
        let trueResultBlock mutable := conditionBlock.
        let trueResultIsTerminator mutable := false.

        trueExpression ifNotNil: {
            builder beginBasicBlock: trueDestination.
            trueResult := trueExpression generateHIRValueWith: context.
            trueResultBlock := builder basicBlock.

            let isTerminator := builder isLastTerminator.
            trueResultIsTerminator := isTerminator.
            isTerminator
                ifTrue: (trueResult := builder literal: void)
                ifFalse: (builder branch: mergeBlock)
        } ifNil: {
            trueResult := builder literal: void
        }.

        ## False branch
        let falseResult mutable => HIRValue := nil.
        let falseResultBlock mutable := conditionBlock.
        let falseResultIsTerminator mutable := false.
        falseExpression ifNotNil: {
            builder beginBasicBlock: falseDestination.
            falseResult := falseExpression generateHIRValueWith: context.
            falseResultBlock := builder basicBlock.

            let isTerminator := builder isLastTerminator.
            falseResultIsTerminator := isTerminator.
            isTerminator
                ifTrue: (falseResult := builder literal: void)
                ifFalse: (builder branch: mergeBlock)
        } ifNil: {
            falseResult := builder literal: void
        }.

        ## Merge
        builder beginBasicBlock: mergeBlock.
        if: self analyzedType isVoidType || (trueResultIsTerminator && falseResultIsTerminator) then: {
            builder literal: void
        } else: {
            trueResultIsTerminator ifTrue: (
                falseResult
            ) ifFalse: (
                falseResultIsTerminator ifTrue: (
                    trueResult
                ) ifFalse: (
                    (builder phi: self analyzedType)
                        addValue: trueResult incomingFrom: trueResultBlock;
                        addValue: falseResult incomingFrom: falseResultBlock;
                        yourself
                )
            ).
        }
    }
}.

ASTDoWhileContinueWithNode extend: {
    public override method doGenerateHIRValueWith: (context: HIRFunctionCompilationContext) ::=> HIRValue := {
        let builder := context builder.

        let conditionExpression := self conditionExpression.
        let bodyExpression := self bodyExpression.
        let continueExpression := self continueExpression.

        let entryBlock := builder newBasicBlockNamed: #doWhileBody.
        let conditionBlock := builder newBasicBlockNamed: #doWhileCondition.
        let continueBlock := continueExpression
            ifNil: (entryBlock)
            ifNotNil: (builder newBasicBlockNamed: #doWhileContinue).
        let mergeBlock := builder newBasicBlockNamed: #doWhileMerge.

        builder
            branch: entryBlock;
            beginBasicBlock: entryBlock.

        ## Emit the body.
        bodyExpression ifNotNil: {
            context withBreakDestination: mergeBlock continueDestination: continueBlock do: {:: Void |
                bodyExpression generateHIRValueWith: context.
                builder isLastTerminator ifFalse: {
                    builder branch: conditionBlock
                }.
            }
        }.

        ## Emit the condition.
        builder beginBasicBlock: conditionBlock.
        conditionExpression ifNil: {
            builder branch: continueBlock
        } ifNotNil: {
            let condition := conditionExpression generateHIRValueWith: context.
            builder isLastTerminator ifFalse: {
                builder conditionalBranch: condition trueDestination: continueBlock falseDestination: mergeBlock
            }
        }.

        ## Emit the optional continue expression.
        continueExpression ifNotNil: {
            builder beginBasicBlock: continueBlock.
            continueExpression generateHIRValueWith: context.
            builder isLastTerminator ifFalse: {
                builder branch: entryBlock
            }.
        }.

        builder beginBasicBlock: mergeBlock.
        builder literal: void
    }
}.

ASTWhileContinueWithNode extend: {
    public override method doGenerateHIRValueWith: (context: HIRFunctionCompilationContext) ::=> HIRValue := {
        let builder := context builder.

        let conditionExpression := self conditionExpression.
        let bodyExpression := self bodyExpression.
        let continueExpression := self continueExpression.

        let entryBlock := builder newBasicBlockNamed: #whileEntry.
        let bodyBlock := builder newBasicBlockNamed: #whileBody.
        let continueBlock := continueExpression
            ifNil: (entryBlock)
            ifNotNil: (builder newBasicBlockNamed: #whileContinue).
        let mergeBlock := builder newBasicBlockNamed: #whileMerge.

        builder
            branch: entryBlock;
            beginBasicBlock: entryBlock.

        ## Emit the condition.
        conditionExpression ifNil: {
            builder branch: bodyBlock
        } ifNotNil: {
            let condition := conditionExpression generateHIRValueWith: context.
            builder isLastTerminator ifFalse: {
                builder conditionalBranch: condition trueDestination: bodyBlock falseDestination: mergeBlock
            }
        }.

        ## Emit the body.
        builder beginBasicBlock: bodyBlock.
        bodyExpression ifNotNil: {
            context withBreakDestination: mergeBlock continueDestination: continueBlock do: {:: Void |
                bodyExpression generateHIRValueWith: context.
                builder isLastTerminator ifFalse: {
                    builder branch: continueBlock
                }.
            }
        }.

        ## Emit the optional continue expression.
        continueExpression ifNotNil: {
            builder beginBasicBlock: continueBlock.
            continueExpression generateHIRValueWith: context.
            builder isLastTerminator ifFalse: {
                builder branch: entryBlock
            }.
        }.

        builder beginBasicBlock: mergeBlock.
        builder literal: void
    }
}.

ASTMakeArrayNode extend: {
    public override method doGenerateHIRValueWith: (context: HIRFunctionCompilationContext) ::=> HIRValue
        := context builder makeArray: (self elements collect: {:(ASTNode)each :: HIRValue | each generateHIRValueWith: context }).
}.

ASTMakeAssociationNode extend: {
    public override method doGenerateHIRValueWith: (context: HIRFunctionCompilationContext) ::=> HIRValue
        := context builder makeAssociationWithKey: (self key generateHIRValueWith: context)
            value: (self value
                ifNotNil: (self value generateHIRValueWith: context)
                ifNil: (context builder literal: nil)).
}.

ASTMakeByteArrayNode extend: {
    public override method doGenerateHIRValueWith: (context: HIRFunctionCompilationContext) ::=> HIRValue
        := context builder makeByteArray: (self elements collect: {:(ASTNode)each :: HIRValue | each generateHIRValueWith: context }).
}.

ASTMakeDictionaryNode extend: {
    public override method doGenerateHIRValueWith: (context: HIRFunctionCompilationContext) ::=> HIRValue
        := context builder makeDictionary: (self elements collect: {:(ASTNode)each :: HIRValue | each generateHIRValueWith: context })
}.

ASTMessageSendNode extend: {
    public override method doGenerateHIRValueWith: (context: HIRFunctionCompilationContext) ::=> HIRValue := {
        let sendInstruction := context builder send: (self receiver generateHIRValueWith: context)
            receiverLookupType: (self receiverLookupType ifNotNil: {:(ASTNode)lookupTypeExpression :: HIRValue | lookupTypeExpression generateHIRValueWith: context })
            selector: (self selector generateHIRValueWith: context)
            arguments: (self arguments collect: {:(ASTNode)each :: HIRValue | each generateHIRValueWith: context }) asArray
            resultType: self analyzedType.

        sendInstruction isUnchecked: self isNoTypechecked.

        (sendInstruction type isSubtypeOf: ControlFlowEscapeType) ifTrue: {
            context builder
                unreachable;
                beginBasicBlockNamed: #deadCode;
                literal: void
        } ifFalse: {
            sendInstruction type isVoidType
                ifTrue: (context builder literal: void)
                ifFalse: sendInstruction
        }
    }
}.

ASTReturnNode extend: {
    public override method doGenerateHIRValueWith: (context: HIRFunctionCompilationContext) ::=> HIRValue
        := context builder return: (self expression generateHIRValueWith: context)
}.

ASTSequenceNode extend: {
    public override method doGenerateHIRValueWith: (context: HIRFunctionCompilationContext) ::=> HIRValue := {
        let voidLiteral :=  context builder literal: void.
        let result mutable => HIRValue := voidLiteral.
        self expressions do: {:(ASTNode)expression :: Void |
            context builder isLastTerminator ifTrue: {
                result := voidLiteral
            } ifFalse: {
                result := expression generateHIRValueWith: context
            }
        }.

        result
    }
}.

ASTTupleSlotNamedAtNode extend: {
    public override method doGenerateHIRValueWith: (context: HIRFunctionCompilationContext) ::=> HIRValue := {
        context builder tuple: (self tupleExpression generateHIRValueWith: context) typedSlotAt: self boundSlot.
    }.
}.

ASTTupleSlotNamedReferenceAtNode extend: {
    public override method doGenerateHIRValueWith: (context: HIRFunctionCompilationContext) ::=> HIRValue := {
        context builder tuple: (self tupleExpression generateHIRValueWith: context) typedSlotReferenceAt: self boundSlot.
    }.
}.

ASTTupleSlotNamedAtPutNode extend: {
    public override method doGenerateHIRValueWith: (context: HIRFunctionCompilationContext) ::=> HIRValue := {
        context builder tuple: (self tupleExpression generateHIRValueWith: context) typedSlotAt: self boundSlot put: (self valueExpression generateHIRValueWith: context).
    }.
}.

ASTUseNamedSlotsOfNode extend: {
    public override method doGenerateHIRValueWith: (context: HIRFunctionCompilationContext) ::=> HIRValue := {
        context setValue: (self tupleExpression generateHIRValueWith: context) forBinding: self binding.
        context builder literal: void.
    }.
}.

FunctionDefinition extend: {
    public method asHIRModuleForTarget: (compilationTarget: HIRCompilationTarget) ::=> HIRModule
        := (HIRModuleCompilationContext forTarget: compilationTarget)
            exclusiveCompilationMode: true;
            compileFunctionDefinition: self;
            finish.

    public method asHIRModule => HIRModule
        := HIRModuleCompilationContext forDefaultTarget
            exclusiveCompilationMode: true;
            compileFunctionDefinition: self;
            finish.
}.

Function extend: {
    public method asHIRModuleForTarget: (compilationTarget: HIRCompilationTarget) ::=> HIRModule
        := (HIRModuleCompilationContext forTarget: compilationTarget)
            exclusiveCompilationMode: true;
            declareFunctionDefinition: self definition;
            declareFunction: self;
            compileFunctionDefinition: self definition;
            finish.

    public method asHIRModule => HIRModule
        := HIRModuleCompilationContext forDefaultTarget
            exclusiveCompilationMode: true;
            declareFunctionDefinition: self definition;
            declareFunction: self;
            compileFunctionDefinition: self definition;
            finish.
}.
