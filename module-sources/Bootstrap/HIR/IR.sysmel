public abstract class HIRCompilationTarget superclass: Object.

public class HIRValue superclass: Object.
public class HIRConstant superclass: HIRValue.
public class HIRGlobalValue superclass: HIRConstant.
public class HIRFunction superclass: HIRGlobalValue.
public class HIRFunctionDefinition superclass: HIRGlobalValue.
public class HIRFunctionLocalValue superclass: HIRValue.
public final class HIRFunctionArgument superclass: HIRFunctionLocalValue.
public final class HIRFunctionCapture superclass: HIRFunctionLocalValue.
public class HIRBasicBlock superclass: HIRFunctionLocalValue.
public class HIRInstruction superclass: HIRFunctionLocalValue.
public final class HIRPhiInstruction superclass: HIRInstruction.
public final class HIRInstructionBuilder superclass: Object.

HIRValue definition: {
    public field type => Type.
    public field sourcePosition => SourcePosition.
    public field sourceASTNode => ASTNode.
    public field sourceEnvironment => Environment.
    private field users => WeakOrderedCollection.

    public virtual method isConstant => Boolean := false.
    public virtual method isLiteralConstant => Boolean := false.
    public virtual method isLiteralConstantTrue => Boolean := false.
    public virtual method isLiteralConstantFalse => Boolean := false.
    public virtual method isUndefinedConstant => Boolean := false.
    public virtual method isEvaluableConstant => Boolean := false.

    public virtual method isCaptureless => Boolean := false.

    public virtual method isFunction => Boolean := false.
    public virtual method isFunctionDefinition => Boolean := false.
    public virtual method isFunctionLocalValue => Boolean := false.
    public virtual method isBasicBlock => Boolean := false.
    
    public virtual method isInstruction => Boolean := false.
    public virtual method isAllocaInstruction => Boolean := false.
    public virtual method isBranchInstruction => Boolean := false.
    public virtual method isCallInstruction => Boolean := false.
    public virtual method isConditionalBranchInstruction => Boolean := false.
    public virtual method isDownCastInstruction => Boolean := false.
    public virtual method isPhiInstruction => Boolean := false.
    public virtual method isReferenceElementAtInstruction => Boolean := false.
    public virtual method isPointerElementAtInstruction => Boolean := false.
    public virtual method isLoadInstruction => Boolean := false.
    public virtual method isLoadStoreOrDebugBindingInstruction => Boolean := false.
    public virtual method isMakeArrayInstruction => Boolean := false.
    public virtual method isMakeAssociationInstruction => Boolean := false.
    public virtual method isMakeByteArrayInstruction => Boolean := false.
    public virtual method isMakeDictionaryInstruction => Boolean := false.
    public virtual method isMakeClosureInstruction => Boolean := false.
    public virtual method isReturnInstruction => Boolean := false.
    public virtual method isSendInstruction => Boolean := false.
    public virtual method isSetDebugValueForBindingInstruction => Boolean := false.
    public virtual method isStoreInstruction => Boolean := false.
    public virtual method isTypeSlotAtInstruction => Boolean := false.
    public virtual method isTerminatorInstruction => Boolean := false.
    public virtual method isUnreachableInstruction => Boolean := false.

    public virtual method hasSideEffects => Boolean := true.
    public virtual method isPureFunction => Boolean := false.

    public virtual method primitiveName => Symbol := nil.
    public virtual method evaluateAsHIRFunctionDefinitionOrNil => HIRFunctionDefinition := nil.
    public virtual method evaluateCaptureValueListOrNil => Array := nil.

    public virtual method usedValuesDo: (aBlock: (HIRValue) => Void) ::=> Void := {}.

    public abstract method evaluateConstant => Untyped
        := self subclassResponsibility.

    public method userCount => Size
        := users ifNil: 0sz ifNotNil: users size.

    public method usersDo: (aBlock: (HIRValue) => Void) ::=> Void := {
        users ifNotNil: {:users | users do: aBlock }
    }.

    public virtual method replaceWith: (replacement: HIRValue) ::=> Void := {
        self == replacement ifTrue: (return: void).
        
        users ifNotNil: {
            users do: {:(HIRValue)user :: Void |
                user replaceUsedValue: self with: replacement.
                replacement registerUser: user
            }.
        }.

        self usedValuesDo: {:(HIRValue)usedValue :: Void |
            usedValue unregisterUser: self
        }.
    }.

    public virtual method replaceUsedValue: replacedValue with: replacement ::=> Void := {}.
    public virtual method replaceUsedValuesWith: (replacementDictionary: Dictionary) ::=> Void := {}.

    public method registerInUsedValues => Void := {
        self usedValuesDo: {:(HIRValue)each :: Void | each registerUser: self }
    }.

    public method unregisterFromUsedValues => Void := {
        self usedValuesDo: {:(HIRValue)each :: Void | each unregisterUser: self }
    }.

    public method registerUser: (user: HIRValue) ::=> Void := {
        users ifNil: {
            users := WeakOrderedCollection new
        }.

        users add: user
    }.

    public method unregisterUser: (user: HIRValue) ::=> Void := {
        users ifNotNil: {
            users removeAllOcurrencesOf: user
        }.
    }.

    public override method postCopy => Void := {
        super postCopy.
        users := nil
    }.

    public method useSourceInformationOfValue: (value: HIRValue) ::=> Void := {
        self sourcePosition: value sourcePosition.
        self sourceASTNode: value sourceASTNode.
        self sourceEnvironment: value sourceEnvironment.
    }.
}.

HIRConstant definition: {
    public override method isConstant => Boolean := true.

    public override method hasSideEffects => Boolean := false.
}.

public final class HIRUndefinedConstant superclass: HIRConstant; definition: {
    public override method isEvaluableConstant => Boolean := true.
    public override method isUndefinedConstant => Boolean := true.

    public override method hasSideEffects => Boolean := false.

    public override method evaluateConstant => Untyped := self type defaultValue.

    public override method printOn: (stream: Stream) ::=> Void
        := stream nextPutAll: "undefined "; print: self type.
}.

public final class HIRLiteralConstant superclass: HIRConstant; definition: {
    public field value => Untyped.
    public field isBoxed => Boolean.

    public override method isLiteralConstant => Boolean := true.
    public override method isLiteralConstantTrue => Boolean := (Untyped::==)(self __slotNamedAt__: #value, true).
    public override method isLiteralConstantFalse => Boolean := (Untyped::==)(self __slotNamedAt__: #value, false).
    public override method isEvaluableConstant => Boolean := true.

    public override method evaluateConstant => Untyped := self __slotNamedAt__: #value.

    public override method isPureFunction => Boolean := {
        let value := self __slotNamedAt__: #value.
        (RawTuple::type(value) ifNil: Untyped) isFunction && value isPure
    }.

    public method asBoxedLiteralConstant => HIRLiteralConstant
        := isBoxed || RawTuple::type(self __slotNamedAt__: #value) isValueType not
            ifTrue: (self)
            ifFalse: (self copy
                isBoxed: true;
                yourself).

    public override method primitiveName => Symbol := {
        if: (RawTuple::type(self __slotNamedAt__: #value) isSubtypeOf: Function)
        then: (self __slotNamedAt__: #value) primitiveName
        else: nil
    }.

    public override method printOn: (stream: Stream) ::=> Void := {
        let value := self __slotNamedAt__: #value.
        let valueType := RawTuple::type(value).
        RawTuple::isBytes(value) || valueType isValueType ifTrue: {
            stream nextPutAll: (isBoxed ifTrue: "BoxedLiteral" ifFalse: "Literal("); print: valueType; nextPutAll: " => "; print: value; nextPut: ')'c8
        } ifFalse: {
            (valueType isSubtypeOf: ProgramEntity) ifTrue: {
                stream nextPutAll: (isBoxed ifTrue: "BoxedLiteral" ifFalse: "Literal("); print: value; nextPut: ')'c8
            } ifFalse: {
                stream nextPutAll: (isBoxed ifTrue: "BoxedLiteral" ifFalse: "Literal("); print: valueType; nextPut: ')'c8    
            }
        }.
    }.
}.

HIRGlobalValue definition: {
    public field name => Symbol.

    public virtual method sourceObject := nil.
}.

HIRFunction definition: {
    public field sourceObject => Function.
    public field captures => Array.
    public field definition => HIRFunctionDefinition.
    public field primitiveName => Symbol.
    public field exportedSymbols => Array.

    public override method initialize => Void := {
        super initialize.
        captures := #().
        exportedSymbols := #().
    }.

    public override method isFunction => Boolean := true.

    public override method isPureFunction => Boolean
        := sourceObject isNotNil && sourceObject isPure.

    public override method evaluateConstant => Untyped
        := self __slotNamedAt__: #sourceObject.

    public override method isCaptureless => Boolean := captures isEmpty.
    public method isTargetDefinedPrimitive => Boolean := sourceObject isNotNil && sourceObject isTargetDefinedPrimitive.

    public override method evaluateAsHIRFunctionDefinitionOrNil => HIRFunctionDefinition
        := definition.
    public override method evaluateCaptureValueListOrNil => Array
        := captures.

    public override method printOn: (stream: Stream) ::=> Void := {
        stream nextPut: '@'c8.
        name ifNil: {
            stream print: sourcePosition.
        } ifNotNil: {:name :: Void |
            stream print: name
        }
    }.

    public override method fullPrintOn: (stream: Stream) ::=> Void := {
        stream print: self.
        stream nextPutAll: " captures [".
        captures doWithIndex: {:(HIRValue)capture :(Size)index :: Void |
            index > 0sz ifTrue: (stream nextPutAll: ", ").
            stream print: capture
        }.

        stream nextPut: ']'c8.
        definition ifNotNil: {:(HIRValue)definition :: Void |
            stream nextPutAll: " definition ".
            stream print: definition
        }
    }.
}.

HIRFunctionCapture definition: {
    public field sourceBinding => SymbolBinding.
}.

HIRFunctionArgument definition: {
    public field sourceBinding => SymbolBinding.
}.

HIRFunctionDefinition definition: {
    public field sourceObject => FunctionDefinition.
    public field arguments => Array.
    public field captures => Array.
    public field functionType => FunctionType.
    public field importedSymbols => Array.
    public field primitiveName => Symbol.

    public field firstBasicBlock => HIRBasicBlock.
    public field lastBasicBlock => HIRBasicBlock.

    public field calledFunctionDefinitions => Array.
    public field traversalColor => UInt8.
    public field hasRecursiveCalls => Boolean.

    public override method isFunctionDefinition => Boolean := true.
    public override method evaluateAsHIRFunctionDefinitionOrNil => HIRFunctionDefinition := self.

    public method isTargetDefinedPrimitive => Boolean := sourceObject isNotNil && sourceObject isTargetDefinedPrimitive.

    public method requiresArgumentExpansionDuringApplication => Boolean
        := sourceObject isNotNil && sourceObject requiresArgumentExpansionDuringApplication.

    public override method initialize => Void := {
        super initialize.
        arguments := #().
        captures := #().
        importedSymbols := #().
    }.

    HIRValue extend: {
        public virtual method asHIRFunctionDefinitionOrNil => HIRFunctionDefinition := nil
    }.

    HIRFunction extend: {
        public override method asHIRFunctionDefinitionOrNil => HIRFunctionDefinition := definition.
    }.

    public method markWhite => Void := {
        self traversalColor: 0u8
    }.

    public method isWhite => Boolean := self traversalColor == 0u8.

    public method markGray => Void := {
        self traversalColor: 1u8
    }.

    public method isGray => Boolean := self traversalColor == 1u8.

    public method markBlack => Void := {
        self traversalColor: 2u8
    }.

    public method isBlack => Boolean := self traversalColor == 2u8.
    
    public override method asHIRFunctionDefinitionOrNil => HIRFunctionDefinition := self.

    public override method isCaptureless => Boolean := captures isEmpty.

    public method addBasicBlock: (basicBlock: HIRBasicBlock) before: (position: HIRBasicBlock) ::=> Void := {
        self assert: basicBlock parent isNil.

        let before := position ifNotNil: position previousBlock ifNil: self lastBasicBlock.
        let after := position.

        before ifNotNil: {
            before nextBlock: basicBlock.
            basicBlock previousBlock: before.
        } ifNil: {
            firstBasicBlock := basicBlock
        }.

        after ifNotNil: {
            after previousBlock: basicBlock.
            basicBlock nextBlock: after
        } ifNil: {
            lastBasicBlock := basicBlock
        }.

        basicBlock parent: self
    }.

    public method addBasicBlock: (basicBlock: HIRBasicBlock) after: (position: HIRBasicBlock) ::=> Void := {
        self assert: basicBlock parent isNil.

        let before := position .
        let after := position ifNotNil: position nextBlock ifNil: self firstBasicBlock.

        before ifNotNil: {
            before nextBlock: basicBlock.
            basicBlock previousBlock: before.
        } ifNil: {
            firstBasicBlock := basicBlock
        }.

        after ifNotNil: {
            after previousBlock: basicBlock.
            basicBlock nextBlock: after
        } ifNil: {
            lastBasicBlock := basicBlock
        }.

        basicBlock parent: self
    }.

    public method addBasicBlock: (basicBlock: HIRBasicBlock) ::=> Void
        := self addBasicBlock: basicBlock before: nil.

    public method addFirstBasicBlock: (basicBlock: HIRBasicBlock) ::=> Void
        := self addBasicBlock: basicBlock after: nil.

    public method basicBlocksDo: aBlock ::=> Void := {
        let position mutable := firstBasicBlock.
        while: position isNotNil do: {
            let nextPosition := position nextBlock.
            aBlock(position).
            position := nextPosition
        }
    }.

    public method instructionsDo: aBlock ::=> Void := {
        let position mutable := firstBasicBlock.
        while: position isNotNil do: {
            let nextPosition := position nextBlock.
            position instructionsDo: aBlock.
            position := nextPosition
        }
    }.

    public method localValuesDo: aBlock ::=> Void := {
        arguments do: aBlock.
        captures do: aBlock.
        self basicBlocksDo: {:basicBlock :: Void |
            aBlock(basicBlock).
            basicBlock instructionsDo: aBlock
        }.
    }.

    public method allLocalValues ::=> Array := {
        let result := OrderedCollection new.
        self localValuesDo: {:(HIRFunctionLocalValue)localValue :: Void |
            result add: localValue
        }.
        result asArray
    }.

    public method enumerateLocalValueIndices => Void := {
        let index mutable := 0sz.
        self localValuesDo: {:localValue :: Void |
            localValue localValueIndex: index.
            index := index + 1sz
        }
    }.

    public method traverseAndKeepLiveBasicBlocks => OrderedCollection := {
        let sortedBlocks := OrderedCollection new.
        self basicBlocksDo: {:(HIRBasicBlock)basicBlock :: Void |
            basicBlock
                resetPredecessors;
                computeSuccessors;
                markWhite.
        }.

        self firstBasicBlock ifNotNil: {:(HIRBasicBlock)entryBlock :: Void |
            entryBlock traverseForConnectivityAndLivenessFrom: nil sortingInto: sortedBlocks
        }.

        ## Delete the unreachable basic blocks.
        self basicBlocksDo: {:(HIRBasicBlock)eachBasicBlock :: Void |
            eachBasicBlock isBlack ifFalse: {
                self assert: eachBasicBlock isWhite.
                self deleteBasicBlock: eachBasicBlock
            }
        }.

        sortedBlocks
    }.

    public method useBasicBlockSortingOrder: (sortedBlocks: OrderedCollection) ::=> Void := {
        ## Use the new sorted order.
        sortedBlocks do: {:(HIRBasicBlock)each :: Void |
            each parent: nil; previousBlock: nil; nextBlock: nil.
        }.
        firstBasicBlock := nil.
        lastBasicBlock := nil.

        sortedBlocks reverseDo: {:(HIRBasicBlock)each :: Void |
            self addBasicBlock: each
        }.


    }.

    public method normalizePhiInstructions => Void := {
        ## Normalize the phi instructions.
        self basicBlocksDo: {:(HIRBasicBlock)eachBasicBlock :: Void |
            eachBasicBlock normalizePhiInstructions
        }.
    }.

    public method computeControlFlowAndNormalizeBasicBlocks => Void := {
        self simplifyOutgoingEdges.
        self traverseAndKeepLiveBasicBlocks.

        self fixCriticalEdges.
        self mergeBasicBlocks.

        self useBasicBlockSortingOrder: self traverseAndKeepLiveBasicBlocks.
        self normalizePhiInstructions.
    }.

    public method computeDominance => Void := {
        self computeControlFlowAndNormalizeBasicBlocks.

        self basicBlocksDo: {:(HIRBasicBlock)basicBlock :: Void |
            basicBlock markWhite.
        }.

        let dfsBlocks := OrderedCollection new.
        self firstBasicBlock ifNotNil: {:(HIRBasicBlock)entryBlock :: Void |
            entryBlock dfsEnumerateFrom: nil sortingInto: dfsBlocks
        }.

        ## Compute the dominance.
        dfsBlocks do: {:(HIRBasicBlock)each :: Void |
            each resetDominance.
        }.

        dfsBlocks reverseDo: {:(HIRBasicBlock)each :: Void |
            each computeDominanceFirstPass.
        }.

        dfsBlocks do: {:(HIRBasicBlock)each :: Void |
            each computeDominanceSecondPass.
        }.

        ## Compute the dominance frontier.
        firstBasicBlock ifNotNil: {
            firstBasicBlock computeDominanceFrontier
        }.
    }.

    public method simplifyOutgoingEdges => Void := {
        self basicBlocksDo: {:(HIRBasicBlock)eachBasicBlock :: Void |
            eachBasicBlock simplifyOutgoingEdges
        }.
    }.

    public method fixCriticalEdges => Void := {
        self basicBlocksDo: {:(HIRBasicBlock)eachBasicBlock :: Void |
            eachBasicBlock fixCriticalEdges
        }
    }.

    public method mergeBlock: (previousBlock: HIRBasicBlock) withSuccessor: (mergeBlock: HIRBasicBlock) ::=> Boolean := {
        mergeBlock firstInstruction isPhiInstruction ifTrue: {
            return: false
        }.

        self assert: mergeBlock firstInstruction isPhiInstruction not.
        self assert: previousBlock lastInstruction isBranchInstruction.
        self removeBasicBlock: mergeBlock.

        previousBlock deleteInstruction: previousBlock lastInstruction.
        mergeBlock instructionsDo: {:(HIRInstruction)eachInstruction :: Void |
            eachInstruction parent: nil; previousInstruction: nil; nextInstruction: nil.
            previousBlock addInstruction: eachInstruction.
        }.

        previousBlock successors: previousBlock lastInstruction successors.
        previousBlock successors do: {:(HIRBasicBlock)oldSuccessor :: Void |
            oldSuccessor replacePredecessor: mergeBlock with: previousBlock
        }.

        true
    }.

    public method mergeBasicBlocks => Void := {
        let position mutable := firstBasicBlock.
        while: (position isNotNil) do: {
            let nextPosition mutable := position nextBlock.
            (position successors size = 1sz) && position lastInstruction isBranchInstruction ifTrue: {
                let mergedBlock => HIRBasicBlock := position successors first.

                mergedBlock predecessors size = 1sz ifTrue: {
                    self assert: mergedBlock predecessors first == position.

                    ## Avoid introducing a new critical edge.
                    (position predecessors size >= 2sz) && (mergedBlock successors size >= 2sz) ifFalse: {
                        (self mergeBlock: position withSuccessor: mergedBlock) ifTrue: {
                            nextPosition := position
                        }.
                    }
                }
            }.

            position := nextPosition
        }
    }.

    public method removeBasicBlock: (basicBlock: HIRBasicBlock) ::=> Void := {
        self assert: basicBlock parent == self.

        let previousBlock := basicBlock previousBlock.
        let nextBlock := basicBlock nextBlock.

        previousBlock ifNotNil: {
            previousBlock nextBlock: nextBlock
        } ifNil: {
            self firstBasicBlock: nextBlock
        }.

        nextBlock ifNotNil: {
            nextBlock previousBlock: previousBlock
        } ifNil: {
            self lastBasicBlock: previousBlock
        }.

        basicBlock
            parent: nil;
            previousBlock: nil;
            nextBlock: nil
    }.

    public method deleteBasicBlock: (basicBlock: HIRBasicBlock) ::=> Void := {
        basicBlock
            removeFromControlFlow;
            deleteInstructions;
            unregisterFromUsedValues.

        self removeBasicBlock: basicBlock.
    }.

    public method computeCalledFunctionDefinitionsInto: (set: OrderedInsertionIdentitySet) ::=> Void := {
        self instructionsDo: {:(HIRInstruction)instruction :: Void |
            instruction isCallInstruction ifTrue: {
                let call := instruction downCastTo: HIRCallInstruction.
                let functionDefinition := call calledFunction evaluateAsHIRFunctionDefinitionOrNil.
                functionDefinition ifNotNil: {
                    set add: functionDefinition
                }
            }
        }.
    }.

    public method computeCalledFunctionDefinitions => Void := {
        let set := OrderedInsertionIdentitySet new.
        self computeCalledFunctionDefinitionsInto: set.
        calledFunctionDefinitions := set asArray
    }.

    public method computeNewCalledFunctionDefinitions => Void := {
        let set := OrderedInsertionIdentitySet new.
        set addAll: calledFunctionDefinitions.
        self computeCalledFunctionDefinitionsInto: set.
        calledFunctionDefinitions := set asArray
    }.

    public method shouldBeInlinedIn: (callerFunction: HIRFunctionDefinition) ::=> Boolean
        := hasRecursiveCalls not && firstBasicBlock isNotNil
            && sourceObject isNotNil
            && sourceObject isNeverInline not
            && (sourceObject isInline || sourceObject isAlwaysInline).

    public override method postCopy => Void := {
        super postCopy.

        let oldLocalValues := self allLocalValues.

        self arguments: (self arguments collect: {:(HIRFunctionArgument)each | each copy}).
        self captures: (self captures collect: {:(HIRFunctionCapture)each | each copy}).

        let nextBasicBlockToAdd mutable := firstBasicBlock.
        firstBasicBlock := nil.
        lastBasicBlock := nil.

        while: nextBasicBlockToAdd ~~ nil do: {
            self addBasicBlock: nextBasicBlockToAdd copy
        } continueWith: (nextBasicBlockToAdd := nextBasicBlockToAdd nextBlock).

        ## Construct a replacement dictionary.
        let newLocalValues := self allLocalValues.
        self assert: oldLocalValues size = newLocalValues size.

        let replacementDictionary := Dictionary new.
        oldLocalValues doWithIndex: {:(HIRFunctionLocalValue)oldValue :(Size)index :: Void |
            let newValue := newLocalValues at: index.
            replacementDictionary at: oldValue put: newValue
        }.

        self localValuesDo: {:(HIRFunctionLocalValue)each :: Void |
            each
                replaceUsedValuesWith: replacementDictionary;
                registerInUsedValues
        }.
    }.

    public method inlineInto: (targetFunctionDefinition: HIRFunctionDefinition) before: (targetPosition: HIRBasicBlock) arguments: (inlineArguments: Array) captures: (inlineCaptures: Array) exitBlock: (exitBlock: HIRBasicBlock) resultPhi: (resultPhi: HIRPhiInstruction) ::=> HIRBasicBlock := {
        self assert: arguments size = inlineArguments size.
        self assert: captures size = inlineCaptures size.

        let replacementDictionary := Dictionary new.
        arguments doWithIndex: {:(HIRValue)argument :(Size)index :: Void |
            replacementDictionary at: argument put: (inlineArguments at: index)
        }.

        captures doWithIndex: {:(HIRValue)capture :(Size)index :: Void |
            replacementDictionary at: capture put: (inlineCaptures at: index)
        }.

        ## First pass: copy the basic blocks and their instructions.
        let inlinedBasicBlocks := OrderedCollection new.
        self basicBlocksDo: {:(HIRBasicBlock)eachBasicBlock :: Void |
            let inlinedBlock := eachBasicBlock copyRegisteringInReplacementDictionary: replacementDictionary.
            self assert: inlinedBlock ~~ eachBasicBlock.
            targetFunctionDefinition addBasicBlock: inlinedBlock before: targetPosition.
            inlinedBasicBlocks add: inlinedBlock
        }.

        ## Second pass: fix the used values.
        inlinedBasicBlocks do: {:(HIRBasicBlock)eachBasicBlock :: Void |
            self assert: eachBasicBlock parent == targetFunctionDefinition.
            eachBasicBlock instructionsDo: {:(HIRInstruction)eachInstruction |
                self assert: eachInstruction parent == eachBasicBlock.
                eachInstruction
                    replaceUsedValuesWith: replacementDictionary;
                    registerInUsedValues.

                ## Fix return instructions.
                eachInstruction isReturnInstruction ifTrue: {
                    let returnInstruction := eachInstruction downCastTo: HIRReturnInstruction.

                    ## Add the result value onto the phi node.
                    resultPhi ifNotNil: {
                        resultPhi addValue: returnInstruction value incomingFrom: returnInstruction parent
                    }.

                    ## Replace the return with a branch.
                    let exitBranch := HIRBranchInstruction new
                        useSourceInformationOfValue: returnInstruction;
                        destination: exitBlock;
                        type: Void;
                        registerInUsedValues;
                        yourself.
                    
                    eachBasicBlock addInstruction: exitBranch before: returnInstruction.
                    returnInstruction deleteFromParent
                }.
            }.
        }.

        inlinedBasicBlocks first
    }.

    public override method printOn: (stream: Stream) ::=> Void := {
        stream nextPut: '%'c8.
        self name ifNotNil: {:name :: Void |
            stream print: self name
        }.

        self sourcePosition ifNotNil: {:sourcePosition :: Void |
            self name ifNotNil: (stream space).
            stream nextPutAll: "at "; print: sourcePosition
        }.
    }.

    public override method fullPrintOn: (stream: Stream) ::=> Void := {
        self enumerateLocalValueIndices.
        self printOn: stream.
        
        stream nextPut: '('c8.
        self arguments doWithIndex: {:(HIRFunctionArgument)argument :(Size)index :: Void |
            index > 0sz ifTrue: (stream nextPutAll: ", ").
            stream print: argument
        }.
        stream nextPut: ')'c8.
        stream nextPut: '['c8.
        self captures doWithIndex: {:(HIRFunctionCapture)capture :(Size)index :: Void |
            index > 0sz ifTrue: (stream nextPutAll: ", ").
            stream print: capture
        }.
        stream nextPut: ']'c8.

        stream nextPutAll: " := {"; nl.
        self basicBlocksDo: {:(HIRBasicBlock)basicBlock :: Void |
            basicBlock fullPrintOn: stream
        }.
        stream nextPutAll: "}"; nl.
    }.

    public method computeBasicBlockPredecessors => Void := {
        self basicBlocksDo: {:(HIRBasicBlock)each :: Void |
        }.
    }.
}.

HIRFunctionLocalValue definition: {
    public field name.
    public field localValueIndex => Size.

    public override method initialize => Void := {
        super initialize.
        self localValueIndex: 0sz
    }.

    public override method isFunctionLocalValue => Boolean := true.

    public override method printOn: (stream: Stream) ::=> Void := {
        stream nextPut: '$'c8; print: self localValueIndex.

        self name ifNotNil: {:name |
            stream nextPut: ':'c8; string: self name.
        }.
        self type ifNotNil: {:type |
            stream nextPutAll: " => "; print: self type.
        }.
    }.
}.

HIRBasicBlock definition: {
    public field parent => HIRFunctionDefinition.

    public field previousBlock => HIRBasicBlock.
    public field nextBlock => HIRBasicBlock.

    public field firstInstruction => HIRInstruction.
    public field lastInstruction => HIRInstruction.

    public field traversalColor => UInt8.
    public field predecessors => OrderedCollection.
    public field predecessorKinds => OrderedCollection.
    public field successors => Array.

    public field dfsParent => HIRBasicBlock.
    public field dfsIndex => UInt32.

    public field semiDominator => HIRBasicBlock.
    public field dominanceAncestor => HIRBasicBlock.
    private field dominanceAncestorWithLowestSemiDominator => HIRBasicBlock.
    public field immediateDominator => HIRBasicBlock.
    public field dominatorTreeChildren => OrderedCollection.
    public field sameDominator => HIRBasicBlock.
    public field dominanceBucket => OrderedCollection.
    public field dominanceFrontier => OrderedCollection.

    public override method isBasicBlock => Boolean := true.

    public method markWhite => Void := {
        self traversalColor: 0u8
    }.

    public method isWhite => Boolean := self traversalColor == 0u8.

    public method markGray => Void := {
        self traversalColor: 1u8
    }.

    public method isGray => Boolean := self traversalColor == 1u8.

    public method markBlack => Void := {
        self traversalColor: 2u8
    }.

    public method isBlack => Boolean := self traversalColor == 2u8.

    public method resetPredecessors => Void := {
        self predecessors: OrderedCollection new.
        self predecessorKinds: OrderedCollection new.
    }.

    public method traverseForConnectivityAndLivenessFrom: (predecessor: HIRBasicBlock) sortingInto: (sortedBlocks: OrderedCollection) ::=> Void := {
        predecessor ifNotNil: {
            self addPredecessor: predecessor isBackEdge: self isGray.
        }.

        self isWhite ifFalse: {return: void}.

        self markGray.

        self successors reverseDo: {:(HIRBasicBlock)eachSuccessor :: Void|
            eachSuccessor traverseForConnectivityAndLivenessFrom: self sortingInto: sortedBlocks
        }.

        self markBlack.
        sortedBlocks add: self
    }.

    public method dfsEnumerateFrom: (predecessor: HIRBasicBlock) sortingInto: (sortedBlocks: OrderedCollection) ::=> Void := {
        self isWhite ifFalse: {return: void}.

        self markGray.
        self dfsParent: predecessor.
        self dfsIndex: sortedBlocks size asUInt32.
        sortedBlocks add: self.

        self successors reverseDo: {:(HIRBasicBlock)eachSuccessor :: Void|
            eachSuccessor dfsEnumerateFrom: self sortingInto: sortedBlocks
        }.

        self markBlack.
    }.

    public method clearDominance => Void := {
        semiDominator := nil.
        dominanceAncestor := nil.
        dominanceAncestorWithLowestSemiDominator := nil.
        immediateDominator := nil.
        sameDominator := nil.
        dominanceBucket := nil.
        dominanceFrontier := nil.
        dominatorTreeChildren := nil.
    }.

    public method resetDominance => Void := {
        semiDominator := nil.
        dominanceAncestor := nil.
        dominanceAncestorWithLowestSemiDominator := nil.
        immediateDominator := nil.
        sameDominator := nil.
        dominanceBucket := OrderedCollection new.
        dominanceFrontier := nil.
        dominatorTreeChildren := OrderedCollection new.
    }.

    public method ancestorWithLowestSemiDominator => HIRBasicBlock := {
        dominanceAncestor dominanceAncestor ifNotNil: {
            let newBest := dominanceAncestor ancestorWithLowestSemiDominator.
            dominanceAncestor := dominanceAncestor dominanceAncestor.

            newBest semiDominator dfsIndex < dominanceAncestorWithLowestSemiDominator semiDominator dfsIndex ifTrue: {
                dominanceAncestorWithLowestSemiDominator := newBest
            }
        }.

        dominanceAncestorWithLowestSemiDominator
    }.

    public method dominanceLinkWithAncestor: (newAncestor: HIRBasicBlock) ::=> Void := {
        dominanceAncestor := newAncestor.
        dominanceAncestorWithLowestSemiDominator := self.
    }.

    public method computeDominanceFirstPass => Void := {
        ## Lengauer-Tarjan algorithm from Moden Compiler Implementation in C
        let parent := self dfsParent.
        parent ifNil: {return: void}.

        let newSemiDominator mutable := parent.

        self predecessors do: {:(HIRBasicBlock)pred :: Void |
            let semiDominatorCandidate := pred dfsIndex <= self dfsIndex
                ifTrue: pred
                ifFalse: pred ancestorWithLowestSemiDominator semiDominator.
            semiDominatorCandidate dfsIndex < newSemiDominator dfsIndex ifTrue: {
                newSemiDominator := semiDominatorCandidate
            }.
        }.

        self semiDominator: newSemiDominator.
        newSemiDominator dominanceBucket add: self.

        self dominanceLinkWithAncestor: parent.

        parent dominanceBucket do: {:(HIRBasicBlock)child :: Void |
            let ancestor := child ancestorWithLowestSemiDominator.
            ancestor semiDominator == child semiDominator ifTrue: {
                child immediateDominator: parent
            } ifFalse: {
                child sameDominator: ancestor
            }
        }.

        parent dominanceBucket removeAll.
    }.

    public method computeDominanceSecondPass => Void := {
        self dfsParent ifNil: {return: void}.

        self sameDominator ifNotNil: {
            self immediateDominator: self sameDominator immediateDominator
        }.

        self assert: immediateDominator isNotNil.
        immediateDominator dominatorTreeChildren add: self.
        dominanceBucket := nil.
    }.

    public method dominates: (other: HIRBasicBlock) ::=> Boolean := {
        let position mutable := other.
        while: (position isNotNil) do: {
            position == self ifTrue: {
                return: true
            }
        } continueWith: (position := position immediateDominator).

        false
    }.

    public method computeDominanceFrontier => Void := {
        let set := IdentitySet new.
        let list := OrderedCollection new.
        self successors do: {:(HIRBasicBlock)succ :: Void |
            succ immediateDominator ~~ self ifTrue: {
                (set includes: succ) ifFalse: {
                    set add: succ.
                    list add: succ
                }
            }
        }.

        dominatorTreeChildren do: {:(HIRBasicBlock)child :: Void |
            child computeDominanceFrontier.
            child dominanceFrontier do: {:(HIRBasicBlock)w :: Void |
                (self dominates: w) ifFalse: {
                    (set includes: w) ifFalse: {
                        set add: w.
                        list add: w
                    }
                }
            }
        }.

        dominanceFrontier := list
    }.

    public method addPredecessor: (predecessor: HIRBasicBlock) isBackEdge: (isBackEdge: Boolean) ::=> Void := {
        (self predecessors includes: predecessor) ifFalse: {
            self predecessors add: predecessor.
            self predecessorKinds add: isBackEdge.
        }.
    }.

    public method addPredecessor: (predecessor: HIRBasicBlock) ::=> Void := {
        self addPredecessor: predecessor isBackEdge: false
    }.

    public method removePredecessor: (predecessor: HIRBasicBlock) ::=> Void := {
        let index := self predecessors indexOf: predecessor.
        index >= 0iptr ifTrue: {
            self predecessors removeAt: index asSize.
            self predecessorKinds removeAt: index asSize.
        }.

        self phiInstructionsDo: {:(HIRPhiInstruction)phi :: Void |
            phi removeIncomingBlock: predecessor
        }
    }.

    public method addInstruction: (instruction: HIRInstruction) before: (position: HIRInstruction) ::=> Void := {
        self assert: instruction parent isNil.

        let before := position ifNotNil: position previousInstruction ifNil: lastInstruction.
        let after := position.

        before ifNotNil: {
            before nextInstruction: instruction.
            instruction previousInstruction: before.
        } ifNil: {
            firstInstruction := instruction
        }.

        after ifNotNil: {
            after previousInstruction: instruction.
            instruction nextInstruction: after
        } ifNil: {
            lastInstruction := instruction
        }.

        instruction parent: self
    }.

    public method addInstruction: (instruction: HIRInstruction) after: (position: HIRInstruction) ::=> Void := {
        self assert: instruction parent isNil.

        let before := position .
        let after := position ifNotNil: position nextInstruction ifNil: firstInstruction.

        before ifNotNil: {
            before nextInstruction: instruction.
            instruction previousInstruction: before.
        } ifNil: {
            firstInstruction := instruction
        }.

        after ifNotNil: {
            after previousInstruction: instruction.
            instruction nextInstruction: after
        } ifNil: {
            lastInstruction := instruction
        }.

        instruction parent: self
    }.

    public method addInstruction: (instruction: HIRInstruction) ::=> Void
        := self addInstruction: instruction before: nil.

    public method addFirstInstruction: (instruction: HIRInstruction) ::=> Void
        := self addInstruction: instruction after: nil.

    public method splitAfter: (position: HIRInstruction) ::=> HIRBasicBlock := {
        self assert: position isNotNil && (position parent == self).

        ## Make the new block.
        let afterBlock := HIRBasicBlock new
            useSourceInformationOfValue: self;
            yourself.

        parent ifNotNil: (parent addBasicBlock: afterBlock after: self).

        ## Move 
        let afterInstruction mutable := position nextInstruction.
        while: (afterInstruction isNotNil) do: {
            let next := afterInstruction nextInstruction.
            afterInstruction parent: nil; previousInstruction: nil; nextInstruction: nil.
            afterBlock addInstruction: afterInstruction.
            afterInstruction := next
        }.

        ## End myself at the position.
        position nextInstruction: nil.
        lastInstruction := position.

        ## Fix the succesors
        afterBlock successors: successors.
        afterBlock successors do: {:(HIRBasicBlock)succ :: Void |
            succ replacePredecessor: self with: afterBlock
        }.
        successors := #().

        afterBlock
    }.

    public method removeFromControlFlow => Void := {
        self successors do: {:(HIRBasicBlock)succ :: Void |
            succ removePredecessor: self
        }
    }.

    public method deleteInstructions => Void := {
        self instructionsDo: {:(HIRInstruction)instruction :: Void |
            instruction unregisterFromUsedValues
        }.
        firstInstruction := lastInstruction := nil.
    }.

    public method instructionsDo: aBlock ::=> Void := {
        let position mutable := firstInstruction.
        while: position isNotNil do: {
            let nextPosition := position nextInstruction.
            aBlock(position).
            position := nextPosition
        }
    }.

    public method firstAllocaInstructionsDo: aBlock ::=> Void := {
        let position mutable := firstInstruction.
        while: position isNotNil && position isAllocaInstruction do: {
            let nextPosition := position nextInstruction.
            aBlock(position).
            position := nextPosition
        }
    }.

    public method findAllocaInsertionPoint => HIRInstruction := {
        let position mutable := firstInstruction.
        while: position isNotNil && position isAllocaInstruction do: (
            position := position nextInstruction
        ).

        position
    }.

    public method findPhiLoadInsertionPoint => HIRInstruction := {
        let position mutable := firstInstruction.
        while: position isNotNil && position isPhiInstruction do: (
            position := position nextInstruction
        ).

        position
    }.

    public method phiInstructionsDo: aBlock ::=> Void := {
        let position mutable := firstInstruction.
        while: position isNotNil && position isPhiInstruction do: {
            let nextPosition := position nextInstruction.
            aBlock(position).
            position := nextPosition
        }
    }.

    public method firstInstructionAfterPhi => HIRInstruction := {
        let position mutable := firstInstruction.
        while: position isNotNil && position isPhiInstruction do: {
            position := position nextInstruction
        }.

        position
    }.

    public method normalizePhiInstructions => Void := {
        let predecessors := self predecessors.
        self phiInstructionsDo: {:(HIRPhiInstruction)phi :: Void |
            let newIncomingBlocksAndValues := predecessors collect: {:(HIRBasicBlock)eachRequiredPredecessor :: Association |
                (phi findIncomingBlockAndValueFor: eachRequiredPredecessor)
                    ifNotNil: {:(Association)found | found }
                    ifNil: { eachRequiredPredecessor -> (HIRUndefinedConstant new type: phi type; yourself) }.
            } as: Array.

            phi incomingBlocksAndValues: newIncomingBlocksAndValues
        }.
    }.

    public method incomingBranchDestinationReplacement => HIRBasicBlock := {
        firstInstruction isNotNil && lastInstruction isNotNil && firstInstruction isBranchInstruction ifTrue: {
            let branch := firstInstruction downCastTo: HIRBranchInstruction.
            let branchDestination := branch destination.
            branchDestination firstInstruction isNil || branchDestination firstInstruction isPhiInstruction not ifTrue: {
                return: branchDestination incomingBranchDestinationReplacement
            }
        }.

        self
    }.

    public method simplifyOutgoingEdges => Void := {
        lastInstruction isNotNil && lastInstruction isTerminatorInstruction ifFalse: {return: void}.

        lastInstruction successors do: {:(HIRBasicBlock)eachSuccessor :: Void |
            let actualDestination := eachSuccessor incomingBranchDestinationReplacement.
            eachSuccessor == actualDestination ifFalse: {
                lastInstruction replaceDestination: eachSuccessor with: actualDestination
            }
        }
    }.

    public method fixCriticalEdges => Void := {
        ## We require at least two predecessors in order for having a critical edge.
        if: self predecessors size > 1sz then: {
            self predecessors doWithIndex: {:(HIRBasicBlock)predecessor :(Size)predecessorIndex :: Void |
                if: predecessor successors size > 1sz then: {
                    self fixCriticalEdge: predecessor index: predecessorIndex.
                }
            }
        }.
    }.

    public method fixCriticalEdge: (incomingBlock: HIRBasicBlock) index: (incomingBlockIndex: Size) ::=> Void := {
        self assert: self predecessors size > 1sz.
        self assert: incomingBlock successors size > 1sz.
        self assert: incomingBlock lastInstruction isTerminatorInstruction.

        let builder := HIRInstructionBuilder new
            function: incomingBlock parent;
            useSourceInformationOfValue: incomingBlock lastInstruction;
            yourself.
        
        let intermediateBlock := builder newBasicBlockNamed: #criticalEdge.
        intermediateBlock
            traversalColor: incomingBlock traversalColor;
            successors: (Array with: self);
            resetPredecessors;
            addPredecessor: incomingBlock isBackEdge: (self predecessorKinds at: incomingBlockIndex).

        incomingBlock parent addBasicBlock: intermediateBlock after: incomingBlock.
        builder
            beginInsertingInBasicBlock: intermediateBlock;
            branch: self.
        
        incomingBlock lastInstruction replaceDestination: self with: intermediateBlock.
        incomingBlock replaceSuccessor: self with: intermediateBlock.
        self predecessors at: incomingBlockIndex put: intermediateBlock.

        self phiInstructionsDo: {:(HIRPhiInstruction)each :: Void |
            each replaceIncomingBlock: incomingBlock with: intermediateBlock
        }
    }.

    public method replacePredecessor: (oldPredecessor: HIRBasicBlock) with: (newPredecessor: HIRBasicBlock) ::=> Void := {
        self predecessors at: (self predecessors indexOf: oldPredecessor) asSize put: newPredecessor.
        
        self phiInstructionsDo: {:(HIRPhiInstruction)each :: Void |
            each replaceIncomingBlock: oldPredecessor with: newPredecessor
        }
    }.

    public method deleteInstruction: (instruction: HIRInstruction) ::=> Void := {
        self assert: instruction userCount = 0sz.
        self removeInstruction: instruction.
        instruction unregisterFromUsedValues
    }.

    public method removeInstruction: (instruction: HIRInstruction) ::=> Void := {
        self assert: instruction parent == self.

        let previousInstruction := instruction previousInstruction.
        let nextInstruction := instruction nextInstruction.

        previousInstruction ifNotNil: {
            previousInstruction nextInstruction: nextInstruction
        } ifNil: {
            firstInstruction := nextInstruction
        }.

        nextInstruction ifNotNil: {
            nextInstruction previousInstruction: previousInstruction
        } ifNil: {
            lastInstruction := previousInstruction
        }.

        instruction
            parent: nil;
            previousInstruction: nil;
            nextInstruction: nil
    }.

    public method replaceSuccessor: (oldSuccessor: HIRBasicBlock) with: (newSuccessor: HIRBasicBlock) ::=> Void := {
        let index := self successors indexOf: oldSuccessor.
        self successors at: index asSize put: newSuccessor.
    }.

    public method computeSuccessors => Void := {
        self successors: self lastInstruction successors.
    }.

    public override method postCopy => Void := {
        super postCopy.
        self parent: nil.

        let nextInstructionToAdd mutable => HIRInstruction := self firstInstruction.
        self firstInstruction: nil.
        self lastInstruction: nil.
        self successors: nil.
        self predecessors: nil.
        self predecessorKinds: nil.
        self clearDominance.

        while: nextInstructionToAdd ~~ nil do: {
            self addInstruction: nextInstructionToAdd copy
        } continueWith: (nextInstructionToAdd := nextInstructionToAdd nextInstruction)
    }.

    public method postCopyRegisteringInReplacementDictionary: (replacementDictionary: Dictionary) ::=> Void := {
        super postCopy.

        self parent: nil.

        let nextInstructionToAdd mutable => HIRInstruction := self firstInstruction.
        self firstInstruction: nil.
        self lastInstruction: nil.
        self successors: nil.
        self predecessors: nil.
        self predecessorKinds: nil.
        self clearDominance.

        while: nextInstructionToAdd ~~ nil do: {
            let instructionCopy := nextInstructionToAdd copy.
            replacementDictionary at: nextInstructionToAdd put: instructionCopy.
            self addInstruction: instructionCopy
        } continueWith: (nextInstructionToAdd := nextInstructionToAdd nextInstruction)
    }.

    public method copyRegisteringInReplacementDictionary: (replacementDictionary: Dictionary) ::=> HIRBasicBlock
        := self shallowCopy
            postCopyRegisteringInReplacementDictionary: replacementDictionary;
            yourself.

    public override method replaceWith: (replacement: HIRValue) ::=> Void := {
        self == replacement ifTrue: (return: void).

        super replaceWith: replacement.
        self parent ifNotNil: {:parent :: Void | parent removeBasicBlock: self }
    }.

    public override method fullPrintOn: (stream: Stream) ::=> Void := {
        self printOn: stream.
        stream nextPutAll: ":".
        if: (self predecessors ~~ nil) && self predecessors isNotEmpty then: {
            stream nextPutAll: " ## Predecessors".
            self predecessors do: {:(HIRBasicBlock)each :: Void |
                stream nextPut: ' 'c8; print: each
            }
        }.

        if: (self successors ~~ nil) && self successors isNotEmpty then: {
            stream nextPutAll: " ## Successors".
            self successors do: {:(HIRBasicBlock)each :: Void |
                stream nextPut: ' 'c8; print: each
            }
        }.

        immediateDominator ifNotNil: {
            stream nextPutAll: " IDom "; print: immediateDominator.
        }.

        dominanceFrontier isNotNil && dominanceFrontier isNotEmpty ifTrue: {
            stream nextPutAll: " DomFr".
            dominanceFrontier do: {:(HIRBasicBlock)each :: Void |
                stream nextPut: ' 'c8; print: each
            }
        }.

        stream nl.
        self instructionsDo: {:(HIRInstruction)instruction :: Void |
            stream nextPutAll: "    ".
            instruction fullPrintOn: stream.
            stream nl.
        }.
    }.
}.

HIRInstruction definition: {
    public field parent => HIRBasicBlock.

    public field previousInstruction => HIRInstruction.
    public field nextInstruction => HIRInstruction.

    public method parentFunction => HIRFunctionDefinition
        := self parent ifNil: nil ifNotNil: {:(HIRBasicBlock)parentBlock | parentBlock parent }.

    public override method isInstruction => Boolean := true.

    public method isCapturedInClosure => Boolean
        := users isNotNil && (users anySatisfy: {:(HIRValue)user :: Boolean |
            user isMakeClosureInstruction && ((user downCastTo: HIRMakeClosureInstruction) captures includes: self)
        }).

    public override method postCopy => Void := {
        super postCopy.
        parent := nil.
        previousInstruction := nil.
        nextInstruction := nil.
    }.

    public override method replaceWith: (replacement: HIRValue) ::=> Void := {
        self == replacement ifTrue: (return: void).

        super replaceWith: replacement.
        parent ifNotNil: {parent removeInstruction: self }
    }.

    public virtual method replaceDestination: (oldDestination: HIRBasicBlock) with: (newDestination: HIRBasicBlock) ::=> Void
        := self error: "Not a branch instruction.".

    public virtual method successors => Array
        := self error: "Non terminator instruction is present at the end of a basic block " -- self fullPrintString.

    public virtual method evaluateConstantFolding => HIRValue
        := self.

    public method deleteFromParent => Void
        := parent deleteInstruction: self.
}.

public final class HIRAllocaInstruction superclass: HIRInstruction; definition: {
    public field valueType => HIRValue.

    public override method isAllocaInstruction => Boolean := true.
    public override method hasSideEffects => Boolean := false.

    public method isLocalOnlyAlloca => Boolean
        := users isNil || (users allSatisfy: {:(HIRValue)each :: Boolean | each isLoadStoreOrDebugBindingInstruction }).

    public override method fullPrintOn: (stream: Stream) ::=> Void
        := stream print: self; nextPutAll: " := alloca: "; print: self valueType.

    public override method usedValuesDo: aBlock ::=> Void := {
        aBlock(self valueType)
    }.

    public override method replaceUsedValue: replacedValue with: replacement ::=> Void := {
        if: self valueType = replacedValue then: (self valueType: replacement)
    }.

    public override method replaceUsedValuesWith: (replacementDictionary: Dictionary) ::=> Void := {
        replacementDictionary at: self valueType ifPresent: {:(HIRValue)replacement :: Void | self valueType: replacement}.
    }.
}.

public final class HIRBranchInstruction superclass: HIRInstruction; definition: {
    public field destination => HIRBasicBlock.

    public override method isBranchInstruction => Boolean := true.
    public override method isTerminatorInstruction => Boolean := true.

    public override method successors => Array
        := Array with: self destination.

    public override method fullPrintOn: (stream: Stream) ::=> Void
        := stream nextPutAll: "branch: "; print: self destination.

    public override method usedValuesDo: aBlock ::=> Void := {
        aBlock(self destination).
    }.

    public override method replaceUsedValue: replacedValue with: replacement ::=> Void := {
        if: self destination = replacedValue then: (self destination: replacement)
    }.

    public override method replaceDestination: (oldDestination: HIRBasicBlock) with: (newDestination: HIRBasicBlock) ::=> Void := {
        if: self destination = oldDestination then: (self destination: newDestination)
    }.

    public override method replaceUsedValuesWith: (replacementDictionary: Dictionary) ::=> Void := {
        replacementDictionary at: self destination ifPresent: {:(HIRBasicBlock)replacement :: Void | self destination: replacement}.
    }.
}.

public final class HIRCallInstruction superclass: HIRInstruction; definition: {
    public field calledFunction => HIRValue.
    public field arguments => Array.
    public field isUnchecked => Boolean.
    
    public override method isCallInstruction => Boolean := true.
    public override method hasSideEffects => Boolean := calledFunction isPureFunction not.

    public override method evaluateConstantFolding => HIRValue := {
        calledFunction isPureFunction && (arguments allSatisfy: {:(HIRValue)each :: Boolean | each isEvaluableConstant }) ifFalse: {
            return: self.
        }.

        let calledFunctionValue := calledFunction evaluateConstant.
        let argumentValues := Array new: arguments size.
        arguments doWithIndex: {:(HIRValue)each :(Size)index :: Void |
            argumentValues untypedAt: index put: (each evaluateConstant)
        }.

        let evaluatedConstant := calledFunctionValue applyWithArguments: argumentValues.
        HIRLiteralConstant new
            value: evaluatedConstant;
            type: RawTuple::type(evaluatedConstant);
            yourself
    }.

    public override method fullPrintOn: (stream: Stream) ::=> Void := {
        stream
            print: self; nextPutAll: " := ";
            nextPutAll: "call "; print: self calledFunction.
        self arguments do: {:(HIRValue)argument :: Void |
            stream nextPutAll: ", ".
            stream print: argument
        }
    }.

    public override method postCopy => Void := {
        super postCopy.
        arguments := arguments copy.
    }.

    public override method usedValuesDo: aBlock ::=> Void := {
        aBlock(self calledFunction).
        arguments do: aBlock
    }.

    public override method replaceUsedValue: replacedValue with: replacement ::=> Void := {
        if: calledFunction = replacedValue then: (calledFunction := replacement).
        arguments replaceAll: replacedValue with: replacement
    }.

    public override method replaceUsedValuesWith: (replacementDictionary: Dictionary) ::=> Void := {
        replacementDictionary at: self calledFunction ifPresent: {:(HIRValue)replacement :: Void | self calledFunction: replacement}.
        arguments replaceAllWithDictionary: replacementDictionary
    }.
}.

public final class HIRBitcastInstruction superclass: HIRInstruction; definition: {
    public field value => HIRValue.
    public field targetType => HIRValue.

    public override method hasSideEffects => Boolean := false.

    public override method fullPrintOn: (stream: Stream) ::=> Void
        := stream print: self; nextPutAll: " := bitcast: "; print: self value;
            space; print: self targetType.

    public override method usedValuesDo: aBlock ::=> Void := {
        aBlock(self value).
        aBlock(self targetType).
    }.

    public override method replaceUsedValue: replacedValue with: replacement ::=> Void := {
        if: self value = replacedValue then: (self value: replacement).
        if: self targetType = replacedValue then: (self targetType: replacement).
    }.

    public override method replaceUsedValuesWith: (replacementDictionary: Dictionary) ::=> Void := {
        replacementDictionary at: self value ifPresent: {:(HIRValue)replacement :: Void | self value: replacement}.
        replacementDictionary at: self targetType ifPresent: {:(HIRValue)replacement :: Void | self targetType: replacement}.
    }.
}.

public final class HIRCoerceValueInstruction superclass: HIRInstruction; definition: {
    public field value => HIRValue.
    public field targetType => HIRValue.

    public override method fullPrintOn: (stream: Stream) ::=> Void
        := stream print: self; nextPutAll: " := coerceValue: "; print: self value;
            nextPut: ' 'c8; print: self targetType.

    public override method usedValuesDo: aBlock ::=> Void := {
        aBlock(self value).
        aBlock(self targetType).
    }.

    public override method replaceUsedValue: replacedValue with: replacement ::=> Void := {
        if: self value = replacedValue then: (self value: replacement).
        if: self targetType = replacedValue then: (self targetType: replacement).
    }.

    public override method replaceUsedValuesWith: (replacementDictionary: Dictionary) ::=> Void := {
        replacementDictionary at: self value ifPresent: {:(HIRValue)replacement :: Void | self value: replacement}.
        replacementDictionary at: self targetType ifPresent: {:(HIRValue)replacement :: Void | self targetType: replacement}.
    }.
}.

public final class HIRConditionalBranchInstruction superclass: HIRInstruction; definition: {
    public field condition => HIRValue.
    public field trueDestination => HIRBasicBlock.
    public field falseDestination => HIRBasicBlock.

    public override method isConditionalBranchInstruction => Boolean := false.
    public override method isTerminatorInstruction => Boolean := true.

    public override method successors => Array
        := Array with: self trueDestination with: self falseDestination.

    public override method fullPrintOn: (stream: Stream) ::=> Void
        := stream nextPutAll: "condBranch: "; print: self condition;
            space; print: self trueDestination;
            space; print: self falseDestination.

    public override method usedValuesDo: aBlock ::=> Void := {
        aBlock(self condition).
        aBlock(self trueDestination).
        aBlock(self falseDestination).
    }.

    public override method replaceUsedValue: replacedValue with: replacement ::=> Void := {
        if: self condition = replacedValue then: (self condition: replacement).
        if: self trueDestination = replacedValue then: (self trueDestination: replacement).
        if: self falseDestination = replacedValue then: (self falseDestination: replacement).
    }.

    public override method replaceUsedValuesWith: (replacementDictionary: Dictionary) ::=> Void := {
        replacementDictionary at: self condition ifPresent: {:(HIRValue)replacement :: Void | self condition: replacement}.
        replacementDictionary at: self trueDestination ifPresent: {:(HIRBasicBlock)replacement :: Void | self trueDestination: replacement}.
        replacementDictionary at: self falseDestination ifPresent: {:(HIRBasicBlock)replacement :: Void | self falseDestination: replacement}.
    }.

    public override method replaceDestination: (oldDestination: HIRBasicBlock) with: (newDestination: HIRBasicBlock) ::=> Void := {
        if: self trueDestination = oldDestination then: (self trueDestination: newDestination).
        if: self falseDestination = oldDestination then: (self falseDestination: newDestination)
    }.
}.

public final class HIRDownCastInstruction superclass: HIRInstruction; definition: {
    public field targetType => HIRValue.
    public field value => HIRValue.
    public field isUnchecked => Boolean.

    public override method isDownCastInstruction => Boolean := true.
    public override method hasSideEffects => Boolean := isUnchecked not.

    public override method fullPrintOn: (stream: Stream) ::=> Void := {
        stream print: self;
            nextPutAll: (isUnchecked ifTrue: " := uncheckedDowncast " ifFalse: " := downcast ");
            print: value; nextPutAll: " into "; print: targetType
    }.

    public override method usedValuesDo: aBlock ::=> Void := {
        aBlock(targetType).
        aBlock(value).
    }.

    public override method replaceUsedValue: replacedValue with: replacement ::=> Void := {
        if: targetType = replacedValue then: (targetType := replacement).
        if: value = replacedValue then: (value := replacement).
    }.

    public override method replaceUsedValuesWith: (replacementDictionary: Dictionary) ::=> Void := {
        replacementDictionary at: self targetType ifPresent: {:(HIRValue)replacement :: Void | self targetType: replacement}.
        replacementDictionary at: self value ifPresent: {:(HIRValue)replacement :: Void | self value: replacement}.
    }.
}.

public final class HIRReferenceElementAtInstruction superclass: HIRInstruction; definition: {
    public field reference => HIRValue.
    public field index => HIRValue.

    public override method isReferenceElementAtInstruction => Boolean := true.
    public override method hasSideEffects => Boolean := false.

    public override method fullPrintOn: (stream: Stream) ::=> Void := {
        stream print: self; nextPutAll: " := reference "; print: self reference; nextPutAll: " elementAt "; print: self index
    }.

    public override method usedValuesDo: aBlock ::=> Void := {
        aBlock(self reference).
        aBlock(self index).
    }.

    public override method replaceUsedValue: replacedValue with: replacement ::=> Void := {
        if: self reference = replacedValue then: (self reference: replacement).
        if: self index = replacedValue then: (self index: replacement).
    }.

    public override method replaceUsedValuesWith: (replacementDictionary: Dictionary) ::=> Void := {
        replacementDictionary at: self reference ifPresent: {:(HIRValue)replacement :: Void | self reference: replacement}.
        replacementDictionary at: self index ifPresent: {:(HIRValue)replacement :: Void | self index: replacement}.
    }.
}.

public final class HIRPointerElementAtInstruction superclass: HIRInstruction; definition: {
    public field pointer => HIRValue.
    public field index => HIRValue.

    public override method isPointerElementAtInstruction => Boolean := true.
    public override method hasSideEffects => Boolean := false.

    public override method fullPrintOn: (stream: Stream) ::=> Void := {
        stream print: self; nextPutAll: " := pointer "; print: self pointer; nextPutAll: " elementAt "; print: self index
    }.

    public override method usedValuesDo: aBlock ::=> Void := {
        aBlock(self pointer).
        aBlock(self index).
    }.

    public override method replaceUsedValue: replacedValue with: replacement ::=> Void := {
        if: self pointer = replacedValue then: (self pointer: replacement).
        if: self index = replacedValue then: (self index: replacement).
    }.

    public override method replaceUsedValuesWith: (replacementDictionary: Dictionary) ::=> Void := {
        replacementDictionary at: self pointer ifPresent: {:(HIRValue)replacement :: Void | self pointer: replacement}.
        replacementDictionary at: self index ifPresent: {:(HIRValue)replacement :: Void | self index: replacement}.
    }.
}.

public final class HIRTypeSlotAtInstruction superclass: HIRInstruction; definition: {
    public field tuple => HIRValue.
    public field typeSlot => TypeSlot.

    public override method isTypeSlotAtInstruction => Boolean := true.
    public override method hasSideEffects => Boolean := false.

    public override method fullPrintOn: (stream: Stream) ::=> Void := {
        stream print: self; nextPutAll: " := typedSlotOf "; print: self tuple; nextPutAll: " at "; print: self typeSlot
    }.

    public override method usedValuesDo: aBlock ::=> Void := {
        aBlock(self tuple).
    }.

    public override method replaceUsedValue: replacedValue with: replacement ::=> Void := {
        if: self tuple = replacedValue then: (self tuple: replacement).
    }.

    public override method replaceUsedValuesWith: (replacementDictionary: Dictionary) ::=> Void := {
        replacementDictionary at: self tuple ifPresent: {:(HIRValue)replacement :: Void | self tuple: replacement}.
    }.
}.

public final class HIRTypeSlotReferenceAtInstruction superclass: HIRInstruction; definition: {
    public field tuple => HIRValue.
    public field typeSlot => TypeSlot.

    public override method isTypeSlotAtInstruction => Boolean := true.
    public override method hasSideEffects => Boolean := false.

    public override method fullPrintOn: (stream: Stream) ::=> Void := {
        stream print: self; nextPutAll: " := typedSlotOf "; print: self tuple; nextPutAll: " referenceAt "; print: self typeSlot
    }.

    public override method usedValuesDo: aBlock ::=> Void := {
        aBlock(self tuple).
    }.

    public override method replaceUsedValue: replacedValue with: replacement ::=> Void := {
        if: self tuple = replacedValue then: (self tuple: replacement).
    }.

    public override method replaceUsedValuesWith: (replacementDictionary: Dictionary) ::=> Void := {
        replacementDictionary at: self tuple ifPresent: {:(HIRValue)replacement :: Void | self tuple: replacement}.
    }.
}.

public final class HIRTypeSlotAtPutInstruction superclass: HIRInstruction; definition: {
    public field tuple => HIRValue.
    public field value => HIRValue.
    public field typeSlot => TypeSlot.

    public override method isTypeSlotAtInstruction => Boolean := true.

    public override method fullPrintOn: (stream: Stream) ::=> Void := {
        stream print: self; nextPutAll: " typedSlotOf "; print: self tuple;
            nextPutAll: " at "; print: self typeSlot;
            nextPutAll: " put "; print: self value
    }.

    public override method usedValuesDo: aBlock ::=> Void := {
        aBlock(self tuple).
        aBlock(self value).
    }.

    public override method replaceUsedValue: replacedValue with: replacement ::=> Void := {
        if: self tuple = replacedValue then: (self tuple: replacement).
        if: self value = replacedValue then: (self value: replacement).
    }.

    public override method replaceUsedValuesWith: (replacementDictionary: Dictionary) ::=> Void := {
        replacementDictionary at: self tuple ifPresent: {:(HIRValue)replacement :: Void | self tuple: replacement}.
        replacementDictionary at: self value ifPresent: {:(HIRValue)replacement :: Void | self value: replacement}.
    }.
}.

public final class HIRLoadInstruction superclass: HIRInstruction; definition: {
    public field storage => HIRValue.
    public field isVolatile => Boolean.

    public override method isLoadInstruction => Boolean := true.
    public override method isLoadStoreOrDebugBindingInstruction => Boolean := true.
    public override method hasSideEffects => Boolean := isVolatile not.

    public override method fullPrintOn: (stream: Stream) ::=> Void := {
        stream print: self; nextPutAll: " := load "; print: self storage
    }.

    public override method usedValuesDo: aBlock ::=> Void := {
        aBlock(self storage).
    }.

    public override method replaceUsedValue: replacedValue with: replacement ::=> Void := {
        if: self storage = replacedValue then: (self storage: replacement).
    }.

    public override method replaceUsedValuesWith: (replacementDictionary: Dictionary) ::=> Void := {
        replacementDictionary at: self storage ifPresent: {:(HIRValue)replacement :: Void | self storage: replacement}.
    }.
}.

public final class HIRMakeAssociationInstruction superclass: HIRInstruction; definition: {
    public field key => HIRValue.
    public field value => HIRValue.

    public override method isMakeAssociationInstruction => Boolean := true.
    public override method hasSideEffects => Boolean := false.

    public override method fullPrintOn: (stream: Stream) ::=> Void := {
        stream print: self; nextPutAll: " := makeAssociation "; print: self key;
            nextPutAll: " : "; print: self value.
    }.

    public override method usedValuesDo: aBlock ::=> Void := {
        aBlock(self key).
        aBlock(self value).
    }.

    public override method replaceUsedValue: replacedValue with: replacement ::=> Void := {
        if: self key = replacedValue then: (self key: replacement).
        if: self value = replacedValue then: (self value: replacement).
    }.

    public override method replaceUsedValuesWith: (replacementDictionary: Dictionary) ::=> Void := {
        replacementDictionary at: self key ifPresent: {:(HIRValue)replacement :: Void | self key: replacement}.
        replacementDictionary at: self value ifPresent: {:(HIRValue)replacement :: Void | self value: replacement}.
    }.
}.

public final class HIRMakeArrayInstruction superclass: HIRInstruction; definition: {
    public field elements => Array.

    public override method isMakeArrayInstruction => Boolean := true.
    public override method hasSideEffects => Boolean := false.

    public override method fullPrintOn: (stream: Stream) ::=> Void := {
        stream print: self; nextPutAll: " := makeArray".
        self elements do: {:(HIRValue)element :: Void |
            stream nextPutAll: " "; print: element
        }
    }.

    public override method postCopy => Void := {
        super postCopy.
        elements := elements copy.
    }.

    public override method usedValuesDo: aBlock ::=> Void := {
        self elements do: aBlock
    }.

    public override method replaceUsedValue: replacedValue with: replacement ::=> Void := {
        self elements replaceAll: replacedValue with: replacement
    }.

    public override method replaceUsedValuesWith: (replacementDictionary: Dictionary) ::=> Void := {
        self elements replaceAllWithDictionary: replacementDictionary
    }.
}.

public final class HIRMakeByteArrayInstruction superclass: HIRInstruction; definition: {
    public field elements => Array.

    public override method isMakeByteArrayInstruction => Boolean := true.
    public override method hasSideEffects => Boolean := false.

    public override method fullPrintOn: (stream: Stream) ::=> Void := {
        stream print: self; nextPutAll: " := makeByteArray".
        self elements do: {:(HIRValue)element :: Void |
            stream nextPutAll: " "; print: element
        }
    }.

    public override method postCopy => Void := {
        super postCopy.
        elements := elements copy.
    }.

    public override method usedValuesDo: aBlock ::=> Void := {
        self elements do: aBlock
    }.

    public override method replaceUsedValue: replacedValue with: replacement ::=> Void := {
        self elements replaceAll: replacedValue with: replacement
    }.

    public override method replaceUsedValuesWith: (replacementDictionary: Dictionary) ::=> Void := {
        self elements replaceAllWithDictionary: replacementDictionary
    }.
}.

public final class HIRMakeClosureInstruction superclass: HIRInstruction; definition: {
    public field functionDefinition => HIRValue.
    public field captures => Array.

    public override method isMakeClosureInstruction => Boolean := true.
    public override method hasSideEffects => Boolean := false.

    public override method evaluateAsHIRFunctionDefinitionOrNil => HIRFunctionDefinition
        := functionDefinition evaluateAsHIRFunctionDefinitionOrNil.

    public override method evaluateCaptureValueListOrNil => Array
        := captures.

    public override method fullPrintOn: (stream: Stream) ::=> Void := {
        stream print: self; nextPutAll: " := makeClosure "; print: self functionDefinition.
        self captures do: {:(HIRValue)capture :: Void |
            stream nextPutAll: ", "; print: capture
        }
    }.

    public override method postCopy => Void := {
        super postCopy.
        captures := captures copy.
    }.

    public override method usedValuesDo: aBlock ::=> Void := {
        aBlock(self functionDefinition).
        self captures do: aBlock
    }.

    public override method replaceUsedValue: replacedValue with: replacement ::=> Void := {
        if: self functionDefinition = replacedValue then: (self functionDefinition: replacement).
        self captures replaceAll: replacedValue with: replacement
    }.

    public override method replaceUsedValuesWith: (replacementDictionary: Dictionary) ::=> Void := {
        replacementDictionary at: self functionDefinition ifPresent: {:(HIRValue)replacement :: Void | self functionDefinition: replacement}.
        self captures replaceAllWithDictionary: replacementDictionary
    }.
}.

public final class HIRMakeDictionaryInstruction superclass: HIRInstruction; definition: {
    public field elements => Array.

    public override method isMakeDictionaryInstruction => Boolean := true.
    public override method hasSideEffects => Boolean := false.

    public override method fullPrintOn: (stream: Stream) ::=> Void := {
        stream print: self; nextPutAll: " := makeDictionary".
        self elements do: {:(HIRValue)element :: Void |
            stream nextPutAll: " "; print: element
        }
    }.

    public override method postCopy => Void := {
        super postCopy.
        elements := elements copy.
    }.

    public override method usedValuesDo: aBlock ::=> Void := {
        self elements do: aBlock
    }.

    public override method replaceUsedValue: replacedValue with: replacement ::=> Void := {
        self elements replaceAll: replacedValue with: replacement
    }.

    public override method replaceUsedValuesWith: (replacementDictionary: Dictionary) ::=> Void := {
        self elements replaceAllWithDictionary: replacementDictionary
    }.
}.

HIRPhiInstruction definition: {
    public field incomingBlocksAndValues => Array.

    public override method isPhiInstruction => Boolean := true.
    public override method hasSideEffects => Boolean := false.

    public override method initialize => Void := {
        super initialize.
        self incomingBlocksAndValues: #().
    }.

    public override method fullPrintOn: (stream: Stream) ::=> Void := {
        stream print: self; nextPutAll: " := phi ["; nl.
        self incomingBlocksAndValues do: {:(Association)blockAndValue :: Void |
            stream nextPutAll: "        "; print: blockAndValue value; nextPutAll: " from "; print: blockAndValue key; nl 
        }.

        stream nextPutAll: "    ]"
    }.

    public method addValue: (value: HIRValue) incomingFrom: (block: HIRBasicBlock) ::=> Void := {
        self incomingBlocksAndValues: self incomingBlocksAndValues -- (Array with: block -> value).
        value registerUser: self.
        block registerUser: self.
    }.

    public method indexOfIncomingBlock: (block: HIRBasicBlock) ::=> IntPointer := {
        let i mutable := 0sz.
        while: i < incomingBlocksAndValues size do: {
            let assoc => Association := incomingBlocksAndValues at: i.
            assoc key = block ifTrue: {
                return: i asIntPointer
            }
        } continueWith: (i := i + 1sz).
        -1iptr
    }.

    public method removeIncomingBlock: (block: HIRBasicBlock) ::=> Void := {
        let blockIndex := self indexOfIncomingBlock: block.
        blockIndex >= 0iptr ifTrue: {
            incomingBlocksAndValues := incomingBlocksAndValues copyWithoutElementAt: blockIndex asSize
        }.
    }.

    public method findIncomingBlockAndValueFor: (expectedBlock: HIRBasicBlock) ::=> Association
        := self incomingBlocksAndValues detect: {:(Association)each | each key = expectedBlock } ifNone: {: nil}.

    public method incomingBlocksAndValuesDo: aBlock ::=> Void := {
        self incomingBlocksAndValues do: {:(Association)blockAndValue :: Void |
            aBlock(blockAndValue key, blockAndValue value)
        }
    }.

    public override method postCopy => Void := {
        super postCopy.
        incomingBlocksAndValues := incomingBlocksAndValues copy.
    }.

    public override method usedValuesDo: aBlock ::=> Void := {
        self incomingBlocksAndValues do: {:(Association)association :: Void |
            aBlock(association key).
            aBlock(association value).
        }
    }.

    public override method replaceUsedValue: replacedValue with: replacement ::=> Void := {
        self incomingBlocksAndValues do: {:(Association)association :: Void |
            if: association key = replacedValue then: (association key: replacement).
            if: association value = replacedValue then: (association value: replacement).
        }
    }.

    public override method replaceUsedValuesWith: (replacementDictionary: Dictionary) ::=> Void := {
        self incomingBlocksAndValues do: {:(Association)association :: Void |
            replacementDictionary at: association key ifPresent: {:(HIRValue)replacement :: Void | association key: replacement}.
            replacementDictionary at: association value ifPresent: {:(HIRValue)replacement :: Void | association value: replacement}.
        }
    }.

    public method replaceIncomingBlock: (oldIncomingBlock: HIRBasicBlock) with: (newIncomingBlock: HIRBasicBlock) ::=> Void := {
        self incomingBlocksAndValues do: {:(Association)association :: Void |
            if: association key = oldIncomingBlock then: (association key: newIncomingBlock).
        }
    }.

    public override method evaluateConstantFolding => HIRValue := {
        let bestResult mutable => HIRValue := nil.

        let valueCount := incomingBlocksAndValues size.
        valueCount = 1sz ifTrue: {
            return: incomingBlocksAndValues first value
        }.

        let i mutable := 0sz.
        while: (i < valueCount) do: {
            let association => Association := incomingBlocksAndValues at: i.
            let value => HIRValue := association value.

            bestResult ifNil: {
                bestResult := value.
                continue()
            }.

            value isConstant && bestResult isUndefinedConstant ifTrue: {
                bestResult := value.
                continue().
            }.

            value isUndefinedConstant ifTrue: {
                continue()
            }.

            bestResult == value ifFalse: {
                return: self
            }.
        } continueWith: (i := i + 1sz).

        bestResult ifNil: (HIRUndefinedConstant new type: self type; yourself)
    }.

    public method simplify => Void := {
        let simplified := self evaluateConstantFolding.
        self ~~ simplified ifTrue: (self replaceWith: simplified).
    }.
}.

public final class HIRReturnInstruction superclass: HIRInstruction; definition: {
    public field value => HIRValue.

    public override method isReturnInstruction => Boolean := true.
    public override method isTerminatorInstruction => Boolean := true.

    public override method successors => Array
        := #().

    public override method fullPrintOn: (stream: Stream) ::=> Void
        := stream nextPutAll: "return: "; print: self value.

    public override method usedValuesDo: aBlock ::=> Void := {
        aBlock(self value)
    }.

    public override method replaceUsedValue: replacedValue with: replacement ::=> Void := {
        if: self value = replacedValue then: (self value: replacement)
    }.

    public override method replaceUsedValuesWith: (replacementDictionary: Dictionary) ::=> Void := {
        replacementDictionary at: self value ifPresent: {:(HIRValue)replacement :: Void | self value: replacement}.
    }.
}.

public final class HIRSendInstruction superclass: HIRInstruction; definition: {
    public field receiver => HIRValue.
    public field receiverLookupType => HIRValue.
    public field selector => HIRValue.
    public field arguments => Array.
    public field isUnchecked => Boolean.

    public override method isSendInstruction => Boolean := true.

    public override method fullPrintOn: (stream: Stream) ::=> Void := {
        stream
            print: self; nextPutAll: " := ";
            nextPutAll: "send "; print: self receiver.
        self receiverLookupType ifNotNil: {:(HIRValue)receiverLookupType :: Void |
            stream nextPutAll: " lookupFrom: "; print: self receiverLookupType.
        }.

        stream nextPutAll: ", "; print: self selector.

        self arguments doWithIndex: {:(HIRValue)argument :(Size)index :: Void |
            index = 0sz
                ifTrue: (stream nextPut: ' 'c8)
                ifFalse: (stream nextPutAll: ", ").
            stream print: argument
        }
    }.

    public override method postCopy => Void := {
        super postCopy.
        arguments := arguments copy.
    }.

    public override method usedValuesDo: aBlock ::=> Void := {
        aBlock(self receiver).
        if: self receiverLookupType ~~ nil then: aBlock(self receiverLookupType).
        aBlock(self selector).
        self arguments do: aBlock
    }.

    public override method replaceUsedValue: replacedValue with: replacement ::=> Void := {
        if: self receiver = replacedValue then: (self receiver: replacement).
        if: self receiverLookupType = replacedValue then: (self receiverLookupType: replacement).
        if: self selector = replacedValue then: (self selector: replacement).
        self arguments replaceAll: replacedValue with: replacement
    }.

    public override method replaceUsedValuesWith: (replacementDictionary: Dictionary) ::=> Void := {
        replacementDictionary at: self receiver ifPresent: {:(HIRValue)replacement :: Void | self receiver: replacement}.
        replacementDictionary at: self receiverLookupType ifPresent: {:(HIRValue)replacement :: Void | self receiverLookupType: replacement}.
        replacementDictionary at: self selector ifPresent: {:(HIRValue)replacement :: Void | self selector: replacement}.
        self arguments replaceAllWithDictionary: replacementDictionary
    }.
}.

public final class HIRSetDebugValueForBindingInstruction superclass: HIRInstruction; definition: {
    public field value => HIRValue.
    public field binding => SymbolBinding.
    public field promotedFromAlloca => Boolean.

    public override method isLoadStoreOrDebugBindingInstruction => Boolean := true.
    public override method isSetDebugValueForBindingInstruction => Boolean := true.

    public override method initialize => Void := {
        super initialize.
        type := Void
    }.

    public override method fullPrintOn: (stream: Stream) ::=> Void := {
        stream nextPutAll: "setDebugValue "; print: self value; nextPutAll: " forBinding "; print: self binding
    }.

    public override method usedValuesDo: aBlock ::=> Void := {
        aBlock(self value).
    }.

    public override method replaceUsedValue: replacedValue with: replacement ::=> Void := {
        if: self value = replacedValue then: (self value: replacement).
    }.

    public override method replaceUsedValuesWith: (replacementDictionary: Dictionary) ::=> Void := {
        replacementDictionary at: self value ifPresent: {:(HIRValue)replacement :: Void | self value: replacement}.
    }.
}.

public final class HIRStoreInstruction superclass: HIRInstruction; definition: {
    public field storage => HIRValue.
    public field value => HIRValue.
    public field isVolatile => Boolean.

    public override method isStoreInstruction => Boolean := true.
    public override method isLoadStoreOrDebugBindingInstruction => Boolean := true.

    public override method initialize => Void := {
        super initialize.
        type := Void
    }.

    public override method fullPrintOn: (stream: Stream) ::=> Void := {
        stream nextPutAll: "store "; print: self value; nextPutAll: " in "; print: self storage
    }.

    public override method usedValuesDo: aBlock ::=> Void := {
        aBlock(self storage).
        aBlock(self value).
    }.

    public override method replaceUsedValue: replacedValue with: replacement ::=> Void := {
        if: self storage = replacedValue then: (self storage: replacement).
        if: self value = replacedValue then: (self value: replacement).
    }.

    public override method replaceUsedValuesWith: (replacementDictionary: Dictionary) ::=> Void := {
        replacementDictionary at: self storage ifPresent: {:(HIRValue)replacement :: Void | self storage: replacement}.
        replacementDictionary at: self value ifPresent: {:(HIRValue)replacement :: Void | self value: replacement}.
    }.
}.

public final class HIRUnreachableInstruction superclass: HIRInstruction; definition: {
    public override method isUnreachableInstruction => Boolean := true.

    public override method isTerminatorInstruction => Boolean := true.

    public override method successors => Array
        := #().

    public override method fullPrintOn: (stream: Stream) ::=> Void
        := stream nextPutAll: "unreachable".
}.

public final class HIRModule superclass: Object; definition: {
    public field globalValues => OrderedCollection.
    private field globalValueDictionary => IdentityDictionary.

    public override method initialize => Void := {
        globalValues := OrderedCollection new.
        globalValueDictionary := IdentityDictionary new.
    }.

    public method addGlobalValue: (globalValue: HIRGlobalValue) ::=> Void := {
        globalValues add: globalValue.
        globalValue sourceObject ifNotNil: {
            globalValueDictionary at: globalValue sourceObject put: globalValue
        }
    }.

    public method getGlobalValueFor: value ::=> HIRValue
        := globalValueDictionary at: value.

    public method getGlobalValueOrNilFor: value ::=> HIRValue
        := globalValueDictionary atOrNil: value.

    public method functionDefinitions => OrderedCollection
        := globalValues select: {:(HIRValue)value :: Boolean | value isFunctionDefinition }.

    public override method fullPrintOn: (stream: Stream) ::=> Void := {
        globalValues do: {:(HIRGlobalValue)eachValue :: Void |
            stream fullPrint: eachValue; nl
        }
    }.
}.

HIRInstructionBuilder definition: {
    public field sourcePosition => SourcePosition.
    public field sourceASTNode => ASTNode.
    public field sourceEnvironment => Environment.

    public field function => HIRFunctionDefinition.
    public field basicBlock => HIRBasicBlock.
    public field insertionPoint => HIRInstruction.

    __Meta__ definition: {
        public method for: (function: HIRFunctionDefinition)
            := self new function: function; yourself.
    }.

    public method newBasicBlockNamed: name ::=> HIRBasicBlock := {
        let newBasicBlock := HIRBasicBlock new
            name: name;
            sourcePosition: self sourcePosition;
            sourceASTNode: self sourceASTNode;
            sourceEnvironment: self sourceEnvironment;
            yourself.
        newBasicBlock
    }.

    public method beginBasicBlock: (newBasicBlock: HIRBasicBlock) ::=> HIRBasicBlock := {
        self basicBlock: newBasicBlock.
        self insertionPoint: nil.
        self function addBasicBlock: newBasicBlock.
        newBasicBlock
    }.

    public method beginInsertingInBasicBlock: (newBasicBlock: HIRBasicBlock) ::=> HIRBasicBlock := {
        self function: newBasicBlock parent.
        self basicBlock: newBasicBlock.
        self insertionPoint: nil.
        newBasicBlock
    }.

    public method beginBasicBlockNamed: name ::=> HIRBasicBlock
        := self beginBasicBlock: (self newBasicBlockNamed: name).

    public method addInstruction: (instruction: HIRInstruction) ::=> instruction __type__ := {
        instruction
            sourcePosition: self sourcePosition;
            sourceASTNode: self sourceASTNode;
            sourceEnvironment: self sourceEnvironment.
        self basicBlock addInstruction: instruction before: self insertionPoint.
        instruction
    }.

    public method useSourceInformationOfValue: (value: HIRValue) ::=> Void := {
        self sourcePosition: value sourcePosition.
        self sourceASTNode: value sourceASTNode.
        self sourceEnvironment: value sourceEnvironment.
    }.

    public method withSourcePosition: (sourcePosition: SourcePosition) do: aBlock := {
        let oldPosition := self sourcePosition.
        self sourcePosition: sourcePosition.
        let result := aBlock().
        self sourcePosition: oldPosition.
        result
    }.

    public method withSourceASTNode: (sourceASTNode: ASTNode) do: aBlock := {
        let oldSourceASTNode := self sourceASTNode.
        self sourceASTNode: sourceASTNode.
        let result := self withSourcePosition: sourceASTNode sourcePosition do: aBlock.
        self sourceASTNode: oldSourceASTNode.
        result
    }.

    public method withSourceEnvironment: (sourceEnvironment: Environment) do: aBlock := {
        let oldSourceEnvironment := self sourceEnvironment.
        self sourceEnvironment: sourceEnvironment.
        let result := aBlock().
        self sourceEnvironment: oldSourceEnvironment.
        result
    }.

    public method alloca: (valueType: HIRValue) type: (type: Type) ::=> HIRAllocaInstruction
        := self addInstruction: (HIRAllocaInstruction new
            valueType: valueType;
            type: type;
            registerInUsedValues;
            yourself).

    public method branch: (destination: HIRBasicBlock) ::=> HIRBranchInstruction
        := self addInstruction: (HIRBranchInstruction new
            destination: destination;
            type: Void;
            registerInUsedValues;
            yourself).

    public method call: (calledFunction: HIRValue) arguments: (arguments: Array) resultType: (resultType: Type) ::=> HIRCallInstruction
        := self addInstruction: (HIRCallInstruction new
            calledFunction: calledFunction;
            arguments: arguments;
            type: resultType;
            registerInUsedValues;
            yourself).

    public method call: (receiver: HIRValue) arguments: (arguments: Array) ::=> HIRCallInstruction
        := self call: receiver arguments: arguments resultType: nil.

    public method bitcast: (value: HIRValue) into: (targetType: HIRValue) type: (type: Type) ::=> HIRValue := {
        (targetType == nil) || (targetType isLiteralConstant && (value type == (targetType downCastTo: HIRLiteralConstant) value)) ifTrue: {
            value
        } ifFalse: {
            self addInstruction: (HIRBitcastInstruction new
                value: value;
                targetType: targetType;
                type: type;
                registerInUsedValues;
                yourself)
        }.
    }.

    public method coerceValue: (value: HIRValue) into: (targetType: HIRValue) type: (type: Type) ::=> HIRValue := {
        (value type isSubtypeOf: ControlFlowEscapeType) ifTrue: {
            return: (self undefined: type)
        }.

        (targetType == nil) || (targetType isLiteralConstant && (value type == (targetType downCastTo: HIRLiteralConstant) value)) ifTrue: {
            value
        } ifFalse: {
            self addInstruction: (HIRCoerceValueInstruction new
                value: value;
                targetType: targetType;
                type: type;
                registerInUsedValues;
                yourself)
        }.
    }.

    public method conditionalBranch: (condition: HIRValue) trueDestination: (trueDestination: HIRBasicBlock) falseDestination: (falseDestination: HIRBasicBlock) ::=> HIRConditionalBranchInstruction
        := self addInstruction: (HIRConditionalBranchInstruction new
            condition: condition;
            trueDestination: trueDestination;
            falseDestination: falseDestination;
            type: Void;
            registerInUsedValues;
            yourself).

    public method unchecked: (isUnchecked: Boolean) downCast: (value: HIRValue) into: (targetType: HIRValue) type: (type: Type) ::=> HIRValue := {
        (value type isSubtypeOf: ControlFlowEscapeType) ifTrue: {
            return: (self undefined: type)
        }.

        (targetType == nil) || (targetType isLiteralConstant && (value type == (targetType downCastTo: HIRLiteralConstant) value)) ifTrue: {
            value
        } ifFalse: {
            self addInstruction: (HIRDownCastInstruction new
                value: value;
                targetType: targetType;
                isUnchecked: isUnchecked;
                type: type;
            registerInUsedValues;
                yourself)
        }.
    }.

    public method downCast: (value: HIRValue) into: (targetType: HIRValue) type: (type: Type) ::=> HIRValue
        := self unchecked: false downCast: value into: targetType type: type.

    public method undefined: (type: Type) ::=> HIRUndefinedConstant
        := HIRUndefinedConstant new
            sourcePosition: self sourcePosition;
            sourceASTNode: self sourceASTNode;
            sourceEnvironment: self sourceEnvironment;
            type: type;
            yourself.

    public method unreachable ::=> HIRUnreachableInstruction
        := self addInstruction: (HIRUnreachableInstruction new
            sourcePosition: self sourcePosition;
            sourceASTNode: self sourceASTNode;
            sourceEnvironment: self sourceEnvironment;
            type: Void;
            yourself).

    public method literal: value type: (type: Type) ::=> HIRLiteralConstant
        := HIRLiteralConstant new
            sourcePosition: self sourcePosition;
            sourceASTNode: self sourceASTNode;
            sourceEnvironment: self sourceEnvironment;
            value: value;
            type: type;
            yourself.

    public method literal: value ::=> HIRLiteralConstant
        := self literal: value type: value __type__.

    public method load: (storage: HIRValue) type: (type: Type) ::=> HIRLoadInstruction
        := self addInstruction: (HIRLoadInstruction new
            storage: storage;
            type: type;
            registerInUsedValues;
            yourself).

    public method makeArray: (elements: Array) ::=> HIRValue := {
        elements isEmpty ifTrue: {
            self literal: #()
        } ifFalse: {
            self addInstruction: (HIRMakeArrayInstruction new
                elements: elements;
                type: Array;
                registerInUsedValues;
                yourself)
        }
    }.

    public method makeByteArray: (elements: Array) ::=> HIRValue := {
        elements isEmpty ifTrue: {
            self literal: #[]
        } ifFalse: {
            self addInstruction: (HIRMakeByteArrayInstruction new
                elements: elements;
                type: ByteArray;
                registerInUsedValues;
                yourself)
        }
    }.

    public method makeAssociationWithKey: (key: HIRValue) value: (value: HIRValue) ::=> HIRMakeAssociationInstruction
        := self addInstruction: (HIRMakeAssociationInstruction new
            key: key;
            value: value;
            type: Association;
            registerInUsedValues;
            yourself).

    public method makeDictionary: (elements: Array) ::=> HIRMakeDictionaryInstruction
        := self addInstruction: (HIRMakeDictionaryInstruction new
            elements: elements;
            type: Dictionary;
            registerInUsedValues;
            yourself).

    public method makeClosure: (functionDefinition: HIRValue) captures: (captures: Array) type: (type: Type) ::=> HIRMakeClosureInstruction
        := self addInstruction: (HIRMakeClosureInstruction new
            functionDefinition: functionDefinition;
            captures: captures;
            type: type;
            registerInUsedValues;
            yourself).

    public method phi: (type: Type) ::=> HIRPhiInstruction
        := self addInstruction: (HIRPhiInstruction new
            type: type;
            registerInUsedValues;
            yourself).

    public method return: (value: HIRValue) ::=> HIRReturnInstruction
        := self addInstruction: (HIRReturnInstruction new
            type: Void;
            value: value;
            registerInUsedValues;
            yourself).

    public method returnVoid ::=> HIRReturnInstruction
        := self return: (self literal: void).

    public method send: (receiver: HIRValue) receiverLookupType: (receiverLookupType: HIRValue) selector: (selector: HIRValue) arguments: (arguments: Array) resultType: (resultType: Type) ::=> HIRSendInstruction
        := self addInstruction: (HIRSendInstruction new
            receiver: receiver;
            receiverLookupType: receiverLookupType;
            selector: selector;
            arguments: arguments;
            type: resultType;
            registerInUsedValues;
            yourself).

    public method send: (receiver: HIRValue) selector: (selector: HIRValue) arguments: (arguments: Array) resultType: (resultType: Type) ::=> HIRSendInstruction
        := self send: receiver receiverLookupType: nil selector: selector arguments: arguments resultType: resultType.

    public method send: (receiver: HIRValue) selector: (selector: HIRValue) arguments: (arguments: Array) ::=> HIRSendInstruction
        := self send: receiver receiverLookupType: nil selector: selector arguments: arguments resultType: nil.

    public method setDebugValue: (value: HIRValue) forBinding: (binding: SymbolBinding) ::=> HIRSetDebugValueForBindingInstruction
        := self addInstruction: (HIRSetDebugValueForBindingInstruction new
            value: value;
            binding: binding;
            registerInUsedValues;
            yourself).

    public method store: (value: HIRValue) in: (storage: HIRValue) ::=> HIRStoreInstruction
        := self addInstruction: (HIRStoreInstruction new
            value: value;
            storage: storage;
            registerInUsedValues;
            yourself).

    public method reference: (reference: HIRValue) elementAt: (index: HIRValue) type: (type: Type) ::=> HIRReferenceElementAtInstruction
        := self addInstruction: (HIRReferenceElementAtInstruction new
            reference: reference;
            index: index;
            type: type;
            registerInUsedValues;
            yourself).

    public method pointer: (pointer: HIRValue) elementAt: (index: HIRValue) type: (type: Type) ::=> HIRPointerElementAtInstruction
        := self addInstruction: (HIRPointerElementAtInstruction new
            pointer: pointer;
            index: index;
            type: type;
            registerInUsedValues;
            yourself).

    public method tuple: (tuple: HIRValue) typedSlotAt: (typeSlot: TypeSlot) ::=> HIRTypeSlotAtInstruction
        := self addInstruction: (HIRTypeSlotAtInstruction new
            tuple: tuple;
            typeSlot: typeSlot;
            type: typeSlot type;
            registerInUsedValues;
            yourself).

    public method tuple: (tuple: HIRValue) typedSlotReferenceAt: (typeSlot: TypeSlot) ::=> HIRTypeSlotReferenceAtInstruction
        := self addInstruction: (HIRTypeSlotReferenceAtInstruction new
            tuple: tuple;
            typeSlot: typeSlot;
            type: typeSlot referenceType;
            registerInUsedValues;
            yourself).

    public method tuple: (tuple: HIRValue) typedSlotAt: (typeSlot: TypeSlot) put: (value: HIRValue) ::=> HIRTypeSlotAtPutInstruction
        := self addInstruction: (HIRTypeSlotAtPutInstruction new
            tuple: tuple;
            typeSlot: typeSlot;
            value: value;
            type: Void;
            registerInUsedValues;
            yourself).

    public method lastInstruction => HIRInstruction
        := self basicBlock ifNotNil: {:basicBlock :: HIRInstruction | basicBlock lastInstruction }.

    public method isLastTerminator => Boolean
        := self lastInstruction
            ifNil: false
            ifNotNil: {:instruction :: Boolean | instruction isTerminatorInstruction }.
}.

HIRCompilationTarget definition: {
    public abstract method objectModel => ObjectModelVariant
        := self subclassResponsibility.

    public abstract method pointerSize => Size
        := self subclassResponsibility.

    public abstract method pointerAlignment => Size
        := self subclassResponsibility.

    public abstract method hasLogicalObjectModel => Boolean
        := self subclassResponsibility.

    public abstract method hasNativeObjectModel => Boolean
        := self subclassResponsibility.
}.

public class HIRTupleVMCompilationTarget superclass: HIRCompilationTarget; definition: {
    HIRCompilationTarget class extend: {
        public method default => self := HIRTupleVMCompilationTarget new.
    }.

    public override method hasLogicalObjectModel => Boolean
        := true.

    public override method hasNativeObjectModel => Boolean
        := false.
}.

