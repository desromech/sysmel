let IgnoreNotYetImplementedErrors := true.

public class HIRMIRCompilationTarget superclass: HIRCompilationTarget; definition: {
    public field mirCompilationTarget => MIRCompilationTarget.

    public override method objectModel => ObjectModelVariant
        := mirCompilationTarget objectModel.

    public override method pointerSize => Size
        := mirCompilationTarget pointerSize.

    public override method pointerAlignment => Size
        := mirCompilationTarget pointerAlignment.

    public override method hasLogicalObjectModel => Boolean
        := false.

    public override method hasNativeObjectModel => Boolean
        := true.
}.

public abstract class HIRMIRCodeGenerator superclass: Object; definition: {

}.

MIRCompilationTarget extend: {
    public method asHIRCompilationTarget => HIRCompilationTarget
        := HIRMIRCompilationTarget new mirCompilationTarget: self; yourself.
}.

public final class HIRModuleMIRCodeGenerator superclass: HIRMIRCodeGenerator; definition: {
    public field compilationTarget => MIRCompilationTarget.
    public field hirModule => HIRModule.
    public field targetModule => MIRModule.
    public field globalValueDictionary => Dictionary.

    public field runtimeFunctionDictionary => Dictionary.
    public field importRuntimeFunction => Boolean.
    private field runtimeFunctionCompilerFrontend => HIRModuleCompilationContext.

    public field capturelessUncheckedEntryPointDictionary => Dictionary.
    public field uncheckedEntryPointDictionary => Dictionary.
    public field checkedEntryPointDictionary => Dictionary.
    public field uncheckedInterpreterTrampolinesDictionary => Dictionary.
    public field boxingApplicationTrampolinesDictionary => Dictionary.

    public field nullPointerConstant => MIRConstant.
    public field nullFatPointerConstant => MIRConstant.

    public method initializeWithTarget: (theCompilationTarget: MIRCompilationTarget) ::=> Void := {
        compilationTarget := theCompilationTarget.
        targetModule := MIRModule new
            compilationTarget: compilationTarget;
            yourself.
        globalValueDictionary := Dictionary new.
        runtimeFunctionDictionary := Dictionary new.
        capturelessUncheckedEntryPointDictionary := Dictionary new.
        uncheckedEntryPointDictionary := Dictionary new.
        checkedEntryPointDictionary := Dictionary new.
        uncheckedInterpreterTrampolinesDictionary := Dictionary new.
        boxingApplicationTrampolinesDictionary := Dictionary new.
    }.

    public method compileHIRModule: (module: HIRModule) patchingFunctions: (patchedFunctionList: SequenceableCollection) definitions: (patchedFunctionDefinitionList: SequenceableCollection) ::=> MIRModule := {
        ## Declare the values.
        hirModule := module.
        module globalValues do: {:(HIRGlobalValue)each :: Void |
            each compileDirectMirTranslationWith: self
        }.

        runtimeFunctionCompilerFrontend ifNotNil: {
            runtimeFunctionCompilerFrontend hirModule globalValues do: {:(HIRGlobalValue)each :: Void |
                each compileDirectMirTranslationWith: self
            }.
        }.

        patchedFunctionDefinitionList do: {:(FunctionDefinition)eachFunctionDefinition :: Void |
            let ssaFunctionDefinition := hirModule getGlobalValueFor: eachFunctionDefinition.
            let patch := MIRFunctionDefinitionPatch new
                functionDefinition: eachFunctionDefinition;
                yourself.

            ssaFunctionDefinition isCaptureless ifTrue: {
                patch uncheckedCapturelessEntryPoint: (self translateCapturelessUncheckedFunctionEntryPoint: ssaFunctionDefinition).
            }.

            patch uncheckedEntryPoint: (self translateUncheckedFunctionEntryPointOrNil: ssaFunctionDefinition).
            patch checkedEntryPoint: (self translateCheckedFunctionEntryPointOrNil: ssaFunctionDefinition).
            targetModule functionDefinitionPatches add: patch.
        }.

        ## Return the target module.
        targetModule
    }.

    public method compileHIRModule: (module: HIRModule) ::=> MIRModule
        := self compileHIRModule: module patchingFunctions: #() definitions: #().

    public method finish => MIRModule
        := targetModule.

    public method compileDirectFunction: (function: HIRFunction) ::=> Void := {
        (function isTargetDefinedPrimitive && function exportedSymbols isEmpty) ifTrue: {return: void}.

        function definition ifNotNil: {
            function isCaptureless ifTrue: {
                (self translateCapturelessUncheckedFunctionEntryPoint: function definition)
                    addExportedSymbols: function exportedSymbols
            } ifFalse: {
                function exportedSymbols isNotEmpty ifTrue: {
                    self error: "TODO: Compile non-captureless exported function."
                }
            }.
        }
    }.

    public method compileDirectFunctionDefinition: (functionDefinition: HIRFunctionDefinition) ::=> Void := {
        functionDefinition isTargetDefinedPrimitive ifTrue: {return: void}.

        functionDefinition isCaptureless ifTrue: {
            self translateCapturelessUncheckedFunctionEntryPoint: functionDefinition
        } ifFalse: {
            self translateUncheckedFunctionEntryPointOrNil: functionDefinition
        }
    }.

    public method translateValue: (value: HIRValue) ::=> MIRValue
        := globalValueDictionary at: value ifAbsent: {|
        value translateIntoMirValueWith: self
    }.

    public method compileGlobalVariable: (globalVariable: HIRGlobalVariable) ::=> MIRGlobalVariable := {
        let mirGlobalVariable := (MIRGlobalVariable withName: globalVariable name type: globalVariable type valueType: globalVariable valueType isValueInstance: false compilationTarget: compilationTarget)
            sourceProgramEntity: globalVariable sourceBinding;
            isReadOnly: globalVariable isReadOnly;
            isExternal: globalVariable isExternal;
            isThreadLocal: globalVariable isThreadLocal;
            yourself.
        targetModule addProgramEntity: mirGlobalVariable.
        globalValueDictionary at: globalVariable put: mirGlobalVariable.

        mirGlobalVariable
    }.

    public method translateGlobalVariable: (globalVariable: HIRGlobalVariable) ::=> MIRValue := {
        globalValueDictionary at: globalVariable ifAbsentPut: {|
            self compileGlobalVariable: globalVariable
        }.
    }.

    public method translateFunction: (function: HIRFunction) ::=> MIRValue
        := globalValueDictionary at: function ifAbsentPut: {|
            self compileFunction: function
        }.

    public method translateFunctionDefinition: (functionDefinition: HIRFunctionDefinition) ::=> MIRValue
        := globalValueDictionary at: functionDefinition ifAbsentPut: {|
            self compileFunctionDefinition: functionDefinition
        }.

    public method compileFunction: (function: HIRFunction) ::=> MIRValue := {
        let functionObject := MIRGlobalVariable withName: function name type: Function valueType: Function isValueInstance: true compilationTarget: compilationTarget.
        targetModule addProgramEntity: functionObject.
        globalValueDictionary at: function put: functionObject.

        functionObject
    }.

    public method compileFunctionDefinition: (functionDefinition: HIRFunctionDefinition) ::=> MIRValue := {
        let functionDefinitionObject := MIRGlobalVariable withName: functionDefinition name type: FunctionDefinition valueType: FunctionDefinition isValueInstance: true compilationTarget: compilationTarget.
        targetModule addProgramEntity: functionDefinitionObject.
        globalValueDictionary at: functionDefinition put: functionDefinitionObject.

        functionDefinitionObject
    }.

    public method compileCapturelessUncheckedFunctionEntryPoint: (functionDefinition: HIRFunctionDefinition) ::=> MIRProgramEntity := {
        let importedSymbols := functionDefinition importedSymbols.
        importedSymbols isEmpty ifTrue: {
            let entryPoint := MIRFunction new
                compilationTarget: compilationTarget;
                callingConvention: (compilationTarget callingConventionNamed: functionDefinition callingConvention);
                name: functionDefinition name asCapturelessUncheckedEntryPointNameSymbol;
                debugSourcePosition: functionDefinition sourcePosition;
                debugSourceNode: functionDefinition sourceASTNode;
                debugSourceEnvironment: functionDefinition sourceEnvironment;
                sourceProgramEntity: functionDefinition sourceObject;
                isNoGC: functionDefinition isNoGC;
                yourself.
            targetModule addProgramEntity: entryPoint.
            capturelessUncheckedEntryPointDictionary at: functionDefinition put: entryPoint.

            HIRFunctionDefinitionMIRCodeGenerator new
                moduleCodeGenerator: self;
                compileHIRFunctionDefinition: functionDefinition intoCapturelessEntryPoint: entryPoint.

            entryPoint
        } ifFalse: {
            let importedEntity := MIRImportedFunction new
                name: importedSymbols first;
                compilationTarget: compilationTarget;
                callingConvention: (compilationTarget callingConventionNamed: functionDefinition callingConvention);
                alternativeSymbols: importedSymbols;
                yourself.
            targetModule addProgramEntity: importedEntity.
            capturelessUncheckedEntryPointDictionary at: functionDefinition put: importedEntity.

            importedEntity
        }.
    }.

    public method compileUncheckedFunctionEntryPoint: (functionDefinition: HIRFunctionDefinition) ::=> MIRProgramEntity := {
        let entryPoint := MIRFunction new
            compilationTarget: compilationTarget;
            callingConvention: (compilationTarget callingConventionNamed: functionDefinition callingConvention);
            name: functionDefinition name asUncheckedEntryPointNameSymbol;
            debugSourcePosition: functionDefinition sourcePosition;
            debugSourceNode: functionDefinition sourceASTNode;
            debugSourceEnvironment: functionDefinition sourceEnvironment;
            sourceProgramEntity: functionDefinition sourceObject;
            isNoGC: functionDefinition isNoGC;
            yourself.
        targetModule addProgramEntity: entryPoint.
        uncheckedEntryPointDictionary at: functionDefinition put: entryPoint.

        functionDefinition isCaptureless ifTrue: {
            HIRFunctionDefinitionMIRCodeGenerator new
                moduleCodeGenerator: self;
                compileHIRFunctionDefinition: functionDefinition
                    uncheckedEntryPoint: entryPoint
                    into: (self translateCapturelessUncheckedFunctionEntryPoint: functionDefinition)
        } ifFalse: {
            HIRFunctionDefinitionMIRCodeGenerator new
                moduleCodeGenerator: self;
                compileHIRFunctionDefinition: functionDefinition intoUncheckedEntryPoint: entryPoint.
        }.

        entryPoint
    }.

    public method compileCheckedFunctionEntryPoint: (functionDefinition: HIRFunctionDefinition) ::=> MIRProgramEntity := {
        let entryPoint := MIRFunction new
            compilationTarget: compilationTarget;
            callingConvention: compilationTarget defaultCallingConvention;
            name: functionDefinition name asCheckedEntryPointNameSymbol;
            debugSourcePosition: functionDefinition sourcePosition;
            debugSourceNode: functionDefinition sourceASTNode;
            debugSourceEnvironment: functionDefinition sourceEnvironment;
            sourceProgramEntity: functionDefinition sourceObject;
            isNoGC: functionDefinition isNoGC;
            yourself.
        targetModule addProgramEntity: entryPoint.
        checkedEntryPointDictionary at: functionDefinition put: entryPoint.

        HIRFunctionDefinitionMIRCodeGenerator new
            moduleCodeGenerator: self;
            compileHIRFunctionDefinition: functionDefinition checkedEntryPoint: entryPoint
            into: (functionDefinition isCaptureless
                    ifTrue: (self translateCapturelessUncheckedFunctionEntryPoint: functionDefinition)
                    ifFalse: (self translateUncheckedFunctionEntryPointOrNil: functionDefinition)
                ) isCaptureless: functionDefinition isCaptureless.

        entryPoint
    }.

    public method getOrCreateUncheckedInterpreterTrampolineWithSignature: (signature: Array) ::=> MIRProgramEntity := {
        uncheckedInterpreterTrampolinesDictionary at: signature ifAbsent: {|
            let nameBuilder := StringStream new.
            nameBuilder nextPutAll: "uncheckedInterpreterTrampoline"; print: signature size; nextPutAll: ".SUIT".
            signature hash printHexOn: nameBuilder.

            let trampoline := MIRFunction new
                compilationTarget: compilationTarget;
                callingConvention: compilationTarget defaultCallingConvention;
                name: nameBuilder asSymbol;
                yourself.
            targetModule addProgramEntity: trampoline.
            uncheckedInterpreterTrampolinesDictionary at: signature put: trampoline.

            HIRFunctionDefinitionMIRCodeGenerator new
                moduleCodeGenerator: self;
                compileUncheckedInterpreterTrampolineWithSignature: signature into: trampoline.

            trampoline
        }.
    }.

    public method getOrCreateBoxingApplicationTrampolineWithSignature: (signature: Array) ::=> MIRProgramEntity := {
        boxingApplicationTrampolinesDictionary at: signature ifAbsent: {|
            let nameBuilder := StringStream new.
            nameBuilder nextPutAll: "boxingApplicationTrampoline"; print: signature size; nextPutAll: ".SUIT".
            signature hash printHexOn: nameBuilder.

            let trampoline := MIRFunction new
                compilationTarget: compilationTarget;
                callingConvention: compilationTarget defaultCallingConvention;
                name: nameBuilder asSymbol;
                yourself.
            targetModule addProgramEntity: trampoline.
            boxingApplicationTrampolinesDictionary at: signature put: trampoline.

            HIRFunctionDefinitionMIRCodeGenerator new
                moduleCodeGenerator: self;
                compileBoxingApplicationTrampolineWithSignature: signature into: trampoline.

            trampoline
        }.
    }.

    public method setValue: (value: HIRValue) translationInto: (mirValue: MIRValue) ::=> MIRValue := {
        globalValueDictionary at: value put: mirValue.
        mirValue
    }.

    public method getVirtualTableIndexValueForSelector: (selector: Symbol) type: (type: Type) ::=> MIRValue := {
        selector isNotNil && type isNotNil ifTrue: {
            let vtableLayout := hirModule virtualTableSetSource getVirtualTableLayoutOrNilOf: type.
            vtableLayout ifNotNil: {
                let vtableIndexOrNil := vtableLayout selectorToIndexTable atOrNil: selector.
                vtableIndexOrNil ifNotNil: {
                    let vtableIndex := vtableIndexOrNil downCastTo: Size.
                    compilationTarget pointerSize = 4sz
                        ifTrue: vtableIndex asUInt32 asMirConstant
                        ifFalse: vtableIndex asUInt64 asMirConstant
                }
            }.
        } ifFalse: {
            nil
        }
    }.

    public method shouldCompileFunctionDefinition: (definition: HIRFunctionDefinition) ::=> Boolean
        := definition ~~ nil.

    public method translateCapturelessUncheckedFunctionEntryPoint: (value: HIRValue) ::=> MIRProgramEntity := {
        let functionDefinition := value asHIRFunctionDefinitionOrNil.
        functionDefinition ifNil: {
            self error: "Cannot generate captureless unchecked entry point for function without a definition " -- value printString
        }.

        capturelessUncheckedEntryPointDictionary at: functionDefinition ifAbsent: {:: MIRProgramEntity |
            self compileCapturelessUncheckedFunctionEntryPoint: functionDefinition
        }
    }.

    public method translateUncheckedFunctionEntryPointOrNil: (value: HIRValue) ::=> MIRProgramEntity := {
        let functionDefinition := value asHIRFunctionDefinitionOrNil.
        (self shouldCompileFunctionDefinition: functionDefinition) ifTrue: {
            uncheckedEntryPointDictionary at: functionDefinition ifAbsent: {:: MIRProgramEntity |
                self compileUncheckedFunctionEntryPoint: functionDefinition
            }
        } ifFalse: {
            nil
        }
    }.

    public method translateCheckedFunctionEntryPointOrNil: (value: HIRValue) ::=> MIRProgramEntity := {
        let functionDefinition := value asHIRFunctionDefinitionOrNil.
        (self shouldCompileFunctionDefinition: functionDefinition) ifTrue: {
            checkedEntryPointDictionary at: functionDefinition ifAbsent: {:: MIRProgramEntity |
                self compileCheckedFunctionEntryPoint: functionDefinition
            }
        } ifFalse: {
            nil
        }
    }.

    public method translateCheckedFunctionEntryPoint: (value: HIRValue) argumentCount: (argumentCount: Size)::=> MIRProgramEntity := {
        let functionDefinition := value asHIRFunctionDefinitionOrNil.
        (self shouldCompileFunctionDefinition: functionDefinition) && functionDefinition requiresArgumentExpansionDuringApplication not ifTrue: {
            checkedEntryPointDictionary at: functionDefinition ifAbsent: {:: MIRProgramEntity |
                self compileCheckedFunctionEntryPoint: functionDefinition
            }
        } ifFalse: {
            argumentCount < ObjectModel::CheckedFunctionApplicationTrampolines size ifTrue: {
                self translateRuntimeFunction: (ObjectModel::CheckedFunctionApplicationTrampolines at: argumentCount)
            } ifFalse: {
                nil
            }.
        }
    }.

    public method translateRuntimeFunction: (function: Function) ::=> MIRProgramEntity := {
        runtimeFunctionDictionary at: function ifAbsentPut: {:MIRProgramEntity |
            let ssaRuntimeFunction := hirModule getGlobalValueOrNilFor: function.
            ssaRuntimeFunction ifNotNil: {
                self translateCapturelessUncheckedFunctionEntryPoint: ssaRuntimeFunction
            } ifNil: {
                importRuntimeFunction ifTrue: {
                    let importedRuntimeFunction := MIRImportedFunction new
                        name: function definition capturelessUncheckedEntryPointNameSymbol;
                        compilationTarget: compilationTarget;
                        callingConvention: (compilationTarget callingConventionNamed: function definition callingConventionName);
                        yourself.
                    targetModule addProgramEntity: importedRuntimeFunction.
                    importedRuntimeFunction
                } ifFalse: {
                    runtimeFunctionCompilerFrontend ifNil: {
                        runtimeFunctionCompilerFrontend := HIRModuleCompilationContext forTarget: compilationTarget asHIRCompilationTarget.
                        runtimeFunctionCompilerFrontend addUsedModule: hirModule.
                    }.
                    self translateCapturelessUncheckedFunctionEntryPoint: (runtimeFunctionCompilerFrontend translateFunction: function)
                }.
            }.
        }.
    }.

    public method translateGenericObjectPointer: (object: Untyped) ::=> MIRValue := {
        (compilationTarget objectModel isImmediateReference: object) ifTrue: {
            compilationTarget objectModel mirImmediateReferenceFor: object 
        } ifFalse: {
            MIRGenericObjectPointerConstant new
                size: compilationTarget pointerSize;
                alignment: compilationTarget pointerAlignment;
                object: object;
                type: compilationTarget uintPointerType;
                yourself
        }.
    }.

    public method translateStructureConstant: (structure: AnyValue) ::=> MIRValue := {
        let structureType := structure __type__.
        MIRStructureConstant new
            value: structure;
            size: structureType validInstanceSize;
            alignment: structureType validInstanceAlignment;
            type: structureType;
            yourself.
    }.

    public method translateCStringConstant: (string: String) ::=> MIRValue
        := MIRStringLiteralPointerConstant new
            size: compilationTarget pointerSize;
            alignment: compilationTarget pointerAlignment;
            string: string;
            type: compilationTarget uintPointerType;
            nullTerminated: true;
            yourself.

    public method nullPointerConstant => MIRConstant
        := nullPointerConstant ifNil: (nullPointerConstant := compilationTarget pointerSize = 4sz ifTrue: 0u32 asMirConstant ifFalse: 0u64 asMirConstant).

    public method nullFatPointerConstant => MIRConstant
        := nullFatPointerConstant ifNil: (nullFatPointerConstant := compilationTarget pointerSize = 4sz ifTrue: MIRConstantUInt32x2 new ifFalse: MIRConstantUInt64x2 new).
}.

public final class HIRFunctionDefinitionMIRCodeGenerator superclass: HIRMIRCodeGenerator; definition: {
    public field moduleCodeGenerator => HIRModuleMIRCodeGenerator.
    public field ssaFunctionDefinition => HIRFunctionDefinition.
    public field mirFunction => MIRFunction.
    public field functionBuilder => MIRFunctionBuilder.
    public field blockBuilder => MIRBlockBuilder.
    protected field isCapturelessEntryPoint => Boolean.
    protected field valueDictionary => Dictionary.
    public field localOnlyAllocaDictionary => Dictionary.
    public field functionArgument => MIRValue.
    protected field boxedValueDictionary => Dictionary.

    public override method initialize => Void := {
        valueDictionary := Dictionary new.
        localOnlyAllocaDictionary := Dictionary new.
    }.

    public method compilationTarget => MIRCompilationTarget
        := moduleCodeGenerator compilationTarget.

    public method nullPointerConstant => MIRConstant
        := moduleCodeGenerator nullPointerConstant.

    public method nullFatPointerConstant => MIRConstant
        := moduleCodeGenerator nullFatPointerConstant.

    public method compileHIRFunctionDefinition: (ssaFunctionDefinition: HIRFunctionDefinition) intoCapturelessEntryPoint: (entryPoint: MIRFunction) ::=> Void := {
        self ssaFunctionDefinition: ssaFunctionDefinition.
        isCapturelessEntryPoint := true.

        entryPoint build: {:(MIRFunctionBuilder)functionBuilder :: Void |
            mirFunction := functionBuilder function.
            self functionBuilder: functionBuilder.
            moduleCodeGenerator capturelessUncheckedEntryPointDictionary at: ssaFunctionDefinition put: mirFunction.

            self compileDefinition.

            mirFunction
        }.
    }.

    public method compileHIRFunctionDefinition: (ssaFunctionDefinition: HIRFunctionDefinition) intoUncheckedEntryPoint: (entryPoint: MIRFunction) ::=> Void := {
        self ssaFunctionDefinition: ssaFunctionDefinition.
        isCapturelessEntryPoint := false.

        entryPoint build: {:(MIRFunctionBuilder)functionBuilder :: Void |
            mirFunction := functionBuilder function.
            self functionBuilder: functionBuilder.
            moduleCodeGenerator uncheckedEntryPointDictionary at: ssaFunctionDefinition put: mirFunction.

            self compileDefinition.

            mirFunction
        }.
    }.

    public method compileFunction: (ssaFunction: HIRFunction) exportedEntryPoint: (exportedEntryPoint: MIRFunction) into: (uncheckedEntryPoint: MIRValue) ::=> Void := {
        let arguments := ssaFunction definition arguments collect: {:(HIRFunctionArgument)argument :: MIRValue |
            exportedEntryPoint newArgument: argument name withType: argument type sourceBinding: argument sourceBinding.
        }.

        exportedEntryPoint arguments: arguments.

        exportedEntryPoint build: {:(MIRFunctionBuilder)functionBuilder :: Void |
            self functionBuilder: functionBuilder.
            functionBuilder basicBlock: #trampoline build: {:(MIRBlockBuilder)asm :: Void |
                let closure := self translateValue: ssaFunction.
                let callArguments := (Array with: closure) -- arguments.

                let canonicalResultType := ssaFunction definition functionType canonicalResultType.
                let result := canonicalResultType emitMirCall: uncheckedEntryPoint convention: (moduleCodeGenerator compilationTarget callingConventionNamed: ssaFunction callingConventionNameOrNil)
                    withArguments: callArguments withBlockBuilder: asm.

                canonicalResultType emitMirReturn: result withBlockBuilder: asm
            }.
        }.
    }.

    public method compileHIRFunctionDefinition: (ssaFunctionDefinition: HIRFunctionDefinition) uncheckedEntryPoint: (uncheckedEntryPoint: MIRFunction) into: (capturelessEntryPoint: MIRProgramEntity) ::=> Void := {
        let mirArguments := OrderedCollection new.
        functionArgument := uncheckedEntryPoint newArgument: #closure withType: Function.
        mirArguments add: functionArgument.

        let calledArguments := ssaFunctionDefinition arguments collect: {:(HIRFunctionArgument)argument :: MIRValue |
            let mirArgument := uncheckedEntryPoint newArgument: argument name withType: argument type sourceBinding: argument sourceBinding.
            mirArguments add: mirArgument.
            mirArgument
        }.
        uncheckedEntryPoint arguments: mirArguments asArray.
        uncheckedEntryPoint trampolineTarget: capturelessEntryPoint.

        uncheckedEntryPoint build: {:(MIRFunctionBuilder)functionBuilder :: Void |
            mirFunction := functionBuilder function.
            self functionBuilder: functionBuilder.

            functionBuilder basicBlock: #wrapper build: {:(MIRBlockBuilder)asm :: Void |
                let canonicalResultType := ssaFunctionDefinition functionType canonicalResultType.
                let result := canonicalResultType emitMirCall: capturelessEntryPoint convention: capturelessEntryPoint callingConvention
                    withArguments: calledArguments withBlockBuilder: asm.

                canonicalResultType emitMirReturn: result withBlockBuilder: asm.
            }.
        }
    }.

    public method compileHIRFunctionDefinition: (ssaFunctionDefinition: HIRFunctionDefinition) checkedEntryPoint: (checkedEntryPoint: MIRFunction) into: (uncheckedEntryPoint: MIRProgramEntity) isCaptureless: (isCaptureless: Boolean) ::=> Void := {
        let mirArguments := OrderedCollection new.
        functionArgument := checkedEntryPoint newArgument: #closure withType: Function.
        mirArguments add: functionArgument.

        let uncheckedArguments := ssaFunctionDefinition arguments collect: {:(HIRFunctionArgument)argument :: MIRValue |
            let mirArgument := checkedEntryPoint newArgument: argument name withType: Untyped sourceBinding: argument sourceBinding.
            mirArguments add: mirArgument.
            mirArgument
        }.

        checkedEntryPoint arguments: mirArguments asArray.
        checkedEntryPoint trampolineTarget: uncheckedEntryPoint.

        checkedEntryPoint build: {:(MIRFunctionBuilder)functionBuilder :: Void |
            mirFunction := functionBuilder function.
            self functionBuilder: functionBuilder.

            functionBuilder basicBlock: #wrapper build: {:(MIRBlockBuilder)asm :: Void |
                self blockBuilder: asm.
                let checkedAndConvertedArguments := ssaFunctionDefinition arguments collectWithIndex: {:(HIRFunctionArgument)argument :(Size)index :: MIRValue |
                    let mirArgument => MIRValue := mirArguments at: index + 1sz.
                    argument type emitMirCheckAndUnbox: mirArgument withHIRCodeGenerator: self
                }.

                let canonicalResultType := ssaFunctionDefinition functionType canonicalResultType.
                let result := isCaptureless ifTrue: {
                    canonicalResultType emitMirCall: uncheckedEntryPoint convention: uncheckedEntryPoint callingConvention
                        withArguments: checkedAndConvertedArguments withBlockBuilder: asm.
                } ifFalse: {
                    canonicalResultType emitMirCall: uncheckedEntryPoint convention: uncheckedEntryPoint callingConvention
                        withArguments: (Array with: functionArgument) -- checkedAndConvertedArguments withBlockBuilder: asm.
                }.

                let boxedResult := canonicalResultType emitMirBox: result withHIRCodeGenerator: self.
                asm returnPointer: boxedResult
            }.
        }
    }.

    public method compileUncheckedInterpreterTrampolineWithSignature: (signature: Array) into: (trampoline: MIRFunction) ::=> Void := {
        let mirArguments := OrderedCollection new.
        functionArgument := trampoline newArgument: #closure withType: Function.
        mirArguments add: functionArgument.

        let argumentTypes := signature allButLast.
        let resultType => Type := signature last.

        let uncheckedArguments := argumentTypes collect: {:(Type)argumentType :: MIRValue |
            let mirArgument := trampoline newArgumentWithType: argumentType.
            mirArguments add: mirArgument.
            mirArgument
        }.

        trampoline arguments: mirArguments asArray.

        trampoline build: {:(MIRFunctionBuilder)functionBuilder :: Void |
            mirFunction := functionBuilder function.
            self functionBuilder: functionBuilder.

            functionBuilder basicBlock: #trampoline build: {:(MIRBlockBuilder)asm :: Void |
                self blockBuilder: asm.

                ## Allocate the boxed argument vector.
                let boxedArgumentVector := asm callPointer: (self translateRuntimeFunction: ObjectModel::makeArrayWithSize)
                    with: (asm pointerConstantWith: uncheckedArguments size asUInt64)
                    type: Array.

                ## Box the arguments and store them in the vecotr
                let headerSize := (Array objectHeaderSizeForObjectModel: self compilationTarget objectModel) asInt64.
                let pointerSize := self compilationTarget pointerSize asInt64.
                uncheckedArguments doWithIndex: {:(MIRValue)unboxedArgument :(Size)index :: Void |
                    let argumentType => Type := argumentTypes at: index.
                    let boxedArgument := argumentType emitMirBox: unboxedArgument withHIRCodeGenerator: self.
                    self storePointer: boxedArgument into: boxedArgumentVector constantOffset: headerSize + (index asInt64 * pointerSize) in: boxedArgumentVector
                }.

                ## Call the interpreter.
                let boxedResult := asm callPointer: (self translateRuntimeFunction: ObjectModel::interpretFunctionWithArguments)
                    with: functionArgument with: boxedArgumentVector type: Untyped.

                ## Unbox and return the result.
                let unboxedResult := resultType emitMirCheckAndUnbox: boxedResult withHIRCodeGenerator: self.
                resultType emitMirReturn: unboxedResult withBlockBuilder: asm.
            }
        }
    }.

    public method compileBoxingApplicationTrampolineWithSignature: (signature: Array) into: (trampoline: MIRFunction) ::=> Void := {
        let mirArguments := OrderedCollection new.
        functionArgument := trampoline newArgument: #closure withType: Function.
        mirArguments add: functionArgument.

        let argumentTypes := signature allButLast.
        let resultType => Type := signature last.

        let uncheckedArguments := argumentTypes collect: {:(Type)argumentType :: MIRValue |
            let mirArgument := trampoline newArgumentWithType: argumentType.
            mirArguments add: mirArgument.
            mirArgument
        }.

        trampoline arguments: mirArguments asArray.
        trampoline build: {:(MIRFunctionBuilder)functionBuilder :: Void |
            mirFunction := functionBuilder function.
            self functionBuilder: functionBuilder.

            functionBuilder basicBlock: #trampoline build: {:(MIRBlockBuilder)asm :: Void |
                self blockBuilder: asm.

                let boxedArguments := uncheckedArguments collectWithIndex: {:(MIRValue)unboxedArgument :(Size)index :: MIRValue |
                    let argumentType => Type := argumentTypes at: index.
                    argumentType emitMirBox: unboxedArgument withHIRCodeGenerator: self
                }.

                let boxedResult := asm callPointer: (self translateRuntimeFunction: (ObjectModel::CheckedFunctionApplicationTrampolines at: uncheckedArguments size))
                    arguments: (Array with: functionArgument) -- boxedArguments type: Untyped.

                ## Unbox and return the result.
                let unboxedResult := resultType emitMirCheckAndUnbox: boxedResult withHIRCodeGenerator: self.
                resultType emitMirReturn: unboxedResult withBlockBuilder: asm.
            }
        }
    }.

    public method compileDefinition => Void := {
        ssaFunctionDefinition importedSymbols size > 0sz ifTrue: {
            return: void.
        }.

        self declareArguments.

        self compilePrimitiveFunctionBody ifFalse: {
            self
                declareCaptures;
                declareValues;
                compileBasicBlocks.
        }.
    }.

    public method declareArguments => Void := {
        let mirArguments := OrderedCollection new.
        isCapturelessEntryPoint ifFalse: {
            functionArgument := mirFunction newArgument: #closure withType: Function.
            mirArguments add: functionArgument.
        }.
        
        ssaFunctionDefinition arguments do: {:(HIRFunctionArgument)argument :: Void |
            let mirArgument := mirFunction newArgument: argument name withType: argument type sourceBinding: argument sourceBinding.
            valueDictionary at: argument put: mirArgument.
            mirArguments add: mirArgument.
        }.

        mirFunction arguments: mirArguments asArray.
    }.

    public method directArguments => Array
        := isCapturelessEntryPoint
            ifTrue: mirFunction arguments
            ifFalse: mirFunction arguments allButFirst.

    public method declareCaptures => Void := {
        let mirCaptures := OrderedCollection new.
        ssaFunctionDefinition captures do: {:(HIRFunctionCapture)capture :: Void |
            let mirCapture := mirFunction newCapture: capture name withType: capture type.
            mirCapture sourceBinding: capture sourceBinding.
            valueDictionary at: capture put: mirCapture.
            mirCaptures add: mirCapture.
        }.

        mirFunction
            captures: mirCaptures asArray;
            computeCaptureVectorLayout
    }.

    public method declareValues => Void := {
        ssaFunctionDefinition basicBlocksDo: {:(HIRBasicBlock)eachBlock :: Void |
            let mirBlock := MIRBasicBlock new
                name: eachBlock name;
                debugSourcePosition: eachBlock sourcePosition;
                debugSourceNode: eachBlock sourceASTNode;
                debugSourceEnvironment: eachBlock sourceEnvironment;
                yourself.

            mirFunction addBasicBlock: mirBlock.
            valueDictionary at: eachBlock put: mirBlock.

        }
    }.

    public method compileBasicBlocks => Void := {
        ssaFunctionDefinition basicBlocksDo: {:(HIRBasicBlock)eachBlock :: Void |
            let mirBlock => MIRBasicBlock := valueDictionary at: eachBlock.
            self compileBasicBlock: eachBlock into: mirBlock
        }.

        ## Fix the Phi instruction incoming references.
        ssaFunctionDefinition basicBlocksDo: {:(HIRBasicBlock)eachBlock :: Void |
            eachBlock phiInstructionsDo: {:(HIRPhiInstruction)eachPhi :: Void |
                self convertPhiIncomingValues: eachPhi
            }.
        }.
    }.

    public method convertPhiIncomingValues: (hirPhi: HIRPhiInstruction) ::=> Void := {
        let mirPhi => MIRInstruction := valueDictionary at: hirPhi.

        let operands := OrderedCollection new.
        hirPhi incomingBlocksAndValues do: {:(Association)incomingBlockAndValue :: Void |
            let incomingHirBlock => HIRBasicBlock := incomingBlockAndValue key.
            let incomingHirValue => HIRValue := incomingBlockAndValue value.

            let incomingMirBlock => MIRBasicBlock := valueDictionary at: incomingHirBlock.
            self assert: incomingMirBlock lastInstruction isNotNil && incomingMirBlock lastInstruction isTerminator.
            blockBuilder
                block: incomingMirBlock;
                function: mirFunction;
                insertionPoint: incomingMirBlock lastInstruction;
                debugSourcePosition: hirPhi sourcePosition;
                debugSourceNode: hirPhi sourceASTNode;
                debugSourceEnvironment: hirPhi sourceEnvironment;
                yourself.

            let incomingMirValue := self translateValue: incomingHirValue withExpectedType: hirPhi type.
            operands add: incomingMirBlock; add: incomingMirValue.
        }.

        mirPhi operands: operands asArray.
        mirPhi registerInUsedValues.
    }.

    public method compileBasicBlock: (ssaBasicBlock: HIRBasicBlock) into: (mirBlock: MIRBasicBlock) ::=> Void := {
        blockBuilder := MIRBlockBuilder new
            block: mirBlock;
            function: mirFunction;
            yourself.
        boxedValueDictionary := nil.
        ssaBasicBlock instructionsDo: {:(HIRInstruction)eachInstruction :: Void |
            functionBuilder useDebugInfoOfHIRValue: eachInstruction.
            blockBuilder useDebugInfoOfHIRValue: eachInstruction.
            let instructionValue := eachInstruction compileIntoMIRWith: self.
            valueDictionary at: eachInstruction put: instructionValue
        }
    }.

    public method translateValue: (value: HIRValue) ::=> MIRValue
        := valueDictionary at: value ifAbsent: {|
            self assert: value isFunctionLocalValue not.
            moduleCodeGenerator translateValue: value
        }.
    
    public method translateBoxedValue: (value: HIRValue) ::=> MIRValue := {
        boxedValueDictionary ifNil: (boxedValueDictionary := Dictionary new).
        boxedValueDictionary at: value ifAbsentPut: {:: MIRValue |
            value isLiteralConstant ifTrue: {
                self translateValue: (value downCastTo: HIRLiteralConstant) asBoxedLiteralConstant
            } ifFalse: {
                let translatedValue := self translateValue: value.
                value type emitMirBox: translatedValue withHIRCodeGenerator: self
            }.
        }
    }.

    public method translateValue: (value: HIRValue) withExpectedType: (expectedType: Type) ::=> MIRValue := {
        value type == expectedType || (value type isValueType = expectedType isValueType) ifTrue: {
            self translateValue: value
        } ifFalse: {
            value type isValueType ifTrue: {
                self assert: value type isValueType && expectedType isValueType not.
                self translateBoxedValue: value
            } ifFalse: {
                self assert: value type isValueType not && expectedType isValueType.
                expectedType emitMirCheckAndUnbox: (self translateValue: value) withHIRCodeGenerator: self
            }
        }
    }.

    public method translateCapturelessUncheckedFunctionEntryPoint: (value: HIRValue) ::=> MIRValue
        := moduleCodeGenerator translateCapturelessUncheckedFunctionEntryPoint: value.

    public method translateUncheckedFunctionEntryPoint: (value: HIRValue) functionType: (functionType: Type) resultType: (resultType: Type) argumentCount: (argumentCount: Size) ::=> MIRValue := {
        (moduleCodeGenerator translateUncheckedFunctionEntryPointOrNil: value) ifNil: {
            let trampolineTypeSignature := Array new: argumentCount + 1sz.
            {
                let i mutable := 0sz.
                while: (i < argumentCount) do: {
                    trampolineTypeSignature at: i put: (functionType canonicalTypeForApplicationArgumentWithIndex: i)
                } continueWith: (i := i + 1sz).

                trampolineTypeSignature at: i put: resultType.
            }.

            let interpreterTrampoline := moduleCodeGenerator getOrCreateUncheckedInterpreterTrampolineWithSignature: trampolineTypeSignature.

            blockBuilder callPointer: (self translateRuntimeFunction: ObjectModel::fetchUncheckedEntryPointOrInterpreterTrampoline)
                with: (self translateValue: value) with: interpreterTrampoline
                type: Void pointer
        }
    }.

    public method translateCheckedFunctionEntryPoint: (value: HIRValue) argumentCount: (argumentCount: Size)::=> MIRValue
        := moduleCodeGenerator translateCheckedFunctionEntryPoint: value argumentCount: argumentCount.

    public method translateRuntimeFunction: (function: Function) ::=> MIRProgramEntity
        := moduleCodeGenerator translateRuntimeFunction: function.

    public method notYetImplementedError: (error: String) ::=> MIRValue := {
        IgnoreNotYetImplementedErrors ifTrue: {
            blockBuilder trap
        } ifFalse: {
            self error: "HIR->MIR NotYetImplemented: " -- error
        }.
    }.

    public method objectPointerOrNilFor: (object: MIRValue) ::=> MIRValue := {
        let objectType := object type.
        objectType isValueType ifFalse: {
            object
        } ifTrue: {
            objectType isPointerLikeType && objectType validAddressSpace isFatPointer ifTrue: {
                blockBuilder fatPointerExtractSecond: object type: Untyped
            } ifFalse: {
                nil
            }
        }
    }.

    public method generationalRememberFunction => MIRValue
        := self translateRuntimeFunction: GarbageCollector::rememberPointer.

    public method emitObjectWriteBarrier: (object: MIRValue) value: (value: MIRValue) ::=> Void := {
        mirFunction isNoGC ifTrue: {return: void}.
        object ifNil: {return: void}.
        self assert: object type isValueType not.

        let valueType := value type.
        valueType isValueType ifTrue: {
            valueType validAddressSpace isFatPointer ifTrue: {
                let valueOwner := blockBuilder fatPointerExtractSecond: value type: Void pointer.
                blockBuilder generationalWriteBarrer: object constantOffset: ObjectModel::FlagsOffset asInt64 value: valueOwner rememberFunction: self generationalRememberFunction
            }
        } ifFalse: {
            blockBuilder generationalWriteBarrer: object constantOffset: ObjectModel::FlagsOffset asInt64 value: value rememberFunction: self generationalRememberFunction
        }.
    }.

    public method storePointer: (value: MIRValue) into: (pointer: MIRValue) constantOffset: (constantOffset: Int64) in: (object: MIRValue) ::=> MIRInstruction := {
        self emitObjectWriteBarrier: object value: value.
        blockBuilder storePointer: value into: pointer constantOffset: constantOffset.
    }.

    public method storeFatPointer: (value: MIRValue) into: (pointer: MIRValue) constantOffset: (constantOffset: Int64) in: (object: MIRValue) ::=> MIRInstruction := {
        self emitObjectWriteBarrier: object value: value.
        blockBuilder storeFatPointer: value into: pointer constantOffset: constantOffset.
    }.
}.

MIRFunctionBuilder extend: {
    public method useDebugInfoOfHIRValue: (value: HIRValue) ::=> Void := {
        debugSourcePosition := value sourcePosition.
        debugSourceNode := value sourceASTNode.
        debugSourceEnvironment := value sourceEnvironment.
    }
}.

MIRBlockBuilder extend: {
    public method useDebugInfoOfHIRValue: (value: HIRValue) ::=> Void := {
        debugSourcePosition := value sourcePosition.
        debugSourceNode := value sourceASTNode.
        debugSourceEnvironment := value sourceEnvironment.
    }
}.

Type extend: {
    public virtual method emitMirCoerceInto: (targetType: MIRValue) thenUnbox: (value: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue := {
        let coerceFunction := codegen translateRuntimeFunction: (self isNullable
            ifTrue: ObjectModel::coerceNullableValue
            ifFalse: ObjectModel::coerceValue
        ).

        codegen blockBuilder
            callPointer: (codegen translateRuntimeFunction: ObjectModel::coerceValue)
            with: targetType with: value
            type: self
    }.

    public virtual method emitMirCheckInto: (targetType: MIRValue) thenUnbox: (value: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue := {
        let typecheckFunction := codegen translateRuntimeFunction: (self isNullable
            ifTrue: ObjectModel::typecheckNullableValue
            ifFalse: ObjectModel::typecheckValue
        ).

        codegen blockBuilder callVoid: typecheckFunction with: targetType with: value.
        value
    }.

    public virtual method emitMirUncheckedUnbox: (value: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue := {
        value type ~~ self
            ifTrue: (codegen blockBuilder movePointer: value type: self)
            ifFalse: value
    }.

    public virtual method emitMirCheckAndUnbox: (value: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue := {
        (self == Untyped) || (self == AnyValue) ifFalse: {
            let typecheckFunction := codegen translateRuntimeFunction: (self isNullable
                ifTrue: ObjectModel::typecheckNullableValue
                ifFalse: ObjectModel::typecheckValue
            ).
            codegen blockBuilder callVoid: typecheckFunction with: (codegen moduleCodeGenerator translateGenericObjectPointer: self) with: value.
        }.

        value
    }.

    public virtual method emitMirBox: (value: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue
        := value.

    public virtual method emitMirCall: (function: MIRValue) convention: (callingConvention: MIRCallingConvention) withArguments: (arguments: Array) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder callPointer: function convention: callingConvention arguments: arguments type: self.

    public virtual method emitMirPhiWithBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder phiPointer: self.

    public virtual method emitMirReturn: (value: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder returnPointer: value.

    public virtual method emitMirMove: (value: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder movePointer: value type: self.

    public virtual method emitMirUnboxingCall: (function: MIRValue) convention: (callingConvention: MIRCallingConvention) withArguments: (arguments: Array) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue := {
        let result := codegen blockBuilder callPointer: function convention: callingConvention arguments: arguments type: self.

        (self == Untyped) || (self == AnyValue) ifFalse: {
            let typecheckFunction := codegen translateRuntimeFunction: (self isNullable
                ifTrue: ObjectModel::typecheckNullableValue
                ifFalse: ObjectModel::typecheckValue
            ).
            codegen blockBuilder callVoid: typecheckFunction with: (codegen moduleCodeGenerator translateGenericObjectPointer: self) with: result
        }.

        result
    }.

    public abstract method emitMirReference: (reference: MIRValue) elementPointerAt: (elementIndex: MIRValue) type: (type: Type) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := self subclassResponsibility.


    public virtual method makeMirTemporaryValueNamed: (name: Symbol) withFunctionBuilder: (functionBuilder: MIRFunctionBuilder) ::=> MIRValue
        := functionBuilder newTemporary: name withType: self.

    public virtual method translateHIRLiteralConstant: (constant: HIRLiteralConstant) intoMirWith: (codegen: HIRModuleMIRCodeGenerator) ::=> MIRValue
        := codegen translateGenericObjectPointer: constant value.

    public virtual method translateUndefinedConstant: (constant: HIRUndefinedConstant) intoMirWith: (codegen: HIRModuleMIRCodeGenerator) ::=> MIRValue
        := codegen compilationTarget pointerSize = 4sz ifTrue: 0u32 asMirConstant ifFalse: 0u64 asMirConstant.

    public virtual method translateHIRLiteralConstant: (constant: HIRLiteralConstant) pointerType: (pointerType: PointerLikeType) storage: storage base: base offset: (offset: IntPointer) intoMirWith: (codegen: HIRModuleMIRCodeGenerator) ::=> MIRValue
        := codegen translateGenericObjectPointer: constant value.

    public virtual method emitMirLoadFromPointer: (pointer: MIRValue) constantOffset: (constantOffset: Int64) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder loadPointer: pointer constantOffset: constantOffset type: self.

    public virtual method emitMirStore: (value: MIRValue) intoPointer: (pointer: MIRValue) constantOffset: (constantOffset: Int64) in: (object: MIRValue) with: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue
        := codegen storePointer: value into: pointer constantOffset: constantOffset in: object.

    public virtual method emitMirEquals: (left: MIRValue) with: (right: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder pointerEquals: left with: right.

    public virtual method emitMirNotEquals: (left: MIRValue) with: (right: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder pointerNotEquals: left with: right.
}.

ObjectModelVariant extend: {
    public abstract method mirImmediateReferenceFor: (object: Untyped) ::=> MIRValue
        := self subclassResponsibility.
}.

ObjectModelVariant32 extend: {
    public override method mirImmediateReferenceFor: (object: Untyped) ::=> MIRValue
        := (RawTuple::type(object) encodeImmediateReference32: object) asMirConstant.
}.

ObjectModelVariant64 extend: {
    public override method mirImmediateReferenceFor: (object: Untyped) ::=> MIRValue
        := (RawTuple::type(object) encodeImmediateReference64: object) asMirConstant.
}.

String class extend: {
    public override method translateHIRLiteralConstant: (constant: HIRLiteralConstant) pointerType: (pointerType: PointerLikeType) storage: storage base: base offset: (offset: IntPointer) intoMirWith: (codegen: HIRModuleMIRCodeGenerator) ::=> MIRValue := {
        if: (pointerType baseType == Char8 const) && (base == nil) && (offset = 0iptr) then: {
            codegen translateCStringConstant: storage
        } else: {
            super translateHIRLiteralConstant: constant pointerType: pointerType storage: storage base: base offset: offset intoMirWith: codegen
        }.
    }.
}.

ValueType extend: {
    public override method emitMirCoerceInto: (targetType: MIRValue) thenUnbox: (value: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue
        := self emitMirCheckInto: targetType thenUnbox: value withHIRCodeGenerator: codegen.

    public override method emitMirCheckInto: (targetType: MIRValue) thenUnbox: (value: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue := {
        let typecheckFunction := codegen translateRuntimeFunction: (self isNullable
            ifTrue: ObjectModel::typecheckNullableValue
            ifFalse: ObjectModel::typecheckValue
        ).

        codegen blockBuilder callVoid: typecheckFunction with: targetType with: value.
        self emitMirUncheckedUnbox: value withHIRCodeGenerator: codegen.
    }.

    public override method emitMirCheckAndUnbox: (value: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue := {
        ## TODO: Implement this via some kind of memcpy for the generic case.
        codegen notYetImplementedError: "Generic value type unbox"
    }.

    public override method emitMirUncheckedUnbox: (value: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue := {
        ## TODO: Implement this via some kind of memcpy for the generic case.
        codegen notYetImplementedError: "Generic value type unbox"
    }.

    public override method emitMirBox: (value: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue := {
        ## TODO: Implement this via some kind of memcpy.
        codegen notYetImplementedError: "Generic value type box"
    }.

    public override method emitMirCall: (function: MIRValue) convention: (callingConvention: MIRCallingConvention) withArguments: (arguments: Array) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder callStruct: function convention: callingConvention arguments: arguments type: self.

    public override method emitMirUnboxingCall: (function: MIRValue) convention: (callingConvention: MIRCallingConvention) withArguments: (arguments: Array) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue := {
        let boxedTemporary := codegen blockBuilder callPointer: function convention: callingConvention arguments: arguments type: Untyped.
        self emitMirCheckAndUnbox: boxedTemporary withHIRCodeGenerator: codegen
    }.

    public override method emitMirPhiWithBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder phiStruct: self.

    public override method emitMirReturn: (value: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder returnStruct: value.

    public override method emitMirMove: (value: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder moveStruct: value type: self.

    public override method emitMirLoadFromPointer: (pointer: MIRValue) constantOffset: (constantOffset: Int64) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder loadStruct: pointer constantOffset: constantOffset type: self.

    public override method emitMirStore: (value: MIRValue) intoPointer: (pointer: MIRValue) constantOffset: (constantOffset: Int64) in: (object: MIRValue) with: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue
        := codegen blockBuilder storeStruct: value into: pointer constantOffset: constantOffset.

    public override method translateHIRLiteralConstant: (constant: HIRLiteralConstant) intoMirWith: (codegen: HIRModuleMIRCodeGenerator) ::=> MIRValue
        := codegen translateStructureConstant: constant value.

    public override method translateUndefinedConstant: (constant: HIRUndefinedConstant) intoMirWith: (codegen: HIRModuleMIRCodeGenerator) ::=> MIRValue
        := codegen translateStructureConstant: constant type defaultValue.

    public override method emitMirEquals: (left: MIRValue) with: (right: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := self subclassResponsibility.

    public override method emitMirNotEquals: (left: MIRValue) with: (right: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := self subclassResponsibility.
}.

AddressSpace extend: {
    public virtual method pointerType: (pointerType: PointerLikeType) translateHIRLiteralConstant: (constant: HIRLiteralConstant) intoMirWith: (codegen: HIRModuleMIRCodeGenerator) ::=> MIRValue := {
        let value => Untyped := constant value.
        let isBytes := RawTuple::isBytes(value).
        let pointerSize => Size := RawTuple::size(value).

        if: isBytes then: {
            self error: "TODO: Translate pointer integer value."
        } else: {
            let storage := (if: pointerSize >= 1sz then: (RawTuple::slotAt:)(value, 0sz) else: nil).
            let base := (if: pointerSize >= 2sz then: (RawTuple::slotAt:)(value, 1sz) else: nil).
            let offset := (if: pointerSize >= 3sz then: (RawTuple::slotAt:)(value, 2sz) else: 0iptr).
            storage __type__ translateHIRLiteralConstant: constant pointerType: pointerType storage: storage base: base offset: offset intoMirWith: codegen
        }
    }.

    public virtual method pointerType: (pointerType: PointerLikeType) translateUndefinedConstant: (constant: HIRUndefinedConstant) intoMirWith: (codegen: HIRModuleMIRCodeGenerator) ::=> MIRValue
        := codegen nullPointerConstant.

    public virtual method pointerType: (pointerType: PointerLikeType) emitMirCheckAndUnbox: (boxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue := {
        boxedValue isConstantZero ifTrue: {
            return: codegen nullPointerConstant
        }.

        codegen blockBuilder
            callPointer: (codegen translateRuntimeFunction: ObjectModel::checkAndUnboxPointer)
            with: (codegen moduleCodeGenerator translateGenericObjectPointer: pointerType) with: boxedValue type: pointerType.
    }.

    public virtual method pointerType: (pointerType: PointerLikeType) emitMirUncheckedUnbox: (boxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue
        := codegen blockBuilder
            callPointer: (codegen translateRuntimeFunction: ObjectModel::unboxPointer)
            with: boxedValue type: pointerType.

    public virtual method pointerType: (pointerType: PointerLikeType) emitMirBox: (unboxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue
        := codegen blockBuilder
            callPointer: (codegen translateRuntimeFunction: ObjectModel::boxPointer)
            with: (codegen moduleCodeGenerator translateGenericObjectPointer: pointerType) with: unboxedValue type: pointerType.

    public virtual method pointerType: (pointerType: PointerLikeType) emitMirCall: (function: MIRValue) convention: (callingConvention: MIRCallingConvention) withArguments: (arguments: Array) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder callPointer: function convention: callingConvention arguments: arguments type: pointerType.

    public virtual method pointerType: (pointerType: PointerLikeType) emitMirPhiWithBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder phiPointer: pointerType.

    public virtual method emitMirReturn: (value: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder returnPointer: value.

    public virtual method pointerType: (pointerType: PointerLikeType) emitMirMove: (value: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder movePointer: value type: pointerType.

    public virtual method pointerType: (pointerType: PointerLikeType) emitMirLoadFromPointer: (pointer: MIRValue) constantOffset: (constantOffset: Int64) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder loadPointer: pointer constantOffset: constantOffset type: pointerType.

    public virtual method emitMirStore: (value: MIRValue) intoPointer: (pointer: MIRValue) constantOffset: (constantOffset: Int64) in: (object: MIRValue) with: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue
        := codegen storePointer: value into: pointer constantOffset: constantOffset in: object.
}.

MemberAddressSpace extend: {
    public override method pointerType: (pointerType: PointerLikeType) translateHIRLiteralConstant: (constant: HIRLiteralConstant) intoMirWith: (codegen: HIRModuleMIRCodeGenerator) ::=> MIRValue := {
        let value => Untyped := constant value.
        let isBytes := RawTuple::isBytes(value).
        let pointerSize => Size := RawTuple::size(value).

        if: isBytes then: {
            self error: "TODO: Translate pointer integer value."
        } else: {
            self error: "TODO: Translate Member pointer literal constant."
            #*
            let storage := (if: pointerSize >= 1sz then: (RawTuple::slotAt:)(value, 0sz) else: nil).
            let base := (if: pointerSize >= 2sz then: (RawTuple::slotAt:)(value, 1sz) else: nil).
            let offset := (if: pointerSize >= 3sz then: (RawTuple::slotAt:)(value, 2sz) else: 0iptr).
            storage __type__ translateHIRLiteralConstant: constant pointerType: self storage: storage base: base offset: offset intoMirWith: codegen
            *#
        }
    }.

    public override method pointerType: (pointerType: PointerLikeType) translateUndefinedConstant: (constant: HIRUndefinedConstant) intoMirWith: (codegen: HIRModuleMIRCodeGenerator) ::=> MIRValue
        := codegen nullFatPointerConstant.

    public override method pointerType: (pointerType: PointerLikeType) emitMirCheckAndUnbox: (boxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue := {
        boxedValue isConstantZero ifTrue: {
            return: codegen nullFatPointerConstant.
        }.

        codegen blockBuilder
            callFatPointer: (codegen translateRuntimeFunction: ObjectModel::checkAndUnboxFatPointer)
            with: (codegen moduleCodeGenerator translateGenericObjectPointer: pointerType) with: boxedValue type: pointerType.
    }.

    public override method pointerType: (pointerType: PointerLikeType) emitMirUncheckedUnbox: (boxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue
        := codegen blockBuilder
            callFatPointer: (codegen translateRuntimeFunction: ObjectModel::unboxFatPointer)
            with: boxedValue type: pointerType.

    public override method pointerType: (pointerType: PointerLikeType) emitMirBox: (unboxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue
        := codegen blockBuilder
            callPointer: (codegen translateRuntimeFunction: ObjectModel::boxFatPointer)
            with: (codegen moduleCodeGenerator translateGenericObjectPointer: pointerType) with: unboxedValue type: AnyValue.

    public override method pointerType: (pointerType: PointerLikeType) emitMirCall: (function: MIRValue) convention: (callingConvention: MIRCallingConvention) withArguments: (arguments: Array) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder callFatPointer: function convention: callingConvention arguments: arguments type: pointerType.

    public override method pointerType: (pointerType: PointerLikeType) emitMirPhiWithBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder phiFatPointer: pointerType.

    public override method emitMirReturn: (value: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder returnFatPointer: value.

    public override method pointerType: (pointerType: PointerLikeType) emitMirMove: (value: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder moveFatPointer: value type: pointerType.

    public override method pointerType: (pointerType: PointerLikeType) emitMirLoadFromPointer: (pointer: MIRValue) constantOffset: (constantOffset: Int64) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder loadFatPointer: pointer constantOffset: constantOffset type: pointerType.

    public override method emitMirStore: (value: MIRValue) intoPointer: (pointer: MIRValue) constantOffset: (constantOffset: Int64) in: (object: MIRValue) with: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue
        := codegen storeFatPointer: value into: pointer constantOffset: constantOffset in: object.
}.

PointerLikeType extend: {
    public override method translateHIRLiteralConstant: (constant: HIRLiteralConstant) intoMirWith: (codegen: HIRModuleMIRCodeGenerator) ::=> MIRValue
        := addressSpace pointerType: self translateHIRLiteralConstant: constant intoMirWith: codegen.

    public override method translateUndefinedConstant: (constant: HIRUndefinedConstant) intoMirWith: (codegen: HIRModuleMIRCodeGenerator) ::=> MIRValue
        := addressSpace pointerType: self translateUndefinedConstant: constant intoMirWith: codegen.

    public override method emitMirCheckAndUnbox: (boxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue
        := addressSpace pointerType: self emitMirCheckAndUnbox: boxedValue withHIRCodeGenerator: codegen.

    public override method emitMirUncheckedUnbox: (boxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue
        := addressSpace pointerType: self emitMirUncheckedUnbox: boxedValue withHIRCodeGenerator: codegen.

    public override method emitMirBox: (unboxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue
        := addressSpace pointerType: self emitMirBox: unboxedValue withHIRCodeGenerator: codegen.

    public override method emitMirCall: (function: MIRValue) convention: (callingConvention: MIRCallingConvention) withArguments: (arguments: Array) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := addressSpace pointerType: self emitMirCall: function convention: callingConvention withArguments: arguments withBlockBuilder: builder.

    public override method emitMirPhiWithBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := addressSpace pointerType: self emitMirPhiWithBlockBuilder: builder.

    public override method emitMirReturn: (value: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := addressSpace emitMirReturn: value withBlockBuilder: builder.

    public override method emitMirMove: (value: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := addressSpace pointerType: self emitMirMove: value withBlockBuilder: builder.

    public override method emitMirLoadFromPointer: (pointer: MIRValue) constantOffset: (constantOffset: Int64) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := addressSpace pointerType: self emitMirLoadFromPointer: pointer constantOffset: constantOffset withBlockBuilder: builder.

    public override method emitMirStore: (value: MIRValue) intoPointer: (pointer: MIRValue) constantOffset: (constantOffset: Int64) in: (object: MIRValue) with: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue
        := addressSpace emitMirStore: value intoPointer: pointer constantOffset: constantOffset in: object with: codegen.
}.

FixedArrayType definition: {
    public override method emitMirReference: (reference: MIRValue) elementPointerAt: (elementIndex: MIRValue) type: (type: Type) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue := {
        reference type validAddressSpace isFatPointer ifTrue: {
            builder loadFatEffectiveAddress: reference index: elementIndex constantScale: elementType alignedValueSize asInt64 type: type
        } ifFalse: {
            builder loadEffectiveAddress: reference index: elementIndex constantScale: elementType alignedValueSize asInt64 type: type
        }.
    }.
}.

Char8 __type__ extend: {
    public override method emitMirUncheckedUnbox: (boxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue
        := codegen blockBuilder callInt8: (codegen translateRuntimeFunction: ObjectModel::unboxChar8) with: boxedValue type: self.

    public override method emitMirCheckAndUnbox: (boxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue
        := codegen blockBuilder callInt8: (codegen translateRuntimeFunction: ObjectModel::checkAndUnboxChar8) with: boxedValue type: self.

    public override method emitMirBox: (unboxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue
        := codegen blockBuilder callPointer: (codegen translateRuntimeFunction: ObjectModel::boxChar8) with: unboxedValue type: AnyValue.

    public override method emitMirCall: (function: MIRValue) convention: (callingConvention: MIRCallingConvention) withArguments: (arguments: Array) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder callInt8: function convention: callingConvention arguments: arguments type: self.

    public override method emitMirMove: (value: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder moveUInt8: value.

    public override method emitMirPhiWithBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder phiUInt8.

    public override method emitMirReturn: (value: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder returnInt8: value.

    public override method emitMirLoadFromPointer: (pointer: MIRValue) constantOffset: (constantOffset: Int64) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder loadUInt8: pointer constantOffset: constantOffset.

    public override method emitMirStore: (value: MIRValue) intoPointer: (pointer: MIRValue) constantOffset: (constantOffset: Int64) in: (object: MIRValue) with: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue
        := codegen blockBuilder storeInt8: value into: pointer constantOffset: constantOffset.

    public override method emitMirEquals: (left: MIRValue) with: (right: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder int8Equals: left with: right.

    public override method emitMirNotEquals: (left: MIRValue) with: (right: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder int8NotEquals: left with: right.

    public override method translateUndefinedConstant: (constant: HIRUndefinedConstant) intoMirWith: (codegen: HIRModuleMIRCodeGenerator) ::=> MIRValue
        := 0u8 asMirConstant.

    public override method translateHIRLiteralConstant: (constant: HIRLiteralConstant) intoMirWith: (codegen: HIRModuleMIRCodeGenerator) ::=> MIRValue
        := constant value asUInt8 asMirConstant.
}.

Int8 __type__ extend: {
    public override method emitMirUncheckedUnbox: (boxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue
        := codegen blockBuilder callInt8: (codegen translateRuntimeFunction: ObjectModel::unboxInt8) with: boxedValue type: self.

    public override method emitMirCheckAndUnbox: (boxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue
        := codegen blockBuilder callInt8: (codegen translateRuntimeFunction: ObjectModel::checkAndUnboxInt8) with: boxedValue type: self.

    public override method emitMirBox: (unboxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue
        := codegen blockBuilder callPointer: (codegen translateRuntimeFunction: ObjectModel::boxInt8) with: unboxedValue type: AnyValue.

    public override method emitMirCall: (function: MIRValue) convention: (callingConvention: MIRCallingConvention) withArguments: (arguments: Array) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder callInt8: function convention: callingConvention arguments: arguments type: self.

    public override method emitMirMove: (value: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder moveInt8: value.

    public override method emitMirPhiWithBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder phiInt8.

    public override method emitMirReturn: (value: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder returnInt8: value.

    public override method emitMirLoadFromPointer: (pointer: MIRValue) constantOffset: (constantOffset: Int64) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder loadInt8: pointer constantOffset: constantOffset.

    public override method emitMirStore: (value: MIRValue) intoPointer: (pointer: MIRValue) constantOffset: (constantOffset: Int64) in: (object: MIRValue) with: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue
        := codegen blockBuilder storeInt8: value into: pointer constantOffset: constantOffset.

    public override method emitMirEquals: (left: MIRValue) with: (right: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder int8Equals: left with: right.

    public override method emitMirNotEquals: (left: MIRValue) with: (right: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder int8NotEquals: left with: right.

    public override method translateUndefinedConstant: (constant: HIRUndefinedConstant) intoMirWith: (codegen: HIRModuleMIRCodeGenerator) ::=> MIRValue
        := 0i8 asMirConstant.

    public override method translateHIRLiteralConstant: (constant: HIRLiteralConstant) intoMirWith: (codegen: HIRModuleMIRCodeGenerator) ::=> MIRValue
        := constant value asInt8 asMirConstant.
}.

UInt8 __type__ extend: {
    public override method emitMirUncheckedUnbox: (boxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue
        := codegen blockBuilder callInt8: (codegen translateRuntimeFunction: ObjectModel::unboxUInt8) with: boxedValue type: self.

    public override method emitMirCheckAndUnbox: (boxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue
        := codegen blockBuilder callInt8: (codegen translateRuntimeFunction: ObjectModel::checkAndUnboxUInt8) with: boxedValue type: self.

    public override method emitMirBox: (unboxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue
        := codegen blockBuilder callPointer: (codegen translateRuntimeFunction: ObjectModel::boxUInt8) with: unboxedValue type: AnyValue.

    public override method emitMirCall: (function: MIRValue) convention: (callingConvention: MIRCallingConvention) withArguments: (arguments: Array) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder callInt8: function convention: callingConvention arguments: arguments type: self.

    public override method emitMirMove: (value: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder moveUInt8: value.

    public override method emitMirPhiWithBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder phiUInt8.

    public override method emitMirReturn: (value: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder returnInt8: value.

    public override method emitMirLoadFromPointer: (pointer: MIRValue) constantOffset: (constantOffset: Int64) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder loadUInt8: pointer constantOffset: constantOffset.

    public override method emitMirStore: (value: MIRValue) intoPointer: (pointer: MIRValue) constantOffset: (constantOffset: Int64) in: (object: MIRValue) with: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue
        := codegen blockBuilder storeInt8: value into: pointer constantOffset: constantOffset.

    public override method emitMirEquals: (left: MIRValue) with: (right: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder int8Equals: left with: right.

    public override method emitMirNotEquals: (left: MIRValue) with: (right: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder int8NotEquals: left with: right.

    public override method translateUndefinedConstant: (constant: HIRUndefinedConstant) intoMirWith: (codegen: HIRModuleMIRCodeGenerator) ::=> MIRValue
        := 0u8 asMirConstant.

    public override method translateHIRLiteralConstant: (constant: HIRLiteralConstant) intoMirWith: (codegen: HIRModuleMIRCodeGenerator) ::=> MIRValue
        := constant value asUInt8 asMirConstant.
}.

Boolean __type__ extend: {
    public override method emitMirUncheckedUnbox: (boxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue
        := codegen blockBuilder callInt8: (codegen translateRuntimeFunction: ObjectModel::unboxBoolean) with: boxedValue type: self.

    public override method emitMirCheckAndUnbox: (boxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue
        := codegen blockBuilder callInt8: (codegen translateRuntimeFunction: ObjectModel::checkAndUnboxBoolean) with: boxedValue type: self.

    public override method emitMirBox: (unboxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue
        := codegen blockBuilder callPointer: (codegen translateRuntimeFunction: ObjectModel::boxBoolean) with: unboxedValue type: AnyValue.

    public override method emitMirCall: (function: MIRValue) convention: (callingConvention: MIRCallingConvention) withArguments: (arguments: Array) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder callInt8: function convention: callingConvention arguments: arguments type: self.

    public override method emitMirMove: (value: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder moveUInt8: value.

    public override method emitMirPhiWithBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder phiUInt8.

    public override method emitMirReturn: (value: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder returnInt8: value.

    public override method emitMirLoadFromPointer: (pointer: MIRValue) constantOffset: (constantOffset: Int64) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder loadUInt8: pointer constantOffset: constantOffset.

    public override method emitMirStore: (value: MIRValue) intoPointer: (pointer: MIRValue) constantOffset: (constantOffset: Int64) in: (object: MIRValue) with: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue
        := codegen blockBuilder storeInt8: value into: pointer constantOffset: constantOffset.

    public override method emitMirEquals: (left: MIRValue) with: (right: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder int8Equals: left with: right.

    public override method emitMirNotEquals: (left: MIRValue) with: (right: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder int8NotEquals: left with: right.

    public override method translateUndefinedConstant: (constant: HIRUndefinedConstant) intoMirWith: (codegen: HIRModuleMIRCodeGenerator) ::=> MIRValue
        := 0u8 asMirConstant.
}.

False __type__ extend: {
    public override method translateHIRLiteralConstant: (constant: HIRLiteralConstant) intoMirWith: (codegen: HIRModuleMIRCodeGenerator) ::=> MIRValue
        := 0u8 asMirConstant.

}.

True __type__ extend: {
    public override method translateHIRLiteralConstant: (constant: HIRLiteralConstant) intoMirWith: (codegen: HIRModuleMIRCodeGenerator) ::=> MIRValue
        := 1u8 asMirConstant.
}.

Char16 __type__ extend: {
    public override method emitMirUncheckedUnbox: (boxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue
        := codegen blockBuilder callInt16: (codegen translateRuntimeFunction: ObjectModel::unboxChar16) with: boxedValue type: self.

    public override method emitMirCheckAndUnbox: (boxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue
        := codegen blockBuilder callInt16: (codegen translateRuntimeFunction: ObjectModel::checkAndUnboxChar16) with: boxedValue type: self.

    public override method emitMirBox: (unboxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue
        := codegen blockBuilder callPointer: (codegen translateRuntimeFunction: ObjectModel::boxChar16) with: unboxedValue type: AnyValue.

    public override method emitMirCall: (function: MIRValue) convention: (callingConvention: MIRCallingConvention) withArguments: (arguments: Array) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder callInt16: function convention: callingConvention arguments: arguments type: self.

    public override method emitMirMove: (value: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder moveUInt16: value.

    public override method emitMirPhiWithBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder phiUInt16.

    public override method emitMirReturn: (value: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder returnInt16: value.

    public override method emitMirLoadFromPointer: (pointer: MIRValue) constantOffset: (constantOffset: Int64) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder loadUInt16: pointer constantOffset: constantOffset.

    public override method emitMirStore: (value: MIRValue) intoPointer: (pointer: MIRValue) constantOffset: (constantOffset: Int64) in: (object: MIRValue) with: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue
        := codegen blockBuilder storeInt16: value into: pointer constantOffset: constantOffset.

    public override method emitMirEquals: (left: MIRValue) with: (right: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder int16Equals: left with: right.

    public override method emitMirNotEquals: (left: MIRValue) with: (right: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder int16NotEquals: left with: right.

    public override method translateUndefinedConstant: (constant: HIRUndefinedConstant) intoMirWith: (codegen: HIRModuleMIRCodeGenerator) ::=> MIRValue
        := 0u16 asMirConstant.

    public override method translateHIRLiteralConstant: (constant: HIRLiteralConstant) intoMirWith: (codegen: HIRModuleMIRCodeGenerator) ::=> MIRValue
        := constant value asUInt16 asMirConstant.
}.

Int16 __type__ extend: {
    public override method emitMirUncheckedUnbox: (boxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue
        := codegen blockBuilder callInt16: (codegen translateRuntimeFunction: ObjectModel::unboxInt16) with: boxedValue type: self.

    public override method emitMirCheckAndUnbox: (boxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue
        := codegen blockBuilder callInt16: (codegen translateRuntimeFunction: ObjectModel::checkAndUnboxInt16) with: boxedValue type: self.

    public override method emitMirBox: (unboxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue
        := codegen blockBuilder callPointer: (codegen translateRuntimeFunction: ObjectModel::boxInt16) with: unboxedValue type: AnyValue.

    public override method emitMirCall: (function: MIRValue) convention: (callingConvention: MIRCallingConvention) withArguments: (arguments: Array) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder callInt16: function convention: callingConvention arguments: arguments type: self.

    public override method emitMirMove: (value: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder moveInt16: value.

    public override method emitMirPhiWithBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder phiInt16.

    public override method emitMirReturn: (value: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder returnInt16: value.

    public override method emitMirLoadFromPointer: (pointer: MIRValue) constantOffset: (constantOffset: Int64) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder loadInt16: pointer constantOffset: constantOffset.

    public override method emitMirStore: (value: MIRValue) intoPointer: (pointer: MIRValue) constantOffset: (constantOffset: Int64) in: (object: MIRValue) with: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue
        := codegen blockBuilder storeInt16: value into: pointer constantOffset: constantOffset.

    public override method emitMirEquals: (left: MIRValue) with: (right: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder int16Equals: left with: right.

    public override method emitMirNotEquals: (left: MIRValue) with: (right: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder int16NotEquals: left with: right.

    public override method translateUndefinedConstant: (constant: HIRUndefinedConstant) intoMirWith: (codegen: HIRModuleMIRCodeGenerator) ::=> MIRValue
        := 0i16 asMirConstant.

    public override method translateHIRLiteralConstant: (constant: HIRLiteralConstant) intoMirWith: (codegen: HIRModuleMIRCodeGenerator) ::=> MIRValue
        := constant value asInt16 asMirConstant.
}.

UInt16 __type__ extend: {
    public override method emitMirUncheckedUnbox: (boxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue
        := codegen blockBuilder callInt16: (codegen translateRuntimeFunction: ObjectModel::unboxUInt16) with: boxedValue type: self.

    public override method emitMirCheckAndUnbox: (boxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue
        := codegen blockBuilder callInt16: (codegen translateRuntimeFunction: ObjectModel::checkAndUnboxUInt16) with: boxedValue type: self.

    public override method emitMirBox: (unboxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue
        := codegen blockBuilder callPointer: (codegen translateRuntimeFunction: ObjectModel::boxUInt16) with: unboxedValue type: AnyValue.

    public override method emitMirCall: (function: MIRValue) convention: (callingConvention: MIRCallingConvention) withArguments: (arguments: Array) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder callInt16: function convention: callingConvention arguments: arguments type: self.

    public override method emitMirMove: (value: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder moveUInt16: value.

    public override method emitMirPhiWithBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder phiUInt16.

    public override method emitMirReturn: (value: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder returnInt16: value.

    public override method emitMirLoadFromPointer: (pointer: MIRValue) constantOffset: (constantOffset: Int64) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder loadUInt16: pointer constantOffset: constantOffset.

    public override method emitMirStore: (value: MIRValue) intoPointer: (pointer: MIRValue) constantOffset: (constantOffset: Int64) in: (object: MIRValue) with: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue
        := codegen blockBuilder storeInt16: value into: pointer constantOffset: constantOffset.

    public override method emitMirEquals: (left: MIRValue) with: (right: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder int16Equals: left with: right.

    public override method emitMirNotEquals: (left: MIRValue) with: (right: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder int16NotEquals: left with: right.

    public override method translateUndefinedConstant: (constant: HIRUndefinedConstant) intoMirWith: (codegen: HIRModuleMIRCodeGenerator) ::=> MIRValue
        := 0u16 asMirConstant.

    public override method translateHIRLiteralConstant: (constant: HIRLiteralConstant) intoMirWith: (codegen: HIRModuleMIRCodeGenerator) ::=> MIRValue
        := constant value asUInt16 asMirConstant.
}.

Char32 __type__ extend: {
    public override method emitMirUncheckedUnbox: (boxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue
        := codegen blockBuilder callInt32: (codegen translateRuntimeFunction: ObjectModel::unboxChar32) with: boxedValue type: self.

    public override method emitMirCheckAndUnbox: (boxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue
        := codegen blockBuilder callInt32: (codegen translateRuntimeFunction: ObjectModel::checkAndUnboxChar32) with: boxedValue type: self.

    public override method emitMirBox: (unboxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue
        := codegen blockBuilder callPointer: (codegen translateRuntimeFunction: ObjectModel::boxChar32) with: unboxedValue type: AnyValue.

    public override method emitMirCall: (function: MIRValue) convention: (callingConvention: MIRCallingConvention) withArguments: (arguments: Array) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder callInt32: function convention: callingConvention arguments: arguments type: self.

    public override method emitMirMove: (value: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder moveUInt32: value.

    public override method emitMirPhiWithBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder phiUInt32.

    public override method emitMirReturn: (value: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder returnInt32: value.

    public override method emitMirLoadFromPointer: (pointer: MIRValue) constantOffset: (constantOffset: Int64) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder loadUInt32: pointer constantOffset: constantOffset.

    public override method emitMirStore: (value: MIRValue) intoPointer: (pointer: MIRValue) constantOffset: (constantOffset: Int64) in: (object: MIRValue) with: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue
        := codegen blockBuilder storeInt32: value into: pointer constantOffset: constantOffset.

    public override method emitMirEquals: (left: MIRValue) with: (right: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder int32Equals: left with: right.

    public override method emitMirNotEquals: (left: MIRValue) with: (right: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder int32NotEquals: left with: right.

    public override method translateUndefinedConstant: (constant: HIRUndefinedConstant) intoMirWith: (codegen: HIRModuleMIRCodeGenerator) ::=> MIRValue
        := 0u32 asMirConstant.

    public override method translateHIRLiteralConstant: (constant: HIRLiteralConstant) intoMirWith: (codegen: HIRModuleMIRCodeGenerator) ::=> MIRValue
        := constant value asUInt32 asMirConstant.
}.

Int32 __type__ extend: {
    public override method emitMirUncheckedUnbox: (boxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue
        := codegen blockBuilder callInt32: (codegen translateRuntimeFunction: ObjectModel::unboxInt32) with: boxedValue type: self.

    public override method emitMirCheckAndUnbox: (boxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue
        := codegen blockBuilder callInt32: (codegen translateRuntimeFunction: ObjectModel::checkAndUnboxInt32) with: boxedValue type: self.

    public override method emitMirBox: (unboxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue
        := codegen blockBuilder callPointer: (codegen translateRuntimeFunction: ObjectModel::boxInt32) with: unboxedValue type: AnyValue.

    public override method emitMirCall: (function: MIRValue) convention: (callingConvention: MIRCallingConvention) withArguments: (arguments: Array) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder callInt32: function convention: callingConvention arguments: arguments type: self.

    public override method emitMirMove: (value: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder moveInt32: value.

    public override method emitMirPhiWithBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder phiInt32.

    public override method emitMirReturn: (value: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder returnInt32: value.

    public override method emitMirLoadFromPointer: (pointer: MIRValue) constantOffset: (constantOffset: Int64) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder loadInt32: pointer constantOffset: constantOffset.

    public override method emitMirStore: (value: MIRValue) intoPointer: (pointer: MIRValue) constantOffset: (constantOffset: Int64) in: (object: MIRValue) with: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue
        := codegen blockBuilder storeInt32: value into: pointer constantOffset: constantOffset.

    public override method emitMirEquals: (left: MIRValue) with: (right: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder int32Equals: left with: right.

    public override method emitMirNotEquals: (left: MIRValue) with: (right: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder int32NotEquals: left with: right.

    public override method translateUndefinedConstant: (constant: HIRUndefinedConstant) intoMirWith: (codegen: HIRModuleMIRCodeGenerator) ::=> MIRValue
        := 0i32 asMirConstant.

    public override method translateHIRLiteralConstant: (constant: HIRLiteralConstant) intoMirWith: (codegen: HIRModuleMIRCodeGenerator) ::=> MIRValue
        := constant value asInt32 asMirConstant.
}.

UInt32 __type__ extend: {
    public override method emitMirUncheckedUnbox: (boxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue
        := codegen blockBuilder callInt32: (codegen translateRuntimeFunction: ObjectModel::unboxUInt32) with: boxedValue type: self.

    public override method emitMirCheckAndUnbox: (boxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue
        := codegen blockBuilder callInt32: (codegen translateRuntimeFunction: ObjectModel::checkAndUnboxUInt32) with: boxedValue type: self.

    public override method emitMirBox: (unboxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue
        := codegen blockBuilder callPointer: (codegen translateRuntimeFunction: ObjectModel::boxUInt32) with: unboxedValue type: AnyValue.

    public override method emitMirCall: (function: MIRValue) convention: (callingConvention: MIRCallingConvention) withArguments: (arguments: Array) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder callInt32: function convention: callingConvention arguments: arguments type: self.

    public override method emitMirMove: (value: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder moveUInt32: value.

    public override method emitMirPhiWithBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder phiUInt32.

    public override method emitMirReturn: (value: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder returnInt32: value.

    public override method emitMirLoadFromPointer: (pointer: MIRValue) constantOffset: (constantOffset: Int64) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder loadUInt32: pointer constantOffset: constantOffset.

    public override method emitMirStore: (value: MIRValue) intoPointer: (pointer: MIRValue) constantOffset: (constantOffset: Int64) in: (object: MIRValue) with: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue
        := codegen blockBuilder storeInt32: value into: pointer constantOffset: constantOffset.

    public override method emitMirEquals: (left: MIRValue) with: (right: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder int32Equals: left with: right.

    public override method emitMirNotEquals: (left: MIRValue) with: (right: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder int32NotEquals: left with: right.

    public override method translateUndefinedConstant: (constant: HIRUndefinedConstant) intoMirWith: (codegen: HIRModuleMIRCodeGenerator) ::=> MIRValue
        := 0u32 asMirConstant.

    public override method translateHIRLiteralConstant: (constant: HIRLiteralConstant) intoMirWith: (codegen: HIRModuleMIRCodeGenerator) ::=> MIRValue
        := constant value asUInt32 asMirConstant.
}.

Int64 __type__ extend: {
    public override method emitMirUncheckedUnbox: (boxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue
        := codegen blockBuilder callInt64: (codegen translateRuntimeFunction: ObjectModel::unboxInt64) with: boxedValue type: self.

    public override method emitMirCheckAndUnbox: (boxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue
        := codegen blockBuilder callInt64: (codegen translateRuntimeFunction: ObjectModel::checkAndUnboxInt64) with: boxedValue type: self.

    public override method emitMirBox: (unboxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue
        := codegen blockBuilder callPointer: (codegen translateRuntimeFunction: ObjectModel::boxInt64) with: unboxedValue type: AnyValue.

    public override method emitMirCall: (function: MIRValue) convention: (callingConvention: MIRCallingConvention) withArguments: (arguments: Array) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder callInt64: function convention: callingConvention arguments: arguments type: self.

    public override method emitMirMove: (value: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder moveInt64: value.

    public override method emitMirPhiWithBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder phiInt64.

    public override method emitMirReturn: (value: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder returnInt64: value.

    public override method emitMirLoadFromPointer: (pointer: MIRValue) constantOffset: (constantOffset: Int64) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder loadInt64: pointer constantOffset: constantOffset.

    public override method emitMirStore: (value: MIRValue) intoPointer: (pointer: MIRValue) constantOffset: (constantOffset: Int64) in: (object: MIRValue) with: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue
        := codegen blockBuilder storeInt64: value into: pointer constantOffset: constantOffset.

    public override method emitMirEquals: (left: MIRValue) with: (right: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder int64Equals: left with: right.

    public override method emitMirNotEquals: (left: MIRValue) with: (right: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder int64NotEquals: left with: right.

    public override method translateUndefinedConstant: (constant: HIRUndefinedConstant) intoMirWith: (codegen: HIRModuleMIRCodeGenerator) ::=> MIRValue
        := 0i64 asMirConstant.

    public override method translateHIRLiteralConstant: (constant: HIRLiteralConstant) intoMirWith: (codegen: HIRModuleMIRCodeGenerator) ::=> MIRValue
        := constant value asInt64 asMirConstant.
}.

UInt64 __type__ extend: {
    public override method emitMirUncheckedUnbox: (boxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue
        := codegen blockBuilder callInt64: (codegen translateRuntimeFunction: ObjectModel::unboxUInt64) with: boxedValue type: self.

    public override method emitMirCheckAndUnbox: (boxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue
        := codegen blockBuilder callInt64: (codegen translateRuntimeFunction: ObjectModel::checkAndUnboxUInt64) with: boxedValue type: self.

    public override method emitMirBox: (unboxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue
        := codegen blockBuilder callPointer: (codegen translateRuntimeFunction: ObjectModel::boxUInt64) with: unboxedValue type: AnyValue.

    public override method emitMirCall: (function: MIRValue) convention: (callingConvention: MIRCallingConvention) withArguments: (arguments: Array) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder callInt64: function convention: callingConvention arguments: arguments type: self.

    public override method emitMirMove: (value: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder moveUInt64: value.

    public override method emitMirPhiWithBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder phiUInt64.

    public override method emitMirReturn: (value: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder returnInt64: value.

    public override method emitMirLoadFromPointer: (pointer: MIRValue) constantOffset: (constantOffset: Int64) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder loadUInt64: pointer constantOffset: constantOffset.

    public override method emitMirStore: (value: MIRValue) intoPointer: (pointer: MIRValue) constantOffset: (constantOffset: Int64) in: (object: MIRValue) with: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue
        := codegen blockBuilder storeInt64: value into: pointer constantOffset: constantOffset.

    public override method emitMirEquals: (left: MIRValue) with: (right: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder int64Equals: left with: right.

    public override method emitMirNotEquals: (left: MIRValue) with: (right: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder int64NotEquals: left with: right.

    public override method translateUndefinedConstant: (constant: HIRUndefinedConstant) intoMirWith: (codegen: HIRModuleMIRCodeGenerator) ::=> MIRValue
        := 0u64 asMirConstant.

    public override method translateHIRLiteralConstant: (constant: HIRLiteralConstant) intoMirWith: (codegen: HIRModuleMIRCodeGenerator) ::=> MIRValue
        := constant value asUInt64 asMirConstant.
}.

Float32 __type__ extend: {
    public override method emitMirUncheckedUnbox: (boxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue
        := codegen blockBuilder callFloat32: (codegen translateRuntimeFunction: ObjectModel::unboxFloat32) with: boxedValue.

    public override method emitMirCheckAndUnbox: (boxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue
        := codegen blockBuilder callFloat32: (codegen translateRuntimeFunction: ObjectModel::checkAndUnboxFloat32) with: boxedValue.

    public override method emitMirBox: (unboxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue
        := codegen blockBuilder callPointer: (codegen translateRuntimeFunction: ObjectModel::boxFloat32) with: unboxedValue type: AnyValue.

    public override method emitMirCall: (function: MIRValue) convention: (callingConvention: MIRCallingConvention) withArguments: (arguments: Array) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder callFloat32: function convention: callingConvention arguments: arguments.

    public override method emitMirMove: (value: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder moveFloat32: value.

    public override method emitMirPhiWithBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder phiFloat32.

    public override method emitMirReturn: (value: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder returnFloat32: value.

    public override method emitMirLoadFromPointer: (pointer: MIRValue) constantOffset: (constantOffset: Int64) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder loadFloat32: pointer constantOffset: constantOffset.

    public override method emitMirStore: (value: MIRValue) intoPointer: (pointer: MIRValue) constantOffset: (constantOffset: Int64) in: (object: MIRValue) with: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue
        := codegen blockBuilder storeFloat32: value into: pointer constantOffset: constantOffset.

    public override method translateUndefinedConstant: (constant: HIRUndefinedConstant) intoMirWith: (codegen: HIRModuleMIRCodeGenerator) ::=> MIRValue
        := 0.0f32 asMirConstant.

    public override method translateHIRLiteralConstant: (constant: HIRLiteralConstant) intoMirWith: (codegen: HIRModuleMIRCodeGenerator) ::=> MIRValue := {
        let floatValue => Float32 := constant value.
        floatValue asMirConstant
    }.
}.

Float64 __type__ extend: {
    public override method emitMirUncheckedUnbox: (boxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue
        := codegen blockBuilder callFloat64: (codegen translateRuntimeFunction: ObjectModel::unboxFloat64) with: boxedValue.

    public override method emitMirCheckAndUnbox: (boxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue
        := codegen blockBuilder callFloat64: (codegen translateRuntimeFunction: ObjectModel::checkAndUnboxFloat64) with: boxedValue.

    public override method emitMirBox: (unboxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue
        := codegen blockBuilder callPointer: (codegen translateRuntimeFunction: ObjectModel::boxFloat64) with: unboxedValue type: AnyValue.

    public override method emitMirCall: (function: MIRValue) convention: (callingConvention: MIRCallingConvention) withArguments: (arguments: Array) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder callFloat64: function convention: callingConvention arguments: arguments.

    public override method emitMirMove: (value: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder moveFloat64: value.

    public override method emitMirPhiWithBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder phiFloat64.

    public override method emitMirReturn: (value: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder returnFloat64: value.

    public override method emitMirLoadFromPointer: (pointer: MIRValue) constantOffset: (constantOffset: Int64) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder loadFloat64: pointer constantOffset: constantOffset.

    public override method emitMirStore: (value: MIRValue) intoPointer: (pointer: MIRValue) constantOffset: (constantOffset: Int64) in: (object: MIRValue) with: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue
        := codegen blockBuilder storeFloat64: value into: pointer constantOffset: constantOffset.

    public override method translateUndefinedConstant: (constant: HIRUndefinedConstant) intoMirWith: (codegen: HIRModuleMIRCodeGenerator) ::=> MIRValue
        := 0.0 asMirConstant.

    public override method translateHIRLiteralConstant: (constant: HIRLiteralConstant) intoMirWith: (codegen: HIRModuleMIRCodeGenerator) ::=> MIRValue := {
        let floatValue => Float64 := constant value.
        floatValue asMirConstant
    }.
}.

Void __type__ extend: {
    public override method emitMirUncheckedUnbox: (boxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue
        := void asMirConstant.

    public override method emitMirCheckAndUnbox: (boxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue
        := void asMirConstant.

    public override method emitMirBox: (unboxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue
        := codegen moduleCodeGenerator translateGenericObjectPointer: void.

    public override method emitMirCall: (function: MIRValue) convention: (callingConvention: MIRCallingConvention) withArguments: (arguments: Array) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue := {
        builder callVoid: function convention: callingConvention arguments: arguments.
        void asMirConstant
    }.

    public override method emitMirMove: (value: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := void asMirConstant.

    public override method emitMirPhiWithBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := void asMirConstant.

    public override method emitMirReturn: (value: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := builder returnVoid.

    public override method emitMirLoadFromPointer: (pointer: MIRValue) constantOffset: (constantOffset: Float64) withBlockBuilder: (builder: MIRBlockBuilder) ::=> MIRValue
        := void asMirConstant.

    public override method emitMirStore: (value: MIRValue) intoPointer: (pointer: MIRValue) constantOffset: (constantOffset: Int64) in: (object: MIRValue) with: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue
        := void asMirConstant.

    public override method translateUndefinedConstant: (constant: HIRUndefinedConstant) intoMirWith: (codegen: HIRModuleMIRCodeGenerator) ::=> MIRValue
        := void asMirConstant.

    public override method translateHIRLiteralConstant: (constant: HIRLiteralConstant) intoMirWith: (codegen: HIRModuleMIRCodeGenerator) ::=> MIRValue
        := void asMirConstant.
}.

HIRValue extend: {
    public abstract method translateIntoMirValueWith: (codegen: HIRModuleMIRCodeGenerator) ::=> MIRValue
        := self subclassResponsibility.
}.

HIRLiteralConstant extend: {
    public override method translateIntoMirValueWith: (codegen: HIRModuleMIRCodeGenerator) ::=> MIRValue
        := isBoxed
            ifTrue: (codegen setValue: self translationInto: (codegen translateGenericObjectPointer: (self __slotNamedAt__: #value)))
            ifFalse: (codegen setValue: self translationInto: (type translateHIRLiteralConstant: self intoMirWith: codegen)).
}.

HIRUndefinedConstant extend: {
    public override method translateIntoMirValueWith: (codegen: HIRModuleMIRCodeGenerator) ::=> MIRValue
        := codegen setValue: self translationInto: (type translateUndefinedConstant: self intoMirWith: codegen).
}.

HIRGlobalValue extend: {
    public virtual method compileDirectMirTranslationWith: (codegen: HIRModuleMIRCodeGenerator) ::=> Void := {}.
}.

HIRGlobalVariable extend: {
    public override method translateIntoMirValueWith: (codegen: HIRModuleMIRCodeGenerator) ::=> MIRValue
        := codegen translateGlobalVariable: self.

    public override method compileDirectMirTranslationWith: (codegen: HIRModuleMIRCodeGenerator) ::=> Void := {
        codegen translateGlobalVariable: self.
    }.
}.

HIRFunction extend: {
    public override method translateIntoMirValueWith: (codegen: HIRModuleMIRCodeGenerator) ::=> MIRValue
        := codegen translateGenericObjectPointer: self sourceObject.

    public override method compileDirectMirTranslationWith: (codegen: HIRModuleMIRCodeGenerator) ::=> Void := {
        codegen compileDirectFunction: self
    }.
}.

HIRFunctionDefinition extend: {
    public override method translateIntoMirValueWith: (codegen: HIRModuleMIRCodeGenerator) ::=> MIRValue
        := codegen translateGenericObjectPointer: self sourceObject.

    public override method compileDirectMirTranslationWith: (codegen: HIRModuleMIRCodeGenerator) ::=> Void := {
        codegen compileDirectFunctionDefinition: self
    }.
}.

HIRInstruction extend: {
    public virtual method makeMirValueForResultWith: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue
        := type makeMirTemporaryValueNamed: self name withFunctionBuilder: codegen functionBuilder.

    public abstract method compileIntoMIRWith: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue
        := self subclassResponsibility.
}.

HIRAllocaInstruction extend: {
    public override method compileIntoMIRWith: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue := {
        self isEscapedValue ifFalse: {
            let allocaStorage := codegen functionBuilder newTemporary: self name withType: valueType.
            allocaStorage asValuePointerWithType: self type compilationTarget: codegen compilationTarget
        } ifTrue: {
            codegen blockBuilder callFatPointer: (codegen translateRuntimeFunction: ObjectModel::allocaGC)
                with: (codegen moduleCodeGenerator translateGenericObjectPointer: self valueType)
                type: self type
        }
    }.
}.

HIRBranchInstruction extend: {
    public override method compileIntoMIRWith: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue := {
        let destination := codegen translateValue: self destination.
        codegen blockBuilder branch: destination
    }.
}.

HIRConditionalBranchInstruction extend: {
    public override method compileIntoMIRWith: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue := {
        let condition := codegen translateValue: self condition.
        let trueDestination := codegen translateValue: self trueDestination.
        let falseDestination := codegen translateValue: self falseDestination.
        codegen blockBuilder when: condition branchIfTrue: trueDestination branchIfFalse: falseDestination
    }.
}.

let translateUnaryPrimitiveInto := {:(MIROperation)operation :: ((Array, Type, HIRFunctionDefinitionMIRCodeGenerator) => MIRValue) |
    {:(Array)arguments :(Type)type :(HIRFunctionDefinitionMIRCodeGenerator)codegen :: MIRValue |
        let operand := codegen translateValue: arguments first.
        codegen blockBuilder operation: operation with: operand type: type
    }
}.

let translateBinaryPrimitiveInto := {:(MIROperation)operation :: ((Array, Type, HIRFunctionDefinitionMIRCodeGenerator) => MIRValue) |
    {:(Array)arguments :(Type)type :(HIRFunctionDefinitionMIRCodeGenerator)codegen :: MIRValue |
        let left := codegen translateValue: arguments first.
        let right := codegen translateValue: arguments second.
        codegen blockBuilder operation: operation with: left with: right type: type
    }
}.

let translateYourselfPrimitive := {:(Array)arguments :(Type)type :(HIRFunctionDefinitionMIRCodeGenerator)codegen :: MIRValue |
    codegen translateValue: arguments first
}.

public global HIRMirPrimitiveCallGenerationTable := #{
    ## Pointer primitive
    #PointerLikeType::reinterpretCast : translateYourselfPrimitive.
    #PointerLikeType::reinterpretCastTo: : translateYourselfPrimitive.

    ## Identity equals/not-equals
    #== : {:(Array)arguments :(Type)type :(HIRFunctionDefinitionMIRCodeGenerator)codegen :: MIRValue |
        let leftType => Type := arguments first type.
        let rightType => Type  := arguments second type.
        let hasUndefined := (leftType == UndefinedObject) || (rightType == UndefinedObject).
        let hasPointer := leftType isPointerType || rightType isPointerType.
        let hasFatPointer := leftType validAddressSpace isFatPointer || rightType validAddressSpace isFatPointer.

        (hasUndefined && hasPointer) || (leftType isPointerType && rightType isPointerType) ifTrue: {
            hasFatPointer ifTrue: {
                codegen blockBuilder fatPointerEquals: (codegen translateValue: arguments first) with: (codegen translateValue: arguments second)
            } ifFalse: {
                codegen blockBuilder pointerEquals: (codegen translateValue: arguments first) with: (codegen translateValue: arguments second)
            }
        } ifFalse: {
            leftType == rightType && leftType isValueType ifTrue: {
                leftType emitMirEquals: (codegen translateValue: arguments first) with: (codegen translateValue: arguments second) withBlockBuilder: codegen blockBuilder
            } ifFalse: {
                codegen blockBuilder pointerEquals: (codegen translateBoxedValue: arguments first) with: (codegen translateBoxedValue: arguments second)
            }
        }

    }.
    #~~ : {:(Array)arguments :(Type)type :(HIRFunctionDefinitionMIRCodeGenerator)codegen :: MIRValue |
        let leftType => Type := arguments first type.
        let rightType => Type  := arguments second type.
        let hasUndefined := (leftType == UndefinedObject) || (rightType == UndefinedObject).
        let hasPointer := leftType isPointerType || rightType isPointerType.
        let hasFatPointer := leftType validAddressSpace isFatPointer || rightType validAddressSpace isFatPointer.

        (hasUndefined && hasPointer) || (leftType isPointerType && rightType isPointerType) ifTrue: {
            hasFatPointer ifTrue: {
                codegen blockBuilder fatPointerNotEquals: (codegen translateValue: arguments first) with: (codegen translateValue: arguments second)
            } ifFalse: {
                codegen blockBuilder pointerNotEquals: (codegen translateValue: arguments first) with: (codegen translateValue: arguments second)
            }
        } ifFalse: {
            leftType == rightType && leftType isValueType ifTrue: {
                leftType emitMirNotEquals: (codegen translateValue: arguments first) with: (codegen translateValue: arguments second) withBlockBuilder: codegen blockBuilder
            } ifFalse: {
                codegen blockBuilder pointerNotEquals: (codegen translateBoxedValue: arguments first) with: (codegen translateBoxedValue: arguments second)
            }
        }
    }.
    #memcpy : {:(Array)arguments :(Type)type :(HIRFunctionDefinitionMIRCodeGenerator)codegen :: MIRValue |
        codegen blockBuilder memcpy: (codegen translateValue: arguments first) source: (codegen translateValue: arguments second) size: (codegen translateValue: arguments third).
    }.
    #memset : {:(Array)arguments :(Type)type :(HIRFunctionDefinitionMIRCodeGenerator)codegen :: MIRValue |
        codegen blockBuilder memset: (codegen translateValue: arguments first) value: (codegen translateValue: arguments second) size: (codegen translateValue: arguments third).
    }.

    #Exception::setjmp : {:(Array)arguments :(Type)type :(HIRFunctionDefinitionMIRCodeGenerator)codegen :: MIRValue |
        codegen blockBuilder exceptionSetjmp: (codegen translateValue: arguments first).
        0u8 asMirConstant.
    }.

    #Exception::longjmp : {:(Array)arguments :(Type)type :(HIRFunctionDefinitionMIRCodeGenerator)codegen :: MIRValue |
        codegen blockBuilder exceptionLongjmp: (codegen translateValue: arguments first).
    }.

    #FatPointer::construct : {:(Array)arguments :(Type)type :(HIRFunctionDefinitionMIRCodeGenerator)codegen :: MIRValue |
        codegen blockBuilder fatPointerConstruct: (codegen translateValue: arguments first) with: (codegen translateValue: arguments second) type: type
    }.

    ## Boolean primitives
    #Boolean::not : translateUnaryPrimitiveInto(MIR::Operation::BooleanNot).
    #Boolean::xor: : translateBinaryPrimitiveInto(MIR::Operation::BooleanXor).

    ## Char8 primitives
    #Char8::negated : translateUnaryPrimitiveInto(MIR::Operation::Int8Negate).
    #Char8::bitInvert : translateUnaryPrimitiveInto(MIR::Operation::Int8BitNot).

    #Char8::+ : translateBinaryPrimitiveInto(MIR::Operation::Int8Add).
    #Char8::- : translateBinaryPrimitiveInto(MIR::Operation::Int8Sub).
    #Char8::* : translateBinaryPrimitiveInto(MIR::Operation::Int8Mul).
    #Char8::/ : translateBinaryPrimitiveInto(MIR::Operation::Int8UDiv).
    #Char8::% : translateBinaryPrimitiveInto(MIR::Operation::Int8URem).

    #Char8::& : translateBinaryPrimitiveInto(MIR::Operation::Int8BitAnd).
    #Char8::| : translateBinaryPrimitiveInto(MIR::Operation::Int8BitOr).
    #Char8::^ : translateBinaryPrimitiveInto(MIR::Operation::Int8BitXor).
    #Char8::<< : translateBinaryPrimitiveInto(MIR::Operation::Int8LogicalShiftLeft).
    #Char8::>> : translateBinaryPrimitiveInto(MIR::Operation::Int8LogicalShiftRight).

    #Char8::= : translateBinaryPrimitiveInto(MIR::Operation::Int8Equals).
    #Char8::~= : translateBinaryPrimitiveInto(MIR::Operation::Int8NotEquals).
    #Char8::<=> : translateBinaryPrimitiveInto(MIR::Operation::Int8Compare).
    #Char8::< : translateBinaryPrimitiveInto(MIR::Operation::UInt8LessThan).
    #Char8::<= : translateBinaryPrimitiveInto(MIR::Operation::UInt8LessOrEquals).
    #Char8::> : translateBinaryPrimitiveInto(MIR::Operation::UInt8GreaterThan).
    #Char8::>= : translateBinaryPrimitiveInto(MIR::Operation::UInt8GreaterOrEquals).

    #Char8::asChar8 : translateYourselfPrimitive.
    #Char8::asInt8 : translateYourselfPrimitive.
    #Char8::asUInt8 : translateYourselfPrimitive.
    #Char8::asChar16 : translateUnaryPrimitiveInto(MIR::Operation::ZeroExtendInt8ToInt16).
    #Char8::asInt16 : translateUnaryPrimitiveInto(MIR::Operation::ZeroExtendInt8ToInt16).
    #Char8::asUInt16 : translateUnaryPrimitiveInto(MIR::Operation::ZeroExtendInt8ToInt16).
    #Char8::asChar32 : translateUnaryPrimitiveInto(MIR::Operation::ZeroExtendInt8ToInt32).
    #Char8::asInt32 : translateUnaryPrimitiveInto(MIR::Operation::ZeroExtendInt8ToInt32).
    #Char8::asUInt32 : translateUnaryPrimitiveInto(MIR::Operation::ZeroExtendInt8ToInt32).
    #Char8::asInt64 : translateUnaryPrimitiveInto(MIR::Operation::ZeroExtendInt8ToInt64).
    #Char8::asUInt64 : translateUnaryPrimitiveInto(MIR::Operation::ZeroExtendInt8ToInt64).
    #Char8::asFloat32 : translateUnaryPrimitiveInto(MIR::Operation::UInt8ToFloat32).
    #Char8::asFloat64 : translateUnaryPrimitiveInto(MIR::Operation::UInt8ToFloat64).

    ## UInt8 primitives
    #UInt8::negated : translateUnaryPrimitiveInto(MIR::Operation::Int8Negate).
    #UInt8::bitInvert : translateUnaryPrimitiveInto(MIR::Operation::Int8BitNot).

    #UInt8::+ : translateBinaryPrimitiveInto(MIR::Operation::Int8Add).
    #UInt8::- : translateBinaryPrimitiveInto(MIR::Operation::Int8Sub).
    #UInt8::* : translateBinaryPrimitiveInto(MIR::Operation::Int8Mul).
    #UInt8::/ : translateBinaryPrimitiveInto(MIR::Operation::Int8UDiv).
    #UInt8::% : translateBinaryPrimitiveInto(MIR::Operation::Int8URem).

    #UInt8::& : translateBinaryPrimitiveInto(MIR::Operation::Int8BitAnd).
    #UInt8::| : translateBinaryPrimitiveInto(MIR::Operation::Int8BitOr).
    #UInt8::^ : translateBinaryPrimitiveInto(MIR::Operation::Int8BitXor).
    #UInt8::<< : translateBinaryPrimitiveInto(MIR::Operation::Int8LogicalShiftLeft).
    #UInt8::>> : translateBinaryPrimitiveInto(MIR::Operation::Int8LogicalShiftRight).

    #UInt8::= : translateBinaryPrimitiveInto(MIR::Operation::Int8Equals).
    #UInt8::~= : translateBinaryPrimitiveInto(MIR::Operation::Int8NotEquals).
    #UInt8::<=> : translateBinaryPrimitiveInto(MIR::Operation::Int8Compare).
    #UInt8::< : translateBinaryPrimitiveInto(MIR::Operation::UInt8LessThan).
    #UInt8::<= : translateBinaryPrimitiveInto(MIR::Operation::UInt8LessOrEquals).
    #UInt8::> : translateBinaryPrimitiveInto(MIR::Operation::UInt8GreaterThan).
    #UInt8::>= : translateBinaryPrimitiveInto(MIR::Operation::UInt8GreaterOrEquals).

    #UInt8::asChar8 : translateYourselfPrimitive.
    #UInt8::asInt8 : translateYourselfPrimitive.
    #UInt8::asUInt8 : translateYourselfPrimitive.
    #UInt8::asChar16 : translateUnaryPrimitiveInto(MIR::Operation::ZeroExtendInt8ToInt16).
    #UInt8::asInt16 : translateUnaryPrimitiveInto(MIR::Operation::ZeroExtendInt8ToInt16).
    #UInt8::asUInt16 : translateUnaryPrimitiveInto(MIR::Operation::ZeroExtendInt8ToInt16).
    #UInt8::asChar32 : translateUnaryPrimitiveInto(MIR::Operation::ZeroExtendInt8ToInt32).
    #UInt8::asInt32 : translateUnaryPrimitiveInto(MIR::Operation::ZeroExtendInt8ToInt32).
    #UInt8::asUInt32 : translateUnaryPrimitiveInto(MIR::Operation::ZeroExtendInt8ToInt32).
    #UInt8::asInt64 : translateUnaryPrimitiveInto(MIR::Operation::ZeroExtendInt8ToInt64).
    #UInt8::asUInt64 : translateUnaryPrimitiveInto(MIR::Operation::ZeroExtendInt8ToInt64).
    #UInt8::asFloat32 : translateUnaryPrimitiveInto(MIR::Operation::UInt8ToFloat32).
    #UInt8::asFloat64 : translateUnaryPrimitiveInto(MIR::Operation::UInt8ToFloat64).

    ## Int8 primitives
    #Int8::negated : translateUnaryPrimitiveInto(MIR::Operation::Int8Negate).
    #Int8::bitInvert : translateUnaryPrimitiveInto(MIR::Operation::Int8BitNot).

    #Int8::+ : translateBinaryPrimitiveInto(MIR::Operation::Int8Add).
    #Int8::- : translateBinaryPrimitiveInto(MIR::Operation::Int8Sub).
    #Int8::* : translateBinaryPrimitiveInto(MIR::Operation::Int8Mul).
    #Int8::/ : translateBinaryPrimitiveInto(MIR::Operation::Int8SDiv).
    #Int8::% : translateBinaryPrimitiveInto(MIR::Operation::Int8SRem).

    #Int8::& : translateBinaryPrimitiveInto(MIR::Operation::Int8BitAnd).
    #Int8::| : translateBinaryPrimitiveInto(MIR::Operation::Int8BitOr).
    #Int8::^ : translateBinaryPrimitiveInto(MIR::Operation::Int8BitXor).
    #Int8::<< : translateBinaryPrimitiveInto(MIR::Operation::Int8LogicalShiftLeft).
    #Int8::>> : translateBinaryPrimitiveInto(MIR::Operation::Int8ArithmeticShiftRight).

    #Int8::= : translateBinaryPrimitiveInto(MIR::Operation::Int8Equals).
    #Int8::~= : translateBinaryPrimitiveInto(MIR::Operation::Int8NotEquals).
    #Int8::<=> : translateBinaryPrimitiveInto(MIR::Operation::Int8Compare).
    #Int8::< : translateBinaryPrimitiveInto(MIR::Operation::Int8LessThan).
    #Int8::<= : translateBinaryPrimitiveInto(MIR::Operation::Int8LessOrEquals).
    #Int8::> : translateBinaryPrimitiveInto(MIR::Operation::Int8GreaterThan).
    #Int8::>= : translateBinaryPrimitiveInto(MIR::Operation::Int8GreaterOrEquals).

    #Int8::asChar8 : translateYourselfPrimitive.
    #Int8::asInt8 : translateYourselfPrimitive.
    #Int8::asUInt8 : translateYourselfPrimitive.
    #Int8::asChar16 : translateUnaryPrimitiveInto(MIR::Operation::ZeroExtendInt8ToInt16).
    #Int8::asInt16 : translateUnaryPrimitiveInto(MIR::Operation::SignExtendInt8ToInt16).
    #Int8::asUInt16 : translateUnaryPrimitiveInto(MIR::Operation::ZeroExtendInt8ToInt16).
    #Int8::asChar32 : translateUnaryPrimitiveInto(MIR::Operation::ZeroExtendInt8ToInt32).
    #Int8::asInt32 : translateUnaryPrimitiveInto(MIR::Operation::SignExtendInt8ToInt32).
    #Int8::asUInt32 : translateUnaryPrimitiveInto(MIR::Operation::ZeroExtendInt8ToInt32).
    #Int8::asInt64 : translateUnaryPrimitiveInto(MIR::Operation::SignExtendInt8ToInt64).
    #Int8::asUInt64 : translateUnaryPrimitiveInto(MIR::Operation::ZeroExtendInt8ToInt64).
    #Int8::asFloat32 : translateUnaryPrimitiveInto(MIR::Operation::Int8ToFloat32).
    #Int8::asFloat64 : translateUnaryPrimitiveInto(MIR::Operation::Int8ToFloat64).

    ## Char16 primitives
    #Char16::negated : translateUnaryPrimitiveInto(MIR::Operation::Int16Negate).
    #Char16::bitInvert : translateUnaryPrimitiveInto(MIR::Operation::Int16BitNot).
    #Char16::highBit : translateUnaryPrimitiveInto(MIR::Operation::Int16HighBit).

    #Char16::+ : translateBinaryPrimitiveInto(MIR::Operation::Int16Add).
    #Char16::- : translateBinaryPrimitiveInto(MIR::Operation::Int16Sub).
    #Char16::* : translateBinaryPrimitiveInto(MIR::Operation::Int16Mul).
    #Char16::/ : translateBinaryPrimitiveInto(MIR::Operation::Int16UDiv).
    #Char16::% : translateBinaryPrimitiveInto(MIR::Operation::Int16URem).

    #Char16::& : translateBinaryPrimitiveInto(MIR::Operation::Int16BitAnd).
    #Char16::| : translateBinaryPrimitiveInto(MIR::Operation::Int16BitOr).
    #Char16::^ : translateBinaryPrimitiveInto(MIR::Operation::Int16BitXor).
    #Char16::<< : translateBinaryPrimitiveInto(MIR::Operation::Int16LogicalShiftLeft).
    #Char16::>> : translateBinaryPrimitiveInto(MIR::Operation::Int16LogicalShiftRight).

    #Char16::= : translateBinaryPrimitiveInto(MIR::Operation::Int16Equals).
    #Char16::~= : translateBinaryPrimitiveInto(MIR::Operation::Int16NotEquals).
    #Char16::<=> : translateBinaryPrimitiveInto(MIR::Operation::Int16Compare).
    #Char16::< : translateBinaryPrimitiveInto(MIR::Operation::UInt16LessThan).
    #Char16::<= : translateBinaryPrimitiveInto(MIR::Operation::UInt16LessOrEquals).
    #Char16::> : translateBinaryPrimitiveInto(MIR::Operation::UInt16GreaterThan).
    #Char16::>= : translateBinaryPrimitiveInto(MIR::Operation::UInt16GreaterOrEquals).

    #Char16::asChar8 : translateUnaryPrimitiveInto(MIR::Operation::TruncateInt16ToInt8).
    #Char16::asInt8 : translateUnaryPrimitiveInto(MIR::Operation::TruncateInt16ToInt8).
    #Char16::asUInt8 : translateUnaryPrimitiveInto(MIR::Operation::TruncateInt16ToInt8).
    #Char16::asChar16 : translateYourselfPrimitive.
    #Char16::asInt16 : translateYourselfPrimitive.
    #Char16::asUInt16 : translateYourselfPrimitive.
    #Char16::asChar32 : translateUnaryPrimitiveInto(MIR::Operation::ZeroExtendInt16ToInt32).
    #Char16::asInt32 : translateUnaryPrimitiveInto(MIR::Operation::ZeroExtendInt16ToInt32).
    #Char16::asUInt32 : translateUnaryPrimitiveInto(MIR::Operation::ZeroExtendInt16ToInt32).
    #Char16::asInt64 : translateUnaryPrimitiveInto(MIR::Operation::ZeroExtendInt16ToInt64).
    #Char16::asUInt64 : translateUnaryPrimitiveInto(MIR::Operation::ZeroExtendInt16ToInt64).
    #Char16::asFloat32 : translateUnaryPrimitiveInto(MIR::Operation::UInt16ToFloat32).
    #Char16::asFloat64 : translateUnaryPrimitiveInto(MIR::Operation::UInt16ToFloat64).

    ## UInt16 primitives
    #UInt16::negated : translateUnaryPrimitiveInto(MIR::Operation::Int16Negate).
    #UInt16::bitInvert : translateUnaryPrimitiveInto(MIR::Operation::Int16BitNot).
    #UInt16::highBit : translateUnaryPrimitiveInto(MIR::Operation::Int16HighBit).

    #UInt16::+ : translateBinaryPrimitiveInto(MIR::Operation::Int16Add).
    #UInt16::- : translateBinaryPrimitiveInto(MIR::Operation::Int16Sub).
    #UInt16::* : translateBinaryPrimitiveInto(MIR::Operation::Int16Mul).
    #UInt16::/ : translateBinaryPrimitiveInto(MIR::Operation::Int16UDiv).
    #UInt16::% : translateBinaryPrimitiveInto(MIR::Operation::Int16URem).

    #UInt16::& : translateBinaryPrimitiveInto(MIR::Operation::Int16BitAnd).
    #UInt16::| : translateBinaryPrimitiveInto(MIR::Operation::Int16BitOr).
    #UInt16::^ : translateBinaryPrimitiveInto(MIR::Operation::Int16BitXor).
    #UInt16::<< : translateBinaryPrimitiveInto(MIR::Operation::Int16LogicalShiftLeft).
    #UInt16::>> : translateBinaryPrimitiveInto(MIR::Operation::Int16LogicalShiftRight).

    #UInt16::= : translateBinaryPrimitiveInto(MIR::Operation::Int16Equals).
    #UInt16::~= : translateBinaryPrimitiveInto(MIR::Operation::Int16NotEquals).
    #UInt16::<=> : translateBinaryPrimitiveInto(MIR::Operation::Int16Compare).
    #UInt16::< : translateBinaryPrimitiveInto(MIR::Operation::UInt16LessThan).
    #UInt16::<= : translateBinaryPrimitiveInto(MIR::Operation::UInt16LessOrEquals).
    #UInt16::> : translateBinaryPrimitiveInto(MIR::Operation::UInt16GreaterThan).
    #UInt16::>= : translateBinaryPrimitiveInto(MIR::Operation::UInt16GreaterOrEquals).

    #UInt16::asChar8 : translateUnaryPrimitiveInto(MIR::Operation::TruncateInt16ToInt8).
    #UInt16::asInt8 : translateUnaryPrimitiveInto(MIR::Operation::TruncateInt16ToInt8).
    #UInt16::asUInt8 : translateUnaryPrimitiveInto(MIR::Operation::TruncateInt16ToInt8).
    #UInt16::asChar16 : translateYourselfPrimitive.
    #UInt16::asInt16 : translateYourselfPrimitive.
    #UInt16::asUInt16 : translateYourselfPrimitive.
    #UInt16::asChar32 : translateUnaryPrimitiveInto(MIR::Operation::ZeroExtendInt16ToInt32).
    #UInt16::asInt32 : translateUnaryPrimitiveInto(MIR::Operation::ZeroExtendInt16ToInt32).
    #UInt16::asUInt32 : translateUnaryPrimitiveInto(MIR::Operation::ZeroExtendInt16ToInt32).
    #UInt16::asInt64 : translateUnaryPrimitiveInto(MIR::Operation::ZeroExtendInt16ToInt64).
    #UInt16::asUInt64 : translateUnaryPrimitiveInto(MIR::Operation::ZeroExtendInt16ToInt64).
    #UInt16::asFloat32 : translateUnaryPrimitiveInto(MIR::Operation::UInt16ToFloat32).
    #UInt16::asFloat64 : translateUnaryPrimitiveInto(MIR::Operation::UInt16ToFloat64).

    ## Int16 primitives
    #Int16::negated : translateUnaryPrimitiveInto(MIR::Operation::Int16Negate).
    #Int16::bitInvert : translateUnaryPrimitiveInto(MIR::Operation::Int16BitNot).
    #Int16::highBit : translateUnaryPrimitiveInto(MIR::Operation::Int16HighBit).

    #Int16::+ : translateBinaryPrimitiveInto(MIR::Operation::Int16Add).
    #Int16::- : translateBinaryPrimitiveInto(MIR::Operation::Int16Sub).
    #Int16::* : translateBinaryPrimitiveInto(MIR::Operation::Int16Mul).
    #Int16::/ : translateBinaryPrimitiveInto(MIR::Operation::Int16SDiv).
    #Int16::% : translateBinaryPrimitiveInto(MIR::Operation::Int16SRem).

    #Int16::& : translateBinaryPrimitiveInto(MIR::Operation::Int16BitAnd).
    #Int16::| : translateBinaryPrimitiveInto(MIR::Operation::Int16BitOr).
    #Int16::^ : translateBinaryPrimitiveInto(MIR::Operation::Int16BitXor).
    #Int16::<< : translateBinaryPrimitiveInto(MIR::Operation::Int16LogicalShiftLeft).
    #Int16::>> : translateBinaryPrimitiveInto(MIR::Operation::Int16ArithmeticShiftRight).

    #Int16::= : translateBinaryPrimitiveInto(MIR::Operation::Int16Equals).
    #Int16::~= : translateBinaryPrimitiveInto(MIR::Operation::Int16NotEquals).
    #Int16::<=> : translateBinaryPrimitiveInto(MIR::Operation::Int16Compare).
    #Int16::< : translateBinaryPrimitiveInto(MIR::Operation::Int16LessThan).
    #Int16::<= : translateBinaryPrimitiveInto(MIR::Operation::Int16LessOrEquals).
    #Int16::> : translateBinaryPrimitiveInto(MIR::Operation::Int16GreaterThan).
    #Int16::>= : translateBinaryPrimitiveInto(MIR::Operation::Int16GreaterOrEquals).

    #Int16::asChar8 : translateUnaryPrimitiveInto(MIR::Operation::TruncateInt16ToInt8).
    #Int16::asInt8 : translateUnaryPrimitiveInto(MIR::Operation::TruncateInt16ToInt8).
    #Int16::asUInt8 : translateUnaryPrimitiveInto(MIR::Operation::TruncateInt16ToInt8).
    #Int16::asChar16 : translateYourselfPrimitive.
    #Int16::asInt16 : translateYourselfPrimitive.
    #Int16::asUInt16 : translateYourselfPrimitive.
    #Int16::asChar32 : translateUnaryPrimitiveInto(MIR::Operation::ZeroExtendInt16ToInt32).
    #Int16::asInt32 : translateUnaryPrimitiveInto(MIR::Operation::SignExtendInt16ToInt32).
    #Int16::asUInt32 : translateUnaryPrimitiveInto(MIR::Operation::ZeroExtendInt16ToInt32).
    #Int16::asInt64 : translateUnaryPrimitiveInto(MIR::Operation::SignExtendInt16ToInt64).
    #Int16::asUInt64 : translateUnaryPrimitiveInto(MIR::Operation::ZeroExtendInt16ToInt64).
    #Int16::asFloat32 : translateUnaryPrimitiveInto(MIR::Operation::Int16ToFloat32).
    #Int16::asFloat64 : translateUnaryPrimitiveInto(MIR::Operation::Int16ToFloat64).

    ## Char32 primitives
    #Char32::negated : translateUnaryPrimitiveInto(MIR::Operation::Int32Negate).
    #Char32::bitInvert : translateUnaryPrimitiveInto(MIR::Operation::Int32BitNot).
    #Char32::highBit : translateUnaryPrimitiveInto(MIR::Operation::Int32HighBit).

    #Char32::+ : translateBinaryPrimitiveInto(MIR::Operation::Int32Add).
    #Char32::- : translateBinaryPrimitiveInto(MIR::Operation::Int32Sub).
    #Char32::* : translateBinaryPrimitiveInto(MIR::Operation::Int32Mul).
    #Char32::/ : translateBinaryPrimitiveInto(MIR::Operation::Int32UDiv).
    #Char32::% : translateBinaryPrimitiveInto(MIR::Operation::Int32URem).

    #Char32::& : translateBinaryPrimitiveInto(MIR::Operation::Int32BitAnd).
    #Char32::| : translateBinaryPrimitiveInto(MIR::Operation::Int32BitOr).
    #Char32::^ : translateBinaryPrimitiveInto(MIR::Operation::Int32BitXor).
    #Char32::<< : translateBinaryPrimitiveInto(MIR::Operation::Int32LogicalShiftLeft).
    #Char32::>> : translateBinaryPrimitiveInto(MIR::Operation::Int32LogicalShiftRight).

    #Char32::= : translateBinaryPrimitiveInto(MIR::Operation::Int32Equals).
    #Char32::~= : translateBinaryPrimitiveInto(MIR::Operation::Int32NotEquals).
    #Char32::<=> : translateBinaryPrimitiveInto(MIR::Operation::Int32Compare).
    #Char32::< : translateBinaryPrimitiveInto(MIR::Operation::UInt32LessThan).
    #Char32::<= : translateBinaryPrimitiveInto(MIR::Operation::UInt32LessOrEquals).
    #Char32::> : translateBinaryPrimitiveInto(MIR::Operation::UInt32GreaterThan).
    #Char32::>= : translateBinaryPrimitiveInto(MIR::Operation::UInt32GreaterOrEquals).

    #Char32::asChar8 : translateUnaryPrimitiveInto(MIR::Operation::TruncateInt32ToInt8).
    #Char32::asInt8 : translateUnaryPrimitiveInto(MIR::Operation::TruncateInt32ToInt8).
    #Char32::asUInt8 : translateUnaryPrimitiveInto(MIR::Operation::TruncateInt32ToInt8).
    #Char32::asChar16 : translateUnaryPrimitiveInto(MIR::Operation::TruncateInt32ToInt16).
    #Char32::asInt16 : translateUnaryPrimitiveInto(MIR::Operation::TruncateInt32ToInt16).
    #Char32::asUInt16 : translateUnaryPrimitiveInto(MIR::Operation::TruncateInt32ToInt16).
    #Char32::asChar32 : translateYourselfPrimitive.
    #Char32::asInt32 : translateYourselfPrimitive.
    #Char32::asUInt32 : translateYourselfPrimitive.
    #Char32::asInt64 : translateUnaryPrimitiveInto(MIR::Operation::ZeroExtendInt32ToInt64).
    #Char32::asUInt64 : translateUnaryPrimitiveInto(MIR::Operation::ZeroExtendInt32ToInt64).
    #Char32::asFloat32 : translateUnaryPrimitiveInto(MIR::Operation::UInt32ToFloat32).
    #Char32::asFloat64 : translateUnaryPrimitiveInto(MIR::Operation::UInt32ToFloat64).

    ## UInt32 primitives
    #UInt32::negated : translateUnaryPrimitiveInto(MIR::Operation::Int32Negate).
    #UInt32::bitInvert : translateUnaryPrimitiveInto(MIR::Operation::Int32BitNot).
    #UInt32::highBit : translateUnaryPrimitiveInto(MIR::Operation::Int32HighBit).

    #UInt32::+ : translateBinaryPrimitiveInto(MIR::Operation::Int32Add).
    #UInt32::- : translateBinaryPrimitiveInto(MIR::Operation::Int32Sub).
    #UInt32::* : translateBinaryPrimitiveInto(MIR::Operation::Int32Mul).
    #UInt32::/ : translateBinaryPrimitiveInto(MIR::Operation::Int32UDiv).
    #UInt32::% : translateBinaryPrimitiveInto(MIR::Operation::Int32URem).

    #UInt32::& : translateBinaryPrimitiveInto(MIR::Operation::Int32BitAnd).
    #UInt32::| : translateBinaryPrimitiveInto(MIR::Operation::Int32BitOr).
    #UInt32::^ : translateBinaryPrimitiveInto(MIR::Operation::Int32BitXor).
    #UInt32::<< : translateBinaryPrimitiveInto(MIR::Operation::Int32LogicalShiftLeft).
    #UInt32::>> : translateBinaryPrimitiveInto(MIR::Operation::Int32LogicalShiftRight).

    #UInt32::= : translateBinaryPrimitiveInto(MIR::Operation::Int32Equals).
    #UInt32::~= : translateBinaryPrimitiveInto(MIR::Operation::Int32NotEquals).
    #UInt32::<=> : translateBinaryPrimitiveInto(MIR::Operation::Int32Compare).
    #UInt32::< : translateBinaryPrimitiveInto(MIR::Operation::UInt32LessThan).
    #UInt32::<= : translateBinaryPrimitiveInto(MIR::Operation::UInt32LessOrEquals).
    #UInt32::> : translateBinaryPrimitiveInto(MIR::Operation::UInt32GreaterThan).
    #UInt32::>= : translateBinaryPrimitiveInto(MIR::Operation::UInt32GreaterOrEquals).

    #UInt32::asChar8 : translateUnaryPrimitiveInto(MIR::Operation::TruncateInt32ToInt8).
    #UInt32::asInt8 : translateUnaryPrimitiveInto(MIR::Operation::TruncateInt32ToInt8).
    #UInt32::asUInt8 : translateUnaryPrimitiveInto(MIR::Operation::TruncateInt32ToInt8).
    #UInt32::asChar16 : translateUnaryPrimitiveInto(MIR::Operation::TruncateInt32ToInt16).
    #UInt32::asInt16 : translateUnaryPrimitiveInto(MIR::Operation::TruncateInt32ToInt16).
    #UInt32::asUInt16 : translateUnaryPrimitiveInto(MIR::Operation::TruncateInt32ToInt16).
    #UInt32::asChar32 : translateYourselfPrimitive.
    #UInt32::asInt32 : translateYourselfPrimitive.
    #UInt32::asUInt32 : translateYourselfPrimitive.
    #UInt32::asInt64 : translateUnaryPrimitiveInto(MIR::Operation::ZeroExtendInt32ToInt64).
    #UInt32::asUInt64 : translateUnaryPrimitiveInto(MIR::Operation::ZeroExtendInt32ToInt64).
    #UInt32::asFloat32 : translateUnaryPrimitiveInto(MIR::Operation::UInt32ToFloat32).
    #UInt32::asFloat64 : translateUnaryPrimitiveInto(MIR::Operation::UInt32ToFloat64).
    #UInt32::asIEEEFloat32Decoded : translateUnaryPrimitiveInto(MIR::Operation::IEEEUInt32ToFloat32). 

    ## Int32 primitives
    #Int32::negated : translateUnaryPrimitiveInto(MIR::Operation::Int32Negate).
    #Int32::bitInvert : translateUnaryPrimitiveInto(MIR::Operation::Int32BitNot).
    #Int32::highBit : translateUnaryPrimitiveInto(MIR::Operation::Int32HighBit).

    #Int32::+ : translateBinaryPrimitiveInto(MIR::Operation::Int32Add).
    #Int32::- : translateBinaryPrimitiveInto(MIR::Operation::Int32Sub).
    #Int32::* : translateBinaryPrimitiveInto(MIR::Operation::Int32Mul).
    #Int32::/ : translateBinaryPrimitiveInto(MIR::Operation::Int32SDiv).
    #Int32::% : translateBinaryPrimitiveInto(MIR::Operation::Int32SRem).

    #Int32::& : translateBinaryPrimitiveInto(MIR::Operation::Int32BitAnd).
    #Int32::| : translateBinaryPrimitiveInto(MIR::Operation::Int32BitOr).
    #Int32::^ : translateBinaryPrimitiveInto(MIR::Operation::Int32BitXor).
    #Int32::<< : translateBinaryPrimitiveInto(MIR::Operation::Int32LogicalShiftLeft).
    #Int32::>> : translateBinaryPrimitiveInto(MIR::Operation::Int32ArithmeticShiftRight).

    #Int32::= : translateBinaryPrimitiveInto(MIR::Operation::Int32Equals).
    #Int32::~= : translateBinaryPrimitiveInto(MIR::Operation::Int32NotEquals).
    #Int32::<=> : translateBinaryPrimitiveInto(MIR::Operation::Int32Compare).
    #Int32::< : translateBinaryPrimitiveInto(MIR::Operation::Int32LessThan).
    #Int32::<= : translateBinaryPrimitiveInto(MIR::Operation::Int32LessOrEquals).
    #Int32::> : translateBinaryPrimitiveInto(MIR::Operation::Int32GreaterThan).
    #Int32::>= : translateBinaryPrimitiveInto(MIR::Operation::Int32GreaterOrEquals).

    #Int32::asChar8 : translateUnaryPrimitiveInto(MIR::Operation::TruncateInt32ToInt8).
    #Int32::asInt8 : translateUnaryPrimitiveInto(MIR::Operation::TruncateInt32ToInt8).
    #Int32::asUInt8 : translateUnaryPrimitiveInto(MIR::Operation::TruncateInt32ToInt8).
    #Int32::asChar16 : translateUnaryPrimitiveInto(MIR::Operation::TruncateInt32ToInt16).
    #Int32::asInt16 : translateUnaryPrimitiveInto(MIR::Operation::TruncateInt32ToInt16).
    #Int32::asUInt16 : translateUnaryPrimitiveInto(MIR::Operation::TruncateInt32ToInt16).
    #Int32::asChar32 : translateYourselfPrimitive.
    #Int32::asInt32 : translateYourselfPrimitive.
    #Int32::asUInt32 : translateYourselfPrimitive.
    #Int32::asInt64 : translateUnaryPrimitiveInto(MIR::Operation::SignExtendInt32ToInt64).
    #Int32::asUInt64 : translateUnaryPrimitiveInto(MIR::Operation::ZeroExtendInt32ToInt64).
    #Int32::asFloat32 : translateUnaryPrimitiveInto(MIR::Operation::Int32ToFloat32).
    #Int32::asFloat64 : translateUnaryPrimitiveInto(MIR::Operation::Int32ToFloat64).

    ## Int64 primitives
    #Int64::negated : translateUnaryPrimitiveInto(MIR::Operation::Int64Negate).
    #Int64::bitInvert : translateUnaryPrimitiveInto(MIR::Operation::Int64BitNot).

    #Int64::+ : translateBinaryPrimitiveInto(MIR::Operation::Int64Add).
    #Int64::- : translateBinaryPrimitiveInto(MIR::Operation::Int64Sub).
    #Int64::* : translateBinaryPrimitiveInto(MIR::Operation::Int64Mul).
    #Int64::/ : translateBinaryPrimitiveInto(MIR::Operation::Int64SDiv).
    #Int64::% : translateBinaryPrimitiveInto(MIR::Operation::Int64SRem).

    #Int64::& : translateBinaryPrimitiveInto(MIR::Operation::Int64BitAnd).
    #Int64::| : translateBinaryPrimitiveInto(MIR::Operation::Int64BitOr).
    #Int64::^ : translateBinaryPrimitiveInto(MIR::Operation::Int64BitXor).
    #Int64::<< : translateBinaryPrimitiveInto(MIR::Operation::Int64LogicalShiftLeft).
    #Int64::>> : translateBinaryPrimitiveInto(MIR::Operation::Int64ArithmeticShiftRight).

    #Int64::= : translateBinaryPrimitiveInto(MIR::Operation::Int64Equals).
    #Int64::~= : translateBinaryPrimitiveInto(MIR::Operation::Int64NotEquals).
    #Int64::<=> : translateBinaryPrimitiveInto(MIR::Operation::Int64Compare).
    #Int64::< : translateBinaryPrimitiveInto(MIR::Operation::Int64LessThan).
    #Int64::<= : translateBinaryPrimitiveInto(MIR::Operation::Int64LessOrEquals).
    #Int64::> : translateBinaryPrimitiveInto(MIR::Operation::Int64GreaterThan).
    #Int64::>= : translateBinaryPrimitiveInto(MIR::Operation::Int64GreaterOrEquals).
    #Int64::highBit : translateUnaryPrimitiveInto(MIR::Operation::Int64HighBit).

    #Int64::asChar8 : translateUnaryPrimitiveInto(MIR::Operation::TruncateInt64ToInt8).
    #Int64::asInt8 : translateUnaryPrimitiveInto(MIR::Operation::TruncateInt64ToInt8).
    #Int64::asUInt8 : translateUnaryPrimitiveInto(MIR::Operation::TruncateInt64ToInt8).
    #Int64::asChar16 : translateUnaryPrimitiveInto(MIR::Operation::TruncateInt64ToInt16).
    #Int64::asInt16 : translateUnaryPrimitiveInto(MIR::Operation::TruncateInt64ToInt16).
    #Int64::asUInt16 : translateUnaryPrimitiveInto(MIR::Operation::TruncateInt64ToInt16).
    #Int64::asChar32 : translateUnaryPrimitiveInto(MIR::Operation::TruncateInt64ToInt32).
    #Int64::asInt32 : translateUnaryPrimitiveInto(MIR::Operation::TruncateInt64ToInt32).
    #Int64::asUInt32 : translateUnaryPrimitiveInto(MIR::Operation::TruncateInt64ToInt32).
    #Int64::asInt64 : translateYourselfPrimitive.
    #Int64::asUInt64 : translateYourselfPrimitive.
    #Int64::asFloat32 : translateUnaryPrimitiveInto(MIR::Operation::Int64ToFloat32).
    #Int64::asFloat64 : translateUnaryPrimitiveInto(MIR::Operation::Int64ToFloat64).

    ## UInt64 primitives
    #UInt64::negated : translateUnaryPrimitiveInto(MIR::Operation::Int64Negate).
    #UInt64::bitInvert : translateUnaryPrimitiveInto(MIR::Operation::Int64BitNot).
    #UInt64::highBit : translateUnaryPrimitiveInto(MIR::Operation::Int64HighBit).

    #UInt64::+ : translateBinaryPrimitiveInto(MIR::Operation::Int64Add).
    #UInt64::- : translateBinaryPrimitiveInto(MIR::Operation::Int64Sub).
    #UInt64::* : translateBinaryPrimitiveInto(MIR::Operation::Int64Mul).
    #UInt64::/ : translateBinaryPrimitiveInto(MIR::Operation::Int64UDiv).
    #UInt64::% : translateBinaryPrimitiveInto(MIR::Operation::Int64URem).

    #UInt64::& : translateBinaryPrimitiveInto(MIR::Operation::Int64BitAnd).
    #UInt64::| : translateBinaryPrimitiveInto(MIR::Operation::Int64BitOr).
    #UInt64::^ : translateBinaryPrimitiveInto(MIR::Operation::Int64BitXor).
    #UInt64::<< : translateBinaryPrimitiveInto(MIR::Operation::Int64LogicalShiftLeft).
    #UInt64::>> : translateBinaryPrimitiveInto(MIR::Operation::Int64LogicalShiftRight).

    #UInt64::= : translateBinaryPrimitiveInto(MIR::Operation::Int64Equals).
    #UInt64::~= : translateBinaryPrimitiveInto(MIR::Operation::Int64NotEquals).
    #UInt64::<=> : translateBinaryPrimitiveInto(MIR::Operation::Int64Compare).
    #UInt64::< : translateBinaryPrimitiveInto(MIR::Operation::UInt64LessThan).
    #UInt64::<= : translateBinaryPrimitiveInto(MIR::Operation::UInt64LessOrEquals).
    #UInt64::> : translateBinaryPrimitiveInto(MIR::Operation::UInt64GreaterThan).
    #UInt64::>= : translateBinaryPrimitiveInto(MIR::Operation::UInt64GreaterOrEquals).

    #UInt64::asChar8 : translateUnaryPrimitiveInto(MIR::Operation::TruncateInt64ToInt8).
    #UInt64::asInt8 : translateUnaryPrimitiveInto(MIR::Operation::TruncateInt64ToInt8).
    #UInt64::asUInt8 : translateUnaryPrimitiveInto(MIR::Operation::TruncateInt64ToInt8).
    #UInt64::asChar16 : translateUnaryPrimitiveInto(MIR::Operation::TruncateInt64ToInt16).
    #UInt64::asInt16 : translateUnaryPrimitiveInto(MIR::Operation::TruncateInt64ToInt16).
    #UInt64::asUInt16 : translateUnaryPrimitiveInto(MIR::Operation::TruncateInt64ToInt16).
    #UInt64::asChar32 : translateUnaryPrimitiveInto(MIR::Operation::TruncateInt64ToInt32).
    #UInt64::asInt32 : translateUnaryPrimitiveInto(MIR::Operation::TruncateInt64ToInt32).
    #UInt64::asUInt32 : translateUnaryPrimitiveInto(MIR::Operation::TruncateInt64ToInt32).
    #UInt64::asInt64 : translateYourselfPrimitive.
    #UInt64::asUInt64 : translateYourselfPrimitive.
    #UInt64::asFloat32 : translateUnaryPrimitiveInto(MIR::Operation::UInt64ToFloat32).
    #UInt64::asFloat64 : translateUnaryPrimitiveInto(MIR::Operation::UInt64ToFloat64).
    #UInt64::asIEEEFloat64Decoded : translateUnaryPrimitiveInto(MIR::Operation::IEEEUInt64ToFloat64). 

    ## Float32 primitives
    #Float32::negated : translateUnaryPrimitiveInto(MIR::Operation::Float32Negate).
    #Float32::sqrt : translateUnaryPrimitiveInto(MIR::Operation::Float32Sqrt).

    #Float32::+ : translateBinaryPrimitiveInto(MIR::Operation::Float32Add).
    #Float32::- : translateBinaryPrimitiveInto(MIR::Operation::Float32Sub).
    #Float32::* : translateBinaryPrimitiveInto(MIR::Operation::Float32Mul).
    #Float32::/ : translateBinaryPrimitiveInto(MIR::Operation::Float32Div).

    #Float32::= : translateBinaryPrimitiveInto(MIR::Operation::Float32UnorderedEquals).
    #Float32::~= : translateBinaryPrimitiveInto(MIR::Operation::Float32UnorderedNotEquals).
    #Float32::<=> : translateBinaryPrimitiveInto(MIR::Operation::Float32UnorderedCompare).
    #Float32::< : translateBinaryPrimitiveInto(MIR::Operation::Float32UnorderedLessThan).
    #Float32::<= : translateBinaryPrimitiveInto(MIR::Operation::Float32UnorderedLessOrEquals).
    #Float32::> : translateBinaryPrimitiveInto(MIR::Operation::Float32UnorderedGreaterThan).
    #Float32::>= : translateBinaryPrimitiveInto(MIR::Operation::Float32UnorderedGreaterOrEquals).

    #Float32::asChar8 : translateUnaryPrimitiveInto(MIR::Operation::Float32ToUInt8).
    #Float32::asInt8 : translateUnaryPrimitiveInto(MIR::Operation::Float32ToInt8).
    #Float32::asUInt8 : translateUnaryPrimitiveInto(MIR::Operation::Float32ToUInt8).
    #Float32::asChar16 : translateUnaryPrimitiveInto(MIR::Operation::Float32ToUInt16).
    #Float32::asInt16 : translateUnaryPrimitiveInto(MIR::Operation::Float32ToInt16).
    #Float32::asUInt16 : translateUnaryPrimitiveInto(MIR::Operation::Float32ToUInt16).
    #Float32::asChar32 : translateUnaryPrimitiveInto(MIR::Operation::Float32ToUInt32).
    #Float32::asInt32 : translateUnaryPrimitiveInto(MIR::Operation::Float32ToInt32).
    #Float32::asUInt32 : translateUnaryPrimitiveInto(MIR::Operation::Float32ToUInt32).
    #Float32::asInt64 : translateUnaryPrimitiveInto(MIR::Operation::Float32ToInt64).
    #Float32::asUInt64 : translateUnaryPrimitiveInto(MIR::Operation::Float32ToUInt64).
    #Float32::asFloat32 : translateYourselfPrimitive.
    #Float32::asFloat64 : translateUnaryPrimitiveInto(MIR::Operation::Float32ToFloat64).
    #Float32::asIEEEFloat32Encoding : translateUnaryPrimitiveInto(MIR::Operation::Float32ToIEEEUInt32). 

    ## Float64 primitives
    #Float64::negated : translateUnaryPrimitiveInto(MIR::Operation::Float64Negate).
    #Float64::sqrt : translateUnaryPrimitiveInto(MIR::Operation::Float64Sqrt).

    #Float64::+ : translateBinaryPrimitiveInto(MIR::Operation::Float64Add).
    #Float64::- : translateBinaryPrimitiveInto(MIR::Operation::Float64Sub).
    #Float64::* : translateBinaryPrimitiveInto(MIR::Operation::Float64Mul).
    #Float64::/ : translateBinaryPrimitiveInto(MIR::Operation::Float64Div).

    #Float64::= : translateBinaryPrimitiveInto(MIR::Operation::Float64UnorderedEquals).
    #Float64::~= : translateBinaryPrimitiveInto(MIR::Operation::Float64UnorderedNotEquals).
    #Float64::<=> : translateBinaryPrimitiveInto(MIR::Operation::Float64UnorderedCompare).
    #Float64::< : translateBinaryPrimitiveInto(MIR::Operation::Float64UnorderedLessThan).
    #Float64::<= : translateBinaryPrimitiveInto(MIR::Operation::Float64UnorderedLessOrEquals).
    #Float64::> : translateBinaryPrimitiveInto(MIR::Operation::Float64UnorderedGreaterThan).
    #Float64::>= : translateBinaryPrimitiveInto(MIR::Operation::Float64UnorderedGreaterOrEquals).

    #Float64::asChar8 : translateUnaryPrimitiveInto(MIR::Operation::Float64ToUInt8).
    #Float64::asInt8 : translateUnaryPrimitiveInto(MIR::Operation::Float64ToInt8).
    #Float64::asUInt8 : translateUnaryPrimitiveInto(MIR::Operation::Float64ToUInt8).
    #Float64::asChar16 : translateUnaryPrimitiveInto(MIR::Operation::Float64ToUInt16).
    #Float64::asInt16 : translateUnaryPrimitiveInto(MIR::Operation::Float64ToInt16).
    #Float64::asUInt16 : translateUnaryPrimitiveInto(MIR::Operation::Float64ToUInt16).
    #Float64::asChar32 : translateUnaryPrimitiveInto(MIR::Operation::Float64ToUInt32).
    #Float64::asInt32 : translateUnaryPrimitiveInto(MIR::Operation::Float64ToInt32).
    #Float64::asUInt32 : translateUnaryPrimitiveInto(MIR::Operation::Float64ToUInt32).
    #Float64::asInt64 : translateUnaryPrimitiveInto(MIR::Operation::Float64ToInt64).
    #Float64::asUInt64 : translateUnaryPrimitiveInto(MIR::Operation::Float64ToUInt64).
    #Float64::asFloat32 : translateUnaryPrimitiveInto(MIR::Operation::Float64ToFloat32).
    #Float64::asFloat64 : translateYourselfPrimitive.
    #Float64::asIEEEFloat64Encoding : translateUnaryPrimitiveInto(MIR::Operation::Float64ToIEEEUInt64). 
}.

HIRFunctionDefinitionMIRCodeGenerator extend: {
    public method compilePrimitiveFunctionBody => Boolean := {
        ## Attempt to use the primitive generator first.
        let primitiveGenerator type: (Array, Type, HIRFunctionDefinitionMIRCodeGenerator) => MIRValue := HIRMirPrimitiveCallGenerationTable atOrNil: ssaFunctionDefinition primitiveName.
        let primitiveResultValue mutable => MIRValue := nil.
        primitiveGenerator ifNotNil: {
            functionBuilder basicBlock: #primitive build: {:(MIRBlockBuilder)asm :: Void |
                self blockBuilder: asm.
                let canonicalResultType := ssaFunctionDefinition functionType canonicalResultType.
                primitiveResultValue := primitiveGenerator(ssaFunctionDefinition arguments, canonicalResultType, self).
                primitiveResultValue ifNotNil: {
                    canonicalResultType emitMirReturn: primitiveResultValue withBlockBuilder: asm
                }.
            }.
        }.

        primitiveResultValue ~~ nil
    }.

    public method compileCall: (calledFunction: HIRValue) withArguments: (arguments: Array) unchecked: (isUnchecked: Boolean) type: (resultType: Type) ::=> MIRValue := {
        ## Attempt to use the primitive generator first.
        let primitiveName := calledFunction primitiveName.
        (#(Exception::setjmp Exception::longjmp) includes: primitiveName) ifFalse: {
            let primitiveGenerator type: (Array, Type, HIRFunctionDefinitionMIRCodeGenerator) => MIRValue := HIRMirPrimitiveCallGenerationTable atOrNil: primitiveName.
            primitiveGenerator ifNotNil: {
                let primitiveValue := primitiveGenerator(arguments, resultType, self).
                primitiveValue ifNotNil: {
                    return: primitiveValue
                }
            }
        }.

        ## If this is a pointer like type, then we must perform a direct call.
        calledFunction type isPointerLikeType ifTrue: {
            let entryPoint := self translateValue: calledFunction.
            let mirArguments := arguments collect: {:(HIRValue)eachArgument :: MIRValue | self translateValue: eachArgument}.
            return: (resultType
                emitMirCall: entryPoint convention: (self mirFunction compilationTarget callingConventionNamed: calledFunction callingConventionNameOrNil)
                withArguments: mirArguments
                withBlockBuilder: self blockBuilder)
        }.

        isUnchecked ifTrue: {
            let calledFunctionType := calledFunction type.
            let canonicalResultType := calledFunctionType canonicalResultType.

            let canonicalResult := calledFunction isCaptureless ifTrue: {
                let entryPoint := self translateCapturelessUncheckedFunctionEntryPoint: calledFunction.
                let mirArguments := arguments collectWithIndex: {:(HIRValue)eachArgument :(Size)index :: MIRValue |
                    self translateValue: eachArgument withExpectedType: (calledFunctionType canonicalTypeForApplicationArgumentWithIndex: index)
                }.

                canonicalResultType
                    emitMirCall: entryPoint convention: (self mirFunction compilationTarget callingConventionNamed: calledFunction callingConventionNameOrNil)
                    withArguments: mirArguments
                    withBlockBuilder: self blockBuilder

            } ifFalse: {
                let mirCalledFunction := self translateValue: calledFunction.
                let entryPoint := self translateUncheckedFunctionEntryPoint: calledFunction functionType: calledFunctionType resultType: resultType argumentCount: arguments size.
                let mirArguments := arguments collectWithIndex: {:(HIRValue)eachArgument :(Size)index :: MIRValue |
                    self translateValue: eachArgument withExpectedType: (calledFunctionType canonicalTypeForApplicationArgumentWithIndex: index)
                }.

                canonicalResultType
                    emitMirCall: entryPoint convention: (self mirFunction compilationTarget callingConventionNamed: calledFunction callingConventionNameOrNil)
                    withArguments: (Array with: mirCalledFunction) -- mirArguments
                    withBlockBuilder: self blockBuilder
            }.

            canonicalResultType == resultType ifTrue: {
                canonicalResult
            } ifFalse: {
                resultType emitMirUncheckedUnbox: canonicalResult withHIRCodeGenerator: self
            }
        } ifFalse: {
            let mirCalledFunction := self translateBoxedValue: calledFunction.
            let entryPoint := self translateCheckedFunctionEntryPoint: calledFunction argumentCount: arguments size.
            let mirArguments := arguments collect: {:(HIRValue)eachArgument :: MIRValue | self translateBoxedValue: eachArgument}.
            entryPoint ifNotNil: {
                resultType
                    emitMirUnboxingCall: entryPoint convention: (self mirFunction compilationTarget callingConventionNamed: calledFunction callingConventionNameOrNil)
                    withArguments: (Array with: mirCalledFunction) -- mirArguments
                    withHIRCodeGenerator: self.
            } ifNil: {
                self blockBuilder trap
            }.
        }.
    }.
}.

HIRCallInstruction extend: {
    public override method compileIntoMIRWith: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue := {
        codegen compileCall: calledFunction withArguments: arguments unchecked: isUnchecked type: self type
    }.
}.

HIRAddressSpaceCastInstruction extend: {
    public override method compileIntoMIRWith: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue := {
        let resultValue := codegen translateValue: self value.
        let valueType := resultValue type.

        valueType ~~ type ifTrue: {
            let sourceValueSize := valueType valueSize.
            let destinationValueSize := self type valueSize.
            sourceValueSize = destinationValueSize ifTrue: {
                type emitMirMove: resultValue withBlockBuilder: codegen blockBuilder.
            } ifFalse: {
                sourceValueSize < destinationValueSize ifTrue: {
                    codegen blockBuilder fatPointerConstruct: resultValue with: codegen nullPointerConstant type: self type
                } ifFalse: { ##sourceValueSize > destinationValueSize
                    codegen blockBuilder fatPointerExtractFirst: resultValue type: self type
                }
            }
        } ifFalse: {
            resultValue
        }
    }.
}.

HIRBitcastInstruction extend: {
    public override method compileIntoMIRWith: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue := {
        let resultValue := codegen translateValue: self value.
        let valueType := resultValue type.

        valueType ~~ type ifTrue: {
            self assert: valueType valueSize = self type valueSize.
            self assert: valueType isPrimitiveFloatType not && self type isPrimitiveFloatType not.
            type emitMirMove: resultValue withBlockBuilder: codegen blockBuilder.
        } ifFalse: {
            resultValue
        }
    }.
}.

HIRCoerceValueInstruction extend: {
    public override method compileIntoMIRWith: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue := {
        self targetType isLiteralConstant && (self value type isSubtypeOf: self targetType evaluateAsConstantType) ifTrue: {
            return: (codegen translateValue: self value)
        }.

        self type emitMirCoerceInto: (codegen translateValue: self targetType) thenUnbox: (codegen translateValue: self value) withHIRCodeGenerator: codegen
    }.
}.

HIRDownCastInstruction extend: {
    public override method compileIntoMIRWith: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue := {
        ## Nop case.
        self targetType isLiteralConstant && (self value type isSubtypeOf: self targetType evaluateAsConstantType) ifTrue: {
            return: (codegen translateValue: self value)
        }.

        isUnchecked ifTrue: {
            self type emitMirUncheckedUnbox: (codegen translateValue: self value) withHIRCodeGenerator: codegen
        } ifFalse: {
            self targetType isLiteralConstant ifTrue: {
                self type emitMirCheckAndUnbox: (codegen translateValue: self value) withHIRCodeGenerator: codegen
            } ifFalse: {
                self type emitMirCheckInto: (codegen translateValue: self targetType) thenUnbox: (codegen translateValue: self value) withHIRCodeGenerator: codegen
            }.
        }
    }.
}.

HIRLoadInstruction extend: {
    public override method compileIntoMIRWith: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue := {
        let pointerValue := codegen translateValue: self storage.
        self storage type validAddressSpace isFatPointer ifTrue: {
            let nativePointerValue := codegen blockBuilder fatPointerExtractFirst: pointerValue type: Void pointer.
            self type emitMirLoadFromPointer: nativePointerValue constantOffset: 0i64 withBlockBuilder: codegen blockBuilder
        } ifFalse: {
            self type emitMirLoadFromPointer: pointerValue constantOffset: 0i64 withBlockBuilder: codegen blockBuilder
        }.
    }.
}.

HIRMakeArrayInstruction extend: {
    public override method compileIntoMIRWith: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue := {
        let array := codegen blockBuilder callPointer: (codegen translateRuntimeFunction: ObjectModel::makeArrayWithSize)
            with: (codegen blockBuilder pointerConstantWith: self elements size asUInt64)
            type: Array.

        let headerSize := (self type objectHeaderSizeForObjectModel: codegen compilationTarget objectModel) asInt64.
        let pointerSize := codegen compilationTarget pointerSize asInt64.

        self elements doWithIndex: {:(HIRValue)eachElement :(Size)eachElementIndex :: Void |
            let eachElementValue := codegen translateBoxedValue: eachElement.
            codegen storePointer: eachElementValue into: array constantOffset: headerSize + (eachElementIndex asInt64 * pointerSize) in: array
        }.

        array
    }.
}.

HIRMakeAssociationInstruction extend: {
    public override method compileIntoMIRWith: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue
        := codegen blockBuilder callPointer: (codegen translateRuntimeFunction: ObjectModel::makeAssociation)
            with: (codegen translateBoxedValue: self key)
            with: (codegen translateBoxedValue: self value)
            type: self type.
}.

HIRMakeByteArrayInstruction extend: {
    public override method compileIntoMIRWith: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue := {
        let byteArray := codegen blockBuilder callPointer: (codegen translateRuntimeFunction: ObjectModel::makeByteArrayWithSize)
            with: (codegen blockBuilder pointerConstantWith: self elements size asUInt64)
            type: self type.

        let headerSize := (self type objectHeaderSizeForObjectModel: codegen compilationTarget objectModel) asInt64.
        let pointerSize := codegen compilationTarget pointerSize asInt64.

        self elements doWithIndex: {:(HIRValue)eachElement :(Size)eachElementIndex :: Void |
            let eachElementValue := codegen translateValue: eachElement.

            codegen blockBuilder storeInt8: eachElementValue into: byteArray constantOffset: headerSize + (eachElementIndex asInt64 * pointerSize)
        }.

        byteArray
    }.
}.

HIRMakeClosureInstruction extend: {
    public override method compileIntoMIRWith: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue := {
        let captureVectorType := SequenceTupleTypeTemplate(self captures collect: {:(HIRValue)eachCapture :: Type | eachCapture type ifNil: Untyped}).

        ## Allocate the capture vector.
        let captureVector := codegen blockBuilder
            callPointer: (codegen translateRuntimeFunction: ObjectModel::allocateCaptureVectorOfType)
            with: (codegen moduleCodeGenerator translateGenericObjectPointer: captureVectorType)
            type: captureVectorType.

        ## Fill the capture vector.
        let headerSize := captureVectorType objectHeaderSizeForObjectModel: codegen compilationTarget objectModel.
        self captures doWithIndex: {:(HIRValue)eachCapture :(Size)eachCaptureIndex :: Void |
            let captureVectorSlot := captureVectorType slots at: eachCaptureIndex.
            eachCapture type
                emitMirStore: (codegen translateValue: eachCapture)
                intoPointer: captureVector constantOffset: headerSize asInt64 + captureVectorSlot validOffset asInt64
                in: captureVector
                with: codegen
        }.

        ## Create the closure.
        codegen blockBuilder
            callPointer: (codegen translateRuntimeFunction: ObjectModel::makeClosureWithCaptureVector)
            with: (codegen translateValue: functionDefinition) with: captureVector
            type: self type
    }.
}.

HIRMakeDictionaryInstruction extend: {
    public override method compileIntoMIRWith: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue := {
        let dictionary := codegen blockBuilder callPointer: (codegen translateRuntimeFunction: ObjectModel::makeByteArrayWithSize)
            with: (codegen blockBuilder pointerConstantWith: self elements size asUInt64)
            type: Dictionary.

        let addFunction := codegen translateRuntimeFunction: ObjectModel::Dictionary::add.
        self elements do: {:(HIRValue)eachElement :(Size)eachElementIndex :: Void |
            let eachElementValue := codegen translateValue: eachElement.
            codegen blockBuilder callVoid: addFunction with: dictionary with: eachElementValue
        }.

        dictionary
    }.
}.

HIRSendInstruction extend: {
    public override method compileIntoMIRWith: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue := {
        let mirReceiver := codegen translateBoxedValue: self receiver.
        let mirReceiverLookupType := self receiverLookupType ifNotNil: (codegen translateBoxedValue: self receiverLookupType).
        let mirSelector := codegen translateBoxedValue: self selector.

        let vtableIndex := codegen moduleCodeGenerator getVirtualTableIndexValueForSelector: self boundSelector type: self boundType.

        isUnchecked ifTrue: {
            ## Perform the lookup.
            let foundMethod := vtableIndex ifNotNil: {
                mirReceiverLookupType ifNil: {
                    codegen blockBuilder callPointer: (codegen translateRuntimeFunction: ObjectModel::lookupMethodWithReceiverAndVirtualTableIndex)
                        with: mirReceiver with: vtableIndex
                        type: UIntPointer.
                } ifNotNil: {
                    codegen blockBuilder callPointer: (codegen translateRuntimeFunction: ObjectModel::lookupMethodWithReceiverTypeAndVirtualTableIndex)
                        with: mirReceiverLookupType with: vtableIndex
                        type: UIntPointer.
                }
            } ifNil: {
                mirReceiverLookupType ifNil: {
                    codegen blockBuilder callPointer: (codegen translateRuntimeFunction: ObjectModel::lookupValidMethodWithReceiverAndInlineCache)
                        with: MIRPolymorphicInlineCache new with: mirReceiver with: mirSelector
                        type: UIntPointer.
                } ifNotNil: {
                    codegen blockBuilder callPointer: (codegen translateRuntimeFunction: ObjectModel::lookupValidMethodWithReceiverTypeAndInlineCache)
                        with: MIRPolymorphicInlineCache new with: mirReceiver with: mirReceiverLookupType with: mirSelector
                        type: UIntPointer.
                }
            }.

            ## Get the trampoline for the conversion case.
            let boxingTrampoline := codegen moduleCodeGenerator getOrCreateBoxingApplicationTrampolineWithSignature: self boxingApplicationSignature.
            let applicationBoxDescriptor := self applicationBoxDescriptor asMirConstant.

            ## Fetch the entry point to use
            let entryPoint := codegen blockBuilder
                callPointer: (codegen translateRuntimeFunction: ObjectModel::fetchUncheckedEntryPointMatchingBoxDescriptorOrBoxingTrampoline)
                with: foundMethod with: applicationBoxDescriptor with: boxingTrampoline
                type: UIntPointer.

            let mirValueReceiver := codegen translateValue: self receiver.
            let mirValueArguments := self arguments collect: {:(HIRValue)eachArgument :: MIRValue | codegen translateValue: eachArgument}.

            return: (self type
                emitMirCall: entryPoint convention: codegen compilationTarget defaultCallingConvention
                withArguments: (Array with: foundMethod with: mirValueReceiver) -- mirValueArguments
                withBlockBuilder: codegen blockBuilder)
        }.
    
        let mirArguments := self arguments collect: {:(HIRValue)eachArgument :: MIRValue | codegen translateBoxedValue: eachArgument}.

        mirReceiverLookupType ifNil: {
            let trampoline := codegen translateRuntimeFunction: (ObjectModel::SendTrampolines at: self arguments size).
            self type
                emitMirUnboxingCall: trampoline convention: trampoline callingConvention
                withArguments: (Array with: MIRPolymorphicInlineCache new with: mirReceiver with: mirSelector) -- mirArguments
                withHIRCodeGenerator: codegen.
        } ifNotNil: {
            let trampoline := codegen translateRuntimeFunction: (ObjectModel::SendWithReceiverTypeTrampolines at: self arguments size).
            self type
                emitMirUnboxingCall: trampoline convention: trampoline callingConvention
                withArguments: (Array with: MIRPolymorphicInlineCache new with: mirReceiver with: mirReceiverLookupType with: mirSelector) -- mirArguments
                withHIRCodeGenerator: codegen.
        }.
    }.
}.

HIRSetDebugValueForBindingInstruction extend: {
    public override method compileIntoMIRWith: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue := {
        self value isAllocaInstruction ifTrue: {
            codegen blockBuilder debugSetMutableBinding: self binding value: (codegen translateValue: self value)
        } ifFalse: {
            self promotedFromAlloca ifTrue: {
                codegen blockBuilder debugSetMutableBindingSpecificValue: self binding value: (codegen translateValue: self value)
            } ifFalse: {
                codegen blockBuilder debugSetBinding: self binding value: (codegen translateValue: self value)
            }.
        }
    }.
}.

HIRStoreInstruction extend: {
    public override method compileIntoMIRWith: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue := {
        let pointerType := self storage type.
        self assert: pointerType isPointerLikeType.
        let baseType := (pointerType downCastTo: PointerLikeType) baseType.
        let valueToStore := codegen translateValue: self value withExpectedType: baseType.
        self assert: valueToStore isNotNil.

        let pointerValue := codegen translateValue: self storage.
        pointerType validAddressSpace isFatPointer ifTrue: {
            let nativePointerValue := codegen blockBuilder fatPointerExtractFirst: pointerValue type: Void pointer.
            let object := codegen blockBuilder fatPointerExtractSecond: pointerValue type: Untyped.
            baseType emitMirStore: valueToStore intoPointer: nativePointerValue constantOffset: 0i64 in: object with: codegen
        } ifFalse: {
            baseType emitMirStore: valueToStore intoPointer: pointerValue constantOffset: 0i64 in: nil with: codegen
        }.
    }.
}.

HIRPhiInstruction extend: {
    public override method compileIntoMIRWith: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue := {
        self type emitMirPhiWithBlockBuilder: codegen blockBuilder
    }.
}.

HIRPointerElementAtInstruction extend: {
    public override method compileIntoMIRWith: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue := {
        let pointerValue := codegen translateValue: self pointer.
        let indexValue := codegen translateValue: self index.
        let elementSize := (self pointer type downCastTo: PointerLikeType) baseType alignedValueSize.
        self pointer type validAddressSpace isFatPointer ifTrue: {
            codegen blockBuilder loadFatEffectiveAddress: pointerValue index: indexValue constantScale: elementSize asInt64 type: self type
        } ifFalse: {
            codegen blockBuilder loadEffectiveAddress: pointerValue index: indexValue constantScale: elementSize asInt64 type: self type
        }.
    }.
}.

HIRReferenceElementAtInstruction extend: {
    public override method compileIntoMIRWith: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue := {
        let referenceValue := codegen translateValue: self reference.
        let indexValue := codegen translateValue: self index.
        let referencedType := (self reference type downCastTo: PointerLikeType) baseType.
        referencedType emitMirReference: referenceValue elementPointerAt: indexValue type: self type withBlockBuilder: codegen blockBuilder
    }.
}.

HIRTypeSlotReferenceAtInstruction extend: {
    public override method compileIntoMIRWith: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue := {
        let tuplePointer := codegen translateValue: self tuple.
        let headerSize := (self tuple type ifNil: AnyValue) objectHeaderSizeForObjectModel: codegen compilationTarget objectModel.

        self type validAddressSpace isFatPointer ifTrue: {
            tuplePointer type isValueType ifTrue: {
                tuplePointer type validAddressSpace isFatPointer ifTrue: {
                    codegen blockBuilder fatPointerAdd: tuplePointer constantOffset: headerSize asInt64 + self typeSlot validOffset asInt64 type: self type
                } ifFalse: {
                    let memberPointer := codegen blockBuilder pointerAdd: tuplePointer constantOffset: headerSize asInt64 + self typeSlot validOffset asInt64 type: Void pointer.
                    codegen blockBuilder fatPointerConstruct: memberPointer with: codegen nullPointerConstant type: self type.
                }
            } ifFalse: {
                let memberPointer := codegen blockBuilder pointerAdd: tuplePointer constantOffset: headerSize asInt64 + self typeSlot validOffset asInt64 type: Void pointer.
                codegen blockBuilder fatPointerConstruct: memberPointer with: tuplePointer type: self type.
            }
        } ifFalse: {
            let nativeTuplePointer := tuplePointer type validAddressSpace isFatPointer
                ifTrue: (codegen blockBuilder fatPointerExtractFirst: tuplePointer type: Void pointer)
                ifFalse: (tuplePointer).
            codegen blockBuilder pointerAdd: nativeTuplePointer constantOffset: headerSize asInt64 + self typeSlot validOffset asInt64 type: self type.
        }
    }.
}.

HIRTypeSlotAtInstruction extend: {
    public override method compileIntoMIRWith: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue := {
        let headerSize := (self tuple type ifNil: AnyValue) objectHeaderSizeForObjectModel: codegen compilationTarget objectModel.
        self type emitMirLoadFromPointer: (codegen translateValue: self tuple) constantOffset: headerSize asInt64 + self typeSlot validOffset asInt64 withBlockBuilder: codegen blockBuilder
    }.
}.

HIRTypeSlotAtPutInstruction extend: {
    public override method compileIntoMIRWith: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue := {
        let headerSize := (self tuple type ifNil: AnyValue) objectHeaderSizeForObjectModel: codegen compilationTarget objectModel.
        let slotValueType := typeSlot type.
        let valueToStore := codegen translateValue: self value withExpectedType: slotValueType.
        let tuple := codegen translateValue: self tuple.
        let objectPointer := codegen objectPointerOrNilFor: tuple.
        slotValueType emitMirStore: valueToStore intoPointer: tuple constantOffset: headerSize asInt64 + self typeSlot validOffset asInt64 in: objectPointer with: codegen
    }.
}.

HIRReturnInstruction extend: {
    public override method compileIntoMIRWith: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue := {
        (self value type isSubtypeOf: ControlFlowEscapeType) ifTrue: {return: void asMirConstant}.

        let canonicalResultType := codegen ssaFunctionDefinition functionType canonicalResultType.
        canonicalResultType emitMirReturn: (codegen translateValue: self value withExpectedType: canonicalResultType) withBlockBuilder: codegen blockBuilder
    }.
}.

HIRUnreachableInstruction extend: {
    public override method compileIntoMIRWith: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue := {
        codegen blockBuilder unreachableTrap
    }.
}.

HIRModule extend: {
    public method asMIRModuleFor: (target: MIRCompilationTarget) ::=> MIRModule
        := HIRModuleMIRCodeGenerator new
            initializeWithTarget: target;
            compileHIRModule: self;
            finish
}.
