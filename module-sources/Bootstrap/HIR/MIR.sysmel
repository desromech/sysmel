let IgnoreNotYetImplementedErrors := true.

public class HIRMIRCompilationTarget superclass: HIRCompilationTarget; definition: {
    public field tacCompilationTarget => MIRCompilationTarget.

    public override method objectModel => ObjectModelVariant
        := tacCompilationTarget objectModel.

    public override method pointerSize => Size
        := tacCompilationTarget pointerSize.

    public override method pointerAlignment => Size
        := tacCompilationTarget pointerAlignment.

    public override method hasLogicalObjectModel => Boolean
        := false.

    public override method hasNativeObjectModel => Boolean
        := true.
}.

public abstract class HIRMIRCodeGenerator superclass: Object; definition: {

}.

MIRCompilationTarget extend: {
    public method asHIRCompilationTarget => HIRCompilationTarget
        := HIRMIRCompilationTarget new tacCompilationTarget: self; yourself.
}.

public final class HIRModuleMIRCodeGenerator superclass: HIRMIRCodeGenerator; definition: {
    public field compilationTarget => MIRCompilationTarget.
    public field ssaModule => HIRModule.
    public field targetModule => MIRModule.
    public field globalValueDictionary => Dictionary.

    public field runtimeFunctionDictionary => Dictionary.
    public field importRuntimeFunction => Boolean.
    private field runtimeFunctionCompilerFrontend => HIRModuleCompilationContext.

    public field capturelessUncheckedEntryPointDictionary => Dictionary.
    public field uncheckedEntryPointDictionary => Dictionary.
    public field checkedEntryPointDictionary => Dictionary.
    public field uncheckedInterpreterTrampolinesDictionary => Dictionary.

    public method initializeWithTarget: (theCompilationTarget: MIRCompilationTarget) ::=> Void := {
        compilationTarget := theCompilationTarget.
        targetModule := MIRModule new
            compilationTarget: compilationTarget;
            yourself.
        globalValueDictionary := Dictionary new.
        runtimeFunctionDictionary := Dictionary new.
        capturelessUncheckedEntryPointDictionary := Dictionary new.
        uncheckedEntryPointDictionary := Dictionary new.
        checkedEntryPointDictionary := Dictionary new.
        uncheckedInterpreterTrampolinesDictionary := Dictionary new.
    }.

    public method compileHIRModule: (module: HIRModule) patchingFunctions: (patchedFunctionList: SequenceableCollection) definitions: (patchedFunctionDefinitionList: SequenceableCollection) ::=> MIRModule := {
        ## Declare the values.
        ssaModule := module.
        module globalValues do: {:(HIRGlobalValue)each :: Void |
            each compileDirectTacTranslationWith: self
        }.

        runtimeFunctionCompilerFrontend ifNotNil: {
            runtimeFunctionCompilerFrontend ssaModule globalValues do: {:(HIRGlobalValue)each :: Void |
                each compileDirectTacTranslationWith: self
            }.
        }.

        patchedFunctionDefinitionList do: {:(FunctionDefinition)eachFunctionDefinition :: Void |
            let ssaFunctionDefinition := ssaModule getGlobalValueFor: eachFunctionDefinition.
            let patch := MIRFunctionDefinitionPatch new
                functionDefinition: eachFunctionDefinition;
                yourself.

            ssaFunctionDefinition isCaptureless ifTrue: {
                patch uncheckedCapturelessEntryPoint: (self translateCapturelessUncheckedFunctionEntryPoint: ssaFunctionDefinition).
            }.

            patch uncheckedEntryPoint: (self translateUncheckedFunctionEntryPointOrNil: ssaFunctionDefinition).
            patch checkedEntryPoint: (self translateCheckedFunctionEntryPointOrNil: ssaFunctionDefinition).
            targetModule functionDefinitionPatches add: patch.
        }.

        ## Return the target module.
        targetModule
    }.

    public method compileHIRModule: (module: HIRModule) ::=> MIRModule
        := self compileHIRModule: module patchingFunctions: #() definitions: #().

    public method finish => MIRModule
        := targetModule.

    public method compileDirectFunction: (function: HIRFunction) ::=> Void := {
        (function isTargetDefinedPrimitive && function exportedSymbols isEmpty) ifTrue: {return: void}.

        function definition ifNotNil: {
            function isCaptureless ifTrue: {
                (self translateCapturelessUncheckedFunctionEntryPoint: function definition)
                    addExportedSymbols: function exportedSymbols
            } ifFalse: {
                function exportedSymbols isNotEmpty ifTrue: {
                    self error: "TODO: Compile non-captureless exported function."
                }
            }.
        }
    }.

    public method compileDirectFunctionDefinition: (functionDefinition: HIRFunctionDefinition) ::=> Void := {
        functionDefinition isTargetDefinedPrimitive ifTrue: {return: void}.

        functionDefinition isCaptureless ifTrue: {
            self translateCapturelessUncheckedFunctionEntryPoint: functionDefinition
        } ifFalse: {
            self translateUncheckedFunctionEntryPointOrNil: functionDefinition
        }
    }.

    public method translateValue: (value: HIRValue) ::=> MIRValue
        := globalValueDictionary at: value ifAbsent: {|
        value translateIntoTacValueWith: self
    }.

    public method translateFunction: (function: HIRFunction) ::=> MIRValue
        := globalValueDictionary at: function ifAbsentPut: {|
            self compileFunction: function
        }.

    public method translateFunctionDefinition: (functionDefinition: HIRFunctionDefinition) ::=> MIRValue
        := globalValueDictionary at: functionDefinition ifAbsentPut: {|
            self compileFunctionDefinition: functionDefinition
        }.

    public method compileFunction: (function: HIRFunction) ::=> MIRValue := {
        let functionObject := MIRGlobalVariable new
            type: Function;
            name: function name;
            yourself.
        targetModule addProgramEntity: functionObject.
        globalValueDictionary at: function put: functionObject.

        functionObject
    }.

    public method compileFunctionDefinition: (functionDefinition: HIRFunctionDefinition) ::=> MIRValue := {
        let functionDefinitionObject := MIRGlobalVariable new
            type: FunctionDefinition;
            name: functionDefinition name;
            yourself.
        targetModule addProgramEntity: functionDefinitionObject.
        globalValueDictionary at: functionDefinition put: functionDefinitionObject.

        functionDefinitionObject
    }.

    public method compileCapturelessUncheckedFunctionEntryPoint: (functionDefinition: HIRFunctionDefinition) ::=> MIRProgramEntity := {
        let importedSymbols := functionDefinition importedSymbols.
        importedSymbols isEmpty ifTrue: {
            let entryPoint := MIRFunction new
                compilationTarget: compilationTarget;
                callingConvention: compilationTarget defaultCallingConvention;
                name: functionDefinition name asCapturelessUncheckedEntryPointNameSymbol;
                debugSourcePosition: functionDefinition sourcePosition;
                debugSourceNode: functionDefinition sourceASTNode;
                debugSourceEnvironment: functionDefinition sourceEnvironment;
                sourceProgramEntity: functionDefinition sourceObject;
                yourself.
            targetModule addProgramEntity: entryPoint.
            capturelessUncheckedEntryPointDictionary at: functionDefinition put: entryPoint.

            HIRFunctionDefinitionMIRCodeGenerator new
                moduleCodeGenerator: self;
                compileHIRFunctionDefinition: functionDefinition intoCapturelessEntryPoint: entryPoint.

            entryPoint
        } ifFalse: {
            let importedEntity := MIRImportedFunction new
                name: importedSymbols first;
                compilationTarget: compilationTarget;
                callingConvention: compilationTarget defaultCallingConvention;
                alternativeSymbols: importedSymbols;
                yourself.
            targetModule addProgramEntity: importedEntity.
            capturelessUncheckedEntryPointDictionary at: functionDefinition put: importedEntity.

            importedEntity
        }.
    }.

    public method compileUncheckedFunctionEntryPoint: (functionDefinition: HIRFunctionDefinition) ::=> MIRProgramEntity := {
        let entryPoint := MIRFunction new
            compilationTarget: compilationTarget;
            callingConvention: compilationTarget defaultCallingConvention;
            name: functionDefinition name asUncheckedEntryPointNameSymbol;
            debugSourcePosition: functionDefinition sourcePosition;
            debugSourceNode: functionDefinition sourceASTNode;
            debugSourceEnvironment: functionDefinition sourceEnvironment;
            sourceProgramEntity: functionDefinition sourceObject;
            yourself.
        targetModule addProgramEntity: entryPoint.
        uncheckedEntryPointDictionary at: functionDefinition put: entryPoint.

        functionDefinition isCaptureless ifTrue: {
            HIRFunctionDefinitionMIRCodeGenerator new
                moduleCodeGenerator: self;
                compileHIRFunctionDefinition: functionDefinition
                    uncheckedEntryPoint: entryPoint
                    into: (self translateCapturelessUncheckedFunctionEntryPoint: functionDefinition)
        } ifFalse: {
            HIRFunctionDefinitionMIRCodeGenerator new
                moduleCodeGenerator: self;
                compileHIRFunctionDefinition: functionDefinition intoUncheckedEntryPoint: entryPoint.
        }.

        entryPoint
    }.

    public method compileCheckedFunctionEntryPoint: (functionDefinition: HIRFunctionDefinition) ::=> MIRProgramEntity := {
        let entryPoint := MIRFunction new
            compilationTarget: compilationTarget;
            callingConvention: compilationTarget defaultCallingConvention;
            name: functionDefinition name asCheckedEntryPointNameSymbol;
            debugSourcePosition: functionDefinition sourcePosition;
            debugSourceNode: functionDefinition sourceASTNode;
            debugSourceEnvironment: functionDefinition sourceEnvironment;
            sourceProgramEntity: functionDefinition sourceObject;
            yourself.
        targetModule addProgramEntity: entryPoint.
        checkedEntryPointDictionary at: functionDefinition put: entryPoint.

        HIRFunctionDefinitionMIRCodeGenerator new
            moduleCodeGenerator: self;
            compileHIRFunctionDefinition: functionDefinition checkedEntryPoint: entryPoint
            into: (functionDefinition isCaptureless
                    ifTrue: (self translateCapturelessUncheckedFunctionEntryPoint: functionDefinition)
                    ifFalse: (self translateUncheckedFunctionEntryPointOrNil: functionDefinition)
                ) isCaptureless: functionDefinition isCaptureless.

        entryPoint
    }.

    public method getOrCreateUncheckedInterpreterTrampolineWithSignature: (signature: Array) ::=> MIRProgramEntity := {
        uncheckedInterpreterTrampolinesDictionary at: signature ifAbsent: {|
            let nameBuilder := StringStream new.
            nameBuilder nextPutAll: "uncheckedInterpreterTrampoline"; print: signature size; nextPutAll: ".SUIT".
            signature hash printHexOn: nameBuilder.

            let trampoline := MIRFunction new
                compilationTarget: compilationTarget;
                callingConvention: compilationTarget defaultCallingConvention;
                name: nameBuilder asSymbol;
                yourself.
            targetModule addProgramEntity: trampoline.
            uncheckedInterpreterTrampolinesDictionary at: signature put: trampoline.

            HIRFunctionDefinitionMIRCodeGenerator new
                moduleCodeGenerator: self;
                compileUncheckedInterpreterTrampolineWithSignature: signature into: trampoline.

            trampoline
        }.
    }.

    public method setValue: (value: HIRValue) translationInto: (tacValue: MIRValue) ::=> MIRValue := {
        globalValueDictionary at: value put: tacValue.
        tacValue
    }.

    public method shouldCompileFunctionDefinition: (definition: HIRFunctionDefinition) ::=> Boolean
        := definition ~~ nil.

    public method translateCapturelessUncheckedFunctionEntryPoint: (value: HIRValue) ::=> MIRProgramEntity := {
        let functionDefinition := value asHIRFunctionDefinitionOrNil.
        functionDefinition ifNil: {
            self error: "Cannot generate captureless unchecked entry point for function without a definition " -- value printString
        }.

        capturelessUncheckedEntryPointDictionary at: functionDefinition ifAbsent: {:: MIRProgramEntity |
            self compileCapturelessUncheckedFunctionEntryPoint: functionDefinition
        }
    }.

    public method translateUncheckedFunctionEntryPointOrNil: (value: HIRValue) ::=> MIRProgramEntity := {
        let functionDefinition := value asHIRFunctionDefinitionOrNil.
        (self shouldCompileFunctionDefinition: functionDefinition) ifTrue: {
            uncheckedEntryPointDictionary at: functionDefinition ifAbsent: {:: MIRProgramEntity |
                self compileUncheckedFunctionEntryPoint: functionDefinition
            }
        } ifFalse: {
            nil
        }
    }.

    public method translateCheckedFunctionEntryPointOrNil: (value: HIRValue) ::=> MIRProgramEntity := {
        let functionDefinition := value asHIRFunctionDefinitionOrNil.
        (self shouldCompileFunctionDefinition: functionDefinition) ifTrue: {
            checkedEntryPointDictionary at: functionDefinition ifAbsent: {:: MIRProgramEntity |
                self compileCheckedFunctionEntryPoint: functionDefinition
            }
        } ifFalse: {
            nil
        }
    }.

    public method translateCheckedFunctionEntryPoint: (value: HIRValue) argumentCount: (argumentCount: Size)::=> MIRProgramEntity := {
        let functionDefinition := value asHIRFunctionDefinitionOrNil.
        (self shouldCompileFunctionDefinition: functionDefinition) && functionDefinition requiresArgumentExpansionDuringApplication not ifTrue: {
            checkedEntryPointDictionary at: functionDefinition ifAbsent: {:: MIRProgramEntity |
                self compileCheckedFunctionEntryPoint: functionDefinition
            }
        } ifFalse: {
            argumentCount < ObjectModel::CheckedFunctionApplicationTrampolines size ifTrue: {
                self translateRuntimeFunction: (ObjectModel::CheckedFunctionApplicationTrampolines at: argumentCount)
            } ifFalse: {
                nil
            }.
        }
    }.

    public method translateRuntimeFunction: (function: Function) ::=> MIRProgramEntity := {
        runtimeFunctionDictionary at: function ifAbsentPut: {:MIRProgramEntity |
            let ssaRuntimeFunction := ssaModule getGlobalValueOrNilFor: function.
            ssaRuntimeFunction ifNotNil: {
                self translateCapturelessUncheckedFunctionEntryPoint: ssaRuntimeFunction
            } ifNil: {
                importRuntimeFunction ifTrue: {
                    let importedRuntimeFunction := MIRImportedFunction new
                        name: function definition capturelessUncheckedEntryPointNameSymbol;
                        compilationTarget: compilationTarget;
                        callingConvention: compilationTarget defaultCallingConvention;
                        yourself.
                    targetModule addProgramEntity: importedRuntimeFunction.
                    importedRuntimeFunction
                } ifFalse: {
                    runtimeFunctionCompilerFrontend ifNil: {
                        runtimeFunctionCompilerFrontend := HIRModuleCompilationContext forTarget: compilationTarget asHIRCompilationTarget.
                        runtimeFunctionCompilerFrontend addUsedModule: ssaModule.
                    }.
                    self translateCapturelessUncheckedFunctionEntryPoint: (runtimeFunctionCompilerFrontend translateFunction: function)
                }.
            }.
        }.
    }.

    public method translateGenericObjectPointer: (object: Untyped) ::=> MIRValue := {
        (compilationTarget objectModel isImmediateReference: object) ifTrue: {
            compilationTarget objectModel tacImmediateReferenceFor: object 
        } ifFalse: {
            MIRGenericObjectPointerConstant new
                size: compilationTarget pointerSize;
                alignment: compilationTarget pointerAlignment;
                object: object;
                type: compilationTarget uintPointerType;
                yourself
        }.
    }.

    public method translateStructureConstant: (structure: AnyValue) ::=> MIRValue := {
        let structureType := structure __type__.
        MIRStructureConstant new
            value: structure;
            size: structureType validInstanceSize;
            alignment: structureType validInstanceAlignment;
            type: structureType;
            yourself.
    }.

    public method translateCStringConstant: (string: String) ::=> MIRValue
        := MIRStringLiteralPointerConstant new
            size: compilationTarget pointerSize;
            alignment: compilationTarget pointerAlignment;
            string: string;
            type: compilationTarget uintPointerType;
            nullTerminated: true;
            yourself.
}.

public final class HIRFunctionDefinitionMIRCodeGenerator superclass: HIRMIRCodeGenerator; definition: {
    public field moduleCodeGenerator => HIRModuleMIRCodeGenerator.
    public field ssaFunctionDefinition => HIRFunctionDefinition.
    public field tacFunction => MIRFunction.
    public field functionBuilder => MIRFunctionBuilder.
    public field blockBuilder => MIRBlockBuilder.
    protected field isCapturelessEntryPoint => Boolean.
    protected field valueDictionary => Dictionary.
    public field localOnlyAllocaDictionary => Dictionary.
    public field functionArgument => MIRValue.
    protected field boxedValueDictionary => Dictionary.

    public override method initialize => Void := {
        valueDictionary := Dictionary new.
        localOnlyAllocaDictionary := Dictionary new.
    }.

    public method compilationTarget => MIRCompilationTarget
        := moduleCodeGenerator compilationTarget.

    public method compileHIRFunctionDefinition: (ssaFunctionDefinition: HIRFunctionDefinition) intoCapturelessEntryPoint: (entryPoint: MIRFunction) ::=> Void := {
        self ssaFunctionDefinition: ssaFunctionDefinition.
        isCapturelessEntryPoint := true.

        entryPoint build: {:(MIRFunctionBuilder)functionBuilder :: Void |
            tacFunction := functionBuilder function.
            self functionBuilder: functionBuilder.
            moduleCodeGenerator capturelessUncheckedEntryPointDictionary at: ssaFunctionDefinition put: tacFunction.

            self compileDefinition.

            tacFunction
        }.
    }.

    public method compileHIRFunctionDefinition: (ssaFunctionDefinition: HIRFunctionDefinition) intoUncheckedEntryPoint: (entryPoint: MIRFunction) ::=> Void := {
        self ssaFunctionDefinition: ssaFunctionDefinition.
        isCapturelessEntryPoint := false.

        entryPoint build: {:(MIRFunctionBuilder)functionBuilder :: Void |
            tacFunction := functionBuilder function.
            self functionBuilder: functionBuilder.
            moduleCodeGenerator uncheckedEntryPointDictionary at: ssaFunctionDefinition put: tacFunction.

            self compileDefinition.

            tacFunction
        }.
    }.

    public method compileFunction: (ssaFunction: HIRFunction) exportedEntryPoint: (exportedEntryPoint: MIRFunction) into: (uncheckedEntryPoint: MIRValue) ::=> Void := {
        let arguments := ssaFunction definition arguments collect: {:(HIRFunctionArgument)argument :: MIRValue |
            exportedEntryPoint newArgument: argument name withType: argument type sourceBinding: argument sourceBinding.
        }.

        exportedEntryPoint arguments: arguments.

        exportedEntryPoint build: {:(MIRFunctionBuilder)functionBuilder :: Void |
            self functionBuilder: functionBuilder.
            functionBuilder basicBlock: #trampoline build: {:(MIRBlockBuilder)asm :: Void |
                let closure := self translateValue: ssaFunction.
                let callArguments := (Array with: closure) -- arguments.

                let canonicalResultType := ssaFunction definition functionType canonicalResultType.
                let result := canonicalResultType makeTacTemporaryValueNamed: #result withFunctionBuilder: functionBuilder.
                canonicalResultType emitTacCall: uncheckedEntryPoint convention: moduleCodeGenerator compilationTarget defaultCallingConvention
                    withArguments: callArguments into: result withBlockBuilder: asm.

                canonicalResultType emitTacReturn: result withBlockBuilder: asm
            }.
        }.
    }.

    public method compileHIRFunctionDefinition: (ssaFunctionDefinition: HIRFunctionDefinition) uncheckedEntryPoint: (uncheckedEntryPoint: MIRFunction) into: (capturelessEntryPoint: MIRProgramEntity) ::=> Void := {
        let tacArguments := OrderedCollection new.
        functionArgument := uncheckedEntryPoint newArgument: #closure withType: Function.
        tacArguments add: functionArgument.

        let calledArguments := ssaFunctionDefinition arguments collect: {:(HIRFunctionArgument)argument :: MIRValue |
            let tacArgument := uncheckedEntryPoint newArgument: argument name withType: argument type sourceBinding: argument sourceBinding.
            tacArguments add: tacArgument.
            tacArgument
        }.
        uncheckedEntryPoint arguments: tacArguments asArray.
        uncheckedEntryPoint trampolineTarget: capturelessEntryPoint.

        uncheckedEntryPoint build: {:(MIRFunctionBuilder)functionBuilder :: Void |
            tacFunction := functionBuilder function.
            self functionBuilder: functionBuilder.

            functionBuilder basicBlock: #wrapper build: {:(MIRBlockBuilder)asm :: Void |
                let canonicalResultType := ssaFunctionDefinition functionType canonicalResultType.
                let result := canonicalResultType makeTacTemporaryValueNamed: #result withFunctionBuilder: functionBuilder.

                canonicalResultType emitTacCall: capturelessEntryPoint convention: capturelessEntryPoint callingConvention
                    withArguments: calledArguments into: result withBlockBuilder: asm.

                canonicalResultType emitTacReturn: result withBlockBuilder: asm.
            }.
        }
    }.

    public method compileHIRFunctionDefinition: (ssaFunctionDefinition: HIRFunctionDefinition) checkedEntryPoint: (checkedEntryPoint: MIRFunction) into: (uncheckedEntryPoint: MIRProgramEntity) isCaptureless: (isCaptureless: Boolean) ::=> Void := {
        let tacArguments := OrderedCollection new.
        functionArgument := checkedEntryPoint newArgument: #closure withType: Function.
        tacArguments add: functionArgument.

        let uncheckedArguments := ssaFunctionDefinition arguments collect: {:(HIRFunctionArgument)argument :: MIRValue |
            let tacArgument := checkedEntryPoint newArgument: argument name withType: Untyped sourceBinding: argument sourceBinding.
            tacArguments add: tacArgument.
            tacArgument
        }.

        checkedEntryPoint arguments: tacArguments asArray.
        checkedEntryPoint trampolineTarget: uncheckedEntryPoint.

        checkedEntryPoint build: {:(MIRFunctionBuilder)functionBuilder :: Void |
            tacFunction := functionBuilder function.
            self functionBuilder: functionBuilder.

            functionBuilder basicBlock: #wrapper build: {:(MIRBlockBuilder)asm :: Void |
                self blockBuilder: asm.
                let checkedAndConvertedArguments := ssaFunctionDefinition arguments collectWithIndex: {:(HIRFunctionArgument)argument :(Size)index :: MIRValue |
                    let tacArgument => MIRValue := tacArguments at: index + 1sz.
                    argument type emitTacCheckAndUnbox: tacArgument withHIRCodeGenerator: self
                }.

                let canonicalResultType := ssaFunctionDefinition functionType canonicalResultType.
                let result := canonicalResultType makeTacTemporaryValueNamed: #result withFunctionBuilder: functionBuilder.
                isCaptureless ifTrue: {
                    canonicalResultType emitTacCall: uncheckedEntryPoint convention: uncheckedEntryPoint callingConvention
                        withArguments: checkedAndConvertedArguments into: result withBlockBuilder: asm.
                } ifFalse: {
                    canonicalResultType emitTacCall: uncheckedEntryPoint convention: uncheckedEntryPoint callingConvention
                        withArguments: (Array with: functionArgument) -- checkedAndConvertedArguments into: result withBlockBuilder: asm.
                }.

                let boxedResult := canonicalResultType emitTacBox: result withHIRCodeGenerator: self.
                asm returnPointer: boxedResult
            }.
        }
    }.

    public method compileUncheckedInterpreterTrampolineWithSignature: (signature: Array) into: (trampoline: MIRFunction) ::=> Void := {
        let tacArguments := OrderedCollection new.
        functionArgument := trampoline newArgument: #closure withType: Function.
        tacArguments add: functionArgument.

        let argumentTypes := signature allButLast.
        let resultType => Type := signature last.

        let uncheckedArguments := argumentTypes collect: {:(Type)argumentType :: MIRValue |
            let tacArgument := trampoline newArgumentWithType: argumentType.
            tacArguments add: tacArgument.
            tacArgument
        }.

        trampoline arguments: tacArguments asArray.

        trampoline build: {:(MIRFunctionBuilder)functionBuilder :: Void |
            tacFunction := functionBuilder function.
            self functionBuilder: functionBuilder.

            functionBuilder basicBlock: #trampoline build: {:(MIRBlockBuilder)asm :: Void |
                self blockBuilder: asm.

                ## Allocate the boxed argument vector.
                let boxedArgumentVector := tacFunction newTemporary: #boxedArgumentVector withType: Array.
                asm callPointer: (self translateRuntimeFunction: ObjectModel::makeArrayWithSize)
                    with: (asm pointerConstantWith: uncheckedArguments size asUInt64)
                    result: boxedArgumentVector.

                ## Box the arguments and store them in the vecotr
                let headerSize := (Array objectHeaderSizeForObjectModel: self compilationTarget objectModel) asInt64.
                let pointerSize := self compilationTarget pointerSize asInt64.
                uncheckedArguments doWithIndex: {:(MIRValue)unboxedArgument :(Size)index :: Void |
                    let argumentType := argumentTypes at: index.
                    let boxedArgument := argumentType emitTacBox: unboxedArgument withHIRCodeGenerator: self.
                    asm storePointer: boxedArgument into: boxedArgumentVector constantOffset: headerSize + (index asInt64 * pointerSize)
                }.

                ## Call the interpreter.
                let boxedResult := tacFunction newTemporary: #boxedResult withType: Untyped.
                asm callPointer: (self translateRuntimeFunction: ObjectModel::interpretFunctionWithArguments)
                    with: functionArgument with: boxedArgumentVector result: boxedResult.

                ## Unbox and store the result.
                let unboxedResult := resultType emitTacCheckAndUnbox: boxedResult withHIRCodeGenerator: self.
                resultType emitTacReturn: unboxedResult withBlockBuilder: asm.
            }
        }
    }.

    public method compileDefinition => Void := {
        ssaFunctionDefinition importedSymbols size > 0sz ifTrue: {
            return: void.
        }.

        ## HIR must be destroyed before compiling.
        HIRDestroyHIRFunctionPass runInFunctionDefinition: ssaFunctionDefinition.

        self declareArguments.

        self compilePrimitiveFunctionBody ifFalse: {
            self
                declareCaptures;
                declareValues;
                compileBasicBlocks.
        }.

        tacFunction performBasicOptimizations.
    }.

    public method declareArguments => Void := {
        let tacArguments := OrderedCollection new.
        isCapturelessEntryPoint ifFalse: {
            functionArgument := tacFunction newArgument: #closure withType: Function.
            tacArguments add: functionArgument.
        }.
        
        ssaFunctionDefinition arguments do: {:(HIRFunctionArgument)argument :: Void |
            let tacArgument := tacFunction newArgument: argument name withType: argument type sourceBinding: argument sourceBinding.
            valueDictionary at: argument put: tacArgument.
            tacArguments add: tacArgument.
        }.

        tacFunction arguments: tacArguments asArray.
    }.

    public method directArguments => Array
        := isCapturelessEntryPoint
            ifTrue: tacFunction arguments
            ifFalse: tacFunction arguments allButFirst.

    public method declareCaptures => Void := {
        let tacCaptures := OrderedCollection new.
        ssaFunctionDefinition captures do: {:(HIRFunctionCapture)capture :: Void |
            let tacCapture := tacFunction newCapture: capture name withType: capture type.
            valueDictionary at: capture put: tacCapture.
            tacCaptures add: tacCapture.
        }.

        tacFunction
            captures: tacCaptures asArray;
            computeCaptureVectorLayout
    }.

    public method declareValues => Void := {
        ssaFunctionDefinition basicBlocksDo: {:(HIRBasicBlock)eachBlock :: Void |
            let tacBlock := MIRBasicBlock new
                name: eachBlock name;
                debugSourcePosition: eachBlock sourcePosition;
                debugSourceNode: eachBlock sourceASTNode;
                debugSourceEnvironment: eachBlock sourceEnvironment;
                yourself.

            tacFunction addBasicBlock: tacBlock.
            valueDictionary at: eachBlock put: tacBlock.

            eachBlock instructionsDo: {:(HIRInstruction)each :: Void |
                functionBuilder useDebugInfoOfHIRValue: each.
                let tacValue := each makeTacValueForResultWith: self.
                valueDictionary at: each put: tacValue.
            }
        }
    }.

    public method compileBasicBlocks => Void := {
        ssaFunctionDefinition basicBlocksDo: {:(HIRBasicBlock)eachBlock :: Void |
            let tacBlock := valueDictionary at: eachBlock.
            self compileBasicBlock: eachBlock into: tacBlock
        }.
    }.

    public method compileBasicBlock: (ssaBasicBlock: HIRBasicBlock) into: (tacBlock: MIRBasicBlock) ::=> Void := {
        blockBuilder := MIRBlockBuilder new
            block: tacBlock;
            function: tacFunction;
            yourself.
        boxedValueDictionary := nil.
        ssaBasicBlock instructionsDo: {:(HIRInstruction)eachInstruction :: Void |
            functionBuilder useDebugInfoOfHIRValue: eachInstruction.
            blockBuilder useDebugInfoOfHIRValue: eachInstruction.
            eachInstruction compileIntoTacValue: (valueDictionary at: eachInstruction) with: self
        }
    }.

    public method translateValue: (value: HIRValue) ::=> MIRValue
        := valueDictionary at: value ifAbsent: {|
            moduleCodeGenerator translateValue: value
        }.
    
    public method translateBoxedValue: (value: HIRValue) ::=> MIRValue := {
        boxedValueDictionary ifNil: (boxedValueDictionary := Dictionary new).
        boxedValueDictionary at: value ifAbsentPut: {:: MIRValue |
            value isLiteralConstant ifTrue: {
                self translateValue: (value downCastTo: HIRLiteralConstant) asBoxedLiteralConstant
            } ifFalse: {
                let translatedValue := self translateValue: value.
                value type emitTacBox: translatedValue withHIRCodeGenerator: self
            }.
        }
    }.

    public method translateValue: (value: HIRValue) withExpectedType: (expectedType: Type) ::=> MIRValue := {
        value type == expectedType || (value type isValueType = expectedType isValueType) ifTrue: {
            self translateValue: value
        } ifFalse: {
            value type isValueType ifTrue: {
                self assert: value type isValueType && expectedType isValueType not.
                self translateBoxedValue: value
            } ifFalse: {
                self assert: value type isValueType not && expectedType isValueType.
                expectedType emitTacCheckAndUnbox: (self translateValue: value) withHIRCodeGenerator: self
            }
        }
    }.

    public method translateCapturelessUncheckedFunctionEntryPoint: (value: HIRValue) ::=> MIRValue
        := moduleCodeGenerator translateCapturelessUncheckedFunctionEntryPoint: value.

    public method translateUncheckedFunctionEntryPoint: (value: HIRValue) functionType: (functionType: Type) resultType: (resultType: Type) argumentCount: (argumentCount: Size) ::=> MIRValue := {
        (moduleCodeGenerator translateUncheckedFunctionEntryPointOrNil: value) ifNil: {
            let entryPoint := tacFunction newTemporary: #uncheckedEntryPoint withType: value type.
            let trampolineTypeSignature := Array new: argumentCount + 1sz.
            {
                let i mutable := 0sz.
                while: (i < argumentCount) do: {
                    trampolineTypeSignature at: i put: (functionType canonicalTypeForApplicationArgumentWithIndex: i)
                } continueWith: (i := i + 1sz).

                trampolineTypeSignature at: i put: resultType.
            }.

            let interpreterTrampoline := moduleCodeGenerator getOrCreateUncheckedInterpreterTrampolineWithSignature: trampolineTypeSignature.

            blockBuilder callPointer: (self translateRuntimeFunction: ObjectModel::fetchUncheckedEntryPointOrInterpreterTrampoline)
                with: (self translateValue: value) with: interpreterTrampoline
                result: entryPoint.
            entryPoint
        }
    }.

    public method translateCheckedFunctionEntryPoint: (value: HIRValue) argumentCount: (argumentCount: Size)::=> MIRValue
        := moduleCodeGenerator translateCheckedFunctionEntryPoint: value argumentCount: argumentCount.

    public method translateRuntimeFunction: (function: Function) ::=> MIRProgramEntity
        := moduleCodeGenerator translateRuntimeFunction: function.

    public method notYetImplementedError: (error: String) ::=> Void := {
        IgnoreNotYetImplementedErrors ifTrue: {
            blockBuilder trap
        } ifFalse: {
            self error: "HIR->MIR NotYetImplemented: " -- error
        }.
    }.

}.

MIRFunctionBuilder extend: {
    public method useDebugInfoOfHIRValue: (value: HIRValue) ::=> Void := {
        debugSourcePosition := value sourcePosition.
        debugSourceNode := value sourceASTNode.
        debugSourceEnvironment := value sourceEnvironment.
    }
}.

MIRBlockBuilder extend: {
    public method useDebugInfoOfHIRValue: (value: HIRValue) ::=> Void := {
        debugSourcePosition := value sourcePosition.
        debugSourceNode := value sourceASTNode.
        debugSourceEnvironment := value sourceEnvironment.
    }
}.

Type extend: {
    public virtual method emitTacCoerceInto: (targetType: MIRValue) thenUnbox: (value: MIRValue) into: (resultValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> Void := {
        let coerceFunction := codegen translateRuntimeFunction: (self isNullable
            ifTrue: ObjectModel::coerceNullableValue
            ifFalse: ObjectModel::coerceValue
        ).

        codegen blockBuilder
            callPointer: (codegen translateRuntimeFunction: ObjectModel::coerceValue)
            with: targetType with: value
            result: resultValue
    }.

    public virtual method emitTacCheckInto: (targetType: MIRValue) thenUnbox: (value: MIRValue) into: (resultValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> Void := {
        let typecheckFunction := codegen translateRuntimeFunction: (self isNullable
            ifTrue: ObjectModel::typecheckNullableValue
            ifFalse: ObjectModel::typecheckValue
        ).

        codegen blockBuilder
            callVoid: typecheckFunction with: targetType with: value;
            movePointer: value into: resultValue.
    }.

    public virtual method emitTacUncheckedUnbox: (value: MIRValue) into: (resultValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> Void := {
        codegen blockBuilder movePointer: value into: resultValue.
    }.

    public virtual method emitTacCheckAndUnbox: (value: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue := {
        (self == Untyped) || (self == AnyValue) ifFalse: {
            let typecheckFunction := codegen translateRuntimeFunction: (self isNullable
                ifTrue: ObjectModel::typecheckNullableValue
                ifFalse: ObjectModel::typecheckValue
            ).
            codegen blockBuilder callVoid: typecheckFunction with: (codegen moduleCodeGenerator translateGenericObjectPointer: self) with: value.
        }.

        value
    }.

    public virtual method emitTacUncheckedUnbox: (value: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue
        := value.

    public virtual method emitTacCheckThenUnbox: (value: MIRValue) into: (resultValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> Void := {
        (self == Untyped) || (self == AnyValue) ifFalse: {
            let typecheckFunction := codegen translateRuntimeFunction: (self isNullable
                ifTrue: ObjectModel::typecheckNullableValue
                ifFalse: ObjectModel::typecheckValue
            ).
            codegen blockBuilder callVoid: typecheckFunction with: (codegen moduleCodeGenerator translateGenericObjectPointer: self) with: value.
        }.

        codegen blockBuilder movePointer: value into: resultValue
    }.

    public virtual method emitTacBox: (value: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue := {
        value
    }.

    public virtual method emitTacReturn: (value: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> Void := {
        builder returnPointer: value.
    }.

    public virtual method emitTacCall: (function: MIRValue) convention: (callingConvention: MIRCallingConvention) withArguments: (arguments: Array) into: (result: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> Void := {
        builder callPointer: function convention: callingConvention arguments: arguments result: result
    }.

    public virtual method emitTacUnboxingCall: (function: MIRValue) convention: (callingConvention: MIRCallingConvention) withArguments: (arguments: Array) into: (result: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> Void := {
        (self == Untyped) || (self == AnyValue) ifTrue: {
            codegen blockBuilder callPointer: function convention: callingConvention arguments: arguments result: result.
            return: void.
        }.

        let typecheckFunction := codegen translateRuntimeFunction: (self isNullable
            ifTrue: ObjectModel::typecheckNullableValue
            ifFalse: ObjectModel::typecheckValue
        ).

        codegen blockBuilder
            callPointer: function convention: callingConvention arguments: arguments result: result;
            callVoid: typecheckFunction with: (codegen moduleCodeGenerator translateGenericObjectPointer: self) with: result
    }.

    public abstract method emitTacReference: (reference: MIRValue) elementPointerAt: (elementIndex: MIRValue) into: (elementPointer: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> Void
        := self subclassResponsibility.


    public virtual method makeTacTemporaryValueNamed: (name: Symbol) withFunctionBuilder: (functionBuilder: MIRFunctionBuilder) ::=> MIRValue
        := functionBuilder newTemporary: name withType: self.

    public virtual method translateHIRLiteralConstant: (constant: HIRLiteralConstant) intoTacWith: (codegen: HIRModuleMIRCodeGenerator) ::=> MIRValue
        := codegen translateGenericObjectPointer: constant value.

    public virtual method translateUndefinedConstant: (constant: HIRUndefinedConstant) intoTacWith: (codegen: HIRModuleMIRCodeGenerator) ::=> MIRValue
        := codegen compilationTarget pointerSize = 4sz ifTrue: 0u32 asTacConstant ifFalse: 0u64 asTacConstant.

    public virtual method translateHIRLiteralConstant: (constant: HIRLiteralConstant) pointerType: (pointerType: PointerLikeType) storage: storage base: base offset: (offset: IntPointer) intoTacWith: (codegen: HIRModuleMIRCodeGenerator) ::=> MIRValue
        := codegen translateGenericObjectPointer: constant value.

    public virtual method emitTacMove: (sourceValue: MIRValue) into: (targetValue: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> Void := {
        builder movePointer: sourceValue into: targetValue
    }.

    public virtual method emitTacLoadFromPointer: (pointer: MIRValue) constantOffset: (constantOffset: Int64) into: (result: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> Void := {
        builder loadPointer: pointer constantOffset: constantOffset into: result
    }.

    public virtual method emitTacStore: (value: MIRValue) intoPointer: (pointer: MIRValue) constantOffset: (constantOffset: Int64) withBlockBuilder: (builder: MIRBlockBuilder) ::=> Void := {
        builder storePointer: value into: pointer constantOffset: constantOffset
    }.

    public virtual method emitTacEquals: (left: MIRValue) with: (right: MIRValue) into: (result: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder)  ::=> Void := {
        builder pointerEquals: left with: right into: result
    }.

    public virtual method emitTacNotEquals: (left: MIRValue) with: (right: MIRValue) into: (result: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder)  ::=> Void := {
        builder pointerNotEquals: left with: right into: result
    }.
}.

ObjectModelVariant extend: {
    public abstract method tacImmediateReferenceFor: (object: Untyped) ::=> MIRValue
        := self subclassResponsibility.
}.

ObjectModelVariant32 extend: {
    public override method tacImmediateReferenceFor: (object: Untyped) ::=> MIRValue
        := (RawTuple::type(object) encodeImmediateReference32: object) asTacConstant.
}.

ObjectModelVariant64 extend: {
    public override method tacImmediateReferenceFor: (object: Untyped) ::=> MIRValue
        := (RawTuple::type(object) encodeImmediateReference64: object) asTacConstant.
}.

String class extend: {
    public override method translateHIRLiteralConstant: (constant: HIRLiteralConstant) pointerType: (pointerType: PointerLikeType) storage: storage base: base offset: (offset: IntPointer) intoTacWith: (codegen: HIRModuleMIRCodeGenerator) ::=> MIRValue := {
        if: (pointerType baseType == Char8 const) && (base == nil) && (offset = 0iptr) then: {
            codegen translateCStringConstant: storage
        } else: {
            super translateHIRLiteralConstant: constant pointerType: pointerType storage: storage base: base offset: offset intoTacWith: codegen
        }.
    }.
}.

ValueType extend: {
    public override method emitTacCoerceInto: (targetType: MIRValue) thenUnbox: (value: MIRValue) into: (resultValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> Void := {
        self emitTacCheckInto: targetType thenUnbox: value into: resultValue withHIRCodeGenerator: codegen
    }.

    public override method emitTacCheckInto: (targetType: MIRValue) thenUnbox: (value: MIRValue) into: (resultValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> Void := {
        let typecheckFunction := codegen translateRuntimeFunction: (self isNullable
            ifTrue: ObjectModel::typecheckNullableValue
            ifFalse: ObjectModel::typecheckValue
        ).

        codegen blockBuilder callVoid: typecheckFunction with: targetType with: value.
        self emitTacCheckThenUnbox: value into: resultValue withHIRCodeGenerator: codegen.
    }.

    public override method emitTacCheckThenUnbox: (value: MIRValue) into: (resultValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> Void := {
        ## TODO: Implement this via some kind of memcpy for the generic case.
        codegen notYetImplementedError: "Generic value type unbox"
    }.

    public override method emitTacUncheckedUnbox: (value: MIRValue) into: (resultValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> Void := {
        ## TODO: Implement this via some kind of memcpy for the generic case.
        codegen notYetImplementedError: "Generic value type unbox"
    }.

    public override method emitTacCheckAndUnbox: (value: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue := {
        let unboxedTemporary := codegen blockBuilder function newTemporary: #unboxed withType: self.
        self emitTacCheckThenUnbox: value into: unboxedTemporary withHIRCodeGenerator: codegen.
        unboxedTemporary.
    }.
    
    public override method emitTacUncheckedUnbox: (value: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue := {
        let unboxedTemporary := codegen blockBuilder function newTemporary: #unboxed withType: self.
        self emitTacUncheckedUnbox: value into: unboxedTemporary withHIRCodeGenerator: codegen.
        unboxedTemporary.
    }.

    public virtual method emitTacBox: (value: MIRValue) into: (boxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> Void := {
        ## TODO: Implement this via some kind of memcpy.
        codegen notYetImplementedError: "Generic value type box"
    }.

    public override method emitTacBox: (value: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue := {
        let boxedTemporary := codegen blockBuilder function newTemporary: #boxed withType: Untyped.
        self emitTacBox: value into: boxedTemporary withHIRCodeGenerator: codegen.
        boxedTemporary.
    }.

    public override method emitTacCall: (function: MIRValue) convention: (callingConvention: MIRCallingConvention) withArguments: (arguments: Array) into: (result: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> Void := {
        builder callStruct: function convention: callingConvention arguments: arguments result: result
    }.

    public override method emitTacUnboxingCall: (function: MIRValue) convention: (callingConvention: MIRCallingConvention) withArguments: (arguments: Array) into: (result: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> Void := {
        let boxedTemporary := codegen blockBuilder function newTemporary: #boxed withType: Untyped.
        codegen blockBuilder callPointer: function convention: callingConvention arguments: arguments result: boxedTemporary.
        self emitTacCheckThenUnbox: boxedTemporary into: result withHIRCodeGenerator: codegen
    }.

    public override method emitTacReturn: (value: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> Void := {
        builder returnStruct: value
    }.

    public override method emitTacMove: (sourceValue: MIRValue) into: (targetValue: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> Void := {
        builder moveStruct: sourceValue into: targetValue
    }.

    public override method emitTacLoadFromPointer: (pointer: MIRValue) constantOffset: (constantOffset: Int64) into: (result: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> Void := {
        builder loadStruct: pointer constantOffset: constantOffset into: result
    }.

    public override method emitTacStore: (value: MIRValue) intoPointer: (pointer: MIRValue) constantOffset: (constantOffset: Int64) withBlockBuilder: (builder: MIRBlockBuilder) ::=> Void := {
        builder storeStruct: value into: pointer constantOffset: constantOffset
    }.

    #*public override method translateHIRLiteralConstant: (constant: HIRLiteralConstant) intoTacWith: (codegen: HIRModuleMIRCodeGenerator) ::=> MIRValue
        := codegen translateStructureConstant: constant value.*#

    public virtual method emitTacEquals: (left: MIRValue) with: (right: MIRValue) into: (result: MIRValue) ::=> Void := {
        self subclassResponsibility
    }.

    public virtual method emitTacNotEquals: (left: MIRValue) with: (right: MIRValue) into: (result: MIRValue) ::=> Void := {
        self subclassResponsibility
    }.

}.

PointerLikeType extend: {
    public override method translateHIRLiteralConstant: (constant: HIRLiteralConstant) intoTacWith: (codegen: HIRModuleMIRCodeGenerator) ::=> MIRValue := {
        let value => Untyped := constant value.
        let isBytes := RawTuple::isBytes(value).
        let pointerSize => Size := RawTuple::size(value).

        if: isBytes then: {
            self error: "TODO: Translate pointer integer value."
        } else: {
            let storage := (if: pointerSize >= 1sz then: (RawTuple::slotAt:)(value, 0sz) else: nil).
            let base := (if: pointerSize >= 2sz then: (RawTuple::slotAt:)(value, 1sz) else: nil).
            let offset := (if: pointerSize >= 3sz then: (RawTuple::slotAt:)(value, 2sz) else: 0iptr).
            storage __type__ translateHIRLiteralConstant: constant pointerType: self storage: storage base: base offset: offset intoTacWith: codegen
        }
    }.

    public virtual method emitTacCheckThenUnbox: (boxedValue: MIRValue) into: (unboxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> Void := {
        codegen blockBuilder
            callPointer: (codegen translateRuntimeFunction: ObjectModel::checkAndUnboxPointer)
            with: (codegen moduleCodeGenerator translateGenericObjectPointer: self) with: boxedValue result: unboxedValue
    }.

    public virtual method emitTacBox: (unboxedValue: MIRValue) into: (boxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> Void := {
        codegen blockBuilder
            callPointer: (codegen translateRuntimeFunction: ObjectModel::boxPointer)
            with: (codegen moduleCodeGenerator translateGenericObjectPointer: self) with: unboxedValue result: boxedValue
    }.

    public override method emitTacCall: (function: MIRValue) convention: (callingConvention: MIRCallingConvention) withArguments: (arguments: Array) into: (result: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> Void := {
        builder callPointer: function convention: callingConvention arguments: arguments result: result
    }.

    public override method emitTacReturn: (value: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> Void := {
        builder returnPointer: value
    }.

    public override method emitTacMove: (sourceValue: MIRValue) into: (targetValue: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> Void := {
        builder movePointer: sourceValue into: targetValue
    }.

    public override method emitTacLoadFromPointer: (pointer: MIRValue) constantOffset: (constantOffset: Int64) into: (result: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> Void := {
        builder loadPointer: pointer constantOffset: constantOffset into: result
    }.

    public override method emitTacStore: (value: MIRValue) intoPointer: (pointer: MIRValue) constantOffset: (constantOffset: Int64) withBlockBuilder: (builder: MIRBlockBuilder) ::=> Void := {
        builder storePointer: value into: pointer constantOffset: constantOffset
    }.
}.

FixedArrayType definition: {
    public override method emitTacReference: (reference: MIRValue) elementPointerAt: (elementIndex: MIRValue) into: (elementPointer: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> Void := {
        builder loadEffectiveAddress: reference index: elementIndex constantScale: elementType alignedValueSize asInt64 into: elementPointer
    }.
}.

Char8 __type__ extend: {
    public override method emitTacUncheckedUnbox: (boxedValue: MIRValue) into: (unboxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> Void := {
        codegen blockBuilder callInt8: (codegen translateRuntimeFunction: ObjectModel::unboxChar8) with: boxedValue result: unboxedValue
    }.

    public override method emitTacCheckThenUnbox: (boxedValue: MIRValue) into: (unboxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> Void := {
        codegen blockBuilder callInt8: (codegen translateRuntimeFunction: ObjectModel::checkAndUnboxChar8) with: boxedValue result: unboxedValue
    }.

    public override method emitTacBox: (unboxedValue: MIRValue) into: (boxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> Void := {
        codegen blockBuilder callPointer: (codegen translateRuntimeFunction: ObjectModel::boxChar8) with: unboxedValue result: boxedValue
    }.

    public override method emitTacCall: (function: MIRValue) convention: (callingConvention: MIRCallingConvention) withArguments: (arguments: Array) into: (result: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> Void := {
        builder callInt32: function convention: callingConvention arguments: arguments result: result
    }.

    public override method emitTacReturn: (value: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> Void := {
        builder returnInt32: value
    }.

    public override method emitTacMove: (sourceValue: MIRValue) into: (targetValue: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> Void := {
        builder moveInt8: sourceValue into: targetValue
    }.

    public override method emitTacLoadFromPointer: (pointer: MIRValue) constantOffset: (constantOffset: Int64) into: (result: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> Void := {
        builder loadUInt8: pointer constantOffset: constantOffset into: result
    }.

    public override method emitTacStore: (value: MIRValue) intoPointer: (pointer: MIRValue) constantOffset: (constantOffset: Int64) withBlockBuilder: (builder: MIRBlockBuilder) ::=> Void := {
        builder storeInt8: value into: pointer constantOffset: constantOffset
    }.

    public override method translateUndefinedConstant: (constant: HIRUndefinedConstant) intoTacWith: (codegen: HIRModuleMIRCodeGenerator) ::=> MIRValue
        := 0u8 asTacConstant.

    public override method translateHIRLiteralConstant: (constant: HIRLiteralConstant) intoTacWith: (codegen: HIRModuleMIRCodeGenerator) ::=> MIRValue
        := constant value asUInt8 asTacConstant.
}.

Int8 __type__ extend: {
    public override method emitTacUncheckedUnbox: (boxedValue: MIRValue) into: (unboxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> Void := {
        codegen blockBuilder callInt8: (codegen translateRuntimeFunction: ObjectModel::unboxInt8) with: boxedValue result: unboxedValue
    }.

    public override method emitTacCheckThenUnbox: (boxedValue: MIRValue) into: (unboxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> Void := {
        codegen blockBuilder callInt8: (codegen translateRuntimeFunction: ObjectModel::checkAndUnboxInt8) with: boxedValue result: unboxedValue
    }.

    public override method emitTacBox: (unboxedValue: MIRValue) into: (boxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> Void := {
        codegen blockBuilder callPointer: (codegen translateRuntimeFunction: ObjectModel::boxInt8) with: unboxedValue result: boxedValue
    }.

    public override method emitTacCall: (function: MIRValue) convention: (callingConvention: MIRCallingConvention) withArguments: (arguments: Array) into: (result: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> Void := {
        builder callInt8: function convention: callingConvention arguments: arguments result: result
    }.

    public override method emitTacReturn: (value: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> Void := {
        builder returnInt8: value
    }.

    public override method emitTacMove: (sourceValue: MIRValue) into: (targetValue: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> Void := {
        builder moveInt8: sourceValue into: targetValue
    }.

    public override method emitTacLoadFromPointer: (pointer: MIRValue) constantOffset: (constantOffset: Int64) into: (result: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> Void := {
        builder loadInt8: pointer constantOffset: constantOffset into: result
    }.

    public override method emitTacStore: (value: MIRValue) intoPointer: (pointer: MIRValue) constantOffset: (constantOffset: Int64) withBlockBuilder: (builder: MIRBlockBuilder) ::=> Void := {
        builder storeInt8: value into: pointer constantOffset: constantOffset
    }.

    public override method translateUndefinedConstant: (constant: HIRUndefinedConstant) intoTacWith: (codegen: HIRModuleMIRCodeGenerator) ::=> MIRValue
        := 0i8 asTacConstant.

    public override method translateHIRLiteralConstant: (constant: HIRLiteralConstant) intoTacWith: (codegen: HIRModuleMIRCodeGenerator) ::=> MIRValue
        := constant value asTacConstant.
}.

UInt8 __type__ extend: {
    public override method emitTacUncheckedUnbox: (boxedValue: MIRValue) into: (unboxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> Void := {
        codegen blockBuilder callInt8: (codegen translateRuntimeFunction: ObjectModel::unboxUInt8) with: boxedValue result: unboxedValue
    }.

    public override method emitTacCheckThenUnbox: (boxedValue: MIRValue) into: (unboxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> Void := {
        codegen blockBuilder callInt8: (codegen translateRuntimeFunction: ObjectModel::checkAndUnboxUInt8) with: boxedValue result: unboxedValue
    }.

    public override method emitTacBox: (unboxedValue: MIRValue) into: (boxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> Void := {
        codegen blockBuilder callPointer: (codegen translateRuntimeFunction: ObjectModel::boxUInt8) with: unboxedValue result: boxedValue
    }.

    public override method emitTacCall: (function: MIRValue) convention: (callingConvention: MIRCallingConvention) withArguments: (arguments: Array) into: (result: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> Void := {
        builder callInt8: function convention: callingConvention arguments: arguments result: result
    }.

    public override method emitTacReturn: (value: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> Void := {
        builder returnInt8: value
    }.

    public override method emitTacMove: (sourceValue: MIRValue) into: (targetValue: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> Void := {
        builder moveInt8: sourceValue into: targetValue
    }.

    public override method emitTacLoadFromPointer: (pointer: MIRValue) constantOffset: (constantOffset: Int64) into: (result: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> Void := {
        builder loadUInt8: pointer constantOffset: constantOffset into: result
    }.

    public override method emitTacStore: (value: MIRValue) intoPointer: (pointer: MIRValue) constantOffset: (constantOffset: Int64) withBlockBuilder: (builder: MIRBlockBuilder) ::=> Void := {
        builder storeInt8: value into: pointer constantOffset: constantOffset
    }.

    public override method translateUndefinedConstant: (constant: HIRUndefinedConstant) intoTacWith: (codegen: HIRModuleMIRCodeGenerator) ::=> MIRValue
        := 0u8 asTacConstant.

    public override method translateHIRLiteralConstant: (constant: HIRLiteralConstant) intoTacWith: (codegen: HIRModuleMIRCodeGenerator) ::=> MIRValue
        := constant value asTacConstant.
}.

Boolean __type__ extend: {
    public override method emitTacUncheckedUnbox: (boxedValue: MIRValue) into: (unboxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> Void := {
        codegen blockBuilder callInt8: (codegen translateRuntimeFunction: ObjectModel::unboxBoolean) with: boxedValue result: unboxedValue
    }.

    public override method emitTacCheckThenUnbox: (boxedValue: MIRValue) into: (unboxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> Void := {
        codegen blockBuilder callInt8: (codegen translateRuntimeFunction: ObjectModel::checkAndUnboxBoolean) with: boxedValue result: unboxedValue
    }.

    public override method emitTacBox: (unboxedValue: MIRValue) into: (boxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> Void := {
        codegen blockBuilder callPointer: (codegen translateRuntimeFunction: ObjectModel::boxBoolean) with: unboxedValue result: boxedValue
    }.

    public override method emitTacCall: (function: MIRValue) convention: (callingConvention: MIRCallingConvention) withArguments: (arguments: Array) into: (result: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> Void := {
        builder callInt8: function convention: callingConvention arguments: arguments result: result
    }.

    public override method emitTacReturn: (value: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> Void := {
        builder returnInt8: value
    }.

    public override method emitTacMove: (sourceValue: MIRValue) into: (targetValue: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> Void := {
        builder moveInt8: sourceValue into: targetValue
    }.

    public override method emitTacLoadFromPointer: (pointer: MIRValue) constantOffset: (constantOffset: Int64) into: (result: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> Void := {
        builder loadUInt8: pointer constantOffset: constantOffset into: result
    }.

    public override method emitTacStore: (value: MIRValue) intoPointer: (pointer: MIRValue) constantOffset: (constantOffset: Int64) withBlockBuilder: (builder: MIRBlockBuilder) ::=> Void := {
        builder storeInt8: value into: pointer constantOffset: constantOffset
    }.

    public override method translateUndefinedConstant: (constant: HIRUndefinedConstant) intoTacWith: (codegen: HIRModuleMIRCodeGenerator) ::=> MIRValue
        := 0u8 asTacConstant.
}.

False __type__ extend: {
    public override method translateHIRLiteralConstant: (constant: HIRLiteralConstant) intoTacWith: (codegen: HIRModuleMIRCodeGenerator) ::=> MIRValue
        := 0u8 asTacConstant.

}.

True __type__ extend: {
    public override method translateHIRLiteralConstant: (constant: HIRLiteralConstant) intoTacWith: (codegen: HIRModuleMIRCodeGenerator) ::=> MIRValue
        := 1u8 asTacConstant.
}.

Char16 __type__ extend: {
    public override method emitTacUncheckedUnbox: (boxedValue: MIRValue) into: (unboxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> Void := {
        codegen blockBuilder callInt16: (codegen translateRuntimeFunction: ObjectModel::unboxChar16) with: boxedValue result: unboxedValue
    }.

    public override method emitTacCheckThenUnbox: (boxedValue: MIRValue) into: (unboxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> Void := {
        codegen blockBuilder callInt16: (codegen translateRuntimeFunction: ObjectModel::checkAndUnboxChar16) with: boxedValue result: unboxedValue
    }.

    public override method emitTacBox: (unboxedValue: MIRValue) into: (boxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> Void := {
        codegen blockBuilder callPointer: (codegen translateRuntimeFunction: ObjectModel::boxChar16) with: unboxedValue result: boxedValue
    }.

    public override method emitTacCall: (function: MIRValue) convention: (callingConvention: MIRCallingConvention) withArguments: (arguments: Array) into: (result: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> Void := {
        builder callInt16: function convention: callingConvention arguments: arguments result: result
    }.

    public override method emitTacReturn: (value: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> Void := {
        builder returnInt16: value
    }.

    public override method emitTacMove: (sourceValue: MIRValue) into: (targetValue: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> Void := {
        builder moveInt16: sourceValue into: targetValue
    }.

    public override method emitTacLoadFromPointer: (pointer: MIRValue) constantOffset: (constantOffset: Int64) into: (result: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> Void := {
        builder loadUInt16: pointer constantOffset: constantOffset into: result
    }.

    public override method emitTacStore: (value: MIRValue) intoPointer: (pointer: MIRValue) constantOffset: (constantOffset: Int64) withBlockBuilder: (builder: MIRBlockBuilder) ::=> Void := {
        builder storeInt16: value into: pointer constantOffset: constantOffset
    }.

    public override method translateHIRLiteralConstant: (constant: HIRLiteralConstant) intoTacWith: (codegen: HIRModuleMIRCodeGenerator) ::=> MIRValue
        := constant value asUInt16 asTacConstant.

    public override method translateUndefinedConstant: (constant: HIRUndefinedConstant) intoTacWith: (codegen: HIRModuleMIRCodeGenerator) ::=> MIRValue
        := 0u16 asTacConstant.
}.

Int16 __type__ extend: {
    public override method emitTacUncheckedUnbox: (boxedValue: MIRValue) into: (unboxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> Void := {
        codegen blockBuilder callInt16: (codegen translateRuntimeFunction: ObjectModel::unboxInt16) with: boxedValue result: unboxedValue
    }.

    public override method emitTacCheckThenUnbox: (boxedValue: MIRValue) into: (unboxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> Void := {
        codegen blockBuilder callInt16: (codegen translateRuntimeFunction: ObjectModel::checkAndUnboxInt16) with: boxedValue result: unboxedValue
    }.

    public override method emitTacBox: (unboxedValue: MIRValue) into: (boxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> Void := {
        codegen blockBuilder callPointer: (codegen translateRuntimeFunction: ObjectModel::boxInt16) with: unboxedValue result: boxedValue
    }.

    public override method emitTacCall: (function: MIRValue) convention: (callingConvention: MIRCallingConvention) withArguments: (arguments: Array) into: (result: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> Void := {
        builder callInt16: function convention: callingConvention arguments: arguments result: result
    }.

    public override method emitTacReturn: (value: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> Void := {
        builder returnInt16: value
    }.

    public override method emitTacMove: (sourceValue: MIRValue) into: (targetValue: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> Void := {
        builder moveInt16: sourceValue into: targetValue
    }.

    public override method emitTacLoadFromPointer: (pointer: MIRValue) constantOffset: (constantOffset: Int64) into: (result: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> Void := {
        builder loadInt16: pointer constantOffset: constantOffset into: result
    }.

    public override method emitTacStore: (value: MIRValue) intoPointer: (pointer: MIRValue) constantOffset: (constantOffset: Int64) withBlockBuilder: (builder: MIRBlockBuilder) ::=> Void := {
        builder storeInt16: value into: pointer constantOffset: constantOffset
    }.

    public override method translateHIRLiteralConstant: (constant: HIRLiteralConstant) intoTacWith: (codegen: HIRModuleMIRCodeGenerator) ::=> MIRValue
        := constant value asTacConstant.

    public override method translateUndefinedConstant: (constant: HIRUndefinedConstant) intoTacWith: (codegen: HIRModuleMIRCodeGenerator) ::=> MIRValue
        := 0i16 asTacConstant.
}.

UInt16 __type__ extend: {
    public override method emitTacUncheckedUnbox: (boxedValue: MIRValue) into: (unboxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> Void := {
        codegen blockBuilder callInt16: (codegen translateRuntimeFunction: ObjectModel::unboxUInt16) with: boxedValue result: unboxedValue
    }.

    public override method emitTacCheckThenUnbox: (boxedValue: MIRValue) into: (unboxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> Void := {
        codegen blockBuilder callInt16: (codegen translateRuntimeFunction: ObjectModel::checkAndUnboxUInt16) with: boxedValue result: unboxedValue
    }.

    public override method emitTacBox: (unboxedValue: MIRValue) into: (boxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> Void := {
        codegen blockBuilder callPointer: (codegen translateRuntimeFunction: ObjectModel::boxUInt16) with: unboxedValue result: boxedValue
    }.

    public override method emitTacCall: (function: MIRValue) convention: (callingConvention: MIRCallingConvention) withArguments: (arguments: Array) into: (result: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> Void := {
        builder callInt16: function convention: callingConvention arguments: arguments result: result
    }.

    public override method emitTacReturn: (value: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> Void := {
        builder returnInt16: value
    }.

    public override method emitTacMove: (sourceValue: MIRValue) into: (targetValue: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> Void := {
        builder moveInt16: sourceValue into: targetValue
    }.

    public override method emitTacLoadFromPointer: (pointer: MIRValue) constantOffset: (constantOffset: Int64) into: (result: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> Void := {
        builder loadUInt16: pointer constantOffset: constantOffset into: result
    }.

    public override method emitTacStore: (value: MIRValue) intoPointer: (pointer: MIRValue) constantOffset: (constantOffset: Int64) withBlockBuilder: (builder: MIRBlockBuilder) ::=> Void := {
        builder storeInt16: value into: pointer constantOffset: constantOffset
    }.

    public override method translateHIRLiteralConstant: (constant: HIRLiteralConstant) intoTacWith: (codegen: HIRModuleMIRCodeGenerator) ::=> MIRValue
        := constant value asTacConstant.

    public override method translateUndefinedConstant: (constant: HIRUndefinedConstant) intoTacWith: (codegen: HIRModuleMIRCodeGenerator) ::=> MIRValue
        := 0u16 asTacConstant.
}.

Char32 __type__ extend: {
    public override method emitTacUncheckedUnbox: (boxedValue: MIRValue) into: (unboxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> Void := {
        codegen blockBuilder callInt32: (codegen translateRuntimeFunction: ObjectModel::unboxChar32) with: boxedValue result: unboxedValue
    }.

    public override method emitTacCheckThenUnbox: (boxedValue: MIRValue) into: (unboxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> Void := {
        codegen blockBuilder callInt32: (codegen translateRuntimeFunction: ObjectModel::checkAndUnboxChar32) with: boxedValue result: unboxedValue
    }.

    public override method emitTacBox: (unboxedValue: MIRValue) into: (boxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> Void := {
        codegen blockBuilder callPointer: (codegen translateRuntimeFunction: ObjectModel::boxChar32) with: unboxedValue result: boxedValue
    }.

    public override method emitTacCall: (function: MIRValue) convention: (callingConvention: MIRCallingConvention) withArguments: (arguments: Array) into: (result: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> Void := {
        builder callInt32: function convention: callingConvention arguments: arguments result: result
    }.

    public override method emitTacReturn: (value: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> Void := {
        builder returnInt32: value
    }.

    public override method emitTacMove: (sourceValue: MIRValue) into: (targetValue: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> Void := {
        builder moveInt32: sourceValue into: targetValue
    }.

    public override method emitTacLoadFromPointer: (pointer: MIRValue) constantOffset: (constantOffset: Int64) into: (result: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> Void := {
        builder loadUInt32: pointer constantOffset: constantOffset into: result
    }.

    public override method emitTacStore: (value: MIRValue) intoPointer: (pointer: MIRValue) constantOffset: (constantOffset: Int64) withBlockBuilder: (builder: MIRBlockBuilder) ::=> Void := {
        builder storeInt32: value into: pointer constantOffset: constantOffset
    }.

    public override method translateHIRLiteralConstant: (constant: HIRLiteralConstant) intoTacWith: (codegen: HIRModuleMIRCodeGenerator) ::=> MIRValue
        := constant value asUInt32 asTacConstant.

    public override method translateUndefinedConstant: (constant: HIRUndefinedConstant) intoTacWith: (codegen: HIRModuleMIRCodeGenerator) ::=> MIRValue
        := 0u32 asTacConstant.
}.

Int32 __type__ extend: {
    public override method emitTacUncheckedUnbox: (boxedValue: MIRValue) into: (unboxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> Void := {
        codegen blockBuilder callInt32: (codegen translateRuntimeFunction: ObjectModel::unboxInt32) with: boxedValue result: unboxedValue
    }.

    public override method emitTacCheckThenUnbox: (boxedValue: MIRValue) into: (unboxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> Void := {
        codegen blockBuilder callInt32: (codegen translateRuntimeFunction: ObjectModel::checkAndUnboxInt32) with: boxedValue result: unboxedValue
    }.

    public override method emitTacBox: (unboxedValue: MIRValue) into: (boxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> Void := {
        codegen blockBuilder callPointer: (codegen translateRuntimeFunction: ObjectModel::boxInt32) with: unboxedValue result: boxedValue
    }.

    public override method emitTacCall: (function: MIRValue) convention: (callingConvention: MIRCallingConvention) withArguments: (arguments: Array) into: (result: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> Void := {
        builder callInt32: function convention: callingConvention arguments: arguments result: result
    }.

    public override method emitTacReturn: (value: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> Void := {
        builder returnInt32: value
    }.

    public override method emitTacMove: (sourceValue: MIRValue) into: (targetValue: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> Void := {
        builder moveInt32: sourceValue into: targetValue
    }.

    public override method emitTacLoadFromPointer: (pointer: MIRValue) constantOffset: (constantOffset: Int64) into: (result: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> Void := {
        builder loadInt32: pointer constantOffset: constantOffset into: result
    }.

    public override method emitTacStore: (value: MIRValue) intoPointer: (pointer: MIRValue) constantOffset: (constantOffset: Int64) withBlockBuilder: (builder: MIRBlockBuilder) ::=> Void := {
        builder storeInt32: value into: pointer constantOffset: constantOffset
    }.

    public override method translateHIRLiteralConstant: (constant: HIRLiteralConstant) intoTacWith: (codegen: HIRModuleMIRCodeGenerator) ::=> MIRValue
        := constant value asTacConstant.

    public override method translateUndefinedConstant: (constant: HIRUndefinedConstant) intoTacWith: (codegen: HIRModuleMIRCodeGenerator) ::=> MIRValue
        := 0i32 asTacConstant.
}.

UInt32 __type__ extend: {
    public override method emitTacUncheckedUnbox: (boxedValue: MIRValue) into: (unboxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> Void := {
        codegen blockBuilder callInt32: (codegen translateRuntimeFunction: ObjectModel::unboxUInt32) with: boxedValue result: unboxedValue
    }.

    public override method emitTacCheckThenUnbox: (boxedValue: MIRValue) into: (unboxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> Void := {
        codegen blockBuilder callInt32: (codegen translateRuntimeFunction: ObjectModel::checkAndUnboxUInt32) with: boxedValue result: unboxedValue
    }.

    public override method emitTacBox: (unboxedValue: MIRValue) into: (boxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> Void := {
        codegen blockBuilder callPointer: (codegen translateRuntimeFunction: ObjectModel::boxUInt32) with: unboxedValue result: boxedValue
    }.

    public override method emitTacCall: (function: MIRValue) convention: (callingConvention: MIRCallingConvention) withArguments: (arguments: Array) into: (result: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> Void := {
        builder callInt32: function convention: callingConvention arguments: arguments result: result
    }.

    public override method emitTacReturn: (value: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> Void := {
        builder returnInt32: value
    }.

    public override method emitTacMove: (sourceValue: MIRValue) into: (targetValue: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> Void := {
        builder moveInt32: sourceValue into: targetValue
    }.

    public override method emitTacLoadFromPointer: (pointer: MIRValue) constantOffset: (constantOffset: Int64) into: (result: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> Void := {
        builder loadUInt32: pointer constantOffset: constantOffset into: result
    }.

    public override method emitTacStore: (value: MIRValue) intoPointer: (pointer: MIRValue) constantOffset: (constantOffset: Int64) withBlockBuilder: (builder: MIRBlockBuilder) ::=> Void := {
        builder storeInt32: value into: pointer constantOffset: constantOffset
    }.

    public override method translateHIRLiteralConstant: (constant: HIRLiteralConstant) intoTacWith: (codegen: HIRModuleMIRCodeGenerator) ::=> MIRValue
        := constant value asTacConstant.

    public override method translateUndefinedConstant: (constant: HIRUndefinedConstant) intoTacWith: (codegen: HIRModuleMIRCodeGenerator) ::=> MIRValue
        := 0u32 asTacConstant.
}.

Int64 __type__ extend: {
    public override method emitTacUncheckedUnbox: (boxedValue: MIRValue) into: (unboxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> Void := {
        codegen blockBuilder callInt64: (codegen translateRuntimeFunction: ObjectModel::unboxInt64) with: boxedValue result: unboxedValue
    }.

    public override method emitTacCheckThenUnbox: (boxedValue: MIRValue) into: (unboxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> Void := {
        codegen blockBuilder callInt64: (codegen translateRuntimeFunction: ObjectModel::checkAndUnboxInt64) with: boxedValue result: unboxedValue
    }.

    public override method emitTacBox: (unboxedValue: MIRValue) into: (boxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> Void := {
        codegen blockBuilder callPointer: (codegen translateRuntimeFunction: ObjectModel::boxInt64) with: unboxedValue result: boxedValue
    }.

    public override method emitTacCall: (function: MIRValue) convention: (callingConvention: MIRCallingConvention) withArguments: (arguments: Array) into: (result: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> Void := {
        builder callInt64: function convention: callingConvention arguments: arguments result: result
    }.

    public override method emitTacReturn: (value: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> Void := {
        builder returnInt64: value
    }.

    public override method emitTacMove: (sourceValue: MIRValue) into: (targetValue: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> Void := {
        builder moveInt64: sourceValue into: targetValue
    }.

    public override method emitTacLoadFromPointer: (pointer: MIRValue) constantOffset: (constantOffset: Int64) into: (result: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> Void := {
        builder loadInt64: pointer constantOffset: constantOffset into: result
    }.

    public override method emitTacStore: (value: MIRValue) intoPointer: (pointer: MIRValue) constantOffset: (constantOffset: Int64) withBlockBuilder: (builder: MIRBlockBuilder) ::=> Void := {
        builder storeInt64: value into: pointer constantOffset: constantOffset
    }.

    public override method translateHIRLiteralConstant: (constant: HIRLiteralConstant) intoTacWith: (codegen: HIRModuleMIRCodeGenerator) ::=> MIRValue
        := constant value asTacConstant.

    public override method translateUndefinedConstant: (constant: HIRUndefinedConstant) intoTacWith: (codegen: HIRModuleMIRCodeGenerator) ::=> MIRValue
        := 0i64 asTacConstant.
}.

UInt64 __type__ extend: {
    public override method emitTacUncheckedUnbox: (boxedValue: MIRValue) into: (unboxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> Void := {
        codegen blockBuilder callInt64: (codegen translateRuntimeFunction: ObjectModel::unboxUInt64) with: boxedValue result: unboxedValue
    }.

    public override method emitTacCheckThenUnbox: (boxedValue: MIRValue) into: (unboxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> Void := {
        codegen blockBuilder callInt64: (codegen translateRuntimeFunction: ObjectModel::checkAndUnboxUInt64) with: boxedValue result: unboxedValue
    }.

    public override method emitTacBox: (unboxedValue: MIRValue) into: (boxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> Void := {
        codegen blockBuilder callPointer: (codegen translateRuntimeFunction: ObjectModel::boxUInt64) with: unboxedValue result: boxedValue
    }.

    public override method emitTacCall: (function: MIRValue) convention: (callingConvention: MIRCallingConvention) withArguments: (arguments: Array) into: (result: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> Void := {
        builder callInt64: function convention: callingConvention arguments: arguments result: result
    }.

    public override method emitTacReturn: (value: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> Void := {
        builder returnInt64: value
    }.

    public override method emitTacMove: (sourceValue: MIRValue) into: (targetValue: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> Void := {
        builder moveInt64: sourceValue into: targetValue
    }.

    public override method emitTacLoadFromPointer: (pointer: MIRValue) constantOffset: (constantOffset: Int64) into: (result: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> Void := {
        builder loadUInt64: pointer constantOffset: constantOffset into: result
    }.

    public override method emitTacStore: (value: MIRValue) intoPointer: (pointer: MIRValue) constantOffset: (constantOffset: Int64) withBlockBuilder: (builder: MIRBlockBuilder) ::=> Void := {
        builder storeInt64: value into: pointer constantOffset: constantOffset
    }.

    public override method translateHIRLiteralConstant: (constant: HIRLiteralConstant) intoTacWith: (codegen: HIRModuleMIRCodeGenerator) ::=> MIRValue
        := constant value asTacConstant.

    public override method translateUndefinedConstant: (constant: HIRUndefinedConstant) intoTacWith: (codegen: HIRModuleMIRCodeGenerator) ::=> MIRValue
        := 0u32 asTacConstant.
}.

Float32 __type__ extend: {
    public override method emitTacUncheckedUnbox: (boxedValue: MIRValue) into: (unboxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> Void := {
        codegen blockBuilder callFloat32: (codegen translateRuntimeFunction: ObjectModel::unboxFloat32) with: boxedValue result: unboxedValue
    }.

    public override method emitTacCheckThenUnbox: (boxedValue: MIRValue) into: (unboxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> Void := {
        codegen blockBuilder callFloat32: (codegen translateRuntimeFunction: ObjectModel::checkAndUnboxFloat32) with: boxedValue result: unboxedValue
    }.

    public override method emitTacBox: (unboxedValue: MIRValue) into: (boxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> Void := {
        codegen blockBuilder callPointer: (codegen translateRuntimeFunction: ObjectModel::boxFloat32) with: unboxedValue result: boxedValue
    }.

    public override method emitTacCall: (function: MIRValue) convention: (callingConvention: MIRCallingConvention) withArguments: (arguments: Array) into: (result: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> Void := {
        builder callFloat32: function convention: callingConvention arguments: arguments result: result
    }.

    public override method emitTacReturn: (value: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> Void := {
        builder returnFloat32: value
    }.

    public override method emitTacMove: (sourceValue: MIRValue) into: (targetValue: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> Void := {
        builder moveFloat32: sourceValue into: targetValue
    }.

    public override method emitTacLoadFromPointer: (pointer: MIRValue) constantOffset: (constantOffset: Int64) into: (result: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> Void := {
        builder loadFloat32: pointer constantOffset: constantOffset into: result
    }.

    public override method emitTacStore: (value: MIRValue) intoPointer: (pointer: MIRValue) constantOffset: (constantOffset: Int64) withBlockBuilder: (builder: MIRBlockBuilder) ::=> Void := {
        builder storeFloat32: value into: pointer constantOffset: constantOffset
    }.

    public override method translateHIRLiteralConstant: (constant: HIRLiteralConstant) intoTacWith: (codegen: HIRModuleMIRCodeGenerator) ::=> MIRValue
        := constant value asTacConstant.

    public override method translateUndefinedConstant: (constant: HIRUndefinedConstant) intoTacWith: (codegen: HIRModuleMIRCodeGenerator) ::=> MIRValue
        := 0.0f32 asTacConstant.
}.

Float64 __type__ extend: {
    public override method emitTacUncheckedUnbox: (boxedValue: MIRValue) into: (unboxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> Void := {
        codegen blockBuilder callFloat64: (codegen translateRuntimeFunction: ObjectModel::unboxFloat64) with: boxedValue result: unboxedValue
    }.

    public override method emitTacCheckThenUnbox: (boxedValue: MIRValue) into: (unboxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> Void := {
        codegen blockBuilder callFloat64: (codegen translateRuntimeFunction: ObjectModel::checkAndUnboxFloat64) with: boxedValue result: unboxedValue
    }.

    public override method emitTacBox: (unboxedValue: MIRValue) into: (boxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> Void := {
        codegen blockBuilder callPointer: (codegen translateRuntimeFunction: ObjectModel::boxFloat64) with: unboxedValue result: boxedValue
    }.

    public override method emitTacCall: (function: MIRValue) convention: (callingConvention: MIRCallingConvention) withArguments: (arguments: Array) into: (result: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> Void := {
        builder callFloat64: function convention: callingConvention arguments: arguments result: result
    }.

    public override method emitTacReturn: (value: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> Void := {
        builder returnFloat64: value
    }.

    public override method emitTacMove: (sourceValue: MIRValue) into: (targetValue: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> Void := {
        builder moveFloat64: sourceValue into: targetValue
    }.

    public override method emitTacLoadFromPointer: (pointer: MIRValue) constantOffset: (constantOffset: Int64) into: (result: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> Void := {
        builder loadFloat64: pointer constantOffset: constantOffset into: result
    }.

    public override method emitTacStore: (value: MIRValue) intoPointer: (pointer: MIRValue) constantOffset: (constantOffset: Int64) withBlockBuilder: (builder: MIRBlockBuilder) ::=> Void := {
        builder storeFloat64: value into: pointer constantOffset: constantOffset
    }.

    public override method translateHIRLiteralConstant: (constant: HIRLiteralConstant) intoTacWith: (codegen: HIRModuleMIRCodeGenerator) ::=> MIRValue
        := constant value asTacConstant.

    public override method translateUndefinedConstant: (constant: HIRUndefinedConstant) intoTacWith: (codegen: HIRModuleMIRCodeGenerator) ::=> MIRValue
        := 0.0 asTacConstant.
}.

Void __type__ extend: {
    public override method emitTacUncheckedUnbox: (boxedValue: MIRValue) into: (unboxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> Void := {
        ## Nothing is required here.
    }.

    public override method emitTacCheckThenUnbox: (boxedValue: MIRValue) into: (unboxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> Void := {
        ## Nothing is required here.
    }.

    public override method emitTacBox: (unboxedValue: MIRValue) into: (boxedValue: MIRValue) withHIRCodeGenerator: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> Void := {
        codegen blockBuilder movePointer: (codegen moduleCodeGenerator translateGenericObjectPointer: void) into: boxedValue.
    }.
    public override method emitTacCall: (function: MIRValue) convention: (callingConvention: MIRCallingConvention) withArguments: (arguments: Array) into: (result: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> Void := {
        builder callVoid: function convention: callingConvention arguments: arguments
    }.

    public virtual method emitTacUnboxingCall: (function: MIRValue) convention: (callingConvention: MIRCallingConvention) withArguments: (arguments: Array) into: (result: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> Void := {
        builder callVoid: function convention: callingConvention arguments: arguments
    }.

    public override method emitTacReturn: (value: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> Void := {
        builder returnVoid
    }.

    public override method emitTacMove: (sourceValue: MIRValue) into: (targetValue: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> Void := {
    }.

    public override method emitTacLoadFromPointer: (pointer: MIRValue) constantOffset: (constantOffset: Int64) into: (result: MIRValue) withBlockBuilder: (builder: MIRBlockBuilder) ::=> Void := {
    }.

    public override method emitTacStore: (value: MIRValue) intoPointer: (pointer: MIRValue) constantOffset: (constantOffset: Int64) withBlockBuilder: (builder: MIRBlockBuilder) ::=> Void := {
    }.

    public override method makeTacTemporaryValueNamed: (name: Symbol) withFunctionBuilder: (functionBuilder: MIRFunctionBuilder) ::=> MIRValue
        := nil.
}.

HIRValue extend: {
    public abstract method translateIntoTacValueWith: (codegen: HIRModuleMIRCodeGenerator) ::=> MIRValue
        := self subclassResponsibility.
}.

HIRLiteralConstant extend: {
    public override method translateIntoTacValueWith: (codegen: HIRModuleMIRCodeGenerator) ::=> MIRValue
        := isBoxed
            ifTrue: (codegen setValue: self translationInto: (codegen translateGenericObjectPointer: (self __slotNamedAt__: #value)))
            ifFalse: (codegen setValue: self translationInto: (type translateHIRLiteralConstant: self intoTacWith: codegen)).
}.

HIRUndefinedConstant extend: {
    public override method translateIntoTacValueWith: (codegen: HIRModuleMIRCodeGenerator) ::=> MIRValue
        := codegen setValue: self translationInto: (type translateUndefinedConstant: self intoTacWith: codegen).
}.

HIRGlobalValue extend: {
    public virtual method compileDirectTacTranslationWith: (codegen: HIRModuleMIRCodeGenerator) ::=> Void := {}.
}.

HIRFunction extend: {
    public override method translateIntoTacValueWith: (codegen: HIRModuleMIRCodeGenerator) ::=> MIRValue
        := codegen translateGenericObjectPointer: self sourceObject.

    public override method compileDirectTacTranslationWith: (codegen: HIRModuleMIRCodeGenerator) ::=> Void := {
        codegen compileDirectFunction: self
    }.
}.

HIRFunctionDefinition extend: {
    public override method translateIntoTacValueWith: (codegen: HIRModuleMIRCodeGenerator) ::=> MIRValue
        := codegen translateGenericObjectPointer: self sourceObject.

    public override method compileDirectTacTranslationWith: (codegen: HIRModuleMIRCodeGenerator) ::=> Void := {
        codegen compileDirectFunctionDefinition: self
    }.
}.

HIRInstruction extend: {
    public virtual method makeTacValueForResultWith: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue
        := type makeTacTemporaryValueNamed: self name withFunctionBuilder: codegen functionBuilder.

    public abstract method compileIntoTacValue: (tacValue: MIRValue) with: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> Void
        := self subclassResponsibility.
}.

HIRAllocaInstruction extend: {
    public override method makeTacValueForResultWith: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> MIRValue := {
        self isLocalOnlyAlloca ifTrue: {
            let baseType := (self type downCastTo: PointerLikeType) baseType.
            let localVariable := baseType makeTacTemporaryValueNamed: self name withFunctionBuilder: codegen functionBuilder.
            codegen localOnlyAllocaDictionary at: self put: localVariable.
            nil
        } ifFalse: {
            super makeTacValueForResultWith: codegen
        }.
    }.

    public override method compileIntoTacValue: (tacValue: MIRValue) with: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> Void := {
        tacValue ifNotNil: {
            self assert: self type isPointerLikeType.
            let resultPointerType := self type downCastTo: PointerLikeType.
            let requiredAllocaSize := resultPointerType baseType valueSize.
            codegen blockBuilder callPointer: (codegen translateRuntimeFunction: ObjectModel::allocaGC)
                with: (codegen blockBuilder pointerConstantWith: requiredAllocaSize)
                with: (codegen translateValue: self valueType)
                result: tacValue.
        }
    }.
}.

HIRBranchInstruction extend: {
    public override method compileIntoTacValue: (tacValue: MIRValue) with: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> Void := {
        let destination := codegen translateValue: self destination.
        codegen blockBuilder branch: destination
    }.
}.

HIRConditionalBranchInstruction extend: {
    public override method compileIntoTacValue: (tacValue: MIRValue) with: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> Void := {
        let condition := codegen translateValue: self condition.
        let trueDestination := codegen translateValue: self trueDestination.
        let falseDestination := codegen translateValue: self falseDestination.
        codegen blockBuilder when: condition branchIfTrue: trueDestination branchIfFalse: falseDestination
    }.
}.

let translateUnaryPrimitiveInto := {:(MIROperation)operation :: ((Array, MIRValue, HIRFunctionDefinitionMIRCodeGenerator) => Boolean) |
    {:(Array)arguments :(MIRValue)result :(HIRFunctionDefinitionMIRCodeGenerator)codegen :: Boolean |
        let operand := codegen translateValue: arguments first.
        codegen blockBuilder operation: operation with: operand result: result.
        true
    }
}.

let translateBinaryPrimitiveInto := {:(MIROperation)operation :: ((Array, MIRValue, HIRFunctionDefinitionMIRCodeGenerator) => Boolean) |
    {:(Array)arguments :(MIRValue)result :(HIRFunctionDefinitionMIRCodeGenerator)codegen :: Boolean |
        let left := codegen translateValue: arguments first.
        let right := codegen translateValue: arguments second.
        codegen blockBuilder operation: operation with: left with: right result: result.
        true
    }
}.

public global HIRTacPrimitiveCallGenerationTable := #{
    ## Pointer primitive
    #PointerLikeType::reinterpretCast : {:(Array)arguments :(MIRValue)result :(HIRFunctionDefinitionMIRCodeGenerator)codegen :: Boolean |
        codegen blockBuilder movePointer: (codegen translateValue: arguments first) into: result.
        true
    }.
    #PointerLikeType::reinterpretCastTo: : {:(Array)arguments :(MIRValue)result :(HIRFunctionDefinitionMIRCodeGenerator)codegen :: Boolean |
        codegen blockBuilder movePointer: (codegen translateValue: arguments first) into: result.
        true
    }.

    ## Identity equals/not-equals
    #== : {:(Array)arguments :(MIRValue)result :(HIRFunctionDefinitionMIRCodeGenerator)codegen :: Boolean |
        let leftType => Type := arguments first type.
        let rightType => Type  := arguments second type.
        let hasUndefined := (leftType == UndefinedObject) || (rightType == UndefinedObject).
        let hasPointer := leftType isPointerType || rightType isPointerType.

        (hasUndefined && hasPointer) || (leftType isPointerType && rightType isPointerType) ifTrue: {
            codegen blockBuilder pointerEquals: (codegen translateValue: arguments first) with: (codegen translateValue: arguments second) into: result.
            return: true
        }.

        leftType == rightType && leftType isValueType ifTrue: {
            leftType emitTacEquals: (codegen translateValue: arguments first) with: (codegen translateValue: arguments second) into: result withBlockBuilder: codegen blockBuilder
        } ifFalse: {
            codegen blockBuilder pointerEquals: (codegen translateBoxedValue: arguments first) with: (codegen translateBoxedValue: arguments second) into: result
        }.
        true
    }.
    #~~ : {:(Array)arguments :(MIRValue)result :(HIRFunctionDefinitionMIRCodeGenerator)codegen :: Boolean |
        let leftType => Type := arguments first type.
        let rightType => Type  := arguments second type.
        let hasUndefined := (leftType == UndefinedObject) || (rightType == UndefinedObject).
        let hasPointer := leftType isPointerType || rightType isPointerType.

        (hasUndefined && hasPointer) || (leftType isPointerType && rightType isPointerType) ifTrue: {
            codegen blockBuilder pointerNotEquals: (codegen translateValue: arguments first) with: (codegen translateValue: arguments second) into: result.
            return: true
        }.

        leftType == rightType && leftType isValueType ifTrue: {
            leftType emitTacNotEquals: (codegen translateValue: arguments first) with: (codegen translateValue: arguments second) into: result withBlockBuilder: codegen blockBuilder
        } ifFalse: {
            codegen blockBuilder pointerNotEquals: (codegen translateBoxedValue: arguments first) with: (codegen translateBoxedValue: arguments second) into: result
        }.
        true
    }.

    ## Char8 primitives
    #Char8::negated : translateUnaryPrimitiveInto(MIR::Operation::Int8Negate).
    #Char8::bitInvert : translateUnaryPrimitiveInto(MIR::Operation::Int8BitNot).

    #Char8::+ : translateBinaryPrimitiveInto(MIR::Operation::Int8Add).
    #Char8::- : translateBinaryPrimitiveInto(MIR::Operation::Int8Sub).
    #Char8::* : translateBinaryPrimitiveInto(MIR::Operation::Int8Mul).
    #Char8::/ : translateBinaryPrimitiveInto(MIR::Operation::Int8UDiv).
    #Char8::% : translateBinaryPrimitiveInto(MIR::Operation::Int8URem).

    #Char8::& : translateBinaryPrimitiveInto(MIR::Operation::Int8BitAnd).
    #Char8::| : translateBinaryPrimitiveInto(MIR::Operation::Int8BitOr).
    #Char8::^ : translateBinaryPrimitiveInto(MIR::Operation::Int8BitXor).
    #Char8::<< : translateBinaryPrimitiveInto(MIR::Operation::Int8LogicalShiftLeft).
    #Char8::>> : translateBinaryPrimitiveInto(MIR::Operation::Int8LogicalShiftRight).

    #Char8::= : translateBinaryPrimitiveInto(MIR::Operation::Int8Equals).
    #Char8::~= : translateBinaryPrimitiveInto(MIR::Operation::Int8NotEquals).
    #Char8::<=> : translateBinaryPrimitiveInto(MIR::Operation::Int8Compare).
    #Char8::< : translateBinaryPrimitiveInto(MIR::Operation::UInt8LessThan).
    #Char8::<= : translateBinaryPrimitiveInto(MIR::Operation::UInt8LessOrEquals).
    #Char8::> : translateBinaryPrimitiveInto(MIR::Operation::UInt8GreaterThan).
    #Char8::>= : translateBinaryPrimitiveInto(MIR::Operation::UInt8GreaterOrEquals).

    #Char8::asChar8 : translateUnaryPrimitiveInto(MIR::Operation::MoveInt8).
    #Char8::asInt8 : translateUnaryPrimitiveInto(MIR::Operation::MoveInt8).
    #Char8::asUInt8 : translateUnaryPrimitiveInto(MIR::Operation::MoveInt8).
    #Char8::asChar16 : translateUnaryPrimitiveInto(MIR::Operation::ZeroExtendInt8ToInt16).
    #Char8::asInt16 : translateUnaryPrimitiveInto(MIR::Operation::ZeroExtendInt8ToInt16).
    #Char8::asUInt16 : translateUnaryPrimitiveInto(MIR::Operation::ZeroExtendInt8ToInt16).
    #Char8::asChar32 : translateUnaryPrimitiveInto(MIR::Operation::ZeroExtendInt8ToInt32).
    #Char8::asInt32 : translateUnaryPrimitiveInto(MIR::Operation::ZeroExtendInt8ToInt32).
    #Char8::asUInt32 : translateUnaryPrimitiveInto(MIR::Operation::ZeroExtendInt8ToInt32).
    #Char8::asInt64 : translateUnaryPrimitiveInto(MIR::Operation::ZeroExtendInt8ToInt64).
    #Char8::asUInt64 : translateUnaryPrimitiveInto(MIR::Operation::ZeroExtendInt8ToInt64).
    #Char8::asFloat32 : translateUnaryPrimitiveInto(MIR::Operation::UInt8ToFloat32).
    #Char8::asFloat64 : translateUnaryPrimitiveInto(MIR::Operation::UInt8ToFloat64).

    ## UInt8 primitives
    #UInt8::negated : translateUnaryPrimitiveInto(MIR::Operation::Int8Negate).
    #UInt8::bitInvert : translateUnaryPrimitiveInto(MIR::Operation::Int8BitNot).

    #UInt8::+ : translateBinaryPrimitiveInto(MIR::Operation::Int8Add).
    #UInt8::- : translateBinaryPrimitiveInto(MIR::Operation::Int8Sub).
    #UInt8::* : translateBinaryPrimitiveInto(MIR::Operation::Int8Mul).
    #UInt8::/ : translateBinaryPrimitiveInto(MIR::Operation::Int8UDiv).
    #UInt8::% : translateBinaryPrimitiveInto(MIR::Operation::Int8URem).

    #UInt8::& : translateBinaryPrimitiveInto(MIR::Operation::Int8BitAnd).
    #UInt8::| : translateBinaryPrimitiveInto(MIR::Operation::Int8BitOr).
    #UInt8::^ : translateBinaryPrimitiveInto(MIR::Operation::Int8BitXor).
    #UInt8::<< : translateBinaryPrimitiveInto(MIR::Operation::Int8LogicalShiftLeft).
    #UInt8::>> : translateBinaryPrimitiveInto(MIR::Operation::Int8LogicalShiftRight).

    #UInt8::= : translateBinaryPrimitiveInto(MIR::Operation::Int8Equals).
    #UInt8::~= : translateBinaryPrimitiveInto(MIR::Operation::Int8NotEquals).
    #UInt8::<=> : translateBinaryPrimitiveInto(MIR::Operation::Int8Compare).
    #UInt8::< : translateBinaryPrimitiveInto(MIR::Operation::UInt8LessThan).
    #UInt8::<= : translateBinaryPrimitiveInto(MIR::Operation::UInt8LessOrEquals).
    #UInt8::> : translateBinaryPrimitiveInto(MIR::Operation::UInt8GreaterThan).
    #UInt8::>= : translateBinaryPrimitiveInto(MIR::Operation::UInt8GreaterOrEquals).

    #UInt8::asChar8 : translateUnaryPrimitiveInto(MIR::Operation::MoveInt8).
    #UInt8::asInt8 : translateUnaryPrimitiveInto(MIR::Operation::MoveInt8).
    #UInt8::asUInt8 : translateUnaryPrimitiveInto(MIR::Operation::MoveInt8).
    #UInt8::asChar16 : translateUnaryPrimitiveInto(MIR::Operation::ZeroExtendInt8ToInt16).
    #UInt8::asInt16 : translateUnaryPrimitiveInto(MIR::Operation::ZeroExtendInt8ToInt16).
    #UInt8::asUInt16 : translateUnaryPrimitiveInto(MIR::Operation::ZeroExtendInt8ToInt16).
    #UInt8::asChar32 : translateUnaryPrimitiveInto(MIR::Operation::ZeroExtendInt8ToInt32).
    #UInt8::asInt32 : translateUnaryPrimitiveInto(MIR::Operation::ZeroExtendInt8ToInt32).
    #UInt8::asUInt32 : translateUnaryPrimitiveInto(MIR::Operation::ZeroExtendInt8ToInt32).
    #UInt8::asInt64 : translateUnaryPrimitiveInto(MIR::Operation::ZeroExtendInt8ToInt64).
    #UInt8::asUInt64 : translateUnaryPrimitiveInto(MIR::Operation::ZeroExtendInt8ToInt64).
    #UInt8::asFloat32 : translateUnaryPrimitiveInto(MIR::Operation::UInt8ToFloat32).
    #UInt8::asFloat64 : translateUnaryPrimitiveInto(MIR::Operation::UInt8ToFloat64).

    ## Int8 primitives
    #Int8::negated : translateUnaryPrimitiveInto(MIR::Operation::Int8Negate).
    #Int8::bitInvert : translateUnaryPrimitiveInto(MIR::Operation::Int8BitNot).

    #Int8::+ : translateBinaryPrimitiveInto(MIR::Operation::Int8Add).
    #Int8::- : translateBinaryPrimitiveInto(MIR::Operation::Int8Sub).
    #Int8::* : translateBinaryPrimitiveInto(MIR::Operation::Int8Mul).
    #Int8::/ : translateBinaryPrimitiveInto(MIR::Operation::Int8SDiv).
    #Int8::% : translateBinaryPrimitiveInto(MIR::Operation::Int8SRem).

    #Int8::& : translateBinaryPrimitiveInto(MIR::Operation::Int8BitAnd).
    #Int8::| : translateBinaryPrimitiveInto(MIR::Operation::Int8BitOr).
    #Int8::^ : translateBinaryPrimitiveInto(MIR::Operation::Int8BitXor).
    #Int8::<< : translateBinaryPrimitiveInto(MIR::Operation::Int8LogicalShiftLeft).
    #Int8::>> : translateBinaryPrimitiveInto(MIR::Operation::Int8ArithmeticShiftRight).

    #Int8::= : translateBinaryPrimitiveInto(MIR::Operation::Int8Equals).
    #Int8::~= : translateBinaryPrimitiveInto(MIR::Operation::Int8NotEquals).
    #Int8::<=> : translateBinaryPrimitiveInto(MIR::Operation::Int8Compare).
    #Int8::< : translateBinaryPrimitiveInto(MIR::Operation::Int8LessThan).
    #Int8::<= : translateBinaryPrimitiveInto(MIR::Operation::Int8LessOrEquals).
    #Int8::> : translateBinaryPrimitiveInto(MIR::Operation::Int8GreaterThan).
    #Int8::>= : translateBinaryPrimitiveInto(MIR::Operation::Int8GreaterOrEquals).

    #Int8::asChar8 : translateUnaryPrimitiveInto(MIR::Operation::MoveInt8).
    #Int8::asInt8 : translateUnaryPrimitiveInto(MIR::Operation::MoveInt8).
    #Int8::asUInt8 : translateUnaryPrimitiveInto(MIR::Operation::MoveInt8).
    #Int8::asChar16 : translateUnaryPrimitiveInto(MIR::Operation::ZeroExtendInt8ToInt16).
    #Int8::asInt16 : translateUnaryPrimitiveInto(MIR::Operation::SignExtendInt8ToInt16).
    #Int8::asUInt16 : translateUnaryPrimitiveInto(MIR::Operation::ZeroExtendInt8ToInt16).
    #Int8::asChar32 : translateUnaryPrimitiveInto(MIR::Operation::ZeroExtendInt8ToInt32).
    #Int8::asInt32 : translateUnaryPrimitiveInto(MIR::Operation::SignExtendInt8ToInt32).
    #Int8::asUInt32 : translateUnaryPrimitiveInto(MIR::Operation::ZeroExtendInt8ToInt32).
    #Int8::asInt64 : translateUnaryPrimitiveInto(MIR::Operation::SignExtendInt8ToInt64).
    #Int8::asUInt64 : translateUnaryPrimitiveInto(MIR::Operation::ZeroExtendInt8ToInt64).
    #Int8::asFloat32 : translateUnaryPrimitiveInto(MIR::Operation::Int8ToFloat32).
    #Int8::asFloat64 : translateUnaryPrimitiveInto(MIR::Operation::Int8ToFloat64).

    ## Char16 primitives
    #Char16::negated : translateUnaryPrimitiveInto(MIR::Operation::Int16Negate).
    #Char16::bitInvert : translateUnaryPrimitiveInto(MIR::Operation::Int16BitNot).
    #Char16::highBit : translateUnaryPrimitiveInto(MIR::Operation::Int16HighBit).

    #Char16::+ : translateBinaryPrimitiveInto(MIR::Operation::Int16Add).
    #Char16::- : translateBinaryPrimitiveInto(MIR::Operation::Int16Sub).
    #Char16::* : translateBinaryPrimitiveInto(MIR::Operation::Int16Mul).
    #Char16::/ : translateBinaryPrimitiveInto(MIR::Operation::Int16UDiv).
    #Char16::% : translateBinaryPrimitiveInto(MIR::Operation::Int16URem).

    #Char16::& : translateBinaryPrimitiveInto(MIR::Operation::Int16BitAnd).
    #Char16::| : translateBinaryPrimitiveInto(MIR::Operation::Int16BitOr).
    #Char16::^ : translateBinaryPrimitiveInto(MIR::Operation::Int16BitXor).
    #Char16::<< : translateBinaryPrimitiveInto(MIR::Operation::Int16LogicalShiftLeft).
    #Char16::>> : translateBinaryPrimitiveInto(MIR::Operation::Int16LogicalShiftRight).

    #Char16::= : translateBinaryPrimitiveInto(MIR::Operation::Int16Equals).
    #Char16::~= : translateBinaryPrimitiveInto(MIR::Operation::Int16NotEquals).
    #Char16::<=> : translateBinaryPrimitiveInto(MIR::Operation::Int16Compare).
    #Char16::< : translateBinaryPrimitiveInto(MIR::Operation::UInt16LessThan).
    #Char16::<= : translateBinaryPrimitiveInto(MIR::Operation::UInt16LessOrEquals).
    #Char16::> : translateBinaryPrimitiveInto(MIR::Operation::UInt16GreaterThan).
    #Char16::>= : translateBinaryPrimitiveInto(MIR::Operation::UInt16GreaterOrEquals).

    #Char16::asChar8 : translateUnaryPrimitiveInto(MIR::Operation::TruncateInt16ToInt8).
    #Char16::asInt8 : translateUnaryPrimitiveInto(MIR::Operation::TruncateInt16ToInt8).
    #Char16::asUInt8 : translateUnaryPrimitiveInto(MIR::Operation::TruncateInt16ToInt8).
    #Char16::asChar16 : translateUnaryPrimitiveInto(MIR::Operation::MoveInt16).
    #Char16::asInt16 : translateUnaryPrimitiveInto(MIR::Operation::MoveInt16).
    #Char16::asUInt16 : translateUnaryPrimitiveInto(MIR::Operation::MoveInt16).
    #Char16::asChar32 : translateUnaryPrimitiveInto(MIR::Operation::ZeroExtendInt16ToInt32).
    #Char16::asInt32 : translateUnaryPrimitiveInto(MIR::Operation::ZeroExtendInt16ToInt32).
    #Char16::asUInt32 : translateUnaryPrimitiveInto(MIR::Operation::ZeroExtendInt16ToInt32).
    #Char16::asInt64 : translateUnaryPrimitiveInto(MIR::Operation::ZeroExtendInt16ToInt64).
    #Char16::asUInt64 : translateUnaryPrimitiveInto(MIR::Operation::ZeroExtendInt16ToInt64).
    #Char16::asFloat32 : translateUnaryPrimitiveInto(MIR::Operation::UInt16ToFloat32).
    #Char16::asFloat64 : translateUnaryPrimitiveInto(MIR::Operation::UInt16ToFloat64).

    ## UInt16 primitives
    #UInt16::negated : translateUnaryPrimitiveInto(MIR::Operation::Int16Negate).
    #UInt16::bitInvert : translateUnaryPrimitiveInto(MIR::Operation::Int16BitNot).
    #UInt16::highBit : translateUnaryPrimitiveInto(MIR::Operation::Int16HighBit).

    #UInt16::+ : translateBinaryPrimitiveInto(MIR::Operation::Int16Add).
    #UInt16::- : translateBinaryPrimitiveInto(MIR::Operation::Int16Sub).
    #UInt16::* : translateBinaryPrimitiveInto(MIR::Operation::Int16Mul).
    #UInt16::/ : translateBinaryPrimitiveInto(MIR::Operation::Int16UDiv).
    #UInt16::% : translateBinaryPrimitiveInto(MIR::Operation::Int16URem).

    #UInt16::& : translateBinaryPrimitiveInto(MIR::Operation::Int16BitAnd).
    #UInt16::| : translateBinaryPrimitiveInto(MIR::Operation::Int16BitOr).
    #UInt16::^ : translateBinaryPrimitiveInto(MIR::Operation::Int16BitXor).
    #UInt16::<< : translateBinaryPrimitiveInto(MIR::Operation::Int16LogicalShiftLeft).
    #UInt16::>> : translateBinaryPrimitiveInto(MIR::Operation::Int16LogicalShiftRight).

    #UInt16::= : translateBinaryPrimitiveInto(MIR::Operation::Int16Equals).
    #UInt16::~= : translateBinaryPrimitiveInto(MIR::Operation::Int16NotEquals).
    #UInt16::<=> : translateBinaryPrimitiveInto(MIR::Operation::Int16Compare).
    #UInt16::< : translateBinaryPrimitiveInto(MIR::Operation::UInt16LessThan).
    #UInt16::<= : translateBinaryPrimitiveInto(MIR::Operation::UInt16LessOrEquals).
    #UInt16::> : translateBinaryPrimitiveInto(MIR::Operation::UInt16GreaterThan).
    #UInt16::>= : translateBinaryPrimitiveInto(MIR::Operation::UInt16GreaterOrEquals).

    #UInt16::asChar8 : translateUnaryPrimitiveInto(MIR::Operation::TruncateInt16ToInt8).
    #UInt16::asInt8 : translateUnaryPrimitiveInto(MIR::Operation::TruncateInt16ToInt8).
    #UInt16::asUInt8 : translateUnaryPrimitiveInto(MIR::Operation::TruncateInt16ToInt8).
    #UInt16::asChar16 : translateUnaryPrimitiveInto(MIR::Operation::MoveInt16).
    #UInt16::asInt16 : translateUnaryPrimitiveInto(MIR::Operation::MoveInt16).
    #UInt16::asUInt16 : translateUnaryPrimitiveInto(MIR::Operation::MoveInt16).
    #UInt16::asChar32 : translateUnaryPrimitiveInto(MIR::Operation::ZeroExtendInt16ToInt32).
    #UInt16::asInt32 : translateUnaryPrimitiveInto(MIR::Operation::ZeroExtendInt16ToInt32).
    #UInt16::asUInt32 : translateUnaryPrimitiveInto(MIR::Operation::ZeroExtendInt16ToInt32).
    #UInt16::asInt64 : translateUnaryPrimitiveInto(MIR::Operation::ZeroExtendInt16ToInt64).
    #UInt16::asUInt64 : translateUnaryPrimitiveInto(MIR::Operation::ZeroExtendInt16ToInt64).
    #UInt16::asFloat32 : translateUnaryPrimitiveInto(MIR::Operation::UInt16ToFloat32).
    #UInt16::asFloat64 : translateUnaryPrimitiveInto(MIR::Operation::UInt16ToFloat64).

    ## Int16 primitives
    #Int16::negated : translateUnaryPrimitiveInto(MIR::Operation::Int16Negate).
    #Int16::bitInvert : translateUnaryPrimitiveInto(MIR::Operation::Int16BitNot).
    #Int16::highBit : translateUnaryPrimitiveInto(MIR::Operation::Int16HighBit).

    #Int16::+ : translateBinaryPrimitiveInto(MIR::Operation::Int16Add).
    #Int16::- : translateBinaryPrimitiveInto(MIR::Operation::Int16Sub).
    #Int16::* : translateBinaryPrimitiveInto(MIR::Operation::Int16Mul).
    #Int16::/ : translateBinaryPrimitiveInto(MIR::Operation::Int16SDiv).
    #Int16::% : translateBinaryPrimitiveInto(MIR::Operation::Int16SRem).

    #Int16::& : translateBinaryPrimitiveInto(MIR::Operation::Int16BitAnd).
    #Int16::| : translateBinaryPrimitiveInto(MIR::Operation::Int16BitOr).
    #Int16::^ : translateBinaryPrimitiveInto(MIR::Operation::Int16BitXor).
    #Int16::<< : translateBinaryPrimitiveInto(MIR::Operation::Int16LogicalShiftLeft).
    #Int16::>> : translateBinaryPrimitiveInto(MIR::Operation::Int16ArithmeticShiftRight).

    #Int16::= : translateBinaryPrimitiveInto(MIR::Operation::Int16Equals).
    #Int16::~= : translateBinaryPrimitiveInto(MIR::Operation::Int16NotEquals).
    #Int16::<=> : translateBinaryPrimitiveInto(MIR::Operation::Int16Compare).
    #Int16::< : translateBinaryPrimitiveInto(MIR::Operation::Int16LessThan).
    #Int16::<= : translateBinaryPrimitiveInto(MIR::Operation::Int16LessOrEquals).
    #Int16::> : translateBinaryPrimitiveInto(MIR::Operation::Int16GreaterThan).
    #Int16::>= : translateBinaryPrimitiveInto(MIR::Operation::Int16GreaterOrEquals).

    #Int16::asChar8 : translateUnaryPrimitiveInto(MIR::Operation::TruncateInt16ToInt8).
    #Int16::asInt8 : translateUnaryPrimitiveInto(MIR::Operation::TruncateInt16ToInt8).
    #Int16::asUInt8 : translateUnaryPrimitiveInto(MIR::Operation::TruncateInt16ToInt8).
    #Int16::asChar16 : translateUnaryPrimitiveInto(MIR::Operation::MoveInt16).
    #Int16::asInt16 : translateUnaryPrimitiveInto(MIR::Operation::MoveInt16).
    #Int16::asUInt16 : translateUnaryPrimitiveInto(MIR::Operation::MoveInt16).
    #Int16::asChar32 : translateUnaryPrimitiveInto(MIR::Operation::ZeroExtendInt16ToInt32).
    #Int16::asInt32 : translateUnaryPrimitiveInto(MIR::Operation::SignExtendInt16ToInt32).
    #Int16::asUInt32 : translateUnaryPrimitiveInto(MIR::Operation::ZeroExtendInt16ToInt32).
    #Int16::asInt64 : translateUnaryPrimitiveInto(MIR::Operation::SignExtendInt16ToInt64).
    #Int16::asUInt64 : translateUnaryPrimitiveInto(MIR::Operation::ZeroExtendInt16ToInt64).
    #Int16::asFloat32 : translateUnaryPrimitiveInto(MIR::Operation::Int16ToFloat32).
    #Int16::asFloat64 : translateUnaryPrimitiveInto(MIR::Operation::Int16ToFloat64).

    ## Char32 primitives
    #Char32::negated : translateUnaryPrimitiveInto(MIR::Operation::Int32Negate).
    #Char32::bitInvert : translateUnaryPrimitiveInto(MIR::Operation::Int32BitNot).
    #Char32::highBit : translateUnaryPrimitiveInto(MIR::Operation::Int32HighBit).

    #Char32::+ : translateBinaryPrimitiveInto(MIR::Operation::Int32Add).
    #Char32::- : translateBinaryPrimitiveInto(MIR::Operation::Int32Sub).
    #Char32::* : translateBinaryPrimitiveInto(MIR::Operation::Int32Mul).
    #Char32::/ : translateBinaryPrimitiveInto(MIR::Operation::Int32UDiv).
    #Char32::% : translateBinaryPrimitiveInto(MIR::Operation::Int32URem).

    #Char32::& : translateBinaryPrimitiveInto(MIR::Operation::Int32BitAnd).
    #Char32::| : translateBinaryPrimitiveInto(MIR::Operation::Int32BitOr).
    #Char32::^ : translateBinaryPrimitiveInto(MIR::Operation::Int32BitXor).
    #Char32::<< : translateBinaryPrimitiveInto(MIR::Operation::Int32LogicalShiftLeft).
    #Char32::>> : translateBinaryPrimitiveInto(MIR::Operation::Int32LogicalShiftRight).

    #Char32::= : translateBinaryPrimitiveInto(MIR::Operation::Int32Equals).
    #Char32::~= : translateBinaryPrimitiveInto(MIR::Operation::Int32NotEquals).
    #Char32::<=> : translateBinaryPrimitiveInto(MIR::Operation::Int32Compare).
    #Char32::< : translateBinaryPrimitiveInto(MIR::Operation::UInt32LessThan).
    #Char32::<= : translateBinaryPrimitiveInto(MIR::Operation::UInt32LessOrEquals).
    #Char32::> : translateBinaryPrimitiveInto(MIR::Operation::UInt32GreaterThan).
    #Char32::>= : translateBinaryPrimitiveInto(MIR::Operation::UInt32GreaterOrEquals).

    #Char32::asChar8 : translateUnaryPrimitiveInto(MIR::Operation::TruncateInt32ToInt8).
    #Char32::asInt8 : translateUnaryPrimitiveInto(MIR::Operation::TruncateInt32ToInt8).
    #Char32::asUInt8 : translateUnaryPrimitiveInto(MIR::Operation::TruncateInt32ToInt8).
    #Char32::asChar16 : translateUnaryPrimitiveInto(MIR::Operation::TruncateInt32ToInt16).
    #Char32::asInt16 : translateUnaryPrimitiveInto(MIR::Operation::TruncateInt32ToInt16).
    #Char32::asUInt16 : translateUnaryPrimitiveInto(MIR::Operation::TruncateInt32ToInt16).
    #Char32::asChar32 : translateUnaryPrimitiveInto(MIR::Operation::MoveInt32).
    #Char32::asInt32 : translateUnaryPrimitiveInto(MIR::Operation::MoveInt32).
    #Char32::asUInt32 : translateUnaryPrimitiveInto(MIR::Operation::MoveInt32).
    #Char32::asInt64 : translateUnaryPrimitiveInto(MIR::Operation::ZeroExtendInt32ToInt64).
    #Char32::asUInt64 : translateUnaryPrimitiveInto(MIR::Operation::ZeroExtendInt32ToInt64).
    #Char32::asFloat32 : translateUnaryPrimitiveInto(MIR::Operation::UInt32ToFloat32).
    #Char32::asFloat64 : translateUnaryPrimitiveInto(MIR::Operation::UInt32ToFloat64).

    ## UInt32 primitives
    #UInt32::negated : translateUnaryPrimitiveInto(MIR::Operation::Int32Negate).
    #UInt32::bitInvert : translateUnaryPrimitiveInto(MIR::Operation::Int32BitNot).
    #UInt32::highBit : translateUnaryPrimitiveInto(MIR::Operation::Int32HighBit).

    #UInt32::+ : translateBinaryPrimitiveInto(MIR::Operation::Int32Add).
    #UInt32::- : translateBinaryPrimitiveInto(MIR::Operation::Int32Sub).
    #UInt32::* : translateBinaryPrimitiveInto(MIR::Operation::Int32Mul).
    #UInt32::/ : translateBinaryPrimitiveInto(MIR::Operation::Int32UDiv).
    #UInt32::% : translateBinaryPrimitiveInto(MIR::Operation::Int32URem).

    #UInt32::& : translateBinaryPrimitiveInto(MIR::Operation::Int32BitAnd).
    #UInt32::| : translateBinaryPrimitiveInto(MIR::Operation::Int32BitOr).
    #UInt32::^ : translateBinaryPrimitiveInto(MIR::Operation::Int32BitXor).
    #UInt32::<< : translateBinaryPrimitiveInto(MIR::Operation::Int32LogicalShiftLeft).
    #UInt32::>> : translateBinaryPrimitiveInto(MIR::Operation::Int32LogicalShiftRight).

    #UInt32::= : translateBinaryPrimitiveInto(MIR::Operation::Int32Equals).
    #UInt32::~= : translateBinaryPrimitiveInto(MIR::Operation::Int32NotEquals).
    #UInt32::<=> : translateBinaryPrimitiveInto(MIR::Operation::Int32Compare).
    #UInt32::< : translateBinaryPrimitiveInto(MIR::Operation::UInt32LessThan).
    #UInt32::<= : translateBinaryPrimitiveInto(MIR::Operation::UInt32LessOrEquals).
    #UInt32::> : translateBinaryPrimitiveInto(MIR::Operation::UInt32GreaterThan).
    #UInt32::>= : translateBinaryPrimitiveInto(MIR::Operation::UInt32GreaterOrEquals).

    #UInt32::asChar8 : translateUnaryPrimitiveInto(MIR::Operation::TruncateInt32ToInt8).
    #UInt32::asInt8 : translateUnaryPrimitiveInto(MIR::Operation::TruncateInt32ToInt8).
    #UInt32::asUInt8 : translateUnaryPrimitiveInto(MIR::Operation::TruncateInt32ToInt8).
    #UInt32::asChar16 : translateUnaryPrimitiveInto(MIR::Operation::TruncateInt32ToInt16).
    #UInt32::asInt16 : translateUnaryPrimitiveInto(MIR::Operation::TruncateInt32ToInt16).
    #UInt32::asUInt16 : translateUnaryPrimitiveInto(MIR::Operation::TruncateInt32ToInt16).
    #UInt32::asChar32 : translateUnaryPrimitiveInto(MIR::Operation::MoveInt32).
    #UInt32::asInt32 : translateUnaryPrimitiveInto(MIR::Operation::MoveInt32).
    #UInt32::asUInt32 : translateUnaryPrimitiveInto(MIR::Operation::MoveInt32).
    #UInt32::asInt64 : translateUnaryPrimitiveInto(MIR::Operation::ZeroExtendInt32ToInt64).
    #UInt32::asUInt64 : translateUnaryPrimitiveInto(MIR::Operation::ZeroExtendInt32ToInt64).
    #UInt32::asFloat32 : translateUnaryPrimitiveInto(MIR::Operation::UInt32ToFloat32).
    #UInt32::asFloat64 : translateUnaryPrimitiveInto(MIR::Operation::UInt32ToFloat64).
    #UInt32::asIEEEFloat32Decoded : translateUnaryPrimitiveInto(MIR::Operation::IEEEUInt32ToFloat32). 

    ## Int32 primitives
    #Int32::negated : translateUnaryPrimitiveInto(MIR::Operation::Int32Negate).
    #Int32::bitInvert : translateUnaryPrimitiveInto(MIR::Operation::Int32BitNot).
    #Int32::highBit : translateUnaryPrimitiveInto(MIR::Operation::Int32HighBit).

    #Int32::+ : translateBinaryPrimitiveInto(MIR::Operation::Int32Add).
    #Int32::- : translateBinaryPrimitiveInto(MIR::Operation::Int32Sub).
    #Int32::* : translateBinaryPrimitiveInto(MIR::Operation::Int32Mul).
    #Int32::/ : translateBinaryPrimitiveInto(MIR::Operation::Int32SDiv).
    #Int32::% : translateBinaryPrimitiveInto(MIR::Operation::Int32SRem).

    #Int32::& : translateBinaryPrimitiveInto(MIR::Operation::Int32BitAnd).
    #Int32::| : translateBinaryPrimitiveInto(MIR::Operation::Int32BitOr).
    #Int32::^ : translateBinaryPrimitiveInto(MIR::Operation::Int32BitXor).
    #Int32::<< : translateBinaryPrimitiveInto(MIR::Operation::Int32LogicalShiftLeft).
    #Int32::>> : translateBinaryPrimitiveInto(MIR::Operation::Int32ArithmeticShiftRight).

    #Int32::= : translateBinaryPrimitiveInto(MIR::Operation::Int32Equals).
    #Int32::~= : translateBinaryPrimitiveInto(MIR::Operation::Int32NotEquals).
    #Int32::<=> : translateBinaryPrimitiveInto(MIR::Operation::Int32Compare).
    #Int32::< : translateBinaryPrimitiveInto(MIR::Operation::Int32LessThan).
    #Int32::<= : translateBinaryPrimitiveInto(MIR::Operation::Int32LessOrEquals).
    #Int32::> : translateBinaryPrimitiveInto(MIR::Operation::Int32GreaterThan).
    #Int32::>= : translateBinaryPrimitiveInto(MIR::Operation::Int32GreaterOrEquals).

    #Int32::asChar8 : translateUnaryPrimitiveInto(MIR::Operation::TruncateInt32ToInt8).
    #Int32::asInt8 : translateUnaryPrimitiveInto(MIR::Operation::TruncateInt32ToInt8).
    #Int32::asUInt8 : translateUnaryPrimitiveInto(MIR::Operation::TruncateInt32ToInt8).
    #Int32::asChar16 : translateUnaryPrimitiveInto(MIR::Operation::TruncateInt32ToInt16).
    #Int32::asInt16 : translateUnaryPrimitiveInto(MIR::Operation::TruncateInt32ToInt16).
    #Int32::asUInt16 : translateUnaryPrimitiveInto(MIR::Operation::TruncateInt32ToInt16).
    #Int32::asChar32 : translateUnaryPrimitiveInto(MIR::Operation::MoveInt32).
    #Int32::asInt32 : translateUnaryPrimitiveInto(MIR::Operation::MoveInt32).
    #Int32::asUInt32 : translateUnaryPrimitiveInto(MIR::Operation::MoveInt32).
    #Int32::asInt64 : translateUnaryPrimitiveInto(MIR::Operation::SignExtendInt32ToInt64).
    #Int32::asUInt64 : translateUnaryPrimitiveInto(MIR::Operation::ZeroExtendInt32ToInt64).
    #Int32::asFloat32 : translateUnaryPrimitiveInto(MIR::Operation::Int32ToFloat32).
    #Int32::asFloat64 : translateUnaryPrimitiveInto(MIR::Operation::Int32ToFloat64).

    ## Int64 primitives
    #Int64::negated : translateUnaryPrimitiveInto(MIR::Operation::Int64Negate).
    #Int64::bitInvert : translateUnaryPrimitiveInto(MIR::Operation::Int64BitNot).

    #Int64::+ : translateBinaryPrimitiveInto(MIR::Operation::Int64Add).
    #Int64::- : translateBinaryPrimitiveInto(MIR::Operation::Int64Sub).
    #Int64::* : translateBinaryPrimitiveInto(MIR::Operation::Int64Mul).
    #Int64::/ : translateBinaryPrimitiveInto(MIR::Operation::Int64SDiv).
    #Int64::% : translateBinaryPrimitiveInto(MIR::Operation::Int64SRem).

    #Int64::& : translateBinaryPrimitiveInto(MIR::Operation::Int64BitAnd).
    #Int64::| : translateBinaryPrimitiveInto(MIR::Operation::Int64BitOr).
    #Int64::^ : translateBinaryPrimitiveInto(MIR::Operation::Int64BitXor).
    #Int64::<< : translateBinaryPrimitiveInto(MIR::Operation::Int64LogicalShiftLeft).
    #Int64::>> : translateBinaryPrimitiveInto(MIR::Operation::Int64ArithmeticShiftRight).

    #Int64::= : translateBinaryPrimitiveInto(MIR::Operation::Int64Equals).
    #Int64::~= : translateBinaryPrimitiveInto(MIR::Operation::Int64NotEquals).
    #Int64::<=> : translateBinaryPrimitiveInto(MIR::Operation::Int64Compare).
    #Int64::< : translateBinaryPrimitiveInto(MIR::Operation::Int64LessThan).
    #Int64::<= : translateBinaryPrimitiveInto(MIR::Operation::Int64LessOrEquals).
    #Int64::> : translateBinaryPrimitiveInto(MIR::Operation::Int64GreaterThan).
    #Int64::>= : translateBinaryPrimitiveInto(MIR::Operation::Int64GreaterOrEquals).
    #Int64::highBit : translateUnaryPrimitiveInto(MIR::Operation::Int64HighBit).

    #Int64::asChar8 : translateUnaryPrimitiveInto(MIR::Operation::TruncateInt64ToInt8).
    #Int64::asInt8 : translateUnaryPrimitiveInto(MIR::Operation::TruncateInt64ToInt8).
    #Int64::asUInt8 : translateUnaryPrimitiveInto(MIR::Operation::TruncateInt64ToInt8).
    #Int64::asChar16 : translateUnaryPrimitiveInto(MIR::Operation::TruncateInt64ToInt16).
    #Int64::asInt16 : translateUnaryPrimitiveInto(MIR::Operation::TruncateInt64ToInt16).
    #Int64::asUInt16 : translateUnaryPrimitiveInto(MIR::Operation::TruncateInt64ToInt16).
    #Int64::asChar32 : translateUnaryPrimitiveInto(MIR::Operation::TruncateInt64ToInt32).
    #Int64::asInt32 : translateUnaryPrimitiveInto(MIR::Operation::TruncateInt64ToInt32).
    #Int64::asUInt32 : translateUnaryPrimitiveInto(MIR::Operation::TruncateInt64ToInt32).
    #Int64::asInt64 : translateUnaryPrimitiveInto(MIR::Operation::MoveInt64).
    #Int64::asUInt64 : translateUnaryPrimitiveInto(MIR::Operation::MoveInt64).
    #Int64::asFloat32 : translateUnaryPrimitiveInto(MIR::Operation::Int64ToFloat32).
    #Int64::asFloat64 : translateUnaryPrimitiveInto(MIR::Operation::Int64ToFloat64).

    ## UInt64 primitives
    #UInt64::negated : translateUnaryPrimitiveInto(MIR::Operation::Int64Negate).
    #UInt64::bitInvert : translateUnaryPrimitiveInto(MIR::Operation::Int64BitNot).
    #UInt64::highBit : translateUnaryPrimitiveInto(MIR::Operation::Int64HighBit).

    #UInt64::+ : translateBinaryPrimitiveInto(MIR::Operation::Int64Add).
    #UInt64::- : translateBinaryPrimitiveInto(MIR::Operation::Int64Sub).
    #UInt64::* : translateBinaryPrimitiveInto(MIR::Operation::Int64Mul).
    #UInt64::/ : translateBinaryPrimitiveInto(MIR::Operation::Int64UDiv).
    #UInt64::% : translateBinaryPrimitiveInto(MIR::Operation::Int64URem).

    #UInt64::& : translateBinaryPrimitiveInto(MIR::Operation::Int64BitAnd).
    #UInt64::| : translateBinaryPrimitiveInto(MIR::Operation::Int64BitOr).
    #UInt64::^ : translateBinaryPrimitiveInto(MIR::Operation::Int64BitXor).
    #UInt64::<< : translateBinaryPrimitiveInto(MIR::Operation::Int64LogicalShiftLeft).
    #UInt64::>> : translateBinaryPrimitiveInto(MIR::Operation::Int64LogicalShiftRight).

    #UInt64::= : translateBinaryPrimitiveInto(MIR::Operation::Int64Equals).
    #UInt64::~= : translateBinaryPrimitiveInto(MIR::Operation::Int64NotEquals).
    #UInt64::<=> : translateBinaryPrimitiveInto(MIR::Operation::Int64Compare).
    #UInt64::< : translateBinaryPrimitiveInto(MIR::Operation::UInt64LessThan).
    #UInt64::<= : translateBinaryPrimitiveInto(MIR::Operation::UInt64LessOrEquals).
    #UInt64::> : translateBinaryPrimitiveInto(MIR::Operation::UInt64GreaterThan).
    #UInt64::>= : translateBinaryPrimitiveInto(MIR::Operation::UInt64GreaterOrEquals).

    #UInt64::asChar8 : translateUnaryPrimitiveInto(MIR::Operation::TruncateInt64ToInt8).
    #UInt64::asInt8 : translateUnaryPrimitiveInto(MIR::Operation::TruncateInt64ToInt8).
    #UInt64::asUInt8 : translateUnaryPrimitiveInto(MIR::Operation::TruncateInt64ToInt8).
    #UInt64::asChar16 : translateUnaryPrimitiveInto(MIR::Operation::TruncateInt64ToInt16).
    #UInt64::asInt16 : translateUnaryPrimitiveInto(MIR::Operation::TruncateInt64ToInt16).
    #UInt64::asUInt16 : translateUnaryPrimitiveInto(MIR::Operation::TruncateInt64ToInt16).
    #UInt64::asChar32 : translateUnaryPrimitiveInto(MIR::Operation::TruncateInt64ToInt32).
    #UInt64::asInt32 : translateUnaryPrimitiveInto(MIR::Operation::TruncateInt64ToInt32).
    #UInt64::asUInt32 : translateUnaryPrimitiveInto(MIR::Operation::TruncateInt64ToInt32).
    #UInt64::asInt64 : translateUnaryPrimitiveInto(MIR::Operation::MoveInt64).
    #UInt64::asUInt64 : translateUnaryPrimitiveInto(MIR::Operation::MoveInt64).
    #UInt64::asFloat32 : translateUnaryPrimitiveInto(MIR::Operation::UInt64ToFloat32).
    #UInt64::asFloat64 : translateUnaryPrimitiveInto(MIR::Operation::UInt64ToFloat64).
    #UInt64::asIEEEFloat64Decoded : translateUnaryPrimitiveInto(MIR::Operation::IEEEUInt64ToFloat64). 

    ## Float32 primitives
    #Float32::negated : translateUnaryPrimitiveInto(MIR::Operation::Float32Negate).
    #Float32::sqrt : translateUnaryPrimitiveInto(MIR::Operation::Float32Sqrt).

    #Float32::+ : translateBinaryPrimitiveInto(MIR::Operation::Float32Add).
    #Float32::- : translateBinaryPrimitiveInto(MIR::Operation::Float32Sub).
    #Float32::* : translateBinaryPrimitiveInto(MIR::Operation::Float32Mul).
    #Float32::/ : translateBinaryPrimitiveInto(MIR::Operation::Float32Div).

    #Float32::= : translateBinaryPrimitiveInto(MIR::Operation::Float32UnorderedEquals).
    #Float32::~= : translateBinaryPrimitiveInto(MIR::Operation::Float32UnorderedNotEquals).
    #Float32::<=> : translateBinaryPrimitiveInto(MIR::Operation::Float32UnorderedCompare).
    #Float32::< : translateBinaryPrimitiveInto(MIR::Operation::Float32UnorderedLessThan).
    #Float32::<= : translateBinaryPrimitiveInto(MIR::Operation::Float32UnorderedLessOrEquals).
    #Float32::> : translateBinaryPrimitiveInto(MIR::Operation::Float32UnorderedGreaterThan).
    #Float32::>= : translateBinaryPrimitiveInto(MIR::Operation::Float32UnorderedGreaterOrEquals).

    #Float32::asChar8 : translateUnaryPrimitiveInto(MIR::Operation::Float32ToUInt8).
    #Float32::asInt8 : translateUnaryPrimitiveInto(MIR::Operation::Float32ToInt8).
    #Float32::asUInt8 : translateUnaryPrimitiveInto(MIR::Operation::Float32ToUInt8).
    #Float32::asChar16 : translateUnaryPrimitiveInto(MIR::Operation::Float32ToUInt16).
    #Float32::asInt16 : translateUnaryPrimitiveInto(MIR::Operation::Float32ToInt16).
    #Float32::asUInt16 : translateUnaryPrimitiveInto(MIR::Operation::Float32ToUInt16).
    #Float32::asChar32 : translateUnaryPrimitiveInto(MIR::Operation::Float32ToUInt32).
    #Float32::asInt32 : translateUnaryPrimitiveInto(MIR::Operation::Float32ToInt32).
    #Float32::asUInt32 : translateUnaryPrimitiveInto(MIR::Operation::Float32ToUInt32).
    #Float32::asInt64 : translateUnaryPrimitiveInto(MIR::Operation::Float32ToInt64).
    #Float32::asUInt64 : translateUnaryPrimitiveInto(MIR::Operation::Float32ToUInt64).
    #Float32::asFloat32 : translateUnaryPrimitiveInto(MIR::Operation::MoveFloat32).
    #Float32::asFloat64 : translateUnaryPrimitiveInto(MIR::Operation::Float32ToFloat64).
    #Float32::asIEEEFloat32Encoding : translateUnaryPrimitiveInto(MIR::Operation::Float32ToIEEEUInt32). 

    ## Float64 primitives
    #Float64::negated : translateUnaryPrimitiveInto(MIR::Operation::Float64Negate).
    #Float64::sqrt : translateUnaryPrimitiveInto(MIR::Operation::Float64Sqrt).

    #Float64::+ : translateBinaryPrimitiveInto(MIR::Operation::Float64Add).
    #Float64::- : translateBinaryPrimitiveInto(MIR::Operation::Float64Sub).
    #Float64::* : translateBinaryPrimitiveInto(MIR::Operation::Float64Mul).
    #Float64::/ : translateBinaryPrimitiveInto(MIR::Operation::Float64Div).

    #Float64::= : translateBinaryPrimitiveInto(MIR::Operation::Float64UnorderedEquals).
    #Float64::~= : translateBinaryPrimitiveInto(MIR::Operation::Float64UnorderedNotEquals).
    #Float64::<=> : translateBinaryPrimitiveInto(MIR::Operation::Float64UnorderedCompare).
    #Float64::< : translateBinaryPrimitiveInto(MIR::Operation::Float64UnorderedLessThan).
    #Float64::<= : translateBinaryPrimitiveInto(MIR::Operation::Float64UnorderedLessOrEquals).
    #Float64::> : translateBinaryPrimitiveInto(MIR::Operation::Float64UnorderedGreaterThan).
    #Float64::>= : translateBinaryPrimitiveInto(MIR::Operation::Float64UnorderedGreaterOrEquals).

    #Float64::asChar8 : translateUnaryPrimitiveInto(MIR::Operation::Float64ToUInt8).
    #Float64::asInt8 : translateUnaryPrimitiveInto(MIR::Operation::Float64ToInt8).
    #Float64::asUInt8 : translateUnaryPrimitiveInto(MIR::Operation::Float64ToUInt8).
    #Float64::asChar16 : translateUnaryPrimitiveInto(MIR::Operation::Float64ToUInt16).
    #Float64::asInt16 : translateUnaryPrimitiveInto(MIR::Operation::Float64ToInt16).
    #Float64::asUInt16 : translateUnaryPrimitiveInto(MIR::Operation::Float64ToUInt16).
    #Float64::asChar32 : translateUnaryPrimitiveInto(MIR::Operation::Float64ToUInt32).
    #Float64::asInt32 : translateUnaryPrimitiveInto(MIR::Operation::Float64ToInt32).
    #Float64::asUInt32 : translateUnaryPrimitiveInto(MIR::Operation::Float64ToUInt32).
    #Float64::asInt64 : translateUnaryPrimitiveInto(MIR::Operation::Float64ToInt64).
    #Float64::asUInt64 : translateUnaryPrimitiveInto(MIR::Operation::Float64ToUInt64).
    #Float64::asFloat32 : translateUnaryPrimitiveInto(MIR::Operation::Float64ToFloat32).
    #Float64::asFloat64 : translateUnaryPrimitiveInto(MIR::Operation::MoveFloat64).
    #Float64::asIEEEFloat64Encoding : translateUnaryPrimitiveInto(MIR::Operation::Float64ToIEEEUInt64). 
}.

HIRFunctionDefinitionMIRCodeGenerator extend: {
    public method compilePrimitiveFunctionBody => Boolean := {
        ## Attempt to use the primitive generator first.
        let primitiveGenerator := HIRTacPrimitiveCallGenerationTable atOrNil: ssaFunctionDefinition primitiveName.
        let hasGeneratedPrimitive mutable := false.
        primitiveGenerator ifNotNil: {
            functionBuilder basicBlock: #primitive build: {:(MIRBlockBuilder)asm :: Void |
                self blockBuilder: asm.
                let canonicalResultType := ssaFunctionDefinition functionType canonicalResultType.
                let result := canonicalResultType makeTacTemporaryValueNamed: #result withFunctionBuilder: functionBuilder.
                hasGeneratedPrimitive := primitiveGenerator(ssaFunctionDefinition arguments, result, self).
                canonicalResultType emitTacReturn: result withBlockBuilder: asm
            }.
        }.

        hasGeneratedPrimitive
    }.

    public method compileCall: (calledFunction: HIRValue) withArguments: (arguments: Array) unchecked: (isUnchecked: Boolean) into: (tacValue: MIRValue) type: (resultType: Type)::=> Void := {
        ## Attempt to use the primitive generator first.
        let primitiveGenerator := HIRTacPrimitiveCallGenerationTable atOrNil: calledFunction primitiveName.
        primitiveGenerator ifNotNil: {
            primitiveGenerator(arguments, tacValue, self) ifTrue: {
                return: void
            }
        }.

        ## If this is a pointer like type, then we must perform a direct call.
        calledFunction type isPointerLikeType ifTrue: {
            let entryPoint := self translateValue: calledFunction.
            let tacArguments := arguments collect: {:(HIRValue)eachArgument :: MIRValue | self translateValue: eachArgument}.
            resultType
                emitTacCall: entryPoint convention: self tacFunction compilationTarget defaultCallingConvention
                withArguments: tacArguments into: tacValue
                withBlockBuilder: self blockBuilder.
            return: void.
        }.

        isUnchecked ifTrue: {
            let calledFunctionType := calledFunction type.
            let canonicalResultType := calledFunctionType canonicalResultType.
            let canonicalResult := canonicalResultType == resultType
                ifTrue: (tacValue)
                ifFalse: (self tacFunction newTemporary: #callCanonicalResult withType: canonicalResultType).

            calledFunction isCaptureless ifTrue: {
                let entryPoint := self translateCapturelessUncheckedFunctionEntryPoint: calledFunction.
                let tacArguments := arguments collectWithIndex: {:(HIRValue)eachArgument :(Size)index :: MIRValue |
                    self translateValue: eachArgument withExpectedType: (calledFunctionType canonicalTypeForApplicationArgumentWithIndex: index)
                }.

                canonicalResultType
                    emitTacCall: entryPoint convention: self tacFunction compilationTarget defaultCallingConvention
                    withArguments: tacArguments into: canonicalResult
                    withBlockBuilder: self blockBuilder

            } ifFalse: {
                let tacCalledFunction := self translateValue: calledFunction.
                let entryPoint := self translateUncheckedFunctionEntryPoint: calledFunction functionType: calledFunctionType resultType: resultType argumentCount: arguments size.
                let tacArguments := arguments collectWithIndex: {:(HIRValue)eachArgument :(Size)index :: MIRValue |
                    self translateValue: eachArgument withExpectedType: (calledFunctionType canonicalTypeForApplicationArgumentWithIndex: index)
                }.

                canonicalResultType
                    emitTacCall: entryPoint convention: self tacFunction compilationTarget defaultCallingConvention
                    withArguments: (Array with: tacCalledFunction) -- tacArguments into: canonicalResult
                    withBlockBuilder: self blockBuilder
            }.

            canonicalResult ~~ tacValue ifTrue: {
                resultType emitTacCheckThenUnbox: canonicalResult into: tacValue withHIRCodeGenerator: self
            }
        } ifFalse: {
            let tacCalledFunction := self translateBoxedValue: calledFunction.
            let entryPoint := self translateCheckedFunctionEntryPoint: calledFunction argumentCount: arguments size.
            let tacArguments := arguments collect: {:(HIRValue)eachArgument :: MIRValue | self translateBoxedValue: eachArgument}.
            entryPoint ifNotNil: {
                resultType
                    emitTacUnboxingCall: entryPoint convention: self tacFunction compilationTarget defaultCallingConvention
                    withArguments: (Array with: tacCalledFunction) -- tacArguments into: tacValue
                    withHIRCodeGenerator: self.
            } ifNil: {
                self blockBuilder trap
            }.
        }.
    }.
}.

HIRCallInstruction extend: {
    public override method compileIntoTacValue: (tacValue: MIRValue) with: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> Void := {
        codegen compileCall: calledFunction withArguments: arguments unchecked: isUnchecked into: tacValue type: self type
    }.
}.

HIRBitcastInstruction extend: {
    public override method compileIntoTacValue: (tacValue: MIRValue) with: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> Void := {
        ## FIXME: Add support for non-pointer values.
        codegen blockBuilder movePointer: (codegen translateValue: self value) into: tacValue
    }.
}.

HIRCoerceValueInstruction extend: {
    public override method compileIntoTacValue: (tacValue: MIRValue) with: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> Void := {
        self type emitTacCoerceInto: (codegen translateValue: self targetType) thenUnbox: (codegen translateValue: self value) into: tacValue withHIRCodeGenerator: codegen
    }.
}.

HIRDownCastInstruction extend: {
    public override method compileIntoTacValue: (tacValue: MIRValue) with: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> Void := {
        isUnchecked ifTrue: {
            self type emitTacUncheckedUnbox: (codegen translateValue: self value) into: tacValue withHIRCodeGenerator: codegen
        } ifFalse: {
            self targetType isLiteralConstant ifTrue: {
                self type emitTacCheckThenUnbox: (codegen translateValue: self value) into: tacValue withHIRCodeGenerator: codegen
            } ifFalse: {
                self type emitTacCheckInto: (codegen translateValue: self targetType) thenUnbox: (codegen translateValue: self value) into: tacValue withHIRCodeGenerator: codegen
            }.
        }
    }.
}.

HIRLoadInstruction extend: {
    public override method compileIntoTacValue: (tacValue: MIRValue) with: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> Void := {
        (codegen localOnlyAllocaDictionary atOrNil: self storage) ifNotNil: {:(MIRValue)localOnlyAlloca :: Void | 
            self type emitTacMove: localOnlyAlloca into: tacValue withBlockBuilder: codegen blockBuilder
        } ifNil: {
            self type emitTacLoadFromPointer: (codegen translateValue: self storage) constantOffset: 0i64 into: tacValue withBlockBuilder: codegen blockBuilder
        }
    }.
}.

HIRMakeArrayInstruction extend: {
    public override method compileIntoTacValue: (tacValue: MIRValue) with: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> Void := {
        codegen blockBuilder callPointer: (codegen translateRuntimeFunction: ObjectModel::makeArrayWithSize)
            with: (codegen blockBuilder pointerConstantWith: self elements size asUInt64)
            result: tacValue.

        let headerSize := (self type objectHeaderSizeForObjectModel: codegen compilationTarget objectModel) asInt64.
        let pointerSize := codegen compilationTarget pointerSize asInt64.

        self elements doWithIndex: {:(HIRValue)eachElement :(Size)eachElementIndex :: Void |
            let eachElementValue := codegen translateBoxedValue: eachElement.
            codegen blockBuilder storePointer: eachElementValue into: tacValue constantOffset: headerSize + (eachElementIndex asInt64 * pointerSize)
        }.
    }.
}.

HIRMakeAssociationInstruction extend: {
    public override method compileIntoTacValue: (tacValue: MIRValue) with: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> Void := {
        codegen blockBuilder callPointer: (codegen translateRuntimeFunction: ObjectModel::makeAssociation)
            with: (codegen translateBoxedValue: self key)
            with: (codegen translateBoxedValue: self value)
            result: tacValue.
    }.
}.

HIRMakeByteArrayInstruction extend: {
    public override method compileIntoTacValue: (tacValue: MIRValue) with: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> Void := {
        codegen blockBuilder callPointer: (codegen translateRuntimeFunction: ObjectModel::makeByteArrayWithSize)
            with: (codegen blockBuilder pointerConstantWith: self elements size asUInt64)
            result: tacValue.

        let headerSize := (self type objectHeaderSizeForObjectModel: codegen compilationTarget objectModel) asInt64.
        let pointerSize := codegen compilationTarget pointerSize asInt64.

        self elements doWithIndex: {:(HIRValue)eachElement :(Size)eachElementIndex :: Void |
            let eachElementValue := codegen translateValue: eachElement.

            codegen blockBuilder storeInt8: eachElementValue into: tacValue constantOffset: headerSize + (eachElementIndex asInt64 * pointerSize)
        }.
    }.
}.

HIRMakeClosureInstruction extend: {
    public override method compileIntoTacValue: (tacValue: MIRValue) with: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> Void := {
        let captureVectorType := SequenceTupleTypeTemplate(self captures collect: {:(HIRValue)eachCapture :: Type | eachCapture type ifNil: Untyped}).
        let tacCaptureVector := codegen blockBuilder function newTemporary: #captureVector withType: captureVectorType.

        ## Allocate the capture vector.
        codegen blockBuilder
            callPointer: (codegen translateRuntimeFunction: ObjectModel::allocateCaptureVectorOfType)
            with: (codegen moduleCodeGenerator translateGenericObjectPointer: captureVectorType)
            result: tacCaptureVector.

        ## Fill the capture vector.
        let headerSize := captureVectorType objectHeaderSizeForObjectModel: codegen compilationTarget objectModel.
        self captures doWithIndex: {:(HIRValue)eachCapture :(Size)eachCaptureIndex :: Void |
            let captureVectorSlot := captureVectorType slots at: eachCaptureIndex.
            eachCapture type
                emitTacStore: (codegen translateValue: eachCapture)
                intoPointer: tacCaptureVector constantOffset: headerSize asInt64 + captureVectorSlot validOffset asInt64
                withBlockBuilder: codegen blockBuilder
        }.

        ## Create the closure.
        codegen blockBuilder
            callPointer: (codegen translateRuntimeFunction: ObjectModel::makeClosureWithCaptureVector)
            with: (codegen translateValue: functionDefinition) with: tacCaptureVector
            result: tacValue
    }.
}.

HIRMakeDictionaryInstruction extend: {
    public override method compileIntoTacValue: (tacValue: MIRValue) with: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> Void := {
        codegen blockBuilder callPointer: (codegen translateRuntimeFunction: ObjectModel::makeByteArrayWithSize)
            with: (codegen blockBuilder pointerConstantWith: self elements size asUInt64)
            result: tacValue.

        let addFunction := codegen translateRuntimeFunction: ObjectModel::Dictionary::add.
        self elements do: {:(HIRValue)eachElement :(Size)eachElementIndex :: Void |
            let eachElementValue := codegen translateValue: eachElement.
            codegen blockBuilder callVoid: addFunction with: tacValue with: eachElementValue
        }.
    }.
}.

HIRSendInstruction extend: {
    public override method compileIntoTacValue: (tacValue: MIRValue) with: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> Void := {
        let tacReceiver := codegen translateBoxedValue: self receiver.
        let tacReceiverLookupType := self receiverLookupType ifNotNil: (codegen translateBoxedValue: self receiverLookupType).
        let tacSelector := codegen translateBoxedValue: self selector.
        let tacArguments := self arguments collect: {:(HIRValue)eachArgument :: MIRValue | codegen translateBoxedValue: eachArgument}.

        tacReceiverLookupType ifNil: {
            let trampoline := codegen translateRuntimeFunction: (ObjectModel::SendTrampolines at: self arguments size).
            self type
                emitTacUnboxingCall: trampoline convention: trampoline callingConvention
                withArguments: (Array with: MIRPolymorphicInlineCache new with: tacReceiver with: tacSelector) -- tacArguments into: tacValue
                withHIRCodeGenerator: codegen.
        } ifNotNil: {
            let trampoline := codegen translateRuntimeFunction: (ObjectModel::SendWithReceiverTypeTrampolines at: self arguments size).
            self type
                emitTacUnboxingCall: trampoline convention: trampoline callingConvention
                withArguments: (Array with: MIRPolymorphicInlineCache new with: tacReceiver with: tacReceiverLookupType with: tacSelector) -- tacArguments into: tacValue
                withHIRCodeGenerator: codegen.
        }.
    }.
}.

HIRSetDebugValueForBindingInstruction extend: {
    public override method compileIntoTacValue: (tacValue: MIRValue) with: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> Void := {
        (codegen localOnlyAllocaDictionary atOrNil: self value) ifNotNil: {:(MIRValue)localOnlyAlloca :: Void | 
            codegen blockBuilder debugSetMutableBinding: self binding value: localOnlyAlloca
        } ifNil: {
            codegen blockBuilder debugSetBinding: self binding value: (codegen translateValue: self value)
        }.
    }.
}.

HIRStoreInstruction extend: {
    public override method compileIntoTacValue: (tacValue: MIRValue) with: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> Void := {
        let pointerType := self storage type.
        self assert: pointerType isPointerLikeType.
        let baseType := (pointerType downCastTo: PointerLikeType) baseType.
        let valueToStore := codegen translateValue: self value withExpectedType: baseType.
        valueToStore ifNil: {return: void}.

        (codegen localOnlyAllocaDictionary atOrNil: self storage) ifNotNil: {:(MIRValue)localOnlyAlloca :: Void | 
            baseType emitTacMove: valueToStore into: localOnlyAlloca withBlockBuilder: codegen blockBuilder
        } ifNil: {
            baseType emitTacStore: valueToStore intoPointer: (codegen translateValue: self storage) constantOffset: 0i64 withBlockBuilder: codegen blockBuilder
        }
    }.
}.

HIRPointerElementAtInstruction extend: {
    public override method compileIntoTacValue: (tacValue: MIRValue) with: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> Void := {
        let pointerValue := codegen translateValue: self pointer.
        let indexValue := codegen translateValue: self index.
        let elementSize := (self pointer type downCastTo: PointerLikeType) baseType alignedValueSize.
        codegen blockBuilder loadEffectiveAddress: pointerValue index: indexValue constantScale: elementSize asInt64 into: tacValue
    }.
}.

HIRReferenceElementAtInstruction extend: {
    public override method compileIntoTacValue: (tacValue: MIRValue) with: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> Void := {
        let referenceValue := codegen translateValue: self reference.
        let indexValue := codegen translateValue: self index.
        let referencedType := (self reference type downCastTo: PointerLikeType) baseType.
        referencedType emitTacReference: referenceValue elementPointerAt: indexValue into: tacValue withBlockBuilder: codegen blockBuilder
    }.
}.

HIRTypeSlotReferenceAtInstruction extend: {
    public override method compileIntoTacValue: (tacValue: MIRValue) with: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> Void := {
        let pointerValue := codegen translateValue: self tuple.
        let headerSize := (self tuple type ifNil: AnyValue) objectHeaderSizeForObjectModel: codegen compilationTarget objectModel.
        codegen blockBuilder addPointer: pointerValue constantOffset: headerSize asInt64 + self typeSlot validOffset asInt64 into: tacValue
    }.
}.

HIRTypeSlotAtInstruction extend: {
    public override method compileIntoTacValue: (tacValue: MIRValue) with: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> Void := {
        let headerSize := (self tuple type ifNil: AnyValue) objectHeaderSizeForObjectModel: codegen compilationTarget objectModel.
        self type emitTacLoadFromPointer: (codegen translateValue: self tuple) constantOffset: headerSize asInt64 + self typeSlot validOffset asInt64 into: tacValue withBlockBuilder: codegen blockBuilder
    }.
}.

HIRTypeSlotAtPutInstruction extend: {
    public override method compileIntoTacValue: (tacValue: MIRValue) with: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> Void := {
        let headerSize := (self tuple type ifNil: AnyValue) objectHeaderSizeForObjectModel: codegen compilationTarget objectModel.
        self value type emitTacStore: (codegen translateValue: self value) intoPointer: (codegen translateValue: self tuple) constantOffset: headerSize asInt64 + self typeSlot validOffset asInt64 withBlockBuilder: codegen blockBuilder
    }.
}.

HIRReturnInstruction extend: {
    public override method compileIntoTacValue: (tacValue: MIRValue) with: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> Void := {
        (self value type isSubtypeOf: ControlFlowEscapeType) ifTrue: {return: void}.

        let canonicalResultType := codegen ssaFunctionDefinition functionType canonicalResultType.
        canonicalResultType emitTacReturn: (codegen translateValue: self value withExpectedType: canonicalResultType) withBlockBuilder: codegen blockBuilder
    }.
}.

HIRUnreachableInstruction extend: {
    public override method compileIntoTacValue: (tacValue: MIRValue) with: (codegen: HIRFunctionDefinitionMIRCodeGenerator) ::=> Void := {
        codegen blockBuilder unreachableTrap
    }.
}.

HIRModule extend: {
    public method asMIRModuleFor: (target: MIRCompilationTarget) ::=> MIRModule
        := HIRModuleMIRCodeGenerator new
            initializeWithTarget: target;
            compileHIRModule: self;
            finish
}.
