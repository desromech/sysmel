public final class Dwarf::AsmWriter superclass: Object.
public final class Dwarf::DebugInfoEntry superclass: Object.

public final class Dwarf::Constant superclass: AsmConstantExpressionInteger; definition: {
    public field name => Symbol.

    public override method printOn: (stream: Stream) ::=> Void := {
        stream string: name
    }.
}.

#(
    (DW_SECT_INFO 1 '.debug_info.dwo')
    (DW_SECT_ABBREV 3 '.debug_abbrev.dwo')
    (DW_SECT_LINE 4 '.debug_line.dwo')
    (DW_SECT_LOCLISTS 5 '.debug_loclists.dwo')
    (DW_SECT_STR_OFFSETS 6 '.debug_str_offsets.d')
    (DW_SECT_MACRO 7 '.debug_macro.dwo')
    (DW_SECT_RNGLISTS 8 '.debug_rnglists.dwo')
    
    (DW_UT_compile  1)
    (DW_UT_type  2)
    (DW_UT_partial  3)
    (DW_UT_skeleton  4)
    (DW_UT_split_compile  5)
    (DW_UT_split_type  6)
    (DW_UT_lo_user  128)
    (DW_UT_hi_user  15)
    
    (DW_TAG_array_type 1)
    (DW_TAG_class_type 2)
    (DW_TAG_entry_point 3)
    (DW_TAG_enumeration_type 4)
    (DW_TAG_formal_parameter 5)
    (DW_TAG_imported_declaration 8)
    (DW_TAG_label 10)
    (DW_TAG_lexical_block 11)
    (DW_TAG_member 13)
    (DW_TAG_pointer_type 15)
    (DW_TAG_reference_type 16)
    (DW_TAG_compile_unit 17)
    (DW_TAG_string_type 18)
    (DW_TAG_structure_type 19)
    (DW_TAG_subroutine_type 21)
    (DW_TAG_typedef 22)
    (DW_TAG_union_type 23)
    (DW_TAG_unspecified_parameters 24)
    (DW_TAG_variant 25)
    (DW_TAG_common_block 26)
    (DW_TAG_common_inclusion 27)
    (DW_TAG_inheritance 28)
    (DW_TAG_inlined_subroutine 29)
    (DW_TAG_module 30)
    (DW_TAG_ptr_to_member_type 31)
    (DW_TAG_set_type 32)
    (DW_TAG_subrange_type 33)
    (DW_TAG_with_stmt 34)
    (DW_TAG_access_declaration 35)
    (DW_TAG_base_type 36)
    (DW_TAG_catch_block 37)
    (DW_TAG_const_type 38)
    (DW_TAG_constant 39)
    (DW_TAG_enumerator 40)
    (DW_TAG_file_type 41)
    (DW_TAG_friend 42)
    (DW_TAG_namelist 43)
    (DW_TAG_namelist_item 44)
    (DW_TAG_packed_type 45)
    (DW_TAG_subprogram 46)
    (DW_TAG_template_type_parameter 47)
    (DW_TAG_template_value_parameter 48)
    (DW_TAG_thrown_type 49)
    (DW_TAG_try_block 50)
    (DW_TAG_variant_part 51)
    (DW_TAG_variable 52)
    (DW_TAG_volatile_type 53)
    (DW_TAG_dwarf_procedure 54)
    (DW_TAG_restrict_type 55)
    (DW_TAG_interface_type 56)
    (DW_TAG_namespace 57)
    (DW_TAG_imported_module 58)
    (DW_TAG_unspecified_type 59)
    (DW_TAG_partial_unit 60)
    (DW_TAG_imported_unit 61)
    (DW_TAG_condition 63)
    (DW_TAG_shared_type 64)
    (DW_TAG_type_unit 65)
    (DW_TAG_rvalue_reference_type 66)
    (DW_TAG_template_alias 67)
    (DW_TAG_coarray_type  68)
    (DW_TAG_generic_subrange  69)
    (DW_TAG_dynamic_type  70)
    (DW_TAG_atomic_type  71)
    (DW_TAG_call_site  72)
    (DW_TAG_call_site_parameter  73)
    (DW_TAG_skeleton_unit  74)
    (DW_TAG_immutable_type  75)
    (DW_TAG_lo_user 1032)
    (DW_TAG_hi_user 15)
    
    (DW_CHILDREN_no 0)
    (DW_CHILDREN_yes 1)
    
    (DW_AT_sibling 1 'reference')
    (DW_AT_location 2 '"exprloc' ' loclist"')
    (DW_AT_name 3 'string')
    (DW_AT_ordering 9 'constant')
    (DW_AT_byte_size 11 '"constant' ' exprloc' ' reference"')
    (DW_AT_bit_size 13 '"constant' ' exprloc' ' reference"')
    (DW_AT_stmt_list 16 'lineptr')
    (DW_AT_low_pc 17 'address')
    (DW_AT_high_pc 18 '"address' ' constant"')
    (DW_AT_language 19 'constant')
    (DW_AT_discr 21 'reference')
    (DW_AT_discr_value 22 'constant')
    (DW_AT_visibility 23 'constant')
    (DW_AT_import 24 'reference')
    (DW_AT_string_length 25 '"exprloc' ' loclist' ' reference"')
    (DW_AT_common_reference 26 'reference')
    (DW_AT_comp_dir 27 'string')
    (DW_AT_const_value 28 '"block' ' constant' ' string"')
    (DW_AT_containing_type 29 'reference')
    (DW_AT_default_value 30 '"constant' ' reference' ' flag"')
    (DW_AT_inline 32 'constant')
    (DW_AT_is_optional 33 'flag')
    (DW_AT_lower_bound 34 '"constant' ' exprloc' ' reference"')
    (DW_AT_producer 37 'string')
    (DW_AT_prototyped 39 'flag')
    (DW_AT_return_addr 42 '"exprloc' ' loclist"')
    (DW_AT_start_scope 44 '"constant' ' rnglist"')
    (DW_AT_bit_stride 46 '"constant' ' exprloc' ' reference"')
    (DW_AT_upper_bound 47 '"constant' ' exprloc' ' reference"')
    (DW_AT_abstract_origin 49 'reference')
    (DW_AT_accessibility 50 'constant')
    (DW_AT_address_class 51 'constant')
    (DW_AT_artificial 52 'flag')
    (DW_AT_base_types 53 'reference')
    (DW_AT_calling_convention 54 'constant')
    (DW_AT_count 55 '"constant' ' exprloc' ' reference"')
    (DW_AT_data_member_location 56 '"constant' ' exprloc' ' loclist"')
    (DW_AT_decl_column 57 'constant')
    (DW_AT_decl_file 58 'constant')
    (DW_AT_decl_line 59 'constant')
    (DW_AT_declaration 60 'flag')
    (DW_AT_discr_list 61 'block')
    (DW_AT_encoding 62 'constant')
    (DW_AT_external 63 'flag')
    (DW_AT_frame_base 64 '"exprloc' ' loclist"')
    (DW_AT_friend 65 'reference')
    (DW_AT_identifier_case 66 'constant')
    (DW_AT_namelist_item 68 'reference')
    (DW_AT_priority 69 'reference')
    (DW_AT_segment 70 '"exprloc' ' loclist"')
    (DW_AT_specification 71 'reference')
    (DW_AT_static_link 72 '"exprloc' ' loclist"')
    (DW_AT_type 73 'reference')
    (DW_AT_use_location 74 '"exprloc' ' loclist"')
    (DW_AT_variable_parameter 75 'flag')
    (DW_AT_virtuality 76 'constant')
    (DW_AT_vtable_elem_location 77 '"exprloc' ' loclist"')
    (DW_AT_allocated 78 '"constant' ' exprloc' ' reference"')
    (DW_AT_associated 79 '"constant' ' exprloc' ' reference"')
    (DW_AT_data_location 80 'exprloc')
    (DW_AT_byte_stride 81 '"constant' ' exprloc' ' reference"')
    (DW_AT_entry_pc 82 '"address' ' constant"')
    (DW_AT_use_UTF8 83 'flag')
    (DW_AT_extension 84 'reference')
    (DW_AT_ranges 85 'rnglist')
    (DW_AT_trampoline 86 '"address' ' flag' ' reference' ' string"')
    (DW_AT_call_column 87 'constant')
    (DW_AT_call_file 88 'constant')
    (DW_AT_call_line 89 'constant')
    (DW_AT_description 90 'string')
    (DW_AT_binary_scale 91 'constant')
    (DW_AT_decimal_scale 92 'constant')
    (DW_AT_small 93 'reference')
    (DW_AT_decimal_sign 94 'constant')
    (DW_AT_digit_count 95 'constant')
    (DW_AT_picture_string 96 'string')
    (DW_AT_mutable 97 'flag')
    (DW_AT_threads_scaled 98 'flag')
    (DW_AT_explicit 99 'flag')
    (DW_AT_object_pointer 100 'reference')
    (DW_AT_endianity 101 'constant')
    (DW_AT_elemental 102 'flag')
    (DW_AT_pure 103 'flag')
    (DW_AT_recursive 104 'flag')
    (DW_AT_signature 105 'reference')
    (DW_AT_main_subprogram 106 'flag')
    (DW_AT_data_bit_offset 107 'constant')
    (DW_AT_const_expr 108 'flag')
    (DW_AT_enum_class 109 'flag')
    (DW_AT_linkage_name 110 'string')
    (DW_AT_string_length_bit_size  111 'constant')
    (DW_AT_string_length_byte_size  112 'constant')
    (DW_AT_rank  113 '"constant' ' exprloc"')
    (DW_AT_str_offsets_base  114 'stroffsetsptr')
    (DW_AT_addr_base  115 'addrptr')
    (DW_AT_rnglists_base  116 'rnglistsptr')
    (DW_AT_dwo_name  118 'string')
    (DW_AT_reference  119 'flag')
    (DW_AT_rvalue_reference  120 'flag')
    (DW_AT_macros  121 'macptr')
    (DW_AT_call_all_calls  122 'flag')
    (DW_AT_call_all_source_calls  123 'flag')
    (DW_AT_call_all_tail_calls  124 'flag')
    (DW_AT_call_return_pc  125 'address')
    (DW_AT_call_value  126 'exprloc')
    (DW_AT_call_origin  127 'exprloc')
    (DW_AT_call_parameter  128 'reference')
    (DW_AT_call_pc  129 'address')
    (DW_AT_call_tail_call  130 'flag')
    (DW_AT_call_target  131 'exprloc')
    (DW_AT_call_target_clobbered  132 'exprloc')
    (DW_AT_call_data_location  133 'exprloc')
    (DW_AT_call_data_value  134 'exprloc')
    (DW_AT_noreturn  135 'flag')
    (DW_AT_alignment  136 'constant')
    (DW_AT_export_symbols  137 'flag')
    (DW_AT_deleted  138 'flag')
    (DW_AT_defaulted  139 'constant')
    (DW_AT_loclists_base  140 'loclistsptr')
    (DW_AT_lo_user 8192 '—')
    (DW_AT_hi_user 63 '—')
    
    (DW_FORM_addr 1 'address')
    (DW_FORM_block2 3 'block')
    (DW_FORM_block4 4 'block')
    (DW_FORM_data2 5 'constant')
    (DW_FORM_data4 6 'constant')
    (DW_FORM_data8 7 'constant')
    (DW_FORM_string 8 'string')
    (DW_FORM_block 9 'block')
    (DW_FORM_block1 10 'block')
    (DW_FORM_data1 11 'constant')
    (DW_FORM_flag 12 'flag')
    (DW_FORM_sdata 13 'constant')
    (DW_FORM_strp 14 'string')
    (DW_FORM_udata 15 'constant')
    (DW_FORM_ref_addr 16 'reference')
    (DW_FORM_ref1 17 'reference')
    (DW_FORM_ref2 18 'reference')
    (DW_FORM_ref4 19 'reference')
    (DW_FORM_ref8 20 'reference')
    (DW_FORM_ref_udata 21 'reference')
    (DW_FORM_indirect 22 '(see Section 7.5.3 on page 203)')
    (DW_FORM_sec_offset 23 '"addrptr' ' lineptr' ' loclist' ' loclistsptr' '"')
    (DW_FORM_exprloc 24 'exprloc')
    (DW_FORM_flag_present 25 'flag')
    (DW_FORM_strx  26 'string')
    (DW_FORM_addrx  27 'address')
    (DW_FORM_ref_sup4  28 'reference')
    (DW_FORM_strp_sup  29 'string')
    (DW_FORM_data16  30 'constant')
    (DW_FORM_line_strp  31 'string')
    (DW_FORM_ref_sig8 32 'reference')
    (DW_FORM_implicit_const  33 'constant')
    (DW_FORM_loclistx  34 'loclist')
    (DW_FORM_rnglistx  35 'rnglist')
    (DW_FORM_ref_sup8  36 'reference')
    (DW_FORM_strx1  37 'string')
    (DW_FORM_strx2  38 'string')
    (DW_FORM_strx3  39 'string')
    (DW_FORM_strx4  40 'string')
    (DW_FORM_addrx1  41 'address')
    (DW_FORM_addrx2  42 'address')
    (DW_FORM_addrx3  43 'address')
    (DW_FORM_addrx4  44 'address')
    
    (DW_OP_addr 3 '1' 'constant address')
    (DW_OP_deref 6 '0' '')
    (DW_OP_const1u 8 '1' '1-byte constant')
    (DW_OP_const1s 9 '1' '1-byte constant')
    (DW_OP_const2u 10 '1' '2-byte constant')
    (DW_OP_const2s 11 '1' '2-byte constant')
    (DW_OP_const4u 12 '1' '4-byte constant')
    (DW_OP_const4s 13 '1' '4-byte constant')
    (DW_OP_const8u 14 '1' '8-byte constant')
    (DW_OP_const8s 15 '1' '8-byte constant')
    (DW_OP_constu 16 '1' 'ULEB128 constant')
    (DW_OP_consts 17 '1' 'SLEB128 constant')
    (DW_OP_dup 18 '0' '')
    (DW_OP_drop 19 '0' '')
    (DW_OP_over 20 '0' '')
    (DW_OP_pick 21 '1' '1-byte stack index')
    (DW_OP_swap 22 '0' '')
    (DW_OP_reg0 16r50 '0' '')
    (DW_OP_breg0 16r70 '1' '')
    (DW_OP_regx 16r90 '1' '')
    (DW_OP_fbreg 16r91 '1' '')
    (DW_OP_bregx 16r92 '1' '')
    (DW_OP_entry_value  163 '2' '"ULEB128 size' '"')
    (DW_OP_const_type  164 '3' '"ULEB128 type entry offset' '"')
    (DW_OP_regval_type  165 '2' '"ULEB128 register number' '"')
    (DW_OP_deref_type  166 '2' '"1-byte size' '"')
    (DW_OP_xderef_type  167 '2' '"1-byte size' '"')
    (DW_OP_convert  168 '1' 'ULEB128 type entry offset')
    (DW_OP_reinterpret  169 '1' 'ULEB128 type entry offset')
    (DW_OP_lo_user 224 '' '')
    (DW_OP_hi_user 15 '' '')
    
    (DW_LLE_end_of_list  0)
    (DW_LLE_base_addressx  1)
    (DW_LLE_startx_endx  2)
    (DW_LLE_startx_length  3)
    (DW_LLE_offset_pair  4)
    (DW_LLE_default_location  5)
    (DW_LLE_base_address  6)
    (DW_LLE_start_end  7)
    (DW_LLE_start_length  8)
    
    (DW_ATE_address 1)
    (DW_ATE_boolean 2)
    (DW_ATE_complex_float 3)
    (DW_ATE_float 4)
    (DW_ATE_signed 5)
    (DW_ATE_signed_char 6)
    (DW_ATE_unsigned 7)
    (DW_ATE_unsigned_char 8)
    (DW_ATE_imaginary_float 9)
    (DW_ATE_packed_decimal 10)
    (DW_ATE_numeric_string 11)
    (DW_ATE_edited 12)
    (DW_ATE_signed_fixed 13)
    (DW_ATE_unsigned_fixed 14)
    (DW_ATE_decimal_float 15)
    (DW_ATE_UTF 16)
    (DW_ATE_UCS  17)
    (DW_ATE_ASCII  18)
    (DW_ATE_lo_user 128)
    (DW_ATE_hi_user 15)
    
    (DW_DS_unsigned 1)
    (DW_DS_leading_overpunch 2)
    (DW_DS_trailing_overpunch 3)
    (DW_DS_leading_separate 4)
    (DW_DS_trailing_separate 5)
    
    (DW_END_default 0)
    (DW_END_big 1)
    (DW_END_little 2)
    (DW_END_lo_user 64)
    (DW_END_hi_user 15)
    
    (DW_ACCESS_public 1)
    (DW_ACCESS_protected 2)
    (DW_ACCESS_private 3)
    
    (DW_VIS_local 1)
    (DW_VIS_exported 2)
    (DW_VIS_qualified 3)
    
    (DW_VIRTUALITY_none 0)
    (DW_VIRTUALITY_virtual 1)
    (DW_VIRTUALITY_pure_virtual 2)
    
    (DW_LANG_C89 1 '0')
    (DW_LANG_C 2 '0')
    (DW_LANG_Ada83  3 '1')
    (DW_LANG_C_plus_plus 4 '0')
    (DW_LANG_Cobol74  5 '1')
    (DW_LANG_Cobol85  6 '1')
    (DW_LANG_Fortran77 7 '1')
    (DW_LANG_Fortran90 8 '1')
    (DW_LANG_Pascal83 9 '1')
    (DW_LANG_Modula2 10 '1')
    (DW_LANG_Java 11 '0')
    (DW_LANG_C99 12 '0')
    (DW_LANG_Ada95  13 '1')
    (DW_LANG_Fortran95 14 '1')
    (DW_LANG_PLI  15 '1')
    (DW_LANG_ObjC 16 '0')
    (DW_LANG_ObjC_plus_plus 17 '0')
    (DW_LANG_UPC 18 '0')
    (DW_LANG_D 19 '0')
    (DW_LANG_Python  20 '0')
    (DW_LANG_OpenCL  21 '0')
    (DW_LANG_Go  22 '0')
    (DW_LANG_Modula3  23 '1')
    (DW_LANG_Haskell  24 '0')
    (DW_LANG_C_plus_plus_03  25 '0')
    (DW_LANG_C_plus_plus_11  26 '0')
    (DW_LANG_OCaml  27 '0')
    (DW_LANG_Rust  28 '0')
    (DW_LANG_C11  29 '0')
    (DW_LANG_Swift  30 '0')
    (DW_LANG_Julia  31 '1')
    (DW_LANG_Dylan  32 '0')
    (DW_LANG_C_plus_plus_14  33 '0')
    (DW_LANG_Fortran03  34 '1')
    (DW_LANG_Fortran08  35 '1')
    (DW_LANG_RenderScript  36 '0')
    (DW_LANG_BLISS  37 '0')
    (DW_LANG_lo_user 32768 '')
    (DW_LANG_hi_user 15 '')
    
    (DW_ID_case_sensitive 0)
    (DW_ID_up_case 1)
    (DW_ID_down_case 2)
    (DW_ID_case_insensitive 3)
    
    (DW_CC_normal 1)
    (DW_CC_program 2)
    (DW_CC_nocall 3)
    (DW_CC_pass_by_reference  4)
    (DW_CC_pass_by_value  5)
    (DW_CC_lo_user 64)
    
    (DW_INL_not_inlined 0)
    (DW_INL_inlined 1)
    (DW_INL_declared_not_inlined 2)
    (DW_INL_declared_inlined 3)
    
    (DW_ORD_row_major 0)
    (DW_ORD_col_major 1)
    
    (DW_DSC_label 0)
    (DW_DSC_range 1)
    
    (DW_IDX_compile_unit  1 'constant')
    (DW_IDX_type_unit  2 'constant')
    (DW_IDX_die_offset  3 'reference')
    (DW_IDX_parent  4 'constant')
    (DW_IDX_type_hash  5 'DW_FORM_data8')
    (DW_IDX_lo_user  8192 '')
    (DW_IDX_hi_user  63 '')
    
    (DW_DEFAULTED_no  0)
    (DW_DEFAULTED_in_class  1)
    (DW_DEFAULTED_out_of_class  2)
    
    (DW_LNS_copy 1)
    (DW_LNS_advance_pc 2)
    (DW_LNS_advance_line 3)
    (DW_LNS_set_file 4)
    (DW_LNS_set_column 5)
    (DW_LNS_negate_stmt 6)
    (DW_LNS_set_basic_block 7)
    (DW_LNS_const_add_pc 8)
    (DW_LNS_fixed_advance_pc 9)
    (DW_LNS_set_prologue_end 10)
    (DW_LNS_set_epilogue_begin 11)
    (DW_LNS_set_isa 12)

    (DW_LNE_end_sequence 1)
    (DW_LNE_set_address 2)
    (DW_LNE_set_discriminator 4)
    (DW_LNE_lo_user 128)
    (DW_LNE_hi_user 15)
    
    (DW_LNCT_path  1)
    (DW_LNCT_directory_index  2)
    (DW_LNCT_timestamp  3)
    (DW_LNCT_size  4)
    (DW_LNCT_MD5  5)
    (DW_LNCT_lo_user  8192)
    (DW_LNCT_hi_user  63)
    
    (DW_MACRO_define 1)
    (DW_MACRO_undef  2)
    (DW_MACRO_start_file  3)
    (DW_MACRO_end_file  4)
    (DW_MACRO_define_strp  5)
    (DW_MACRO_undef_strp  6)
    (DW_MACRO_import  7)
    (DW_MACRO_define_sup  8)
    (DW_MACRO_undef_sup  9)
    (DW_MACRO_import_sup  10)
    (DW_MACRO_define_strx  11)
    (DW_MACRO_undef_strx  12)
    (DW_MACRO_lo_user  224)
    (DW_MACRO_hi_user  15)
    
    (DW_RLE_end_of_list  0)
    (DW_RLE_base_addressx  1)
    (DW_RLE_startx_endx  2)
    (DW_RLE_startx_length  3)
    (DW_RLE_offset_pair  4)
    (DW_RLE_base_address  5)
    (DW_RLE_start_end  6)
    (DW_RLE_start_length  7)
) do: {:(Array)constantDescription |
    let name := constantDescription first.
    let value := constantDescription second i64.

    let constant := Dwarf::Constant new name: name; value: value; yourself.
    let constantPublicSymbol := ("Dwarf::" -- name asString) asSymbol.
    __OwnerProgramEntity__ setPublicSymbol: constantPublicSymbol value: constant
}.

public abstract class Dwarf::ExpressionInstruction superclass: Object; definition: {
    public abstract method computeSizeForWritingWith: (writer: Dwarf::AsmWriter) ::=> Size
        := self subclassResponsibility.

    public abstract method writeWith: (writer: Dwarf::AsmWriter) ::=> Void
        := self subclassResponsibility.

    public method sizeForRegister: (register: UInt32) with: (writer: Dwarf::AsmWriter) ::=> Size
        := register <= 31u32 ifTrue: 1sz ifFalse: (1sz + (writer uleb128Size: register asUInt64)).

    public method writeRegister: (register: UInt32) with: (writer: Dwarf::AsmWriter) ::=> Void := {
        register <= 31u32 ifTrue: {
            writer activeStream byte: (Dwarf::DW_OP_reg0 value asUInt32 + register) asUInt8
        } ifFalse: {
            writer activeStream 
                byte: Dwarf::DW_OP_regx value asUInt8;
                uleb128: register asUInt64.
        }
    }.
}.

public final class Dwarf::ExpressionInstructionOpcode superclass: Dwarf::ExpressionInstruction; definition: {
    public field opcode => UInt8.
}.

public final class Dwarf::ExpressionInstructionRegister superclass: Dwarf::ExpressionInstruction; definition: {
    public field register => UInt32.

    public override method computeSizeForWritingWith: (writer: Dwarf::AsmWriter) ::=> Size
        := self sizeForRegister: register with: writer.

    public override method writeWith: (writer: Dwarf::AsmWriter) ::=> Void
        := self writeRegister: register with: writer.
}.

public final class Dwarf::ExpressionInstructionFrameOffset superclass: Dwarf::ExpressionInstruction; definition: {
    public field offset => Int64.

    public override method computeSizeForWritingWith: (writer: Dwarf::AsmWriter) ::=> Size
        := 1sz + (writer sleb128Size: offset).

    public override method writeWith: (writer: Dwarf::AsmWriter) ::=> Void := {
        writer activeStream 
            byte: Dwarf::DW_OP_fbreg value asUInt8;
            sleb128: offset.
    }.
}.

public final class Dwarf::ExpressionBuilder superclass: Object; definition: {
    __Meta__ definition: {
        public method build: (aBlock: (Dwarf::ExpressionBuilder => Void)) ::=> Array
            := self new build: aBlock.

    }.

    public field instructions => OrderedCollection.

    public method build: (aBlock: (Dwarf::ExpressionBuilder => Void)) ::=> Array := {
        instructions := OrderedCollection new.
        aBlock(self).
        instructions asArray
    }.

    public method opcode: (opcode: UInt8) ::=> Void := {
        instructions add: (Dwarf::ExpressionInstructionOpcode new opcode: opcode; yourself)
    }.

    public method register: (register: UInt32) ::=> Void := {
        instructions add: (Dwarf::ExpressionInstructionRegister new register: register; yourself)
    }.

    public method frameOffset: (offset: Int64) ::=> Void := {
        instructions add: (Dwarf::ExpressionInstructionFrameOffset new offset: offset; yourself)
    }.
}.

public abstract class Dwarf::DebugInfoEntryAttribute superclass: Object; definition: {
    public field name => Dwarf::Constant.

    public field next => Dwarf::DebugInfoEntryAttribute.

    public method writeAbbreviationWith: (writer: Dwarf::AsmWriter) ::=> Void := {
        writer activeStream uleb128Expression: name.
        self writeAbbreviationFormWith: writer
    }.

    public virtual method prepareForWritingAssemblyWith: (writer: Dwarf::AsmWriter) ::=> Void := {

    }.

    public abstract method writeAbbreviationFormWith: (writer: Dwarf::AsmWriter) ::=> Void
        := self subclassResponsibility.

    public abstract method writeAttributeWith: (writer: Dwarf::AsmWriter) ::=> Void
        := self subclassResponsibility.
}.


public final class Dwarf::DebugInfoAddrAttribute superclass: Dwarf::DebugInfoEntryAttribute; definition: {
    public field value => AsmConstantExpression.

    public override method writeAbbreviationFormWith: (writer: Dwarf::AsmWriter) ::=> Void := {
        writer activeStream uleb128Expression: Dwarf::DW_FORM_addr
    }.

    public override method writeAttributeWith: (writer: Dwarf::AsmWriter) ::=> Void := {
        writer writeAddress: value
    }.
}.

public final class Dwarf::DebugInfoSectionOffsetAttribute superclass: Dwarf::DebugInfoEntryAttribute; definition: {
    public field value => AsmConstantExpression.

    public override method writeAbbreviationFormWith: (writer: Dwarf::AsmWriter) ::=> Void := {
        writer activeStream uleb128Expression: Dwarf::DW_FORM_sec_offset
    }.

    public override method writeAttributeWith: (writer: Dwarf::AsmWriter) ::=> Void := {
        writer writeAddress: value
    }.
}.

public final class Dwarf::DebugInfoDIEReferenceAttribute superclass: Dwarf::DebugInfoEntryAttribute; definition: {
    public field value => Dwarf::DebugInfoEntry.

    public override method writeAbbreviationFormWith: (writer: Dwarf::AsmWriter) ::=> Void := {
        writer activeStream uleb128Expression: Dwarf::DW_FORM_ref_addr
    }.

    public override method writeAttributeWith: (writer: Dwarf::AsmWriter) ::=> Void := {
        writer writeReferenceToDIE: value
    }.
}.

public final class Dwarf::DebugInfoLocationExpressionAttribute superclass: Dwarf::DebugInfoEntryAttribute; definition: {
    public field value => Array.

    public override method writeAbbreviationFormWith: (writer: Dwarf::AsmWriter) ::=> Void := {
        writer activeStream uleb128Expression: Dwarf::DW_FORM_exprloc
    }.

    public override method writeAttributeWith: (writer: Dwarf::AsmWriter) ::=> Void := {
        let size mutable := 0sz.
        value do: {:(Dwarf::ExpressionInstruction)instruction :: Void |
            size := size + (instruction computeSizeForWritingWith: writer)
        }.

        writer activeStream uleb128: size asUInt64.
        value do: {:(Dwarf::ExpressionInstruction)instruction :: Void |
            instruction writeWith: writer
        }.
    }.
}.


public final class Dwarf::DebugInfoStringAttribute superclass: Dwarf::DebugInfoEntryAttribute; definition: {
    public field value => String.

    public override method prepareForWritingAssemblyWith: (writer: Dwarf::AsmWriter) ::=> Void := {
        writer internString: value
    }.

    public override method writeAbbreviationFormWith: (writer: Dwarf::AsmWriter) ::=> Void := {
        writer activeStream uleb128Expression: Dwarf::DW_FORM_strp
    }.

    public override method writeAttributeWith: (writer: Dwarf::AsmWriter) ::=> Void := {
        writer writeString: value
    }.
}.

public final class Dwarf::DebugInfoSLEB128Attribute superclass: Dwarf::DebugInfoEntryAttribute; definition: {
    public field value => Int64.

    public override method writeAbbreviationFormWith: (writer: Dwarf::AsmWriter) ::=> Void := {
        writer activeStream sleb128Expression: Dwarf::DW_FORM_sdata
    }.

    public override method writeAttributeWith: (writer: Dwarf::AsmWriter) ::=> Void := {
        writer activeStream sleb128: value
    }.
}.

public final class Dwarf::DebugInfoULEB128Attribute superclass: Dwarf::DebugInfoEntryAttribute; definition: {
    public field value => UInt64.

    public override method writeAbbreviationFormWith: (writer: Dwarf::AsmWriter) ::=> Void := {
        writer activeStream uleb128Expression: Dwarf::DW_FORM_udata
    }.

    public override method writeAttributeWith: (writer: Dwarf::AsmWriter) ::=> Void := {
        writer activeStream uleb128: value
    }.
}.

public final class Dwarf::DebugInfoULEB128ExpressionAttribute superclass: Dwarf::DebugInfoEntryAttribute; definition: {
    public field expression => AsmConstantExpression.

    public override method writeAbbreviationFormWith: (writer: Dwarf::AsmWriter) ::=> Void := {
        writer activeStream uleb128Expression: Dwarf::DW_FORM_udata
    }.

    public override method writeAttributeWith: (writer: Dwarf::AsmWriter) ::=> Void := {
        writer activeStream uleb128Expression: expression
    }.
}.

Dwarf::DebugInfoEntry definition: {
    public field tag => Dwarf::Constant.

    public field firstChild => Dwarf::DebugInfoEntry.
    public field lastChild => Dwarf::DebugInfoEntry.
    public field nextSibling => Dwarf::DebugInfoEntry.

    public field firstAttribute => Dwarf::DebugInfoEntryAttribute.
    public field lastAttribute => Dwarf::DebugInfoEntryAttribute.

    public field declaredArguments => Array.
    public field sourceBinding => SymbolBinding.

    __Meta__ definition: {
        public method tag: (tag: Dwarf::Constant) ::=> self
            := self new tag: tag; yourself.
    }.

    public method addChild: (child: Dwarf::DebugInfoEntry) ::=> Void := {
        lastChild ifNil: {
            firstChild := lastChild := child
        } ifNotNil: {
            lastChild nextSibling: child.
            lastChild := child
        }
    }.

    public method hasChildren => Boolean
        := firstChild isNotNil.

    public method shouldEmitSiblingAttribute => Boolean
        := firstChild isNotNil && nextSibling isNotNil.

    public method withAllChildrenDo: (aBlock: (Dwarf::DebugInfoEntry) => Void) ::=> Void := {
        aBlock(self).
        self allChildrenDo: aBlock
    }.

    public method allChildrenDo: (aBlock: (Dwarf::DebugInfoEntry) => Void) ::=> Void := {
        let child mutable := firstChild.
        while: child isNotNil do: {
            child withAllChildrenDo: aBlock
        } continueWith: (child := child nextSibling)
    }.

    public method childrenDo: (aBlock: (Dwarf::DebugInfoEntry) => Void) ::=> Void := {
        let child mutable := firstChild.
        while: child isNotNil do: {
            aBlock(child)
        } continueWith: (child := child nextSibling)
    }.

    public method addAttribute: (attribute: Dwarf::DebugInfoEntryAttribute) ::=> Dwarf::DebugInfoEntryAttribute := {
        lastAttribute ifNil: {
            firstAttribute := lastAttribute := attribute
        } ifNotNil: {
            lastAttribute next: attribute.
            lastAttribute := attribute
        }.

        attribute
    }.

    public method attributesDo: (aBlock: (Dwarf::DebugInfoEntryAttribute) => Void) ::=> Void := {
        let attribute mutable := firstAttribute.
        while: attribute isNotNil do: {
            aBlock(attribute)
        } continueWith: (attribute := attribute next)
    }.

    public method writeAbbreviationWith: (writer: Dwarf::AsmWriter) ::=> Void := {
        writer activeStream
            uleb128Expression: tag;
            byteExpression: (self hasChildren ifTrue: Dwarf::DW_CHILDREN_yes ifFalse: Dwarf::DW_CHILDREN_no).
        self attributesDo: {:(Dwarf::DebugInfoEntryAttribute)attribute :: Void |
            attribute writeAbbreviationWith: writer
        }.

        self shouldEmitSiblingAttribute ifTrue: {
            writer activeStream
                uleb128Expression: Dwarf::DW_AT_sibling;
                uleb128Expression: Dwarf::DW_FORM_addr
        }.

        writer activeStream byte: 0u8; byte: 0u8.
    }.

    public method addAttribute: (attributeName: Dwarf::Constant) addr: (value: AsmConstantExpression) ::=> Dwarf::DebugInfoEntryAttribute
        := self addAttribute: (Dwarf::DebugInfoAddrAttribute new
            name: attributeName;
            value: value;
            yourself).

    public method addAttribute: (attributeName: Dwarf::Constant) sectionOffset: (value: AsmConstantExpression) ::=> Dwarf::DebugInfoEntryAttribute
        := self addAttribute: (Dwarf::DebugInfoSectionOffsetAttribute new
            name: attributeName;
            value: value;
            yourself).

    public method addAttribute: (attributeName: Dwarf::Constant) dieReference: (value: Dwarf::DebugInfoEntry) ::=> Dwarf::DebugInfoEntryAttribute
        := value ifNotNil: (self addAttribute: (Dwarf::DebugInfoDIEReferenceAttribute new
            name: attributeName;
            value: value;
            yourself)).

    public method addAttribute: (attributeName: Dwarf::Constant) locationExpression: (expression: Array) ::=> Dwarf::DebugInfoEntryAttribute
        := self addAttribute: (Dwarf::DebugInfoLocationExpressionAttribute new
            name: attributeName;
            value: expression;
            yourself).

    public method addAttribute: (attributeName: Dwarf::Constant) string: (value: String) ::=> Dwarf::DebugInfoEntryAttribute
        := self addAttribute: (Dwarf::DebugInfoStringAttribute new
            name: attributeName;
            value: value;
            yourself).

    public method addAttribute: (attributeName: Dwarf::Constant) uleb128: (value: UInt64) ::=> Dwarf::DebugInfoEntryAttribute
        := self addAttribute: (Dwarf::DebugInfoULEB128Attribute new
            name: attributeName;
            value: value;
            yourself).

    public method addAttribute: (attributeName: Dwarf::Constant) uleb128Expression: (expression: AsmConstantExpression) ::=> Dwarf::DebugInfoEntryAttribute
        := self addAttribute: (Dwarf::DebugInfoULEB128ExpressionAttribute new
            name: attributeName;
            expression: expression;
            yourself).

    public method name: (name: String) ::=> Dwarf::DebugInfoEntryAttribute
        := self addAttribute: Dwarf::DW_AT_name string: name.

    public method producer: (value: String) ::=> Dwarf::DebugInfoEntryAttribute
        := self addAttribute: Dwarf::DW_AT_producer string: value.

    public method byteSize: (value: UInt64) ::=> Dwarf::DebugInfoEntryAttribute
        := self addAttribute: Dwarf::DW_AT_byte_size uleb128: value.

    public method declFile: (value: UInt32) ::=> Dwarf::DebugInfoEntryAttribute
        := self addAttribute: Dwarf::DW_AT_decl_file uleb128: value asUInt64.

    public method declLine: (value: UInt32) ::=> Dwarf::DebugInfoEntryAttribute
        := self addAttribute: Dwarf::DW_AT_decl_line uleb128: value asUInt64.

    public method declColumn: (value: UInt32) ::=> Dwarf::DebugInfoEntryAttribute
        := self addAttribute: Dwarf::DW_AT_decl_column uleb128: value asUInt64.

    public method external: (value: Boolean) ::=> Dwarf::DebugInfoEntryAttribute
        := self addAttribute: Dwarf::DW_AT_external uleb128: (value ifTrue: 1u64 ifFalse: 0u64).

    public method language: (value: Dwarf::Constant) ::=> Dwarf::DebugInfoEntryAttribute
        := self addAttribute: Dwarf::DW_AT_language uleb128: value value asUInt64.

    public method lowPC: (value: AsmConstantExpression) ::=> Dwarf::DebugInfoEntryAttribute
        := self addAttribute: Dwarf::DW_AT_low_pc addr: value.

    public method highPC: (value: AsmConstantExpression) ::=> Dwarf::DebugInfoEntryAttribute
        := self addAttribute: Dwarf::DW_AT_high_pc addr: value.

    public method stmtList: (value: AsmConstantExpression) ::=> Dwarf::DebugInfoEntryAttribute
        := self addAttribute: Dwarf::DW_AT_stmt_list sectionOffset: value.

    public method encoding: (encoding: Dwarf::Constant) ::=> Dwarf::DebugInfoEntryAttribute
        := self addAttribute: Dwarf::DW_AT_encoding uleb128Expression: encoding.

    public method encodingAddress ::=> Dwarf::DebugInfoEntryAttribute
        := self encoding: Dwarf::DW_ATE_address.

    public method encodingBoolean ::=> Dwarf::DebugInfoEntryAttribute
        := self encoding: Dwarf::DW_ATE_boolean.

    public method encodingFloat ::=> Dwarf::DebugInfoEntryAttribute
        := self encoding: Dwarf::DW_ATE_float.

    public method encodingSigned ::=> Dwarf::DebugInfoEntryAttribute
        := self encoding: Dwarf::DW_ATE_signed.

    public method encodingSignedChar ::=> Dwarf::DebugInfoEntryAttribute
        := self encoding: Dwarf::DW_ATE_signed_char.

    public method encodingUnsigned ::=> Dwarf::DebugInfoEntryAttribute
        := self encoding: Dwarf::DW_ATE_unsigned.

    public method encodingUnsignedChar ::=> Dwarf::DebugInfoEntryAttribute
        := self encoding: Dwarf::DW_ATE_unsigned_char.

    public method frameBase: (expression: Array) ::=> Dwarf::DebugInfoEntryAttribute
        := self addAttribute: Dwarf::DW_AT_frame_base locationExpression: expression.

    public method location: (expression: Array) ::=> Dwarf::DebugInfoEntryAttribute
        := self addAttribute: Dwarf::DW_AT_location locationExpression: expression.

    public method type: (type: Dwarf::DebugInfoEntry) ::=> Dwarf::DebugInfoEntryAttribute
        := self addAttribute: Dwarf::DW_AT_type dieReference: type.

    public method pcRangeSymbol: (symbol: AsmSymbol) pointerSize: (pointerSize: Size) ::=> Void := {
        symbol ifNotNil: {
            let symbolImmediate := symbol immediate: pointerSize.
            self
                lowPC: symbolImmediate asConstantExpression;
                highPC: symbolImmediate endConstantExpression.
        }
    }.
}.

public final class Dwarf::Builder superclass: Object; definition: {
    public field currentNode => Dwarf::DebugInfoEntry.

    public method newDebugInfoEntry: (tag: Dwarf::Constant) ::=> Dwarf::DebugInfoEntry := {
        let die := Dwarf::DebugInfoEntry new
            tag: tag;
            yourself.
        currentNode ifNotNil: (currentNode addChild: die).
        die
    }.

    let DIEBuildBlockType := (Dwarf::DebugInfoEntry, Dwarf::Builder) => Void.

    public method newDebugInfoEntry: (tag: Dwarf::Constant) build: (aBlock: DIEBuildBlockType) ::=> Dwarf::DebugInfoEntry := {
        let die := self newDebugInfoEntry: tag.
        let oldNode := currentNode.
        currentNode := die.
        aBlock(die, self).
        currentNode := oldNode.
        die
    }.

    public method baseType: (aBlock: DIEBuildBlockType) ::=> Dwarf::DebugInfoEntry
        := self newDebugInfoEntry: Dwarf::DW_TAG_base_type build: aBlock.

    public method compileUnit ::=> Dwarf::DebugInfoEntry
        := self newDebugInfoEntry: Dwarf::DW_TAG_compile_unit.

    public method compileUnit: (aBlock: DIEBuildBlockType) ::=> Dwarf::DebugInfoEntry
        := self newDebugInfoEntry: Dwarf::DW_TAG_compile_unit build: aBlock.

    public method formalParameter: (aBlock: DIEBuildBlockType) ::=> Dwarf::DebugInfoEntry
        := self newDebugInfoEntry: Dwarf::DW_TAG_formal_parameter build: aBlock.

    public method subprogram: (aBlock: DIEBuildBlockType) ::=> Dwarf::DebugInfoEntry
        := self newDebugInfoEntry: Dwarf::DW_TAG_subprogram build: aBlock.
}.

Dwarf::DebugInfoEntry extend: {
    public method builder => Dwarf::Builder
        := Dwarf::Builder new
            currentNode: self;
            yourself
}.

AsmStreamBuilder extend: {
    public method dwarf::debugLineSection ::=> AsmSectionDirective
        := self addElement: (AsmSectionDirective new
            name: #".debug_line";
            loaded: true;
            readable: false;
            debugging: true;
            yourself).

    public method dwarf::debugStringSection ::=> AsmSectionDirective
        := self addElement: (AsmSectionDirective new
            name: #".debug_str";
            loaded: true;
            readable: false;
            debugging: true;
            yourself).

    public method dwarf::debugAbbreviationsSection ::=> AsmSectionDirective
        := self addElement: (AsmSectionDirective new
            name: #".debug_abbrev";
            loaded: true;
            readable: false;
            debugging: true;
            yourself).

    public method dwarf::debugInfoSection ::=> AsmSectionDirective
        := self addElement: (AsmSectionDirective new
            name: #".debug_info";
            loaded: true;
            readable: false;
            debugging: true;
            yourself).
}.

Dwarf::AsmWriter definition: {
    public field compilationUnit => Dwarf::DebugInfoEntry.
    public field debugInfoProgramEntity => AsmProgramEntity.
    public field pointerSize => Size.

    public field abbreviationsStart => AsmSymbol.
    public field debugInfoStart => AsmSymbol.
    public field debugInfoEnd => AsmSymbol.
    public field debugLineStart => AsmSymbol.

    public field version => UInt8.
    public field stringTable => OrderedCollection.
    public field stringTableDictionary => Dictionary.
    public field abbreviationsDictionary => Dictionary.
    public field abbreviations => OrderedCollection.
    public field debugInformationEntrySymbolDictionary => IdentityDictionary.

    public field debugLineStream => AsmStreamBuilder.
    public field debugAbbreviationsStream => AsmStreamBuilder.
    public field debugInfoStream => AsmStreamBuilder.
    public field activeStream => AsmStreamBuilder.

    public override method initialize => Void := {
        super initialize.
        version := 4u8.
        stringTable := OrderedCollection new.
        stringTableDictionary := Dictionary new.
        debugInformationEntrySymbolDictionary := IdentityDictionary new.
        abbreviationsDictionary := Dictionary new. ## FIXME: Use a pluggable dictionary here.
        abbreviations := OrderedCollection new.
    }.
    
    public method writeCompilationUnit: (compilationUnit: Dwarf::DebugInfoEntry) toProgramEntity: (debugInfoProgramEntity: AsmProgramEntity) pointerSize: (pointerSize: Size) ::=> Void := {
        self
            compilationUnit: compilationUnit;
            debugInfoProgramEntity: debugInfoProgramEntity;
            pointerSize: pointerSize.

        abbreviationsStart := AsmSymbol new
            name: #abbreviationsStart;
            makePrivate;
            yourself.

        debugLineStart := AsmSymbol new
            name: #debugLineStart;
            makePrivate;
            yourself.

        debugInfoStart := AsmSymbol new
            name: #debugInfoStart;
            makePrivate;
            yourself.

        debugInfoEnd := AsmSymbol new
            name: #debugInfoStart;
            makePrivate;
            yourself.

        debugLineStream := debugInfoProgramEntity newStreamBuilder
            dwarf::debugLineSection;
            label: debugLineStart;
            yourself.

        compilationUnit stmtList: (debugLineStart immediateSectionRelative: pointerSize) asConstantExpression.

        self 
            prepareForWriting;
            writeStrings;
            writeAbbreviations;
            writeDebugInfo
    }.

    public method internString: (string: String) ::=> AsmSymbol := {
        stringTableDictionary at: string ifAbsentPut: {:: AsmSymbol |
            let stringSymbol := AsmSymbol new
                name: #debugString;
                makePrivate;
                yourself.
            stringTable add: string -> stringSymbol.
            stringSymbol
        }
    }.

    public method writeString: (string: String) ::=> Void := {
        let stringSymbol => AsmSymbol := stringTableDictionary at: string.
        activeStream expression: (stringSymbol immediateSectionRelative: pointerSize) asConstantExpression size: pointerSize
    }.

    public method writeAddress: (address: AsmConstantExpression) ::=> Void := {
        activeStream expression: address size: pointerSize
    }.

    public method writeReferenceToDIE: (die: Dwarf::DebugInfoEntry) ::=> Void := {
        let symbol => AsmSymbol := debugInformationEntrySymbolDictionary at: die.
        activeStream expression: (symbol immediateSectionRelative: pointerSize) asConstantExpression size: pointerSize
    }.

    public method recordAbbreviation: (die: Dwarf::DebugInfoEntry) ::=> Void := {
        abbreviationsDictionary at: die ifAbsentPut: {:: Association |
            let assoc := Association key: (abbreviations size + 1sz) value: die.
            abbreviations add: assoc.
            assoc
        }.
    }.

    public method prepareForWriting => Void := {
        compilationUnit withAllChildrenDo: {:(Dwarf::DebugInfoEntry)die :: Void |
            debugInformationEntrySymbolDictionary at: die put: (AsmSymbol new
                name: #die;
                makePrivate;
                yourself).

            self recordAbbreviation: die.
            die attributesDo: {:(Dwarf::DebugInfoEntryAttribute)attribute :: Void |
                attribute prepareForWritingAssemblyWith: self
            }
        }
    }.

    public method writeStrings => Void := {
        let stream := debugInfoProgramEntity newStreamBuilder
            dwarf::debugStringSection;
            yourself.
        stringTable do: {:(Association)stringAndSymbol :: Void |
            stream
                label: stringAndSymbol value;
                string: stringAndSymbol key nullTerminated: true
        }
    }.

    public method writeAbbreviations => Void := {
        debugAbbreviationsStream := debugInfoProgramEntity newStreamBuilder
            dwarf::debugAbbreviationsSection;
            label: abbreviationsStart;
            yourself.
        activeStream := debugAbbreviationsStream.
        abbreviations do: {:(Association)abbreviationIdAndDie :: Void |
            activeStream uleb128: abbreviationIdAndDie key.
            (abbreviationIdAndDie value downCastTo: Dwarf::DebugInfoEntry) writeAbbreviationWith: self
        }.

        activeStream byte: 0u8
    }.

    public method writeDebugInfo => Void := {
        debugInfoStream := debugInfoProgramEntity newStreamBuilder
            dwarf::debugInfoSection;
            yourself.
        activeStream := debugInfoStream.

        pointerSize = 4sz ifTrue: {
            activeStream dwordExpression: debugInfoEnd dword asConstantExpression - debugInfoStart dword asConstantExpression.
        } ifFalse: {
            activeStream dword: 16rFFFFFFFF u32.
            activeStream qwordExpression: debugInfoEnd qword asConstantExpression - debugInfoStart qword asConstantExpression.
        }.

        debugInfoStream label: debugInfoStart.

        version = 4u8 ifTrue: {
            activeStream
                word: 4u16;
                expression: (abbreviationsStart immediateSectionRelative: pointerSize) asConstantExpression size: pointerSize;
                byte: pointerSize asUInt8.
        }.

        version = 5u8 ifTrue: {
            activeStream
                word: 4u16;
                byteExpression: Dwarf::DW_UT_compile;
                byte: pointerSize asUInt8;
                expression: (abbreviationsStart immediateSectionRelative: pointerSize) asConstantExpression size: pointerSize.
        }.

        self writeDebugInfoEntry: compilationUnit.

        debugInfoStream label: debugInfoEnd.
    }.

    public method writeDebugInfoEntry: (debugInfoEntry: Dwarf::DebugInfoEntry) ::=> Void := {
        let abbreviation := abbreviationsDictionary at: debugInfoEntry.
        let symbol := debugInformationEntrySymbolDictionary at: debugInfoEntry.
        
        activeStream
            label: symbol;
            uleb128: abbreviation key.

        debugInfoEntry attributesDo: {:(Dwarf::DebugInfoEntryAttribute)attribute :: Void |
            attribute writeAttributeWith: self
        }.
        debugInfoEntry shouldEmitSiblingAttribute ifTrue: {
            self writeReferenceToDIE: debugInfoEntry nextSibling
        }.

        debugInfoEntry hasChildren ifTrue: {
            debugInfoEntry childrenDo: {:(Dwarf::DebugInfoEntry)child :: Void |
                self writeDebugInfoEntry: child
            }.
            activeStream byte: 0u8.
        }.
    }.

    public method uleb128Size: (value: UInt64) ::=> Size := {
        let result mutable := 0sz.
        let currentValue mutable := value.
        do: {
            let byte := (currentValue & 127u64) asUInt8.
            currentValue := currentValue >> 7u64.
            result := result + 1sz.
        } while: (currentValue ~= 0u64).

        result
    }.

    public method sleb128Size: (value: Int64) ::=> Size := {
        let result mutable := 0sz.
        let more mutable => Boolean := true.

        let currentValue mutable := value.
        while: more do: {
            let byte mutable := (currentValue & 127i64) asInt8.
            currentValue := currentValue >> 7i64.
            
            let byteHasSign := (byte & 16r40 i8) ~= 0i8.
            ((currentValue = 0i64) && byteHasSign not) || (currentValue == -1i64 && byteHasSign) ifTrue: {
                more := false
            }.

            result := result + 1sz.
        }.
        result
    }.
}.

AsmProgramEntity extend: {
    public method buildDwarfCompileUnitWith: (aBlock: (Dwarf::DebugInfoEntry, Dwarf::Builder) => Void) ::=> AsmProgramEntity := {
        let compileUnit := Dwarf::Builder new
            compileUnit: aBlock.
        
        let debugInfoProgramEntity := self newProgramEntity.
        Dwarf::AsmWriter new
            writeCompilationUnit: compileUnit toProgramEntity: debugInfoProgramEntity pointerSize: compilationTarget pointerSize.

        debugInfoProgramEntity
    }.
}.

public final class Dwarf::DebugLineWriter superclass: Object; definition: {
    public field defaultIsStatement => Boolean.
    public field maxNumberOfOperationsPerInstruction => UInt32.
    public field minimumInstructionLength => UInt32.
    public field opcodeBase => UInt32.
    public field pointerSize => Size.

    public field directoryDictionary => Dictionary.
    public field directories => OrderedCollection.

    public field fileDictionary => Dictionary.
    public field files => OrderedCollection.

    public field minLine => Int32.
    public field maxLine => Int32.
    public field previousLine => Int32.
    public field lineAdvance => Int32.
    public field lineBase => Int32.
    public field lineRange => Int32.

    private field regAddress => UInt32.
    private field regAddressSection => AsmSymbol.
    private field regOpIndex => UInt32.
    private field regFile => UInt32.
    private field regLine => UInt32.
    private field regColumn => UInt32.
    private field regIsStatement => Boolean.
    private field regBasicBlock => Boolean.
    private field regEndSequence => Boolean.
    private field regPrologueEnd => Boolean.
    private field regEpilogueBegin => Boolean.
    private field regISA => UInt32.
    private field regDiscriminator => Boolean.

    private field programRelocations => OrderedCollection.
    public field out => ByteStream.

    public override method initialize => Void := {
        defaultIsStatement := true.
        maxNumberOfOperationsPerInstruction := 1u32.
        minimumInstructionLength := 1u32.
        opcodeBase := 13u32.

        directoryDictionary := Dictionary new.
        directories := OrderedCollection new.

        fileDictionary := Dictionary new.
        files := OrderedCollection new.

        programRelocations := OrderedCollection new.
    }.

    public method addSourceDirectory: (directory: String) ::=> UInt32 := {
        directory isNil || (directory = "") ifTrue: {return: 0u32}.

        directoryDictionary at: directory ifAbsentPut: {:: UInt32 |
            directories add: (directory withoutSuffix: "/").
            directories size asUInt32
        }
    }.

    public method addSourceCode: (sourceCode: SourceCode) ::=> UInt32 := {
        sourceCode ifNil: (return: 0u32).

        fileDictionary at: sourceCode ifAbsentPut: {:: UInt32 |
            let directoryIndex := self addSourceDirectory: sourceCode directory.
            files add: (directoryIndex, sourceCode name).
            files size asUInt32
        }
    }.

    public method computeLineRangeForSections: (sections: OrderedCollection) ::=> Void := {
        minLine := Int32 maxVal.
        maxLine := Int32 minVal.
        previousLine := 1i32.

        sections do: {:(AsmObjectCodeSection)section :: Void |
            section executable ifTrue: {
                section debugSourcePositions ifNotNil: {:(Array)sourcePositions | 
                    sourcePositions do: {:(SourcePosition)each :: Void |
                        self addSourceCode: each sourceCode.

                        let startLine := each startLine asInt32.
                        let lineAdvance := startLine - previousLine.
                        lineAdvance abs < 8i32 ifTrue: {
                            minLine := minLine min: lineAdvance.
                            maxLine := maxLine max: lineAdvance.
                        }.
                    }
                }
            }
        }.

        lineBase := (minLine min: 127i32) max: -128i32.
        lineRange := maxLine - minLine min: 255i32.
    }.

    public method writeSourceLocationForSections: (sections: OrderedCollection) onto: (targetSection: AsmObjectCodeSection) pointerSize: (pointerSize: Size) ::=> Void := {
        self pointerSize: pointerSize.
        self computeLineRangeForSections: sections.

        let programHeader := self generateProgramHeader.
        let program := self generateProgramForSections: sections.

        out := ByteStream new.
        pointerSize = 4sz ifTrue: {
            self dword: (programHeader size + program size + pointerSize + 2sz) asUInt32.
        } ifFalse: {
            self
                dword: 16rFFFFFFFF u32;
                qword: (programHeader size + program size + pointerSize + 2sz) asUInt64.
        }.

        self word: 4u16.
        pointerSize = 4sz ifTrue: {
            self dword: programHeader size asUInt32.
        } ifFalse: {
            self qword: programHeader size asUInt64.
        }.

        out nextPutAll: programHeader.
        let relocationAddressBase := out size + targetSection writeOffset.
        out nextPutAll: program.

        targetSection writeUnallocatedBytes: out asByteArray.
        programRelocations do: {:(AsmObjectCodeRelocation)eachRelocation :: Void |
            eachRelocation offset: relocationAddressBase + eachRelocation offset.
            targetSection newRelocations add: eachRelocation
        }
    }.

    public method generateProgramHeader => ByteArray := {
        out := ByteStream new.

		self
			byte: 1u8 #* minimum_instruction_length *#;
			byte: 1u8 #* maximum_operations_per_instruction *#;
			byte: (defaultIsStatement ifTrue: 1u8 ifFalse: 0u8);
			byte: lineBase asUInt8;
			byte: lineRange asUInt8;
			byte: opcodeBase asUInt8 #* opcode_base *#;
			
			byte: 0u8; #* DW_LNS_copy *#
			byte: 1u8; #* DW_LNS_advance_pc *#
			byte: 1u8; #* DW_LNS_advance_line *#
			byte: 1u8; #* DW_LNS_set_file *#
			byte: 1u8; #* DW_LNS_set_column *#
			byte: 0u8; #* DW_LNS_negate_stmt *#
			byte: 0u8; #* DW_LNS_set_basic_block *#
			byte: 0u8; #* DW_LNS_const_add_pc *#
			byte: 1u8; #* DW_LNS_fixed_advance_pc *#
			byte: 0u8; #* DW_LNS_set_prologue_end *#
			byte: 0u8; #* DW_LNS_set_epilogue_begin *#
			byte: 1u8; #* DW_LNS_set_isa *#
			
			yourself.
		
		## Directories
		directories do: { :(String)eachDirectory :: Void |
            self cstring: eachDirectory
        }.
		self byte: 0u8.
		
		## Files
		files do: { :(Array)file :: Void |
			self
				cstring: file second;
				uleb128: file first asUInt64;
				uleb128: 0u64;
				uleb128: 0u64.
        }.
		self byte: 0u8.
        
        out asByteArray
    }.

    public method generateProgramForSections: (sections: OrderedCollection) ::=> ByteArray := {
        out := ByteStream new.

		regAddress := 0u32.
		regAddressSection := nil.
		regOpIndex := 0u32.
		regFile := 1u32.
		regLine := 1u32.
		regColumn := 0u32.
		regIsStatement := defaultIsStatement.
		regBasicBlock := false.
		regEndSequence := false.
		regPrologueEnd := false.
		regEpilogueBegin := false.
		regISA := 0u32.
		regDiscriminator := false.

        sections do: {:(AsmObjectCodeSection)section :: Void |
            section executable ifTrue: {
                section pcToDebugListTable ifNotNil: {:(Array)pcToDebugListTable :: Void |
                    let sectionSymbol := AsmSymbol new
                        section: section;
                        makePrivate;
                        yourself.
                    let debugSourcePositions := section debugSourcePositions.
                    pcToDebugListTable pairsDo: {:(UInt32)pc :(UInt32)sourcePositionIndex :: Void |
                        let sourcePosition => SourcePosition := sourcePositionIndex > 0u32
                            ifTrue: (debugSourcePositions at: (sourcePositionIndex - 1u32) asSize)
                            ifFalse: nil.
                        
                        self emitSourcePosition: sourcePosition section: sectionSymbol pc: pc.
                    }
                }
            }
        }.

        self endSequence.
        out asByteArray
    }.

    public method emitSourcePosition: (sourcePosition: SourcePosition) section: (section: AsmSymbol) pc: (pc: UInt32) ::=> Void := {
        regAddressSection ~~ section ifTrue: {
            self setSection: section pc: pc
        }.
        sourcePosition ifNil: {
            return: void
        }.

        let sourceCode := sourcePosition sourceCode.
        let startLine := sourcePosition startLine asUInt32.
        let startColumn := sourcePosition startColumn asUInt32.

        (regColumn = startColumn) && (regLine = startLine) ifTrue: (return: void).

        self
            setFile: (sourceCode ifNil: 1u32 ifNotNil: (fileDictionary at: sourceCode));
            setColumn: startColumn.

        let pcAdvance := pc - regAddress.
        let lineAdvance := startLine asInt32 - regLine asInt32.
        self advanceLine: lineAdvance pc: pcAdvance andEmitWithOperationIndex: 0u8.
    }.

    public method setFile: (fileIndex: UInt32) ::=> Void := {
        regFile = fileIndex ifFalse: {
            self byte: Dwarf::DW_LNS_set_file value asUInt8; uleb128: fileIndex asUInt64.
            regFile := fileIndex
        }
    }.

    public method setColumn: (column: UInt32) ::=> Void := {
        regColumn = column ifFalse: {
            self byte: Dwarf::DW_LNS_set_column value asUInt8; uleb128: column asUInt64.
            regColumn := column
        }
    }.

    public method advanceLine: (lineAdvance: Int32) pc: (pcAdvance: UInt32) andEmitWithOperationIndex: (operationIndex: UInt8) ::=> Void := {
        let operationAdvance := pcAdvance / minimumInstructionLength.

        let opcode := (lineAdvance - lineBase) + (lineRange * operationAdvance asInt32) + opcodeBase asInt32.
        (0i32 <= opcode) && (opcode <= 255i32) && (lineAdvance - lineBase < lineRange) && (lineAdvance >= lineBase) ifTrue: {
            self byte: opcode asUInt8.
            regLine := (regLine asInt32 + lineAdvance) asUInt32.
            regAddress := regAddress + pcAdvance.
        } ifFalse: {
            self
                advanceLine: lineAdvance;
                advancePC: pcAdvance;
                copyRow
        }.
    }.

    public method advanceLine: (advance: Int32) ::=> Void := {
        self byte: Dwarf::DW_LNS_advance_line value asUInt8; sleb128: advance asInt64.
        regLine := (regLine asInt32 + advance) asUInt32.
    }.

    public method advancePC: (advance: UInt32) ::=> Void := {
        self byte: Dwarf::DW_LNS_advance_pc value asUInt8; uleb128: advance asUInt64.
        regAddress := regAddress + advance
    }.

    public method copyRow => Void := {
        self byte: Dwarf::DW_LNS_copy value asUInt8.
        regDiscriminator := false.
        regBasicBlock := false.
        regPrologueEnd := false.
        regEpilogueBegin := false.
    }.

    public method setSection: (section: AsmSymbol) pc: (pc: UInt32) ::=> Void := {
        self byte: 0u8; uleb128: (1sz + pointerSize) asUInt64; byte: Dwarf::DW_LNE_set_address value asUInt8; relocatableAddress: pc inSection: section
    }.

    public method relocatableAddress: (address: UInt32) inSection: (section: AsmSymbol) ::=> Void := {
        pointerSize = 4sz ifTrue: {
            programRelocations add: (AsmObjectCodeRelocationAbsoluteInt32 new
                symbol: section;
                offset: out size;
                addend: address asInt32;
                yourself).
            self dword: 0u32.
        } ifFalse: {
            programRelocations add: (AsmObjectCodeRelocationAbsoluteInt64 new
                symbol: section;
                offset: out size;
                addend: address asInt64;
                yourself).
            self qword: 0u64.
        }.

        regAddressSection := section.
        regAddress := address.
    }.

    public method endSequence => Void := {
        self byte: 0u8; uleb128: 1u64; byte: Dwarf::DW_LNE_end_sequence value asUInt8
    }.

    public method byte: (value: UInt8) ::=> Void := {
        out nextPut: value
    }.

    public method word: (value: UInt16) ::=> Void := {
        out nextPutUInt16: value
    }.

    public method dword: (value: UInt32) ::=> Void := {
        out nextPutUInt32: value
    }.

    public method qword: (value: UInt64) ::=> Void := {
        out nextPutUInt64: value
    }.

    public method cstring: (value: String) ::=> Void := {
        out nextPutString: value; nextPut: 0u8.
    }.

    public method uleb128: (value: UInt64) ::=> Void := {
        let currentValue mutable := value.
        do: {
            let byte := (currentValue & 127u64) asUInt8.
            currentValue := currentValue >> 7u64.
            out nextPut: byte | (currentValue ~= 0 ifTrue: 128u8 ifFalse: 0u8)
        } while: (currentValue ~= 0u64)
    }.

    public method sleb128: (value: Int64) ::=> Void := {
        let more mutable => Boolean := true.

        let currentValue mutable := value.
        while: more do: {
            let byte mutable := (currentValue & 127i64) asInt8.
            currentValue := currentValue >> 7i64.
            
            let byteHasSign := (byte & 16r40 i8) ~= 0i8.
            ((currentValue = 0i64) && byteHasSign not) || (currentValue == -1i64 && byteHasSign) ifTrue: {
                more := false
            } ifFalse: {
                byte := byte | 16r80 i8.
            }.

            out nextPut: byte asUInt8
        }.
    }.
}.

public final class Dwarf::ObjectDebugInformationGenerator superclass: AsmObjectDebugInformationGenerator; definition: {
    public field pointerSize => Size.
    public field compilationTarget => AsmCompilationTarget.
    public field compileUnit => Dwarf::DebugInfoEntry.

    public field debugInfoProgramEntity => AsmProgramEntity.
    public field debugInfoWriter => Dwarf::AsmWriter.

    public field programEntityDieDictionary => Dictionary.
    public field typeDieDictionary => Dictionary.
    public field lineWriter => Dwarf::DebugLineWriter.

    public override method initialize => Void := {
        super initialize.
        programEntityDieDictionary := Dictionary new.
        typeDieDictionary := Dictionary new.
        lineWriter := Dwarf::DebugLineWriter new.
    }.

    public method setProgramEntity: (programEntity: ProgramEntity) die: (die: Dwarf::DebugInfoEntry) ::=> Void := {
        programEntityDieDictionary at: programEntity put: die
    }.

    public method setType: (type: Type) die: (die: Dwarf::DebugInfoEntry) ::=> Void := {
        typeDieDictionary at: type put: die
    }.

    public method getOrCreateDieForProgramEntity: (programEntity: ProgramEntity) ::=> Dwarf::DebugInfoEntry := {
        programEntity ifNil: {return: nil}.

        programEntityDieDictionary at: programEntity ifAbsent: {:: Dwarf::DebugInfoEntry |
            programEntity dwarf::createDieWith: self
        }
    }.

    public method getOrCreateDieForType: (type: Type) ::=> Dwarf::DebugInfoEntry := {
        type ifNil: {return: nil}.

        typeDieDictionary at: type ifAbsent: {:: Dwarf::DebugInfoEntry |
            type dwarf::createTypeDieWith: self
        }
    }.

    public method getOrCreateDieForProgramEntityOwner: (programEntity: ProgramEntity) ::=> Dwarf::DebugInfoEntry
        := (self getOrCreateDieForProgramEntity: programEntity) ifNil: compileUnit.

    public method setDie: (die: Dwarf::DebugInfoEntry) declarationPosition: (sourcePosition: SourcePosition) ::=> Void := {
        let sourceCode := sourcePosition sourceCode.
        sourceCode ifNotNil: {
            die
                declFile: (lineWriter addSourceCode: sourceCode);
                declLine: sourcePosition startLine asUInt32;
                declColumn: sourcePosition startColumn asUInt32
        }
    }.

    public method generateDebugInfoForProgramEntity: (sourceProgramEntity: ProgramEntity) generatedEntity: (generatedProgramEntity: AsmProgramEntity) ::=> Void := {
        sourceProgramEntity ifNil: {return: void}.
        generatedProgramEntity contentSymbol ifNil: {return: void}.

        sourceProgramEntity dwarf::generateDIEForAsmProgramEntity: generatedProgramEntity with: self
    }.

    public override method generateDebugInformationForModule: (module: AsmProgramEntity) ::=> Void := {
        pointerSize := module compilationTarget pointerSize. 
        compilationTarget := module compilationTarget.

        compileUnit := Dwarf::Builder new compileUnit.
        compileUnit
            ##language: Dwarf::DW_LANG_C;
            producer: "Sysmel Compiler";
            pcRangeSymbol: module contentSymbol pointerSize: pointerSize.

        debugInfoProgramEntity := module newProgramEntity.

        module allChildrenDo: {:(AsmProgramEntity)eachChild :: Void |
            self generateDebugInfoForProgramEntity: eachChild sourceProgramEntity generatedEntity: eachChild
        }.

        debugInfoWriter := Dwarf::AsmWriter new.
        debugInfoWriter writeCompilationUnit: compileUnit toProgramEntity: debugInfoProgramEntity pointerSize: module compilationTarget pointerSize.
    }.

    public override method generateDebugLineInformationForModule: (module: AsmProgramEntity) objectCodeBuilder: (objectCodeBuilder: AsmObjectCodeBuilder) ::=> Void := {
        lineWriter writeSourceLocationForSections: objectCodeBuilder sections onto: (objectCodeBuilder getSectionNamed: #".debug_line") pointerSize: module compilationTarget pointerSize
    }.
}.

ProgramEntity extend: {
    public virtual method dwarf::createDieWith: (debugGenerator: Dwarf::ObjectDebugInformationGenerator) ::=> Dwarf::DebugInfoEntry
        := nil.

    public virtual method dwarf::generateDIEForAsmProgramEntity: (generatedProgramEntity: AsmProgramEntity) with: (debugGenerator: Dwarf::ObjectDebugInformationGenerator) ::=> Void := {
        ## By default do nothing
    }
}.

Type extend: {
    public virtual method dwarf::validOwner => ProgramEntity
        := self owner.

    public virtual method dwarf::validTypeOwner => ProgramEntity
        := self dwarf::hasSeparateDieForType ifTrue: nil ifFalse: self dwarf::validOwner.

    public virtual method dwarf::hasSeparateDieForType => Boolean
        := true.

    public virtual method dwarf::typeTag => Dwarf::Constant
        := Dwarf::DW_TAG_pointer_type.

    public virtual method dwarf::programEntityTag => Dwarf::Constant
        := Dwarf::DW_TAG_class_type.

    public virtual method dwarf::canHaveMemberFields => Boolean
        := true.

    public virtual method dwarf::name => String
        := self name ifNotNil: (self name asString).

    public virtual method dwarf::createTypeDieWith: (debugGenerator: Dwarf::ObjectDebugInformationGenerator) ::=> Dwarf::DebugInfoEntry := {
        self dwarf::hasSeparateDieForType ifTrue: {
            let typeDie := Dwarf::DebugInfoEntry tag: self dwarf::typeTag.
            debugGenerator setType: self die: typeDie.
            (debugGenerator getOrCreateDieForProgramEntityOwner: self dwarf::validTypeOwner) addChild: typeDie.
            self dwarf::fillTypeInfo: typeDie with: debugGenerator.
            typeDie
        } ifFalse: {
            self dwarf::createDieWith: debugGenerator
        }
    }.

    public override method dwarf::createDieWith: (debugGenerator: Dwarf::ObjectDebugInformationGenerator) ::=> Dwarf::DebugInfoEntry := {
        let programEntityDie := Dwarf::DebugInfoEntry tag: self dwarf::programEntityTag.
        debugGenerator setProgramEntity: self die: programEntityDie.
        self dwarf::hasSeparateDieForType ifFalse: {
            debugGenerator setType: self die: programEntityDie.
        }.

        (debugGenerator getOrCreateDieForProgramEntityOwner: self dwarf::validOwner) addChild: programEntityDie.
        self dwarf::name ifNotNil: {:(String)name :: Void | programEntityDie name: self dwarf::name}.
        self dwarf::fillProgramEntityInfo: programEntityDie with: debugGenerator.

        programEntityDie
    }.

    public virtual method dwarf::fillProgramEntityInfo: (die: Dwarf::DebugInfoEntry) with: (debugGenerator: Dwarf::ObjectDebugInformationGenerator) ::=> Void := {
        die byteSize: self instanceSize asUInt64
    }.

    public virtual method dwarf::fillTypeInfo: (die: Dwarf::DebugInfoEntry) with: (debugGenerator: Dwarf::ObjectDebugInformationGenerator) ::=> Void := {
        self assert: self dwarf::hasSeparateDieForType.
        die byteSize: self valueSize asUInt64.
        die type: (debugGenerator getOrCreateDieForProgramEntity: self).
    }.
}.

ValueType extend: {
    public override method dwarf::hasSeparateDieForType => Boolean
        := false.
}.

PointerLikeType extend: {
    public override method dwarf::canHaveMemberFields => Boolean
        := false.

    public override method dwarf::fillProgramEntityInfo: (die: Dwarf::DebugInfoEntry) with: (debugGenerator: Dwarf::ObjectDebugInformationGenerator) ::=> Void := {
        super dwarf::fillProgramEntityInfo: die with: debugGenerator.
        die type: (debugGenerator getOrCreateDieForType: baseType).
    }.
}.

FixedArrayType extend: {
    public override method dwarf::programEntityTag => Dwarf::Constant
        := Dwarf::DW_TAG_array_type.

    public override method dwarf::fillProgramEntityInfo: (die: Dwarf::DebugInfoEntry) with: (debugGenerator: Dwarf::ObjectDebugInformationGenerator) ::=> Void := {
        super dwarf::fillProgramEntityInfo: die with: debugGenerator.
        die type: (debugGenerator getOrCreateDieForType: elementType).
    }.
}.

PointerType extend: {
    public override method dwarf::programEntityTag => Dwarf::Constant
        := Dwarf::DW_TAG_pointer_type.
}.

ReferenceType extend: {
    public override method dwarf::programEntityTag => Dwarf::Constant
        := Dwarf::DW_TAG_reference_type.
}.

PrimitiveValueType extend: {
    public override method dwarf::canHaveMemberFields => Boolean
        := false.

    public virtual method dwarf::programEntityTag => Dwarf::Constant
        := Dwarf::DW_TAG_base_type.
}.

PrimitiveCharacter __type__ extend: {
    public override method dwarf::fillProgramEntityInfo: (die: Dwarf::DebugInfoEntry) with: (debugGenerator: Dwarf::ObjectDebugInformationGenerator) ::=> Void := {
        super dwarf::fillProgramEntityInfo: die with: debugGenerator.
        die encodingUnsignedChar
    }.
}.

PrimitiveSignedInteger __type__ extend: {
    public override method dwarf::fillProgramEntityInfo: (die: Dwarf::DebugInfoEntry) with: (debugGenerator: Dwarf::ObjectDebugInformationGenerator) ::=> Void := {
        super dwarf::fillProgramEntityInfo: die with: debugGenerator.
        die encodingSigned
    }.
}.

PrimitiveUnsignedInteger __type__ extend: {
    public override method dwarf::fillProgramEntityInfo: (die: Dwarf::DebugInfoEntry) with: (debugGenerator: Dwarf::ObjectDebugInformationGenerator) ::=> Void := {
        super dwarf::fillProgramEntityInfo: die with: debugGenerator.
        die encodingUnsigned
    }.
}.

PrimitiveFloat __type__ extend: {
    public override method dwarf::fillProgramEntityInfo: (die: Dwarf::DebugInfoEntry) with: (debugGenerator: Dwarf::ObjectDebugInformationGenerator) ::=> Void := {
        super dwarf::fillProgramEntityInfo: die with: debugGenerator.
        die encodingFloat
    }.
}.

Boolean __type__ extend: {
    public override method dwarf::fillProgramEntityInfo: (die: Dwarf::DebugInfoEntry) with: (debugGenerator: Dwarf::ObjectDebugInformationGenerator) ::=> Void := {
        super dwarf::fillProgramEntityInfo: die with: debugGenerator.
        die encodingBoolean
    }.
}.

Void __type__ extend: {
    public override method dwarf::createTypeDieWith: (debugGenerator: Dwarf::ObjectDebugInformationGenerator) ::=> Dwarf::DebugInfoEntry := {
        debugGenerator setType: self die: nil.
        nil
    }.
}.

Metatype extend: {
    public override method dwarf::validOwner => ProgramEntity
        := thisType ifNotNil: thisType ifNil: owner.

    public override method dwarf::name => String
        := name isNil && thisType isNotNil ifTrue: ("__Meta__") ifFalse: (super dwarf::name).
}.

Namespace extend: {
    public override method dwarf::createDieWith: (debugGenerator: Dwarf::ObjectDebugInformationGenerator) ::=> Dwarf::DebugInfoEntry := {
        let subprogram := Dwarf::DebugInfoEntry tag: Dwarf::DW_TAG_namespace.
        debugGenerator setProgramEntity: self die: subprogram.
        (debugGenerator getOrCreateDieForProgramEntityOwner: self owner) addChild: subprogram.
        self name ifNotNil: (subprogram name: self name asString).

        subprogram
    }.
}.

FunctionDefinition extend: {
    public override method dwarf::createDieWith: (debugGenerator: Dwarf::ObjectDebugInformationGenerator) ::=> Dwarf::DebugInfoEntry := {
        let subprogram := Dwarf::DebugInfoEntry tag: Dwarf::DW_TAG_subprogram.
        debugGenerator setProgramEntity: self die: subprogram.
        (debugGenerator getOrCreateDieForProgramEntityOwner: self owner) addChild: subprogram.

        subprogram external: true.
        self name ifNotNil: (subprogram name: self name asString).
        ##self name ifNotNil: (subprogram name: self qualifiedName).
        sourcePosition ifNotNil: (debugGenerator setDie: subprogram declarationPosition: sourcePosition).

        analyzedType ifNotNil: {
            subprogram type: (debugGenerator getOrCreateDieForType: analyzedType canonicalResultType)
        }.

        subprogram declaredArguments: (analyzedArguments collect: {:(SymbolArgumentBinding)binding :: Dwarf::DebugInfoEntry |
            let argument := Dwarf::DebugInfoEntry tag: Dwarf::DW_TAG_formal_parameter.
            argument sourceBinding: binding.
            subprogram addChild: argument.

            binding name ifNotNil: (argument name: binding name asString).
            argument type: (debugGenerator getOrCreateDieForType: binding type).

            debugGenerator setDie: argument declarationPosition: binding sourcePosition.

            argument
        }).

        subprogram
    }.

    public override method dwarf::generateDIEForAsmProgramEntity: (generatedFunction: AsmProgramEntity) with: (debugGenerator: Dwarf::ObjectDebugInformationGenerator) ::=> Void := {
        generatedFunction isTrampoline ifTrue: {return: void}.

        let subprogram := (debugGenerator getOrCreateDieForProgramEntity: self).
        subprogram
            pcRangeSymbol: generatedFunction contentSymbol pointerSize: debugGenerator pointerSize.

        let stackMap := generatedFunction stackMap.
        stackMap ifNotNil: {
            stackMap dwarf::generateDebugInfoForFunctionDefinition: self subprogram: subprogram with: debugGenerator
        }.
    }.
}.

AsmStackMap extend: {
    public method dwarf::generateDebugInfoForFunctionDefinition: (functionDefinition: FunctionDefinition) subprogram: (subprogram: Dwarf::DebugInfoEntry) with: (debugGenerator: Dwarf::ObjectDebugInformationGenerator) ::=> Void := {
        frameBase ifNotNil: {
            subprogram frameBase: (frameBase dwarf::buildExpressionForStackMap: self target: debugGenerator compilationTarget)
        }.

        subprogram declaredArguments ifNotNil: {:(Array)declaredArguments :: Void |
            declaredArguments do: {:(Dwarf::DebugInfoEntry)argumentDie :: Void |
                self dwarf::emitLocationForLocalDIE: argumentDie with: debugGenerator
            }
        }.

        captures do: {:(AsmSymbolBindingLocationMap)each :: Void |
        }.

        locals do: {:(AsmSymbolBindingLocationMap)each :: Void |
            self dwarf::generateProgramEntityForBindingLocationMap: each subprogram: subprogram with: debugGenerator
        }.
    }.

    public method dwarf::emitLocationForLocalDIE: (localDIE: Dwarf::DebugInfoEntry) with: (debugGenerator: Dwarf::ObjectDebugInformationGenerator) ::=> Void := {
        let binding := localDIE sourceBinding.
        let bindingMap := self getMapOrNilForBinding: binding.

        bindingMap ifNotNil: {
            localDIE location: (bindingMap location dwarf::buildExpressionForStackMap: self target: debugGenerator compilationTarget)
        }.
    }.

    public method dwarf::generateProgramEntityForBindingLocationMap: (bindingLocationMap: AsmSymbolBindingLocationMap) subprogram: (subprogram: Dwarf::DebugInfoEntry) with: (debugGenerator: Dwarf::ObjectDebugInformationGenerator) ::=> Void := {
        let binding := bindingLocationMap binding.
        let variable := Dwarf::DebugInfoEntry tag: Dwarf::DW_TAG_variable.
        variable sourceBinding: binding.
        subprogram addChild: variable.

        binding name ifNotNil: (variable name: binding name asString).
        binding type ifNotNil: {
            let bindingType := binding type.
            bindingLocationMap isMutable && bindingType isReferenceType ifTrue: {
                let valueType := (bindingType downCastTo: ReferenceType) baseType.
                variable type: (debugGenerator getOrCreateDieForType: valueType).
            } ifFalse: {
                variable type: (debugGenerator getOrCreateDieForType: bindingType).
            }.
        }.

        debugGenerator setDie: variable declarationPosition: binding sourcePosition.
        variable location: (bindingLocationMap location dwarf::buildExpressionForStackMap: self target: debugGenerator compilationTarget)
    }.
}.

AsmStackMapLocation extend: {
    public abstract method dwarf::buildExpressionForStackMap: (stackMap: AsmStackMap) target: (compilationTarget: AsmCompilationTarget) ::=> Array
        := Dwarf::ExpressionBuilder build: ({:(Dwarf::ExpressionBuilder)builder :: Void |
            self dwarf::buildExpression: builder forStackMap: stackMap target: compilationTarget.
        }).

    public abstract method dwarf::buildExpression: (builder: Dwarf::ExpressionBuilder) forStackMap: (stackMap: AsmStackMap) target: (compilationTarget: AsmCompilationTarget) ::=> Array
        := self subclassResponsibility.
}.

AsmRegister extend: {
    public abstract method dwarf::registerNumberForTarget: (compilationTarget: AsmCompilationTarget) ::=> UInt32
        := self subclassResponsibility.
}.

AsmStackMapLocationRegister extend: {
    public override method dwarf::buildExpression: (builder: Dwarf::ExpressionBuilder) forStackMap: (stackMap: AsmStackMap) target: (compilationTarget: AsmCompilationTarget) ::=> Void := {
        builder register: (register dwarf::registerNumberForTarget: compilationTarget)
    }.
}.

AsmStackMapLocationFrameOffset extend: {
    public override method dwarf::buildExpression: (builder: Dwarf::ExpressionBuilder) forStackMap: (stackMap: AsmStackMap) target: (compilationTarget: AsmCompilationTarget) ::=> Void := {
        builder frameOffset: offset
    }.
}.

AsmCompilationTarget extend: {
    public method useDwarf => self __type__ := {
        debugInformationGenerator := Dwarf::ObjectDebugInformationGenerator.
        self
    }.
}.
