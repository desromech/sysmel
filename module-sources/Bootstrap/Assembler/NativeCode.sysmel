AsmStream definition: {
    public method asNativeCode => NativeCode
        := self assemble asNativeCode.
}.

AsmProgramEntity definition: {
    public method asNativeCode => NativeCode
        := self assembleWithoutGeneratingTargetInformation asNativeCode.
}.

AsmObjectCode definition: {
    public method asNativeCode => NativeCode := {
        let convertedSections := OrderedCollection new.
        let convertedSectionDictionary := ObjectPointerDictionary new.

        let convertedSymbols := OrderedCollection new.
        let convertedSymbolDictionary := Dictionary new.
        let convertedSymbolObjectDictionary := Dictionary new.

        ## Convert the sections.
        sections do: {:(AsmObjectCodeSection)eachSection :: Void |
            let convertedSection := NativeCodeSection new
                name: eachSection name;
                machoSectionName: eachSection machoSectionName;
                machoSegmentName: eachSection machoSegmentName;
                size: eachSection size;
                alignment: eachSection alignment;
                data: eachSection data;
                flags: eachSection convertFlagsForNativeCodeSection;
                debugSourcePositions: eachSection debugSourcePositions;
                debugSourceNodes: eachSection debugSourceNodes;
                debugSourceEnvironments: eachSection debugSourceEnvironments;
                yourself.

            convertedSections add: convertedSection.
            convertedSectionDictionary at: eachSection put: convertedSection.

            let sectionSymbol := NativeCodeSymbol new
                section: convertedSection;
                type: NativeCodeSymbol::Type::Section;
                visibility: NativeCodeSymbol::Visibility::Private;
                yourself.

            convertedSymbols add: sectionSymbol.
            convertedSymbolDictionary at: eachSection put: convertedSymbols size asUInt32.
        }.

        ## Convert the symbols.
        symbols do: {:(AsmSymbol)each :: Void |
            each isPrivate && (Untyped::==)(nil, each objectValue) ifTrue: {
                return: void
            }.

            (convertedSymbolDictionary includesKey: each) ifTrue: {
                return: void
            }.

            let convertedSymbol := each asNativeCodeSymbolWithSectionDictionary: convertedSectionDictionary.
            convertedSymbols add: convertedSymbol.
            convertedSymbolObjectDictionary at: each put: convertedSymbol.
            convertedSymbolDictionary at: each put: convertedSymbols size asUInt32.
        }.

        let convertSymbolBlock := {:(AsmSymbol)symbol :: NativeCodeSymbol |
            symbol ifNotNil: {
                convertedSymbolObjectDictionary at: symbol
            }
        }.

        ## Convert the program entities.
        let convertedProgramEntities := programEntities collect: {:(AsmObjectCodeProgramEntity)each :: NativeCodeProgramEntity |
            NativeCodeProgramEntity new
                name: each name;
                sourceProgramEntity: each sourceProgramEntity;
                contentSymbol: convertSymbolBlock(each contentSymbol);
                trampolineTarget: convertSymbolBlock(each trampolineTarget);
                ##stackMap: each stackMap;

                debugSourcePosition: each debugSourcePosition;
                debugSourceNode: each debugSourceNode;
                debugSourceEnvironment: each debugSourceEnvironment;
                yourself
        }.

        let convertedProgramEntityImportedSymbols := programEntityImportedSymbols collect: {:(Association)each :: Association |
            each key -> convertSymbolBlock(each value)
        }.

        ## Create the symbol table.
        let symbolTable := NativeCodeSymbolTable new
            symbols: convertedSymbols asArray;
            yourself.

        ## Convert the relocations.
        sections doWithIndex: {:(AsmObjectCodeSection)eachSection :(Size)index :: Void |
            let convertedSection => NativeCodeSection := convertedSections at: index.
            convertedSection symbolTable: symbolTable.

            let encoder := NativeCodeRelocationEncoder new
                symbolDictionary: convertedSymbolDictionary;
                yourself.
            eachSection relocations do: {:(AsmObjectCodeRelocation)eachRelocation :: Void |
                eachRelocation encodeNativeCodeRelocationWith: encoder
            }.

            convertedSection relocations: encoder finish
        }.

        ## Create the native code.
        NativeCode new
            symbolTable: symbolTable;
            sections: convertedSections asArray;
            programEntities: convertedProgramEntities;
            programEntityImportedSymbols: convertedProgramEntityImportedSymbols;
            yourself
    }.
}.

public global NativeCodeRelocation::AsmRelocationConversionFunction := (AsmSymbol, UInt32, Int64) => AsmObjectCodeRelocation.
public global NativeCodeRelocation::AsmRelocationConversionMap := #{
    NativeCodeRelocation::Type::Absolute32 : {:(AsmSymbol)symbol :(UInt32)offset :(Int64)addend :: AsmObjectCodeRelocation |
        AsmObjectCodeRelocationAbsoluteInt32 new
            symbol: symbol;
            offset: offset asSize;
            addend: addend asInt32;
            yourself
    }.
    NativeCodeRelocation::Type::Relative32 : {:(AsmSymbol)symbol :(UInt32)offset :(Int64)addend :: AsmObjectCodeRelocation |
        AsmObjectCodeRelocationRelativeInt32 new
            symbol: symbol;
            offset: offset asSize;
            addend: addend asInt32;
            yourself
    }.
    NativeCodeRelocation::Type::RelativePLT32 : {:(AsmSymbol)symbol :(UInt32)offset :(Int64)addend :: AsmObjectCodeRelocation |
        AsmObjectCodeRelocationRelativeInt32AtPLT new
            symbol: symbol;
            offset: offset asSize;
            addend: addend asInt32;
            yourself
    }.
    NativeCodeRelocation::Type::RelativeGOT32 : {:(AsmSymbol)symbol :(UInt32)offset :(Int64)addend :: AsmObjectCodeRelocation |
        AsmObjectCodeRelocationRelativeInt32AtGOT new
            symbol: symbol;
            offset: offset asSize;
            addend: addend asInt32;
            yourself
    }.
    NativeCodeRelocation::Type::SectionRelative32 : {:(AsmSymbol)symbol :(UInt32)offset :(Int64)addend :: AsmObjectCodeRelocation |
        AsmObjectCodeRelocationSectionRelativeInt32 new
            symbol: symbol;
            offset: offset asSize;
            addend: addend asInt32;
            yourself
    }.
    NativeCodeRelocation::Type::TPOffset32 : {:(AsmSymbol)symbol :(UInt32)offset :(Int64)addend :: AsmObjectCodeRelocation |
        AsmObjectCodeRelocationTPOffset32 new
            symbol: symbol;
            offset: offset asSize;
            addend: addend asInt32;
            yourself
    }.

    NativeCodeRelocation::Type::Absolute64 : {:(AsmSymbol)symbol :(UInt32)offset :(Int64)addend :: AsmObjectCodeRelocation |
        AsmObjectCodeRelocationAbsoluteInt64 new
            symbol: symbol;
            offset: offset asSize;
            addend: addend;
            yourself
    }.
    NativeCodeRelocation::Type::Relative64 : {:(AsmSymbol)symbol :(UInt32)offset :(Int64)addend :: AsmObjectCodeRelocation |
        AsmObjectCodeRelocationRelativeInt64 new
            symbol: symbol;
            offset: offset asSize;
            addend: addend;
            yourself
    }.
    NativeCodeRelocation::Type::SectionRelative64 : {:(AsmSymbol)symbol :(UInt32)offset :(Int64)addend :: AsmObjectCodeRelocation |
        AsmObjectCodeRelocationSectionRelativeInt64 new
            symbol: symbol;
            offset: offset asSize;
            addend: addend;
            yourself
    }.
}.

NativeCode definition: {
    public method asAsmObjectCodeWithTarget: (compilationTarget: AsmCompilationTarget) ::=> AsmObjectCode := {
        let sectionTable := ObjectPointerDictionary new.
        let asmSections := sections collect: {:(NativeCodeSection)eachSection :: AsmObjectCodeSection |
            let asmSection := AsmObjectCodeSection new
                name: eachSection name;
                machoSectionName: eachSection machoSectionName;
                machoSegmentName: eachSection machoSegmentName;
                alignment: eachSection alignment;
                size: eachSection size;
                data: eachSection data;
                executable: eachSection isExecutable;
                writeable: eachSection isWriteable;
                readable: eachSection isReadable;
                loaded: eachSection isLoaded;
                nobits: eachSection isNoBits;
                tls: eachSection isTLS;
                debugSourcePositions: eachSection debugSourcePositions;
                debugSourceNodes: eachSection debugSourceNodes;
                debugSourceEnvironments: eachSection debugSourceEnvironments;
                yourself.
            sectionTable at: eachSection put: asmSection.
            asmSection
        }.

        let symbolDictionary := ObjectPointerDictionary new.
        let asmSymbols := symbolTable symbols collect: {:(NativeCodeSymbol)eachSymbol :: AsmSymbol |
            let convertedSymbol := AsmSymbol new
                name: eachSymbol name;
                section: (eachSymbol section ifNotNil: {sectionTable at: eachSymbol section});
                value: eachSymbol value asUInt64;
                objectValue: eachSymbol objectValue;
                size: eachSymbol size asSize;
                type: eachSymbol type;
                visibility: eachSymbol visibility;
                yourself.

            symbolDictionary at: eachSymbol put: convertedSymbol.
            convertedSymbol
        }.

        sections doWithIndex: {:(NativeCodeSection)eachSection :(Size)index :: Void |
            let asmSection := asmSections at: index.

            eachSection relocations ifNotNil: {
                let asmRelocations := OrderedCollection new.
                eachSection relocations decodedRelocationsDo: {:(UInt8)type :(UInt32)symbolIndex :(UInt32)offset :(Int64)addend :: Void |
                    (symbolIndex = 0u32) || (symbolIndex asSize > asmSymbols size) ifTrue: {
                        return: void
                    }.

                    let asmSymbol => AsmSymbol := asmSymbols at: symbolIndex asSize.
                    let conversionFunction => NativeCodeRelocation::AsmRelocationConversionFunction := NativeCodeRelocation::AsmRelocationConversionMap at: type.
                    asmRelocations add: conversionFunction(asmSymbol, offset, addend)
                }.

                asmSection relocations: asmRelocations asArray
            }
        }.

        let convertSymbolBlock := {:(NativeCodeSymbol)symbol :: AsmSymbol |
            symbol ifNotNil: {
                symbolDictionary at: symbol
            }
        }.

        AsmObjectCode new
            compilationTarget: compilationTarget;
            sections: asmSections;
            symbols: asmSymbols;
            programEntities: (programEntities collect: {:(NativeCodeProgramEntity)each :: AsmObjectCodeProgramEntity |
                AsmObjectCodeProgramEntity new
                    name: each name;
                    sourceProgramEntity: each sourceProgramEntity;
                    contentSymbol: convertSymbolBlock(each contentSymbol);
                    trampolineTarget: convertSymbolBlock(each trampolineTarget);
                    ##stackMap: each stackMap;

                    debugSourcePosition: each debugSourcePosition;
                    debugSourceNode: each debugSourceNode;
                    debugSourceEnvironment: each debugSourceEnvironment;
                    yourself
            });
            programEntityImportedSymbols: (programEntityImportedSymbols collect: {:(Association)each :: Association |
                each key -> convertSymbolBlock(each value)
            });
            yourself
    }.
}.

AsmObjectCodeSection definition: {
    public method convertFlagsForNativeCodeSection => UInt32 := {
        let result mutable := 0u32.
        executable ifTrue: (result := result | NativeCodeSection::Flags::Executable).
        writeable ifTrue: (result := result | NativeCodeSection::Flags::Writeable).
        readable ifTrue: (result := result | NativeCodeSection::Flags::Readable).
        loaded ifTrue: (result := result | NativeCodeSection::Flags::Loaded).
        nobits ifTrue: (result := result | NativeCodeSection::Flags::NoBits).
        tls ifTrue: (result := result | NativeCodeSection::Flags::Tls).
        result
    }
}.

AsmSymbol definition: {
    public method asNativeCodeSymbolWithSectionDictionary: (sectionDictionary: ObjectPointerDictionary) ::=> NativeCodeSymbol
        := NativeCodeSymbol new
            name: name;
            section: (sectionDictionary at: section ifAbsent: {:: NativeCodeSection | nil});
            value: value asIntPointer;
            objectValue: self objectValue;
            size: size asSize;
            type: type;
            visibility: visibility;
            yourself.
}.

AsmObjectCodeRelocation definition: {
    public abstract method encodeNativeCodeRelocationWith: (encoder: NativeCodeRelocationEncoder) ::=> Void
        := self subclassResponsibility.
}.

AsmObjectCodeRelocationTPOffset32 definition: {
    public override method encodeNativeCodeRelocationWith: (encoder: NativeCodeRelocationEncoder) ::=> Void := {
        encoder asm::tpoffset32For: symbol addend: addend at: offset asUInt32
    }.
}.

AsmObjectCodeRelocationAbsoluteInt32 definition: {
    public override method encodeNativeCodeRelocationWith: (encoder: NativeCodeRelocationEncoder) ::=> Void := {
        encoder asm::absolute32For: symbol addend: addend at: offset asUInt32
    }.
}.

AsmObjectCodeRelocationAbsoluteInt64 definition: {
    public override method encodeNativeCodeRelocationWith: (encoder: NativeCodeRelocationEncoder) ::=> Void := {
        encoder asm::absolute64For: symbol addend: addend at: offset asUInt32
    }.
}.

AsmObjectCodeRelocationSectionRelativeInt32 definition: {
    public override method encodeNativeCodeRelocationWith: (encoder: NativeCodeRelocationEncoder) ::=> Void := {
        encoder asm::sectionRelative32For: symbol addend: addend at: offset asUInt32
    }.
}.

AsmObjectCodeRelocationSectionRelativeInt64 definition: {
    public override method encodeNativeCodeRelocationWith: (encoder: NativeCodeRelocationEncoder) ::=> Void := {
        encoder asm::sectionRelative64For: symbol addend: addend at: offset asUInt32
    }.
}.

AsmObjectCodeRelocationRelativeInt32 definition: {
    public override method encodeNativeCodeRelocationWith: (encoder: NativeCodeRelocationEncoder) ::=> Void := {
        encoder asm::relative32For: symbol addend: addend at: offset asUInt32
    }.
}.

AsmObjectCodeRelocationRelativeInt32AtPLT definition: {
    public override method encodeNativeCodeRelocationWith: (encoder: NativeCodeRelocationEncoder) ::=> Void := {
        encoder asm::relativePlt32For: symbol addend: addend at: offset asUInt32
    }.
}.

AsmObjectCodeRelocationRelativeInt32AtGOT definition: {
    public override method encodeNativeCodeRelocationWith: (encoder: NativeCodeRelocationEncoder) ::=> Void := {
        encoder asm::relativeGot32For: symbol addend: addend at: offset asUInt32
    }.
}.


AsmObjectCodeRelocationRelativeInt64 definition: {
    public override method encodeNativeCodeRelocationWith: (encoder: NativeCodeRelocationEncoder) ::=> Void := {
        encoder asm::relative64For: symbol addend: addend at: offset asUInt32
    }.
}.

NativeCodeRelocationEncoder definition: {
    public method asm::symbolIndexFor: (symbol: AsmSymbol) ::=> UInt32 := {
        self assert: symbol section isNotNil || symbol isPrivate not || symbol isGCObject.
        symbol isPrivate && symbol isGCObject not
            ifTrue: (symbolDictionary at: symbol section)
            ifFalse: (symbolDictionary at: symbol)
    }.

    public method asm::symbolAddend32For: (symbol: AsmSymbol) ::=> Int32
        := symbol isPrivate
            ifTrue: symbol value asInt32
            ifFalse: 0i32.

    public method asm::symbolAddend64For: (symbol: AsmSymbol) ::=> Int64
        := symbol isPrivate
            ifTrue: symbol value asInt64
            ifFalse: 0i64.

    public method asm::absolute32For: (symbol: AsmSymbol) addend: (addend: Int32) at: (offset: UInt32) ::=> Void := {
        self type: NativeCodeRelocation::Type::Absolute32 symbolIndex: (self asm::symbolIndexFor: symbol) offset: offset addend32: addend + (self asm::symbolAddend32For: symbol)
    }.

    public method asm::relative32For: (symbol: AsmSymbol) addend: (addend: Int32) at: (offset: UInt32) ::=> Void := {
        self type: NativeCodeRelocation::Type::Relative32 symbolIndex: (self asm::symbolIndexFor: symbol) offset: offset addend32: addend + (self asm::symbolAddend32For: symbol)
    }.

    public method asm::relativePlt32For: (symbol: AsmSymbol) addend: (addend: Int32) at: (offset: UInt32) ::=> Void := {
        self type: NativeCodeRelocation::Type::RelativePLT32 symbolIndex: (self asm::symbolIndexFor: symbol) offset: offset addend32: addend + (self asm::symbolAddend32For: symbol)
    }.

    public method asm::relativeGot32For: (symbol: AsmSymbol) addend: (addend: Int32) at: (offset: UInt32) ::=> Void := {
        self type: NativeCodeRelocation::Type::RelativeGOT32 symbolIndex: (self asm::symbolIndexFor: symbol) offset: offset addend32: addend + (self asm::symbolAddend32For: symbol)
    }.

    public method asm::sectionRelative32For: (symbol: AsmSymbol) addend: (addend: Int32) at: (offset: UInt32) ::=> Void := {
        self type: NativeCodeRelocation::Type::SectionRelative32 symbolIndex: (self asm::symbolIndexFor: symbol) offset: offset addend32: addend + (self asm::symbolAddend32For: symbol)
    }.

    public method asm::tpoffset32For: (symbol: AsmSymbol) addend: (addend: Int32) at: (offset: UInt32) ::=> Void := {
        self type: NativeCodeRelocation::Type::TPOffset32 symbolIndex: (self asm::symbolIndexFor: symbol) offset: offset addend32: addend + (self asm::symbolAddend32For: symbol)
    }.

    public method asm::absolute64For: (symbol: AsmSymbol) addend: (addend: Int64) at: (offset: UInt32) ::=> Void := {
        self type: NativeCodeRelocation::Type::Absolute64 symbolIndex: (self asm::symbolIndexFor: symbol) offset: offset addend64: addend + (self asm::symbolAddend64For: symbol)
    }.

    public method asm::relative64For: (symbol: AsmSymbol) addend: (addend: Int64) at: (offset: UInt32) ::=> Void := {
        self type: NativeCodeRelocation::Type::Relative64 symbolIndex: (self asm::symbolIndexFor: symbol) offset: offset addend64: addend + (self asm::symbolAddend64For: symbol)
    }.

    public method asm::sectionRelative64For: (symbol: AsmSymbol) addend: (addend: Int64) at: (offset: UInt32) ::=> Void := {
        self type: NativeCodeRelocation::Type::SectionRelative64 symbolIndex: (self asm::symbolIndexFor: symbol) offset: offset addend64: addend + (self asm::symbolAddend64For: symbol)
    }.

}.