public global Elf32::Addr := UInt32.
public global Elf32::Off := UInt32.
public global Elf32::Half := UInt16.
public global Elf32::Word := UInt32.
public global Elf32::Sword := Int32.

public global Elf64::Addr := UInt64.
public global Elf64::Off := UInt64.
public global Elf64::Half := UInt16.
public global Elf64::Word := UInt32.
public global Elf64::Sword := Int32.
public global Elf64::Xword := UInt64.
public global Elf64::Sxword := Int64.

public global Elf::Ident::Magic0 := 0sz.
public global Elf::Ident::Magic1 := 1sz.
public global Elf::Ident::Magic2 := 2sz.
public global Elf::Ident::Magic3 := 3sz.
public global Elf::Ident::Class := 4sz.
public global Elf::Ident::Data := 5sz.
public global Elf::Ident::Version := 6sz.
public global Elf::Ident::OSAbi := 7sz.
public global Elf::Ident::AbiVersion := 8sz.
public global Elf::Ident::NIdent := 16sz.

public global Elf::Ident::Class32 := 1u8.
public global Elf::Ident::Class64 := 2u8.

public global Elf::Ident::Data2LSB := 1u8.
public global Elf::Ident::Data2MSB := 2u8.

public global Elf::Ident::CurrentVersion := 1u8.
public global Elf::CurrentVersion := 1u32.

public global Elf::Machine::I386 := 3u16.
public global Elf::Machine::X86_64 := 62u16.

public global Elf::SectionHeaderType::Null := 0u32.
public global Elf::SectionHeaderType::Progbits := 1u32.
public global Elf::SectionHeaderType::Symtab := 2u32.
public global Elf::SectionHeaderType::Strtab := 3u32.
public global Elf::SectionHeaderType::Rela := 4u32.
public global Elf::SectionHeaderType::Hash := 5u32.
public global Elf::SectionHeaderType::Dynamic := 6u32.
public global Elf::SectionHeaderType::Note := 7u32.
public global Elf::SectionHeaderType::Nobits := 8u32.
public global Elf::SectionHeaderType::Rel := 9u32.
public global Elf::SectionHeaderType::Shlib := 10u32.
public global Elf::SectionHeaderType::Dynsym := 11u32.

public global Elf::SectionHeaderFlag::Write := 1u32.
public global Elf::SectionHeaderFlag::Alloc := 2u32.
public global Elf::SectionHeaderFlag::ExecInstr := 4u32.

public global Elf::Type::None := 0u16.
public global Elf::Type::Rel := 1u16.
public global Elf::Type::Exec := 2u16.
public global Elf::Type::Dyn := 3u16.
public global Elf::Type::Core := 4u16.

public struct Elf32::Header definition: {
    public field ident => UInt8[Elf::Ident::NIdent].
    public field type => Elf32::Half.
    public field machine => Elf32::Half.
    public field version => Elf32::Word.
    public field entry => Elf32::Addr.
    public field programHeaderOffset => Elf32::Off.
    public field sectionHeaderOffset => Elf32::Off.
    public field flags => Elf32::Word.
    public field elfHeaderSize => Elf32::Half.
    public field programHeaderEntrySize => Elf32::Half.
    public field programHeaderEntryNumber => Elf32::Half.
    public field sectionHeaderEntrySize => Elf32::Half.
    public field sectionHeaderEntryNumber => Elf32::Half.
    public field sectionNameStringStringTableIndex => Elf32::Half.

    public method initialize => Void := {
        ident
            at: Elf::Ident::Magic0 put: 16r7f u8;
            at: Elf::Ident::Magic1 put: 'E' asUInt8;
            at: Elf::Ident::Magic2 put: 'L' asUInt8;
            at: Elf::Ident::Magic3 put: 'F' asUInt8;
            at: Elf::Ident::Class put: Elf::Ident::Class32;
            at: Elf::Ident::Data put: Elf::Ident::Data2LSB;
            at: Elf::Ident::Version put: Elf::Ident::CurrentVersion.
        
        version := Elf::CurrentVersion.
        elfHeaderSize := self __type__ validInstanceSize asUInt16.
        sectionHeaderEntrySize := Elf32::SectionHeader validInstanceSize asUInt16.
    }.
}.

public struct Elf64::Header definition: {
    public field ident => UInt8[Elf::Ident::NIdent].
    public field type => Elf64::Half.
    public field machine => Elf64::Half.
    public field version => Elf64::Word.
    public field entry => Elf64::Addr.
    public field programHeaderOffset => Elf64::Off.
    public field sectionHeaderOffset => Elf64::Off.
    public field flags => Elf64::Word.
    public field elfHeaderSize => Elf64::Half.
    public field programHeaderEntrySize => Elf64::Half.
    public field programHeaderEntryNumber => Elf64::Half.
    public field sectionHeaderEntrySize => Elf64::Half.
    public field sectionHeaderEntryNumber => Elf64::Half.
    public field sectionNameStringStringTableIndex => Elf64::Half.

    public method initialize => Void := {
        ident
            at: Elf::Ident::Magic0 put: 16r7f u8;
            at: Elf::Ident::Magic1 put: 'E' asUInt8;
            at: Elf::Ident::Magic2 put: 'L' asUInt8;
            at: Elf::Ident::Magic3 put: 'F' asUInt8;
            at: Elf::Ident::Class put: Elf::Ident::Class64;
            at: Elf::Ident::Data put: Elf::Ident::Data2LSB;
            at: Elf::Ident::Version put: Elf::Ident::CurrentVersion.
        
        version := Elf::CurrentVersion.
        elfHeaderSize := self __type__ validInstanceSize asUInt16.
        sectionHeaderEntrySize := Elf64::SectionHeader validInstanceSize asUInt16.
    }.
}.

public struct Elf32::SectionHeader definition: {
    public field name => Elf32::Word.
    public field type => Elf32::Word.
    public field flags => Elf32::Word.
    public field addr => Elf32::Addr.
    public field offset => Elf32::Off.
    public field size => Elf32::Word.
    public field link => Elf32::Word.
    public field info => Elf32::Word.
    public field addrAlign => Elf32::Word.
    public field entrySize => Elf32::Word.
}.

public struct Elf64::SectionHeader definition: {
    public field name => Elf64::Word.
    public field type => Elf64::Word.
    public field flags => Elf64::Xword.
    public field addr => Elf64::Addr.
    public field offset => Elf64::Off.
    public field size => Elf64::Xword.
    public field link => Elf64::Word.
    public field info => Elf64::Word.
    public field addrAlign => Elf64::Xword.
    public field entrySize => Elf64::Xword.
}.

public struct Elf64::Symbol definition: {
    public field name => Elf64::Word.
    public field info => UInt8.
    public field other => UInt8.
    public field sectionHeaderIndex => Elf64::Half.
    public field value => Elf64::Addr.
    public field size => Elf64::Xword.
}.

public struct Elf64::Rel definition: {
    public field offset => Elf64::Addr.
    public field info => Elf64::Xword.
}.

public struct Elf64::Rela definition: {
    public field offset => Elf64::Addr.
    public field info => Elf64::Xword.
    public field addend => Elf64::Sxword.
}.

AsmObjectCodeSection extend: {
    public method elfSectionType => UInt32
        := loaded
            ifTrue: Elf::SectionHeaderType::Progbits
            ifFalse: Elf::SectionHeaderType::Nobits.

    public method elfSectionFlags => UInt32 := {
        let elfFlags mutable := 0u32.
        readable ifTrue: (elfFlags := elfFlags | Elf::SectionHeaderFlag::Alloc).
        writeable ifTrue: (elfFlags := elfFlags | Elf::SectionHeaderFlag::Write).
        executable ifTrue: (elfFlags := elfFlags | Elf::SectionHeaderFlag::ExecInstr).
        elfFlags
    }.
}.

AsmObjectCode extend: {
    public method encodeAsElf64 => ByteArray := {
        let header := Elf64::Header new
            type: Elf::Type::Rel;
            machine: Elf::Machine::X86_64;
            yourself.

        let fileLayout := ArrayList new.
        fileLayout
            add: header;
            addAll: sections.

        let stringTable := AsmObjectCodeCStringTable new.
        let sectionNameStringTable := AsmObjectCodeCStringTable new.
        fileLayout add: sectionNameStringTable.

        let sectionHeaders := ArrayList new.
        let sectionDataElements := ArrayList new.
        sectionHeaders add: Elf64::SectionHeader new. ## Null section
        sectionDataElements add: nil.

        sections do: {:(AsmObjectCodeSection)eachSection :: Void |
            let sectionHeader := Elf64::SectionHeader new
                name: (sectionNameStringTable addSymbol: eachSection name) asUInt32;
                type: eachSection elfSectionType;
                flags: eachSection elfSectionFlags asUInt64;
                size: eachSection size asUInt64;
                addrAlign: eachSection alignment asUInt64;
                yourself.
            sectionHeaders add: sectionHeader.
            sectionDataElements add: eachSection.
        }.

        ## String table.
        {
            stringTable finish.
            sectionHeaders add: (Elf64::SectionHeader new
                name: (sectionNameStringTable addString: ".strtab") asUInt32;
                type: Elf::SectionHeaderType::Strtab;
                size: stringTable size asUInt64;
                addrAlign: 1sz;
                yourself).
            sectionDataElements add: sectionNameStringTable.
        }.

        ## Section name string table.
        {
            header sectionNameStringStringTableIndex: sectionHeaders size asUInt16.
            let sectionNameStringTableHeader := Elf64::SectionHeader new
                name: (sectionNameStringTable addString: ".shstrtab") asUInt32;
                type: Elf::SectionHeaderType::Strtab;
                addrAlign: 1sz;
                yourself.
            sectionNameStringTable finish.
            sectionNameStringTableHeader size: sectionNameStringTable size asUInt64.
            sectionHeaders add: sectionNameStringTableHeader.
            sectionDataElements add: sectionNameStringTable.
        }.

        let sectionsHeadersLabel := ByteStreamEncodingLabel new.
        fileLayout
            add: sectionsHeadersLabel;
            addAll: sectionHeaders;
            computeOffsetsOfEncodedElementsInByteStream.

        sectionDataElements doWithIndex: {:dataElement :(Size)index :: Void |
            dataElement ifNotNil: {
                (sectionHeaders at: index)
                    offset: dataElement offsetOfEncodedElementInByteStream asUInt64
            }.
        }.

        header
            sectionHeaderOffset: sectionsHeadersLabel offsetOfEncodedElementInByteStream asUInt64;
            sectionHeaderEntryNumber: sectionHeaders size asUInt16.

        fileLayout encodedElementsInByteArray
    }.

    public method writeElf64ToFileNamed: (fileName: String) ::=> Void
        := IO::saveWholeFileNamed(fileName, self encodeAsElf64).
}.
