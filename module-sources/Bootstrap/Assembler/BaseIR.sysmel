public final class AsmStream superclass: Object.
public class AsmStreamElement superclass: AsmInstructionOperand.
public abstract class AsmConstantExpression superclass: Object.

let PrintingDebugInfo := false.

public class AsmStreamElement superclass: Object; definition: {
    ## Instruction links.
    public field previous => AsmStreamElement.
    public field next => AsmStreamElement.

    public field position => Size.
    ##public field section => Size.

    ## Debugging information
    public field debugSourcePosition => SourcePosition.
    public field debugSourceNode => ASTNode.
    public field debugSourceEnvironment => Environment.

    public virtual method isLabel => Boolean := false.
    public virtual method isSectionDirective => Boolean := false.

    public method printDebugInfoOn: (stream: Stream) ::=> Void := {
        debugSourcePosition isNotNil && PrintingDebugInfo ifTrue: {
            stream space; nextPutAll: "# at "; print: debugSourcePosition
        }
    }.

    public override method initialize => Void := {
        position := 0sz
    }.

    public virtual method isFormattedWithIndentation => Boolean := true.

    public virtual method recordDebugInfoOnObjectCodeStream: (stream: AsmObjectCodeStream) ::=> Void := {
        stream recordDebugSourcePosition: debugSourcePosition node: debugSourceNode environment: debugSourceEnvironment
    }.

    public abstract method writeOnObjectCodeStream: (stream: AsmObjectCodeStream) ::=> Void
        := self subclassResponsibility.

    public virtual method selectEncodingAlternatives => Void := {
        ## By default do nothing
    }.

    public virtual method isUnneededStreamElement => Boolean := false.
    public virtual method isMetadataStreamElement => Boolean := false.
    public virtual method isMetadataOrAlignStreamElement => Boolean := self isMetadataStreamElement.

    public method nextNonMetadataStreamElement => AsmStreamElement := {
        let position mutable := next.
        while: (position isNotNil && position isMetadataStreamElement) do: {
            position := position next
        }.

        position
    }.

    public method nextNonMetadataOrAlignStreamElement => AsmStreamElement := {
        let position mutable := next.
        while: (position isNotNil && position isMetadataOrAlignStreamElement) do: {
            position := position next
        }.

        position
    }.
}.

AsmInstructionOperand definition: {
    public virtual method isImmediate => Boolean := false.
    public virtual method isImmediateValue1 => Boolean := false.
    public virtual method isImmediateValue0 => Boolean := false.
    public virtual method isImmediate8 => Boolean := self isImmediate && (self size = 1sz).
    public virtual method isImmediate16 => Boolean := self isImmediate && (self size <= 2sz).
    public virtual method isImmediate32 => Boolean := self isImmediate && (self size <= 4sz).
    public virtual method isImmediate64 => Boolean := self isImmediate && (self size <= 8sz).
    public virtual method isImmediate128 => Boolean := self isImmediate && (self size <= 16sz).

    public virtual method isImmediateSymbolWithAddend => Boolean := false.

    public virtual method isImmediateSigned8 => Boolean := false.
    public virtual method isImmediateSigned32 => Boolean := false.
    public virtual method isImmediateSigned64 => Boolean := false.

    public virtual method isImmediateUnsigned32 => Boolean := false.

    public virtual method isAbsoluteOffset => Boolean := false.

    public virtual method asImmediateSigned8Value => Int8 := self error: "Not an immediate signed 8".
    public virtual method asImmediateSigned32Value => Int32 := self error: "Not an immediate signed 8".
    public virtual method asImmediateUnsigned32Value => Int32 := self error: "Not an immediate unsigned 8".

    public virtual method isImmediateConstantChar8 => Boolean := false.
    public virtual method isImmediateConstantUInt8 => Boolean := false.
    public virtual method isImmediateConstantInt8 => Boolean := false.

    public virtual method isImmediateConstantChar16 => Boolean := false.
    public virtual method isImmediateConstantUInt16 => Boolean := false.
    public virtual method isImmediateConstantInt16 => Boolean := false.

    public virtual method isImmediateConstantChar32 => Boolean := false.
    public virtual method isImmediateConstantUInt32 => Boolean := false.
    public virtual method isImmediateConstantInt32 => Boolean := false.

    public virtual method isImmediateConstantUInt64 => Boolean := false.
    public virtual method isImmediateConstantInt64 => Boolean := false.

    public virtual method isImmediateConstantFloat32 => Boolean := false.
    public virtual method isImmediateConstantFloat64 => Boolean := false.

    public virtual method isRegister => Boolean := false.
    public virtual method isRegisterOrRegisterAddress => Boolean := false.
    public virtual method isVectorRegister => Boolean := false.
    public virtual method isVectorRegisterOrRegisterAddress => Boolean := false.
    public virtual method isRegisterAddress => Boolean := false.

    public virtual method matchesStreamElement: (streamElement: AsmStreamElement) ::=> Boolean
        := false.

    public virtual method recordRelocationSymbolOnCodeStream: (codeStream: AsmObjectCodeStream) ::=> Void := {}.

    public abstract method nextPutImmediateWithSize: (requiredSize: Size) onCodeStream: (codeStream: AsmObjectCodeStream) ::=> Void
        := self subclassResponsibility.

    public abstract method nextPutIPRelativeI32WithExtraOffset: (extraOffset: Int32) onCodeStream: (codeStream: AsmObjectCodeStream) ::=> Void
        := self subclassResponsibility.

    public virtual method evaluateImmediateUInt32 => UInt32
        := self error: "Not a valid immediate".

    public virtual method evaluateImmediateInt32 => Int32
        := self error: "Not a valid immediate".

    public abstract method size => Size := self subclassResponsibility.
}.

AsmRegister definition: {
    public override method isRegister => Boolean := true.
    public override method isRegisterOrRegisterAddress => Boolean := true.
}.

public class AsmRegisterAddress superclass: AsmInstructionOperand; definition: {
    public override method isRegisterAddress => Boolean := true.
    public override method isRegisterOrRegisterAddress => Boolean := true.
    public override method isVectorRegisterOrRegisterAddress => Boolean := true.
}.

public class AsmImmediate superclass: AsmInstructionOperand.
public final class AsmImmediateSymbolWithAddend superclass: AsmImmediate.

AsmImmediate definition: {
    public override method isImmediate => Boolean := true.

    public abstract method sumSigned32With: (other: AsmImmediate) ::=> AsmImmediate
        := self subclassResponsibility.

    public abstract method sumSigned32WithInt32: (next: Int32) ::=> AsmImmediate
        := self subclassResponsibility.

    public virtual method sumSigned32WithSymbolWithAddend: (next: AsmImmediateSymbolWithAddend) ::=> AsmImmediate
        := self sumSigned32With: next.
}.

public global AsmSymbol::RelocationMode::None := 0u8.
public global AsmSymbol::RelocationMode::GOT := 1u8.
public global AsmSymbol::RelocationMode::PLT := 2u8.
public global AsmSymbol::RelocationMode::SectionRelative := 3u8.
public global AsmSymbol::RelocationMode::TPOff := 4u8.

AsmImmediateSymbolWithAddend definition: {
    public field symbol => AsmSymbol.
    public field size => Size.
    public field addend => Int64.
    public field relocationMode => UInt8.

    public override method isImmediateSymbolWithAddend => Boolean := true.

    public override method isImmediateSigned8 => Boolean := size = 1sz.
    public override method isImmediateSigned32 => Boolean := size = 2sz.
    public override method isImmediateSigned64 => Boolean := size = 4sz.

    public override method isAbsoluteOffset => Boolean
        := self isTPOff || self isSectionRelative.

    public method asConstantExpression => AsmConstantExpression
        := AsmConstantExpressionSymbolValue new
            immediateSymbolWithAddend: self;
            yourself.

    public method endConstantExpression => AsmConstantExpression
        := AsmConstantExpressionSymbolEndValue new
            immediateSymbolWithAddend: self;
            yourself.

    public method + (extraAddend: Int64) ::=> SelfType
        := self copy
            addend: addend + extraAddend;
            yourself.

    public override method sumSigned32WithInt32: (next: Int32) ::=> AsmImmediate
        := self + next asInt64.

    public override method sumSigned32With: (other: AsmImmediate) ::=> AsmImmediate
        := other sumSigned32WithSymbolWithAddend: self.

    public override method sumSigned32WithSymbolWithAddend: (next: AsmImmediateSymbolWithAddend) ::=> AsmImmediate
        := self error: "Cannot sum two symbols.".

    public override method printOn: (stream: Stream) ::=> Void := {
        stream print: symbol.
        addend ~= 0i64 ifTrue: (stream nextPutAll: " + "; print: addend).
    }.

    public override method recordRelocationSymbolOnCodeStream: (codeStream: AsmObjectCodeStream) ::=> Void := {
        codeStream recordRelocationSymbol: symbol
    }.

    public override method nextPutImmediateWithSize: (requiredSize: Size) onCodeStream: (codeStream: AsmObjectCodeStream) ::=> Void := {
        self assert: (requiredSize = 4sz) || (requiredSize = 8sz).
        requiredSize = 4sz ifTrue: {
            self isTPOff ifTrue: {
                codeStream
                    recordRelocation: (AsmObjectCodeRelocationTPOffset32 new
                        symbol: symbol;
                        addend: addend asInt32;
                        yourself).
            } ifFalse: {
                self isSectionRelative ifTrue: {
                    codeStream
                        recordRelocation: (AsmObjectCodeRelocationSectionRelativeInt32 new
                            symbol: symbol;
                            addend: addend asInt32;
                            yourself)
                } ifFalse: {
                    codeStream
                        recordRelocation: (AsmObjectCodeRelocationAbsoluteInt32 new
                            symbol: symbol;
                            addend: addend asInt32;
                            yourself)
                }
            }.

            codeStream nextPutUInt32: 0u32
        }.
        requiredSize = 8sz ifTrue: {
            self isSectionRelative ifTrue: {
                codeStream
                    recordRelocation: (AsmObjectCodeRelocationSectionRelativeInt64 new
                        symbol: symbol;
                        addend: addend asInt64;
                        yourself);
                    nextPutUInt64: 0u64
            } ifFalse: {
                codeStream
                    recordRelocation: (AsmObjectCodeRelocationAbsoluteInt64 new
                        symbol: symbol;
                        addend: addend asInt64;
                        yourself);
                    nextPutUInt64: 0u64
            }.
        }.
    }.

    public override method nextPutIPRelativeI32WithExtraOffset: (extraOffset: Int32) onCodeStream: (codeStream: AsmObjectCodeStream) ::=> Void := {
        let shouldAvoidRelocation := symbol isPrivate && symbol section isNotNil && (symbol section == codeStream activeSection).
        shouldAvoidRelocation ifTrue:{
            codeStream nextPutInt32: symbol value asInt32 - codeStream activeSection writeOffset asInt32 + addend asInt32 - extraOffset.
            return: void
        }.

        self isAtPLT ifTrue: {
            codeStream recordRelocation: (AsmObjectCodeRelocationRelativeInt32AtPLT new
                symbol: symbol;
                addend: addend asInt32 - extraOffset;
                yourself)
        } ifFalse: {
            self isAtGOT ifTrue: {
                codeStream recordRelocation: (AsmObjectCodeRelocationRelativeInt32AtGOT new
                    symbol: symbol;
                    addend: addend asInt32 - extraOffset;
                    yourself)
            } ifFalse: {
                codeStream recordRelocation: (AsmObjectCodeRelocationRelativeInt32 new
                    symbol: symbol;
                    addend: addend asInt32 - extraOffset;
                    yourself)
            }.
        }.

        codeStream nextPutUInt32: 0u32

    }.

    public method isAtGOT => Boolean
        := relocationMode = AsmSymbol::RelocationMode::GOT.

    public method makeAtGOT => Void :={
        relocationMode := AsmSymbol::RelocationMode::GOT
    }.

    public method isAtPLT => Boolean
        := relocationMode = AsmSymbol::RelocationMode::PLT.

    public method makeAtPLT => Void :={
        relocationMode := AsmSymbol::RelocationMode::PLT
    }.

    public method isSectionRelative => Boolean
        := relocationMode = AsmSymbol::RelocationMode::SectionRelative.

    public method makeSectionRelative => Void :={
        relocationMode := AsmSymbol::RelocationMode::SectionRelative
    }.

    public method isTPOff => Boolean
        := relocationMode = AsmSymbol::RelocationMode::TPOff.

    public method makeTPOff => Void :={
        relocationMode := AsmSymbol::RelocationMode::TPOff
    }.

    public override method matchesStreamElement: (streamElement: AsmStreamElement) ::=> Boolean := {
        (addend = 0i64) && streamElement isLabel ifTrue: { 
            let label := streamElement uncheckedDownCastTo: AsmLabel.
            label symbol == symbol
        } ifFalse: {
            false
        }
    }.
}.

AsmSymbol extend: {
    public method immediate: (immediateSize: Size) ::=> AsmImmediateSymbolWithAddend
        := AsmImmediateSymbolWithAddend new
            symbol: self;
            size: immediateSize;
            yourself.

    public method immediateSectionRelative: (immediateSize: Size) ::=> AsmImmediateSymbolWithAddend
        := AsmImmediateSymbolWithAddend new
            symbol: self;
            size: immediateSize;
            makeSectionRelative;
            yourself.

    public method byte => AsmImmediateSymbolWithAddend
        := self immediate: 1sz.

    public method word => AsmImmediateSymbolWithAddend
        := self immediate: 2sz.

    public method dword => AsmImmediateSymbolWithAddend
        := self immediate: 4sz.

    public method qword => AsmImmediateSymbolWithAddend
        := self immediate: 8sz.
}.

public class AsmImmediateConstant superclass: AsmImmediate; definition: {
    public method isImmediateConstant => Boolean := true.
}.

AsmConstantExpression definition: {
    public abstract method evaluateInt64 => Int64
        := self subclassResponsibility.

    public virtual method evaluateInt32 => Int32
        := self evaluateInt64 asInt32.

    public virtual method evaluateInt16 => Int16
        := self evaluateInt64 asInt16.

    public virtual method evaluateInt8 => Int8
        := self evaluateInt64 asInt8.

    public method + (operand: AsmConstantExpression) ::=> AsmConstantExpression
        := AsmConstantExpressionBinaryAdd new left: self; right: operand; yourself.

    public method - (operand: AsmConstantExpression) ::=> AsmConstantExpression
        := AsmConstantExpressionBinarySubtract new left: self; right: operand; yourself.

    public virtual method writeInt8OnObjectCodeStream: (stream: AsmObjectCodeStream) ::=> Void := {
        stream nextPutInt8: self evaluateInt8
    }.

    public virtual method writeInt16OnObjectCodeStream: (stream: AsmObjectCodeStream) ::=> Void := {
        stream nextPutInt16: self evaluateInt16
    }.

    public virtual method writeInt32OnObjectCodeStream: (stream: AsmObjectCodeStream) ::=> Void := {
        stream nextPutInt32: self evaluateInt32
    }.

    public virtual method writeInt64OnObjectCodeStream: (stream: AsmObjectCodeStream) ::=> Void := {
        stream nextPutInt64: self evaluateInt64
    }.
}.

public abstract class AsmConstantExpressionBinary superclass: AsmConstantExpression; definition: {
    public field left => AsmConstantExpression.
    public field right => AsmConstantExpression.
}.

public final class AsmConstantExpressionBinaryAdd superclass: AsmConstantExpressionBinary; definition: {
    public override method printOn: (stream: Stream) ::=> Void := {
        stream print: left; nextPutAll: " + "; print: right
    }.

    public override method evaluateInt64 => Int64
        := left evaluateInt64 + right evaluateInt64.
}.

public final class AsmConstantExpressionBinarySubtract superclass: AsmConstantExpressionBinary; definition: {
    public override method printOn: (stream: Stream) ::=> Void := {
        stream print: left; nextPutAll: " - "; print: right
    }.

    public override method evaluateInt64 => Int64
        := left evaluateInt64 - right evaluateInt64.
}.

public final class AsmConstantExpressionInteger superclass: AsmConstantExpression; definition: {
    public field value => Int64.

    public override method printOn: (stream: Stream) ::=> Void := {
        stream print: value
    }.

    public override method evaluateInt64 => Int64
        := value.
}.

public final class AsmConstantExpressionSymbolValue superclass: AsmConstantExpression; definition: {
    public field immediateSymbolWithAddend => AsmImmediateSymbolWithAddend.

    public override method printOn: (stream: Stream) ::=> Void := {
        stream print: immediateSymbolWithAddend
    }.

    public override method evaluateInt64 => Int64
        := immediateSymbolWithAddend symbol value asInt64 + immediateSymbolWithAddend addend.

    public override method writeInt8OnObjectCodeStream: (codeStream: AsmObjectCodeStream) ::=> Void := {
        codeStream recordRelocation: (AsmObjectCodeRelocationAbsoluteInt8 new
            symbol: immediateSymbolWithAddend symbol;
            addend: immediateSymbolWithAddend addend asInt8;
            yourself).
        codeStream nextPut: 0u8
    }.

    public override method writeInt16OnObjectCodeStream: (codeStream: AsmObjectCodeStream) ::=> Void := {
        codeStream recordRelocation: (AsmObjectCodeRelocationAbsoluteInt16 new
            symbol: immediateSymbolWithAddend symbol;
            addend: immediateSymbolWithAddend addend asInt16;
            yourself).
        codeStream nextPutUInt16: 0u16
    }.

    public override method writeInt32OnObjectCodeStream: (codeStream: AsmObjectCodeStream) ::=> Void := {
        immediateSymbolWithAddend isSectionRelative ifTrue: {
            codeStream recordRelocation: (AsmObjectCodeRelocationSectionRelativeInt32 new
                symbol: immediateSymbolWithAddend symbol;
                addend: immediateSymbolWithAddend addend asInt32;
                yourself).
        } ifFalse: {
            codeStream recordRelocation: (AsmObjectCodeRelocationAbsoluteInt32 new
                symbol: immediateSymbolWithAddend symbol;
                addend: immediateSymbolWithAddend addend asInt32;
                yourself).
        }.
        codeStream nextPutUInt32: 0u32
    }.

    public override method writeInt64OnObjectCodeStream: (codeStream: AsmObjectCodeStream) ::=> Void := {
        immediateSymbolWithAddend isSectionRelative ifTrue: {
            codeStream recordRelocation: (AsmObjectCodeRelocationSectionRelativeInt64 new
                symbol: immediateSymbolWithAddend symbol;
                addend: immediateSymbolWithAddend addend;
                yourself).
        } ifFalse: {
            codeStream recordRelocation: (AsmObjectCodeRelocationAbsoluteInt64 new
                symbol: immediateSymbolWithAddend symbol;
                addend: immediateSymbolWithAddend addend;
                yourself).
        }.
        codeStream nextPutUInt64: 0u64
    }.
}.

public final class AsmConstantExpressionSymbolEndValue superclass: AsmConstantExpression; definition: {
    public field immediateSymbolWithAddend => AsmImmediateSymbolWithAddend.

    public override method printOn: (stream: Stream) ::=> Void := {
        stream print: immediateSymbolWithAddend
    }.

    public override method evaluateInt64 => Int64
        := immediateSymbolWithAddend symbol value asInt64 + immediateSymbolWithAddend symbol size asInt64 + immediateSymbolWithAddend addend.

    public override method writeInt8OnObjectCodeStream: (codeStream: AsmObjectCodeStream) ::=> Void := {
        codeStream recordRelocation: (AsmObjectCodeRelocationAbsoluteInt8 new
            symbol: immediateSymbolWithAddend symbol;
            addend: immediateSymbolWithAddend symbol size asInt8 + immediateSymbolWithAddend addend asInt8;
            yourself).
        codeStream nextPut: 0u8
    }.

    public override method writeInt16OnObjectCodeStream: (codeStream: AsmObjectCodeStream) ::=> Void := {
        codeStream recordRelocation: (AsmObjectCodeRelocationAbsoluteInt16 new
            symbol: immediateSymbolWithAddend symbol;
            addend: immediateSymbolWithAddend symbol size asInt16 + immediateSymbolWithAddend addend asInt16;
            yourself).
        codeStream nextPutUInt16: 0u16
    }.

    public override method writeInt32OnObjectCodeStream: (codeStream: AsmObjectCodeStream) ::=> Void := {
        immediateSymbolWithAddend isSectionRelative ifTrue: {
            codeStream recordRelocation: (AsmObjectCodeRelocationSectionRelativeInt32 new
                symbol: immediateSymbolWithAddend symbol;
                addend: immediateSymbolWithAddend symbol size asInt32 + immediateSymbolWithAddend addend asInt32;
                yourself).
        } ifFalse: {
            codeStream recordRelocation: (AsmObjectCodeRelocationAbsoluteInt32 new
                symbol: immediateSymbolWithAddend symbol;
                addend: immediateSymbolWithAddend symbol size asInt32 + immediateSymbolWithAddend addend asInt32;
                yourself).
        }.
        codeStream nextPutUInt32: 0u32
    }.

    public override method writeInt64OnObjectCodeStream: (codeStream: AsmObjectCodeStream) ::=> Void := {
        immediateSymbolWithAddend isSectionRelative ifTrue: {
            codeStream recordRelocation: (AsmObjectCodeRelocationSectionRelativeInt64 new
                symbol: immediateSymbolWithAddend symbol;
                addend: immediateSymbolWithAddend symbol size asInt64 + immediateSymbolWithAddend addend;
                yourself).
        } ifFalse: {
            codeStream recordRelocation: (AsmObjectCodeRelocationAbsoluteInt64 new
                symbol: immediateSymbolWithAddend symbol;
                addend: immediateSymbolWithAddend symbol size asInt64 + immediateSymbolWithAddend addend;
                yourself).
        }.

        codeStream nextPutUInt64: 0u64
    }.
}.

public final class AsmImmediateConstantChar8 superclass: AsmImmediateConstant; definition: {
    public field value => Char8.

    public override method isImmediateSigned32 => Boolean := true.
    public override method isImmediateValue1 => Boolean := value = 1c8.
    public override method isImmediateValue0 => Boolean := value = 0c8.
    public override method isImmediateConstantChar8 => Boolean := true.
    public override method size => Size := 1sz.


    public override method nextPutImmediateWithSize: (requiredSize: Size) onCodeStream: (codeStream: AsmObjectCodeStream) ::=> Void := {
        codeStream nextPutUInt32: value asUInt32 withSize: requiredSize
    }.

    public override method printOn: (stream: Stream) ::=> Void := {
        stream print: value; nextPutAll: "c8"
    }.

    Char8 extend: {
        public method asAsmImmediate => AsmImmediateConstantChar8
            := AsmImmediateConstantChar8 new value: self; yourself
    }.
}.

public final class AsmImmediateConstantUInt8 superclass: AsmImmediateConstant; definition: {
    public field value => UInt8.

    public override method isImmediateSigned32 => Boolean := true.
    public override method isImmediateValue1 => Boolean := value = 1u8.
    public override method isImmediateValue0 => Boolean := value = 0u8.

    public override method isImmediateConstantUInt8 => Boolean := true.
    public override method size => Size := 1sz.

    public override method nextPutImmediateWithSize: (requiredSize: Size) onCodeStream: (codeStream: AsmObjectCodeStream) ::=> Void := {
        codeStream nextPutUInt32: value asUInt32 withSize: requiredSize
    }.

    public override method printOn: (stream: Stream) ::=> Void := {
        stream print: value; nextPutAll: "u8"
    }.

    UInt8 extend: {
        public method asAsmImmediate => AsmImmediateConstantUInt8
            := AsmImmediateConstantUInt8 new value: self; yourself
    }.
}.

public final class AsmImmediateConstantInt8 superclass: AsmImmediateConstant; definition: {
    public field value => Int8.
    
    public override method isImmediateSigned32 => Boolean := true.
    public override method isImmediateValue1 => Boolean := value = 1i8.
    public override method isImmediateValue0 => Boolean := value = 0i8.

    public override method isImmediateSigned8 => Boolean := true.
    public override method isImmediateConstantInt8 => Boolean := true.

    public override method asImmediateSigned8Value => Int8 := value.

    public override method size => Size := 1sz.

    public override method nextPutImmediateWithSize: (requiredSize: Size) onCodeStream: (codeStream: AsmObjectCodeStream) ::=> Void := {
        codeStream nextPutInt32: value asInt32 withSize: requiredSize
    }.

    public override method printOn: (stream: Stream) ::=> Void := {
        stream print: value; nextPutAll: "i8"
    }.

    Int8 extend: {
        public method asAsmImmediate => AsmImmediateConstantInt8
            := AsmImmediateConstantInt8 new value: self; yourself
    }.
}.

public final class AsmImmediateConstantChar16 superclass: AsmImmediateConstant; definition: {
    public field value => Char16.

    public override method isImmediateSigned32 => Boolean := true.
    public override method isImmediateConstantChar16 => Boolean := true.
    public override method isImmediateValue0 => Boolean := value = 0c16.
    public override method isImmediateValue1 => Boolean := value = 1c16.

    public override method size => Size := 2sz.

    public override method nextPutImmediateWithSize: (requiredSize: Size) onCodeStream: (codeStream: AsmObjectCodeStream) ::=> Void := {
        codeStream nextPutUInt32: value asUInt32 withSize: requiredSize
    }.

    public override method printOn: (stream: Stream) ::=> Void := {
        stream print: value; nextPutAll: "c16"
    }.

    Char16 extend: {
        public method asAsmImmediate => AsmImmediateConstantChar16
            := AsmImmediateConstantChar16 new value: self; yourself
    }.
}.

public final class AsmImmediateConstantUInt16 superclass: AsmImmediateConstant; definition: {
    public field value => UInt16.

    public override method isImmediateSigned32 => Boolean := true.
    public override method isImmediateConstantUInt16 => Boolean := true.
    public override method isImmediateValue0 => Boolean := value = 0u16.
    public override method isImmediateValue1 => Boolean := value = 1u16.
    public override method size => Size := 2sz.

    public override method nextPutImmediateWithSize: (requiredSize: Size) onCodeStream: (codeStream: AsmObjectCodeStream) ::=> Void := {
        codeStream nextPutUInt32: value asUInt32 withSize: requiredSize
    }.

    public override method printOn: (stream: Stream) ::=> Void := {
        stream print: value; nextPutAll: "u16"
    }.

    UInt16 extend: {
        public method asAsmImmediate => AsmImmediateConstantUInt16
            := AsmImmediateConstantUInt16 new value: self; yourself
    }.
}.

public final class AsmImmediateConstantInt16 superclass: AsmImmediateConstant; definition: {
    public field value => Int16.
    
    public override method isImmediateSigned32 => Boolean := true.
    public override method isImmediateConstantInt16 => Boolean := true.
    public override method isImmediateValue0 => Boolean := value = 0i16.
    public override method isImmediateValue1 => Boolean := value = 1i16.
    public override method size => Size := 2sz.

    public override method nextPutImmediateWithSize: (requiredSize: Size) onCodeStream: (codeStream: AsmObjectCodeStream) ::=> Void := {
        codeStream nextPutInt32: value asInt32 withSize: requiredSize
    }.

    public override method printOn: (stream: Stream) ::=> Void := {
        stream print: value; nextPutAll: "i16"
    }.

    Int16 extend: {
        public method asAsmImmediate => AsmImmediateConstantInt16
            := AsmImmediateConstantInt16 new value: self; yourself
    }.
}.

public final class AsmImmediateConstantChar32 superclass: AsmImmediateConstant; definition: {
    public field value => Char32.

    public override method isImmediateSigned32 => Boolean := value <= 16r7FFF_FFFF c32.

    public override method isImmediateConstantChar32 => Boolean := true.
    public override method isImmediateValue0 => Boolean := value = 0c32.
    public override method isImmediateValue1 => Boolean := value = 1c32.
    public override method size => Size := 4sz.

    public override method nextPutImmediateWithSize: (requiredSize: Size) onCodeStream: (codeStream: AsmObjectCodeStream) ::=> Void := {
        codeStream nextPutUInt32: value asUInt32 withSize: requiredSize
    }.

    public override method printOn: (stream: Stream) ::=> Void := {
        stream print: value; nextPutAll: "c32"
    }.

    Char32 extend: {
        public method asAsmImmediate => AsmImmediateConstantChar32
            := AsmImmediateConstantChar32 new value: self; yourself
    }.
}.

public final class AsmImmediateConstantUInt32 superclass: AsmImmediateConstant; definition: {
    public field value => UInt32.

    public override method isImmediateSigned32 => Boolean := value <= 16r7FFF_FFFF u32.
    public override method isImmediateConstantUInt32 => Boolean := true.
    public override method isImmediateValue0 => Boolean := value = 0u32.
    public override method isImmediateValue1 => Boolean := value = 1u32.
    public override method size => Size := 4sz.

    public override method isImmediateSigned8 => Boolean := value asInt8 asInt32 asUInt32 = value.
    public override method asImmediateSigned8Value => Int8 := value asInt8.

    public override method nextPutImmediateWithSize: (requiredSize: Size) onCodeStream: (codeStream: AsmObjectCodeStream) ::=> Void := {
        codeStream nextPutUInt32: value withSize: requiredSize
    }.

    public override method printOn: (stream: Stream) ::=> Void := {
        stream print: value; nextPutAll: "u32"
    }.

    UInt32 extend: {
        public method asAsmImmediate => AsmImmediateConstantUInt32
            := AsmImmediateConstantUInt32 new value: self; yourself
    }.
}.

public final class AsmImmediateConstantInt32 superclass: AsmImmediateConstant; definition: {
    public field value => Int32.
    
    public override method isImmediateSigned32 => Boolean := true.
    public override method isImmediateConstantInt32 => Boolean := true.
    public override method isImmediateValue0 => Boolean := value = 0i32.
    public override method isImmediateValue1 => Boolean := value = 1i32.
    public override method size => Size := 4sz.

    public override method isImmediateSigned8 => Boolean := value asInt8 asInt32 = value.
    public override method asImmediateSigned8Value => Int8 := value asInt8.

    public override method sumSigned32With: (other: AsmImmediate) ::=> AsmImmediate
        := other sumSigned32WithInt32: value.

    public override method sumSigned32WithInt32: (next: Int32) ::=> AsmImmediate
        := (value + next) asAsmImmediate.

    public override method nextPutImmediateWithSize: (requiredSize: Size) onCodeStream: (codeStream: AsmObjectCodeStream) ::=> Void := {
        codeStream nextPutInt32: value withSize: requiredSize
    }.

    public override method printOn: (stream: Stream) ::=> Void := {
        stream print: value; nextPutAll: "i32"
    }.

    Int32 extend: {
        public method asAsmImmediate => AsmImmediateConstantInt32
            := AsmImmediateConstantInt32 new value: self; yourself
    }.
}.

public final class AsmImmediateConstantUInt64 superclass: AsmImmediateConstant; definition: {
    public field value => UInt64.

    public override method isImmediateConstantUInt64 => Boolean := true.
    public override method isImmediateValue0 => Boolean := value = 0u64.
    public override method isImmediateValue1 => Boolean := value = 1u64.
    public override method size => Size := 8sz.

    public override method isImmediateSigned8 => Boolean := value asInt8 asInt64 asUInt64 = value.
    public override method isImmediateSigned32 => Boolean := value asInt32 asInt64 asUInt64 = value.

    public override method isImmediateUnsigned32 => Boolean := value asUInt32 asUInt64 = value.

    public override method asImmediateSigned8Value => Int8 := value asInt8.


    public override method nextPutImmediateWithSize: (requiredSize: Size) onCodeStream: (codeStream: AsmObjectCodeStream) ::=> Void := {
        codeStream nextPutUInt64: value withSize: requiredSize
    }.

    public override method printOn: (stream: Stream) ::=> Void := {
        stream print: value; nextPutAll: "u64"
    }.

    UInt64 extend: {
        public method asAsmImmediate => AsmImmediateConstantUInt64
            := AsmImmediateConstantUInt64 new value: self; yourself
    }.
}.

public final class AsmImmediateConstantInt64 superclass: AsmImmediateConstant; definition: {
    public field value => Int64.
    
    public override method isImmediateConstantInt64 => Boolean := true.
    public override method isImmediateValue0 => Boolean := value = 0i64.
    public override method isImmediateValue1 => Boolean := value = 1i64.
    public override method size => Size := 8sz.

    public override method isImmediateSigned8 => Boolean := value asInt8 asInt64 = value.
    public override method isImmediateSigned32 => Boolean := value asInt32 asInt64 = value.

    public override method isImmediateUnsigned32 => Boolean := value asUInt32 asUInt64 asInt64 = value.

    public override method asImmediateSigned8Value => Int8 := value asInt8.

    public override method nextPutImmediateWithSize: (requiredSize: Size) onCodeStream: (codeStream: AsmObjectCodeStream) ::=> Void := {
        codeStream nextPutInt64: value withSize: requiredSize
    }.

    public override method printOn: (stream: Stream) ::=> Void := {
        stream print: value; nextPutAll: "i64"
    }.

    Int64 extend: {
        public method asAsmImmediate => AsmImmediateConstantInt64
            := AsmImmediateConstantInt64 new value: self; yourself
    }.
}.

public final class AsmImmediateConstantFloat32 superclass: AsmImmediateConstant; definition: {
    public field value => Float32.
    
    public override method isImmediateConstantFloat32 => Boolean := true.
    public override method size => Size := 4sz.

    public override method nextPutImmediateWithSize: (requiredSize: Size) onCodeStream: (codeStream: AsmObjectCodeStream) ::=> Void := {
        codeStream nextPutUInt32: value asIEEEFloat32Encoding withSize: requiredSize
    }.

    public override method printOn: (stream: Stream) ::=> Void := {
        stream print: value; nextPutAll: "f32"
    }.

    Float32 extend: {
        public method asAsmImmediate => AsmImmediateConstantFloat32
            := AsmImmediateConstantFloat32 new value: self; yourself
    }.
}.

public final class AsmImmediateConstantFloat64 superclass: AsmImmediateConstant; definition: {
    public field value => Float64.
    
    public override method isImmediateConstantFloat64 => Boolean := true.
    public override method size => Size := 8sz.

    public override method nextPutImmediateWithSize: (requiredSize: Size) onCodeStream: (codeStream: AsmObjectCodeStream) ::=> Void := {
        codeStream nextPutUInt64: value asIEEEFloat64Encoding withSize: requiredSize
    }.

    public override method printOn: (stream: Stream) ::=> Void := {
        stream print: value; nextPutAll: "f64"
    }.

    Float64 extend: {
        public method asAsmImmediate => AsmImmediateConstantFloat64
            := AsmImmediateConstantFloat64 new value: self; yourself
    }.
}.

public final class AsmStream superclass: Object; definition: {
    public field compilationTarget => AsmCompilationTarget.

    public field firstElement => AsmStreamElement.
    public field lastElement => AsmStreamElement.

    public method addElement: (element: AsmStreamElement) before: (position: AsmStreamElement) ::=> Void := {
        let before := position ifNotNil: position previous ifNil: lastElement.
        let after := position.

        before ifNotNil: {
            before next: element.
            element previous: before.
        } ifNil: {
            firstElement := element
        }.

        after ifNotNil: {
            after previous: element.
            element next: after
        } ifNil: {
            lastElement := element
        }.
    }.

    public method addElement: (element: AsmStreamElement) after: (position: AsmStreamElement) ::=> Void := {
        let before := position .
        let after := position ifNotNil: position next ifNil: firstElement.

        before ifNotNil: {
            before next: element.
            element previous: before.
        } ifNil: {
            firstElement := element
        }.

        after ifNotNil: {
            after previous: element.
            element next: after
        } ifNil: {
            lastElement := element
        }.
    }.

    public method addElement: (element: AsmStreamElement) ::=> Void
        := self addElement: element before: nil.

    public method addFirstElement: (element: AsmStreamElement) ::=> Void
        := self addElement: element after: nil.

    public inline method elementsDo: (aBlock: (AsmStreamElement) => Void) ::=> Void := {
        let position mutable := firstElement.
        while: position isNotNil do: {
            let nextPosition := position next.
            aBlock(position).
            position := nextPosition
        }
    }.

    public inline method elementsReverseDo: (aBlock: (AsmStreamElement) => Void) ::=> Void := {
        let position mutable := lastElement.
        while: position isNotNil do: {
            let nextPosition := position previous.
            aBlock(position).
            position := nextPosition
        }
    }.

    public method removeElement: (element: AsmStreamElement) ::=> Void := {
        let previousElement := element previous.
        let nextElement := element next.

        previousElement ifNotNil: {
            previousElement next: nextElement
        } ifNil: {
            firstElement := nextElement
        }.

        nextElement ifNotNil: {
            nextElement previous: previousElement
        } ifNil: {
            lastElement := previousElement
        }.
    }.

    public method selectElementsEncodingAlternatives ::=> Void := {
        self elementsDo: {:(AsmStreamElement)each :: Void |
            each selectEncodingAlternatives.
        }.
    }.

    public override method fullPrintOn: (stream: Stream) ::=> Void := {
        self elementsDo: {:(AsmStreamElement)each :: Void |
            each isFormattedWithIndentation ifTrue: (stream nextPutAll: "    ").
            stream fullPrint: each; nl
        }
    }.

    public method prepareToAssemble => Void := {
        self selectElementsEncodingAlternatives.
    }.

    public method performStandardOptimizations => Void := {
        self elementsReverseDo: {:(AsmStreamElement)each :: Void |
            each isUnneededStreamElement ifTrue: {
                self removeElement: each
            }
        }.
    }.

    public method assembleFirstPassWith: (objectCodeBuilder: AsmObjectCodeBuilder) ::=> Void := {
        let sizeStream := objectCodeBuilder newSizeStream.
        self elementsDo: {:(AsmStreamElement)each :: Void |
            each writeOnObjectCodeStream: sizeStream.
        }.
    }.

    public method assembleSecondPassWith: (objectCodeBuilder: AsmObjectCodeBuilder) ::=> Void := {
        let writeStream := objectCodeBuilder newWriteStream.
        self elementsDo: {:(AsmStreamElement)each :: Void |
            each
                recordDebugInfoOnObjectCodeStream: writeStream;
                writeOnObjectCodeStream: writeStream.
        }.
    }.

    public method assemble => AsmObjectCode := {
        let objectCodeBuilder := AsmObjectCodeBuilder new
            compilationTarget: compilationTarget;
            yourself.

        self prepareToAssemble.
        self assembleFirstPassWith: objectCodeBuilder.
        objectCodeBuilder allocateMemoryForWriting.
        self assembleSecondPassWith: objectCodeBuilder.

        objectCodeBuilder finish
    }.
}.

public final class AsmAlignDirective superclass: AsmStreamElement; definition: {
    public field alignment => Size.
    public field unreachable => Boolean.

    public override method isFormattedWithIndentation => Boolean := false.
    public override method isMetadataOrAlignStreamElement => Boolean := true.

    public override method fullPrintOn: (stream: Stream) ::=> Void := {
        stream nextPutAll: ".align "; print: alignment.
        self printDebugInfoOn: stream.
    }.

    public override method writeOnObjectCodeStream: (stream: AsmObjectCodeStream) ::=> Void := {
        stream alignTo: alignment unreachable: unreachable
    }.
}.

public final class AsmLabel superclass: AsmStreamElement; definition: {
    public field symbol => AsmSymbol.

    public override method isFormattedWithIndentation => Boolean := false.
    public override method isLabel => Boolean := true.

    public override method fullPrintOn: (stream: Stream) ::=> Void := {
        stream print: symbol; nextPut: ':'c8.
        self printDebugInfoOn: stream.
    }.

    public override method writeOnObjectCodeStream: (stream: AsmObjectCodeStream) ::=> Void := {
        stream recordSymbol: symbol
    }.
}.

public final class AsmLabelEnd superclass: AsmStreamElement; definition: {
    public field symbol => AsmSymbol.

    public override method isFormattedWithIndentation => Boolean := false.
    public override method isMetadataStreamElement => Boolean := true.

    public override method fullPrintOn: (stream: Stream) ::=> Void := {
        stream nextPutAll: "/* "; print: symbol; nextPutAll: " end */".
        self printDebugInfoOn: stream.
    }.

    public override method writeOnObjectCodeStream: (stream: AsmObjectCodeStream) ::=> Void := {
        stream recordSymbolEnd: symbol
    }.
}.

public final class AsmSectionDirective superclass: AsmStreamElement; definition: {
    public field name => Symbol.
    public field machoSectionName => Symbol.
    public field machoSegmentName => Symbol.

    public field executable => Boolean.
    public field writeable => Boolean.
    public field readable => Boolean.
    public field loaded => Boolean.
    public field debugging => Boolean.
    public field nobits => Boolean.
    public field tls => Boolean.

    public override method isSectionDirective => Boolean := false.
    public override method isFormattedWithIndentation => Boolean := false.

    public override method fullPrintOn: (stream: Stream) ::=> Void := {
        stream nextPutAll: ".section "; string: name.
        self printDebugInfoOn: stream.
    }.

    public override method recordDebugInfoOnObjectCodeStream: (stream: AsmObjectCodeStream) ::=> Void := {
    }.

    public override method writeOnObjectCodeStream: (stream: AsmObjectCodeStream) ::=> Void := {
        (stream enterSectionNamed: name machoSectionName: machoSectionName machoSegmentName: machoSegmentName)
            addExecutable: executable;
            addWriteable: writeable;
            addReadable: readable;
            addLoaded: loaded;
            addNoBits: nobits;
            addTLS: tls
    }.
}.

public final class AsmBytesWithRelocations superclass: AsmStreamElement; definition: {
    public field bytes => ByteArray.
    public field relocations => Collection.
    public field relocationsOffset => Size.

    public override method fullPrintOn: (stream: Stream) ::=> Void := {
        stream nextPutAll: ".bytesWithRelocations ".
        self printDebugInfoOn: stream.
    }.

    public override method writeOnObjectCodeStream: (stream: AsmObjectCodeStream) ::=> Void := {
        stream nextPutBytes: bytes withRelocations: relocations offset: relocationsOffset
    }.
}.

public final class AsmByteDirective superclass: AsmStreamElement; definition: {
    public field value => UInt8.

    public override method fullPrintOn: (stream: Stream) ::=> Void := {
        stream nextPutAll: ".byte "; print: value.
        self printDebugInfoOn: stream.
    }.

    public override method writeOnObjectCodeStream: (stream: AsmObjectCodeStream) ::=> Void := {
        stream nextPut: value
    }.
}.

public final class AsmSByteDirective superclass: AsmStreamElement; definition: {
    public field value => Int8.

    public override method fullPrintOn: (stream: Stream) ::=> Void := {
        stream nextPutAll: ".byte "; print: value.
        self printDebugInfoOn: stream.
    }.
    public override method writeOnObjectCodeStream: (stream: AsmObjectCodeStream) ::=> Void := {
        stream nextPutInt8: value
    }.
}.

public final class AsmWordDirective superclass: AsmStreamElement; definition: {
    public field value => UInt16.

    public override method fullPrintOn: (stream: Stream) ::=> Void := {
        stream nextPutAll: ".word "; print: value.
        self printDebugInfoOn: stream.
    }.

    public override method writeOnObjectCodeStream: (stream: AsmObjectCodeStream) ::=> Void := {
        stream nextPutUInt16: value
    }.
}.

public final class AsmSWordDirective superclass: AsmStreamElement; definition: {
    public field value => Int16.

    public override method fullPrintOn: (stream: Stream) ::=> Void := {
        stream nextPutAll: ".word "; print: value.
        self printDebugInfoOn: stream.
    }.

    public override method writeOnObjectCodeStream: (stream: AsmObjectCodeStream) ::=> Void := {
        stream nextPutInt16: value
    }.
}.

public final class AsmDWordDirective superclass: AsmStreamElement; definition: {
    public field value => UInt32.

    public override method fullPrintOn: (stream: Stream) ::=> Void := {
        stream nextPutAll: ".word "; print: value.
        self printDebugInfoOn: stream.
    }.

    public override method writeOnObjectCodeStream: (stream: AsmObjectCodeStream) ::=> Void := {
        stream nextPutUInt32: value
    }.
}.

public final class AsmSDWordDirective superclass: AsmStreamElement; definition: {
    public field value => Int32.

    public override method fullPrintOn: (stream: Stream) ::=> Void := {
        stream nextPutAll: ".dword "; print: value.
        self printDebugInfoOn: stream.
    }.

    public override method writeOnObjectCodeStream: (stream: AsmObjectCodeStream) ::=> Void := {
        stream nextPutInt32: value
    }.
}.

public final class AsmQWordDirective superclass: AsmStreamElement; definition: {
    public field value => UInt64.

    public override method fullPrintOn: (stream: Stream) ::=> Void := {
        stream nextPutAll: ".qword "; print: value.
        self printDebugInfoOn: stream.
    }.

    public override method writeOnObjectCodeStream: (stream: AsmObjectCodeStream) ::=> Void := {
        stream nextPutUInt64: value
    }.
}.

public final class AsmSQWordDirective superclass: AsmStreamElement; definition: {
    public field value => Int64.

    public override method fullPrintOn: (stream: Stream) ::=> Void := {
        stream nextPutAll: ".qword "; print: value.
        self printDebugInfoOn: stream.
    }.

    public override method writeOnObjectCodeStream: (stream: AsmObjectCodeStream) ::=> Void := {
        stream nextPutInt64: value
    }.
}.

public final class AsmULEB128Directive superclass: AsmStreamElement; definition: {
    public field value => UInt64.

    public override method fullPrintOn: (stream: Stream) ::=> Void := {
        stream nextPutAll: ".uleb "; print: value.
        self printDebugInfoOn: stream.
    }.

    public override method writeOnObjectCodeStream: (stream: AsmObjectCodeStream) ::=> Void := {
        let currentValue mutable := value.
        do: {
            let byte := (currentValue & 127u64) asUInt8.
            currentValue := currentValue >> 7u64.
            stream nextPut: byte | (currentValue ~= 0u64 ifTrue: 128u8 ifFalse: 0u8)
        } while: (currentValue ~= 0u64)
    }.
}.

public final class AsmSLEB128Directive superclass: AsmStreamElement; definition: {
    public field value => Int64.

    public override method fullPrintOn: (stream: Stream) ::=> Void := {
        stream nextPutAll: ".sleb "; print: value.
        self printDebugInfoOn: stream.
    }.

    public override method writeOnObjectCodeStream: (stream: AsmObjectCodeStream) ::=> Void := {
        let more mutable := true.

        let currentValue mutable := value.
        while: more do: {
            let byte mutable := (currentValue & 127i64) asInt8.
            currentValue := currentValue >> 7i64.
            
            let byteHasSign := (byte & 16r40 i8) ~= 0i8.
            ((currentValue = 0i64) && byteHasSign not) || (currentValue == -1i64 && byteHasSign) ifTrue: {
                more := false
            } ifFalse: {
                byte := byte | 16r80 i8.
            }.

            stream nextPut: byte asUInt8
        }.
    }.
}.

public final class AsmFloatDirective superclass: AsmStreamElement; definition: {
    public field value => Float32.

    public override method fullPrintOn: (stream: Stream) ::=> Void := {
        stream nextPutAll: ".float "; print: value.
        self printDebugInfoOn: stream.
    }.

    public override method writeOnObjectCodeStream: (stream: AsmObjectCodeStream) ::=> Void := {
        stream nextPutFloat32: value
    }.
}.

public final class AsmDoubleDirective superclass: AsmStreamElement; definition: {
    public field value => Float64.

    public override method fullPrintOn: (stream: Stream) ::=> Void := {
        stream nextPutAll: ".double "; print: value.
        self printDebugInfoOn: stream.
    }.

    public override method writeOnObjectCodeStream: (stream: AsmObjectCodeStream) ::=> Void := {
        stream nextPutFloat64: value
    }.
}.

public final class AsmStringDirective superclass: AsmStreamElement; definition: {
    public field value => String.
    public field nullTerminated => Boolean.

    public override method fullPrintOn: (stream: Stream) ::=> Void := {
        stream nextPutAll: (nullTerminated ifTrue: ".cstring " ifFalse: ".string "); print: value.
        self printDebugInfoOn: stream.
    }.

    public override method writeOnObjectCodeStream: (stream: AsmObjectCodeStream) ::=> Void := {
        stream nextPutString: value.
        nullTerminated ifTrue: (stream nextPut: 0u8).
    }.
}.

public final class AsmStructureDirective superclass: AsmStreamElement; definition: {
    public field value => AnyValue.
    public field size => Size.

    public override method fullPrintOn: (stream: Stream) ::=> Void := {
        stream nextPutAll: ".struct "; print: value.
        self printDebugInfoOn: stream.
    }.

    public override method writeOnObjectCodeStream: (stream: AsmObjectCodeStream) ::=> Void := {
        stream nextPutStructure: value withSize: size
    }.
}.

public final class AsmReserveBytesDirective superclass: AsmStreamElement; definition: {
    public field size => Size.

    public override method fullPrintOn: (stream: Stream) ::=> Void := {
        stream nextPutAll: ".resb "; print: size.
        self printDebugInfoOn: stream.
    }.

    public override method writeOnObjectCodeStream: (stream: AsmObjectCodeStream) ::=> Void := {
        stream nextReserveBytes: size
    }.
}.

public final class AsmByteConstantExpressionDirective superclass: AsmStreamElement; definition: {
    public field expression => AsmConstantExpression.

    public override method fullPrintOn: (stream: Stream) ::=> Void := {
        stream nextPutAll: ".byte "; print: expression.
        self printDebugInfoOn: stream.
    }.

    public override method writeOnObjectCodeStream: (stream: AsmObjectCodeStream) ::=> Void := {
        expression writeInt8OnObjectCodeStream: stream.
    }.
}.

public final class AsmWordConstantExpressionDirective superclass: AsmStreamElement; definition: {
    public field expression => AsmConstantExpression.

    public override method fullPrintOn: (stream: Stream) ::=> Void := {
        stream nextPutAll: ".word "; print: expression.
        self printDebugInfoOn: stream.
    }.

    public override method writeOnObjectCodeStream: (stream: AsmObjectCodeStream) ::=> Void := {
        expression writeInt16OnObjectCodeStream: stream.
    }.
}.

public final class AsmDWordConstantExpressionDirective superclass: AsmStreamElement; definition: {
    public field expression => AsmConstantExpression.

    public override method fullPrintOn: (stream: Stream) ::=> Void := {
        stream nextPutAll: ".dword "; print: expression.
        self printDebugInfoOn: stream.
    }.

    public override method writeOnObjectCodeStream: (stream: AsmObjectCodeStream) ::=> Void := {
        expression writeInt32OnObjectCodeStream: stream.
    }.
}.

public final class AsmQWordConstantExpressionDirective superclass: AsmStreamElement; definition: {
    public field expression => AsmConstantExpression.

    public override method fullPrintOn: (stream: Stream) ::=> Void := {
        stream nextPutAll: ".qword "; print: expression.
        self printDebugInfoOn: stream.
    }.

    public override method writeOnObjectCodeStream: (stream: AsmObjectCodeStream) ::=> Void := {
        expression writeInt64OnObjectCodeStream: stream.
    }.
}.

public final class AsmSLEB128ConstantExpressionDirective superclass: AsmStreamElement; definition: {
    public field expression => AsmConstantExpression.

    public override method fullPrintOn: (stream: Stream) ::=> Void := {
        stream nextPutAll: ".sleb128 "; print: expression.
        self printDebugInfoOn: stream.
    }.

    public override method writeOnObjectCodeStream: (stream: AsmObjectCodeStream) ::=> Void := {
        error("TODO: Implement this")
    }.
}.

public final class AsmULEB128ConstantExpressionDirective superclass: AsmStreamElement; definition: {
    public field expression => AsmConstantExpression.

    public override method fullPrintOn: (stream: Stream) ::=> Void := {
        stream nextPutAll: ".uleb128 "; print: expression.
        self printDebugInfoOn: stream.
    }.

    public override method writeOnObjectCodeStream: (stream: AsmObjectCodeStream) ::=> Void := {
        let currentValue mutable := expression evaluateInt64 asUInt64.
        do: {
            let byte := (currentValue & 127u64) asUInt8.
            currentValue := currentValue >> 7u64.
            stream nextPut: byte | (currentValue ~= 0u64 ifTrue: 128u8 ifFalse: 0u8)
        } while: (currentValue ~= 0u64)
    }.
}.

public final class AsmCFIBeginProcedureDirective superclass: AsmStreamElement; definition: {
    public override method isMetadataStreamElement => Boolean := true.

    public override method fullPrintOn: (stream: Stream) ::=> Void := {
        stream nextPutAll: ".cfiBeginProcedure".
        self printDebugInfoOn: stream.
    }.

    public override method writeOnObjectCodeStream: (stream: AsmObjectCodeStream) ::=> Void := {
        stream cfiBeginProcedure.
    }.
}.

public final class AsmCFIEndProcedureDirective superclass: AsmStreamElement; definition: {
    public override method isMetadataStreamElement => Boolean := true.

    public override method fullPrintOn: (stream: Stream) ::=> Void := {
        stream nextPutAll: ".cfiEndProcedure".
        self printDebugInfoOn: stream.
    }.

    public override method writeOnObjectCodeStream: (stream: AsmObjectCodeStream) ::=> Void := {
        stream cfiEndProcedure.        
    }.
}.

public final class AsmCFIEndPrologueDirective superclass: AsmStreamElement; definition: {
    public override method isMetadataStreamElement => Boolean := true.

    public override method fullPrintOn: (stream: Stream) ::=> Void := {
        stream nextPutAll: ".cfiEndPrologue".
        self printDebugInfoOn: stream.
    }.

    public override method writeOnObjectCodeStream: (stream: AsmObjectCodeStream) ::=> Void := {
        stream cfiEndPrologue.
    }.
}.

public final class AsmCFIBeginEpilogueDirective superclass: AsmStreamElement; definition: {
    public override method isMetadataStreamElement => Boolean := true.

    public override method fullPrintOn: (stream: Stream) ::=> Void := {
        stream nextPutAll: ".cfiBeginEpilogue".
        self printDebugInfoOn: stream.
    }.

    public override method writeOnObjectCodeStream: (stream: AsmObjectCodeStream) ::=> Void := {
        stream cfiBeginEpilogue.
    }.
}.

public final class AsmCFIEndEpilogueDirective superclass: AsmStreamElement; definition: {
    public override method isMetadataStreamElement => Boolean := true.
    
    public override method fullPrintOn: (stream: Stream) ::=> Void := {
        stream nextPutAll: ".cfiEndEpilogue".
        self printDebugInfoOn: stream.
    }.

    public override method writeOnObjectCodeStream: (stream: AsmObjectCodeStream) ::=> Void := {
        stream cfiEndEpilogue.
    }.
}.

public final class AsmCFIPushRegisterDirective superclass: AsmStreamElement; definition: {
    public field register => AsmRegister.
    
    public override method isMetadataStreamElement => Boolean := true.

    public override method fullPrintOn: (stream: Stream) ::=> Void := {
        stream nextPutAll: ".cfiPushRegister "; print: register.
        self printDebugInfoOn: stream.
    }.

    public override method writeOnObjectCodeStream: (stream: AsmObjectCodeStream) ::=> Void := {
        stream cfiPushRegister: register.
    }.
}.

public final class AsmCFIPopRegisterDirective superclass: AsmStreamElement; definition: {
    public field register => AsmRegister.

    public override method isMetadataStreamElement => Boolean := true.

    public override method fullPrintOn: (stream: Stream) ::=> Void := {
        stream nextPutAll: ".cfiPopRegister "; print: register.
        self printDebugInfoOn: stream.
    }.

    public override method writeOnObjectCodeStream: (stream: AsmObjectCodeStream) ::=> Void := {
        stream cfiPopRegister: register.
    }.
}.

public final class AsmCFISaveFramePointerDirective superclass: AsmStreamElement; definition: {
    public field register => AsmRegister.
    public field offset => Int64.

    public override method isMetadataStreamElement => Boolean := true.

    public override method fullPrintOn: (stream: Stream) ::=> Void := {
        stream nextPutAll: ".cfiSaveFramePointer "; print: register; nextPutAll: " offset: "; print: offset.
        self printDebugInfoOn: stream.
    }.

    public override method writeOnObjectCodeStream: (stream: AsmObjectCodeStream) ::=> Void := {
        stream cfiSaveFramePointer: register offset: offset.
    }.
}.

public final class AsmCFIRestoreFramePointerDirective superclass: AsmStreamElement; definition: {
    public field register => AsmRegister.
    public field offset => Int64.

    public override method isMetadataStreamElement => Boolean := true.

    public override method fullPrintOn: (stream: Stream) ::=> Void := {
        stream nextPutAll: ".cfiRestoreFramePointer "; print: register; space; print: offset.
        self printDebugInfoOn: stream.
    }.

    public override method writeOnObjectCodeStream: (stream: AsmObjectCodeStream) ::=> Void := {
        stream cfiRestoreFramePointer: register offset: offset.
    }.
}.

public final class AsmCFIStackSizeAdvanceDirective superclass: AsmStreamElement; definition: {
    public field increment => Int64.

    public override method isMetadataStreamElement => Boolean := true.

    public override method fullPrintOn: (stream: Stream) ::=> Void := {
        stream nextPutAll: ".cfiStackSizeAdvance "; print: increment.
        self printDebugInfoOn: stream.
    }.

    public override method writeOnObjectCodeStream: (stream: AsmObjectCodeStream) ::=> Void := {
        stream cfiStackSizeAdvance: increment.
    }.
}.

public final class AsmStreamBuilder superclass: Object; definition: {
    public field stream => AsmStream.

    ## Debugging information
    public field debugSourcePosition => SourcePosition.
    public field debugSourceNode => ASTNode.
    public field debugSourceEnvironment => Environment.

    public method addElement: (element: AsmStreamElement) ::=> element __type__ := {
        stream addElement: element.

        element
            debugSourcePosition: debugSourcePosition;
            debugSourceNode: debugSourceNode;
            debugSourceEnvironment: debugSourceEnvironment;
            yourself
    }.

    public method newPrivateSymbolNamed: (name: Symbol) ::=> AsmSymbol
        := AsmSymbol new
            name: name;
            makePrivate;
            yourself.

    public method label: (symbol: AsmSymbol) ::=> AsmLabel
        := self addElement: (AsmLabel new
            symbol: symbol;
            yourself).

    public method label ::=> AsmLabel
        := self label: nil.

    public method endLabel: (symbol: AsmSymbol) ::=> AsmLabelEnd
        := self addElement: (AsmLabelEnd new
            symbol: symbol;
            yourself).

    public method blockNamed: (symbol: AsmSymbol) with: (aBlock: (AsmStreamBuilder => Void)) ::=> AsmLabel := {
        let label := self label: symbol.
        aBlock(self).
        self endLabel: symbol.
        label
    }.

    public method symbolNamed: (name: Symbol) ::=> AsmSymbol
        := AsmSymbol new
            name: name;
            yourself.

    public method align: (alignment: Size) ::=> AsmAlignDirective
        := self addElement: (AsmAlignDirective new
            alignment: alignment;
            yourself).

    public method align: (alignment: Size) unreachable: (unreachable: Boolean)::=> AsmAlignDirective
        := self addElement: (AsmAlignDirective new
            alignment: alignment;
            unreachable: unreachable;
            yourself).

    public method textSection ::=> AsmSectionDirective
        := self addElement: (AsmSectionDirective new
            name: #".text";
            machoSectionName: #__text;
            machoSegmentName: #__TEXT;
            loaded: true;
            executable: true;
            readable: true;
            yourself).

    public method dataSection ::=> AsmSectionDirective
        := self addElement: (AsmSectionDirective new
            name: #".data";
            machoSectionName: #__data;
            machoSegmentName: #__DATA;
            loaded: true;
            readable: true;
            writeable: true;
            yourself).

    public method rodataSection ::=> AsmSectionDirective
        := self addElement: (AsmSectionDirective new
            name: #".rodata";
            machoSectionName: #__rodata;
            machoSegmentName: #__DATA;
            loaded: true;
            readable: true;
            yourself).

    public method bssSection ::=> AsmSectionDirective
        := self addElement: (AsmSectionDirective new
            name: #".bss";
            machoSectionName: #__bss;
            machoSegmentName: #__DATA;
            readable: true;
            writeable: true;
            nobits: true;
            yourself).

    public method tlsSection ::=> AsmSectionDirective
        := self addElement: (AsmSectionDirective new
            name: #".tls$";
            loaded: true;
            readable: true;
            writeable: true;
            tls: true;
            yourself).

    public method tdataSection ::=> AsmSectionDirective
        := self addElement: (AsmSectionDirective new
            name: #".tdata";
            machoSectionName: #__tdata;
            machoSegmentName: #__DATA;
            loaded: true;
            readable: true;
            writeable: true;
            tls: true;
            yourself).

    public method tbssSection ::=> AsmSectionDirective
        := self addElement: (AsmSectionDirective new
            name: #".tbss";
            machoSectionName: #__tbss;
            machoSegmentName: #__TDATA;
            readable: true;
            writeable: true;
            nobits: true;
            tls: true;
            yourself).

    public method bytes: (bytes: ByteArray) relocations: (relocations: Collection) offset: (relocationsOffset: Size) ::=> AsmBytesWithRelocations
        := self addElement: (AsmBytesWithRelocations new
            bytes: bytes;
            relocations: relocations;
            relocationsOffset: relocationsOffset;
            yourself).

    public method byte: (value: UInt8) ::=> AsmByteDirective
        := self addElement: (AsmByteDirective new
            value: value;
            yourself).

    public method sbyte: (value: Int8) ::=> AsmSByteDirective
        := self addElement: (AsmSByteDirective new
            value: value;
            yourself).

    public method word: (value: UInt16) ::=> AsmWordDirective
        := self addElement: (AsmWordDirective new
            value: value;
            yourself).

    public method sword: (value: Int16) ::=> AsmSWordDirective
        := self addElement: (AsmSWordDirective new
            value: value;
            yourself).

    public method dword: (value: UInt32) ::=> AsmDWordDirective
        := self addElement: (AsmDWordDirective new
            value: value;
            yourself).

    public method sdword: (value: Int32) ::=> AsmSDWordDirective
        := self addElement: (AsmSDWordDirective new
            value: value;
            yourself).

    public method qword: (value: UInt64) ::=> AsmQWordDirective
        := self addElement: (AsmQWordDirective new
            value: value;
            yourself).

    public method sqword: (value: Int64) ::=> AsmSQWordDirective
        := self addElement: (AsmSQWordDirective new
            value: value;
            yourself).

    public method uleb128: (value: UInt64) ::=> AsmULEB128Directive
        := self addElement: (AsmULEB128Directive new
            value: value;
            yourself).

    public method sleb128: (value: Int64) ::=> AsmSLEB128Directive
        := self addElement: (AsmSLEB128Directive new
            value: value;
            yourself).

    public method float: (value: Float32) ::=> AsmFloatDirective
        := self addElement: (AsmFloatDirective new
            value: value;
            yourself).

    public method double: (value: Float64) ::=> AsmDoubleDirective
        := self addElement: (AsmDoubleDirective new
            value: value;
            yourself).

    public method string: (string: String) nullTerminated: (nullTerminated: Boolean) ::=> AsmStringDirective
        := self addElement: (AsmStringDirective new
            value: string;
            nullTerminated: nullTerminated;
            yourself).

    public method structure: (value: AnyValue) size: (size: Size) ::=> AsmStructureDirective
        := self addElement: (AsmStructureDirective new
            value: value;
            size: size;
            yourself).

    public method reserveBytes: (size: Size) ::=> AsmReserveBytesDirective
        := self addElement: (AsmReserveBytesDirective new
            size: size;
            yourself).

    public method byteExpression: (expression: AsmConstantExpression) ::=> AsmByteConstantExpressionDirective
        := self addElement: (AsmByteConstantExpressionDirective new
            expression: expression;
            yourself).

    public method wordExpression: (expression: AsmConstantExpression) ::=> AsmWordConstantExpressionDirective
        := self addElement: (AsmWordConstantExpressionDirective new
            expression: expression;
            yourself).

    public method dwordExpression: (expression: AsmConstantExpression) ::=> AsmDWordConstantExpressionDirective
        := self addElement: (AsmDWordConstantExpressionDirective new
            expression: expression;
            yourself).

    public method qwordExpression: (expression: AsmConstantExpression) ::=> AsmQWordConstantExpressionDirective
        := self addElement: (AsmQWordConstantExpressionDirective new
            expression: expression;
            yourself).

    public method expression: (expression: AsmConstantExpression) size: (size: Size) ::=> AsmStreamElement := {
        size = 8sz ifTrue: (return: (self qwordExpression: expression)).
        size = 4sz ifTrue: (return: (self dwordExpression: expression)).
        size = 2sz ifTrue: (return: (self wordExpression: expression)).
        size = 1sz ifTrue: (return: (self byteExpression: expression)).
        self error: "Unsupported asm constant expression of size " -- size asString -- "."
    }.

    public method sleb128Expression: (expression: AsmConstantExpression) ::=> AsmSLEB128ConstantExpressionDirective
        := self addElement: (AsmSLEB128ConstantExpressionDirective new
            expression: expression;
            yourself).

    public method uleb128Expression: (expression: AsmConstantExpression) ::=> AsmULEB128ConstantExpressionDirective
        := self addElement: (AsmULEB128ConstantExpressionDirective new
            expression: expression;
            yourself).

    public method cfiBeginProcedure => AsmCFIBeginProcedureDirective
        := self addElement: (AsmCFIBeginProcedureDirective new).

    public method cfiEndProcedure => AsmCFIEndProcedureDirective
        := self addElement: (AsmCFIEndProcedureDirective new).

    public method cfiEndPrologue => AsmCFIEndPrologueDirective
        := self addElement: (AsmCFIEndPrologueDirective new).

    public method cfiBeginEpilogue => AsmCFIBeginEpilogueDirective
        := self addElement: (AsmCFIBeginEpilogueDirective new).

    public method cfiEndEpilogue => AsmCFIEndEpilogueDirective
        := self addElement: (AsmCFIEndEpilogueDirective new).

    public method cfiPushRegister: (register: AsmRegister) ::=> AsmCFIPushRegisterDirective
        := self addElement: (AsmCFIPushRegisterDirective new
            register: register;
            yourself).

    public method cfiPopRegister: (register: AsmRegister) ::=> AsmCFIPopRegisterDirective
        := self addElement: (AsmCFIPopRegisterDirective new
            register: register;
            yourself).

    public method cfiSaveFramePointer: (register: AsmRegister) offset: (offset: Int64) ::=> AsmCFISaveFramePointerDirective
        := self addElement: (AsmCFISaveFramePointerDirective new
            register: register;
            offset: offset;
            yourself).

    public method cfiSaveFramePointer: (register: AsmRegister) ::=> AsmCFISaveFramePointerDirective
        := self cfiSaveFramePointer: register offset: 0i64.

    public method cfiRestoreFramePointer: (register: AsmRegister) offset: (offset: Int64) ::=> AsmCFIRestoreFramePointerDirective
        := self addElement: (AsmCFIRestoreFramePointerDirective new
            register: register;
            offset: offset;
            yourself).

    public method cfiStackSizeAdvance: (increment: Int64) ::=> AsmCFIStackSizeAdvanceDirective
        := self addElement: (AsmCFIStackSizeAdvanceDirective new
            increment: increment;
            yourself).
}.

public final class AsmProgramEntity superclass: AsmObjectCodeProgramEntity; definition: {
    public field compilationTarget => AsmCompilationTarget.

    public field streams => OrderedCollection.
    public field endStreams => OrderedCollection.
    public field children => OrderedCollection.
    public field importedSymbols => OrderedCollection.
    public field importedProgramEntitySymbols => OrderedCollection.
    public field isDebuggingInformation => Boolean.

    public field debugInformationGenerator => AsmObjectDebugInformationGenerator.
    
    public override method initialize => Void := {
        streams := OrderedCollection new.
        endStreams := OrderedCollection new.
        children := OrderedCollection new.
        importedSymbols := OrderedCollection new.
        importedProgramEntitySymbols := OrderedCollection new.
    }.

    public method newStreamBuilder => AsmStreamBuilder := {
        let stream := AsmStream new
            compilationTarget: compilationTarget;
            yourself.
        streams add: stream.
        AsmStreamBuilder new
            stream: stream;
            yourself
    }.

    public method newEndStreamBuilder => AsmStreamBuilder := {
        let stream := AsmStream new
            compilationTarget: compilationTarget;
            yourself.
        endStreams add: stream.
        AsmStreamBuilder new
            stream: stream;
            yourself
    }.

    public method newProgramEntity => AsmProgramEntity := {
        let entity := AsmProgramEntity new
            compilationTarget: compilationTarget;
            yourself.
        children add: entity.
        entity
    }.

    public method withAllChildrenDo: (aBlock: (AsmProgramEntity) => Void) ::=> Void := {
        aBlock(self).
        self allChildrenDo: aBlock
    }.

    public method allChildrenDo: (aBlock: (AsmProgramEntity) => Void) ::=> Void := {
        children do: {:(AsmProgramEntity)each :: Void |
            each withAllChildrenDo: aBlock
        }
    }.

    public method addImportedSymbol: (symbol: AsmSymbol) ::=> Void := {
        importedSymbols add: symbol
    }.

    public method addSourceProgramEntity: (sourceProgramEntity: ProgramEntity) importedSymbol: (symbol: AsmSymbol) ::=> Void := {
        importedProgramEntitySymbols add: sourceProgramEntity -> symbol
    }.

    public override method fullPrintOn: (stream: Stream) ::=> Void := {
        isDebuggingInformation && PrintingDebugInfo not ifTrue: {return: void}.

        streams do: {:(AsmStream)eachStream :: Void |
            stream fullPrint: eachStream
        }.

        children do: {:(AsmProgramEntity)eachChild :: Void |
            stream fullPrint: eachChild
        }.

        endStreams do: {:(AsmStream)eachStream :: Void |
            stream fullPrint: eachStream
        }.
    }.

    public method performStandardOptimizations => Void := {
        streams do: {:(AsmStream)eachStream :: Void |
            eachStream performStandardOptimizations
        }.

        children do: {:(AsmProgramEntity)eachChild :: Void |
            eachChild performStandardOptimizations
        }.

        endStreams do: {:(AsmStream)eachStream :: Void |
            eachStream performStandardOptimizations
        }.

    }.

    public method prepareToAssemble => Void := {
        streams do: {:(AsmStream)eachStream :: Void |
            eachStream prepareToAssemble
        }.

        children do: {:(AsmProgramEntity)eachChild :: Void |
            eachChild prepareToAssemble
        }.

        endStreams do: {:(AsmStream)eachStream :: Void |
            eachStream prepareToAssemble
        }.
    }.

    public method assembleFirstPassWith: (objectCodeBuilder: AsmObjectCodeBuilder) ::=> Void := {
        streams do: {:(AsmStream)eachStream :: Void |
            eachStream assembleFirstPassWith: objectCodeBuilder
        }.

        children do: {:(AsmProgramEntity)eachChild :: Void |
            eachChild assembleFirstPassWith: objectCodeBuilder
        }.

        endStreams do: {:(AsmStream)eachStream :: Void |
            eachStream assembleFirstPassWith: objectCodeBuilder
        }.
    }.

    public method assembleSecondPassWith: (objectCodeBuilder: AsmObjectCodeBuilder) ::=> Void := {
        isDebuggingInformation not && sourceProgramEntity isNotNil ifTrue: {
            objectCodeBuilder recordProgramEntity: (AsmObjectCodeProgramEntity new
                name: name;
                sourceProgramEntity: sourceProgramEntity;
                contentSymbol: contentSymbol;
                trampolineTarget: trampolineTarget;
                stackMap: stackMap;
                debugSourcePosition: debugSourcePosition;
                debugSourceNode: debugSourceNode;
                debugSourceEnvironment: debugSourceEnvironment;
                yourself)
        }.

        streams do: {:(AsmStream)eachStream :: Void |
            eachStream assembleSecondPassWith: objectCodeBuilder
        }.

        children do: {:(AsmProgramEntity)eachChild :: Void |
            eachChild assembleSecondPassWith: objectCodeBuilder
        }.

        endStreams do: {:(AsmStream)eachStream :: Void |
            eachStream assembleSecondPassWith: objectCodeBuilder
        }.
    }.

    public method assembleWithoutGeneratingTargetInformation => AsmObjectCode := {
        let objectCodeBuilder := AsmObjectCodeBuilder new
            compilationTarget: compilationTarget;
            addImportedSymbols: importedSymbols;
            addProgramEntityImportedSymbols: importedProgramEntitySymbols;
            yourself.

        self prepareToAssemble.
        self assembleFirstPassWith: objectCodeBuilder.

        objectCodeBuilder allocateMemoryForWriting.
        self assembleSecondPassWith: objectCodeBuilder.
        
        objectCodeBuilder 
            finishDebugAndUnwindInfo;
            finish
    }.

    public method assembleAppendingNewSectionsToObjectObject: (initialObjectCode: AsmObjectCode) := {
        let objectCodeBuilder := AsmObjectCodeBuilder new
            compilationTarget: compilationTarget;
            addImportedSymbols: importedSymbols;
            addProgramEntityImportedSymbols: importedProgramEntitySymbols;
            addLinkedObjectCode: initialObjectCode;
            yourself.

        self prepareToAssemble.
        self assembleFirstPassWith: objectCodeBuilder.

        objectCodeBuilder allocateMemoryForWriting.
        self assembleSecondPassWith: objectCodeBuilder.
        
        objectCodeBuilder 
            finish
    }.

    public method assemble => AsmObjectCode := {
        let objectCodeBuilder := AsmObjectCodeBuilder new
            compilationTarget: compilationTarget;
            addImportedSymbols: importedSymbols;
            addProgramEntityImportedSymbols: importedProgramEntitySymbols;
            yourself.

        {|
            self prepareToAssemble.
        } printTimeToRunInMillisecondsWithTitle: "Assembler preparation".

        {|
            self assembleFirstPassWith: objectCodeBuilder.
        } printTimeToRunInMillisecondsWithTitle: "Assembler first pass".

        objectCodeBuilder allocateMemoryForWriting.
        {|
            self assembleSecondPassWith: objectCodeBuilder.
        } printTimeToRunInMillisecondsWithTitle: "Assembler second pass pass".

        objectCodeBuilder finishDebugAndUnwindInfo.
        debugInformationGenerator ifNotNil: {
            {|
                debugInformationGenerator generateDebugLineInformationForModule: self objectCodeBuilder: objectCodeBuilder
            } printTimeToRunInMillisecondsWithTitle: "Debug line information generation".
            
            {|
                debugInformationGenerator generateCallFrameInformationForModule: self objectCodeBuilder: objectCodeBuilder
            } printTimeToRunInMillisecondsWithTitle: "Debug call frame information generation".
        }.

        objectCodeBuilder finish
    }.

    public method buildDebugInfoForObjectCode: (sourceObjectCode: AsmObjectCode) ::=> Void := {
        let debugInformationGeneratorClass := compilationTarget debugInformationGenerator.
        debugInformationGeneratorClass ifNil: {return: void}.

        let targetDebugInformationGenerator := debugInformationGeneratorClass new.
        targetDebugInformationGenerator ifNotNil: {
            {|
                targetDebugInformationGenerator generateDebugInformationForModule: self sourceObjectCode: sourceObjectCode
            } printTimeToRunInMillisecondsWithTitle: "Debug information".
        }.
    }.

    public method writeObjectToFileNamed: (objectFileName: String) ::=> Boolean := {
        let assembledCode := self assemble.
        {|
            assembledCode writeObjectToFileNamed: objectFileName
        } printTimeToRunInMillisecondsWithTitle: "Writing object file " -- objectFileName
    }
}.

AsmObjectCodeStream extend: {
    public abstract method nextPutIPRelativeI32: (operand: AsmInstructionOperand) extraOffset: (extraOffset: Int32) ::=> Void
        := self subclassResponsibility.

    public abstract method nextPutImmediate: (operand: AsmInstructionOperand) withSize: (size: Size) ::=> Void
        := self subclassResponsibility.

    public method nextPutImmediate8: (operand: AsmInstructionOperand) ::=> Void := {
        self nextPutImmediate: operand withSize: 1sz
    }.

    public method nextPutImmediate16: (operand: AsmInstructionOperand) ::=> Void := {
        self nextPutImmediate: operand withSize: 2sz
    }.

    public method nextPutImmediate32: (operand: AsmInstructionOperand) ::=> Void := {
        self nextPutImmediate: operand withSize: 4sz
    }.

    public method nextPutImmediate64: (operand: AsmInstructionOperand) ::=> Void := {
        self nextPutImmediate: operand withSize: 8sz
    }.

    public method nextPutIPRelativeI32: (operand: AsmInstructionOperand) ::=> Void := {
        self nextPutIPRelativeI32: operand extraOffset: 4i32
    }.
}.

AsmObjectCodeSizeStream extend: {
    public override method nextPutImmediate: (operand: AsmInstructionOperand) withSize: (size: Size) ::=> Void := {
        operand recordRelocationSymbolOnCodeStream: self.
        activeSection increaseSizeBy: size
    }.

    public override method nextPutIPRelativeI32: (operand: AsmInstructionOperand) extraOffset: (extraOffset: Int32) ::=> Void := {
        operand recordRelocationSymbolOnCodeStream: self.
        activeSection increaseSizeBy: 4sz
    }.
}.

AsmObjectCodeWriteStream extend: {
    public override method nextPutImmediate: (operand: AsmInstructionOperand) withSize: (size: Size) ::=> Void := {
        operand nextPutImmediateWithSize: size onCodeStream: self
    }.

    public override method nextPutIPRelativeI32: (operand: AsmInstructionOperand) extraOffset: (extraOffset: Int32) ::=> Void := {
        operand nextPutIPRelativeI32WithExtraOffset: extraOffset onCodeStream: self
    }.
}.

AsmStream extend: {
    __Meta__ extend: {
        public method for: (compilationTarget: AsmCompilationTarget) buildWith: (aBlock: (AsmStreamBuilder => Void)) ::=> self := {
            let result := self new
                compilationTarget: compilationTarget;
                yourself.
            let builder := AsmStreamBuilder new
                stream: result;
                yourself.
            aBlock(builder).
            result
        }.

        public method buildWith: (aBlock: (AsmStreamBuilder => Void)) ::=> self
            := self for: AsmCompilationTarget default buildWith: aBlock.
    }
}.

AsmObjectDebugInformationGenerator extend: {
    public abstract method generateDebugInformationForModule: (module: AsmProgramEntity) ::=> Void
        := self subclassResponsibility.

    public abstract method generateDebugLineInformationForModule: (module: AsmProgramEntity) objectCodeBuilder: (objectCodeBuilder: AsmObjectCodeBuilder) ::=> Void
        := self subclassResponsibility.

    public abstract method generateCallFrameInformationForModule: (module: AsmProgramEntity) objectCodeBuilder: (objectCodeBuilder: AsmObjectCodeBuilder) ::=> Void
        := self subclassResponsibility.

    public abstract method generateDebugInformationForModule: (module: AsmProgramEntity) sourceObjectCode: (sourceObjectCode: AsmObjectCode) ::=> Void
        := self subclassResponsibility.
}.

public abstract class AsmStackMapLocation superclass: Object; definition: {

}.

public final class AsmStackMapLocationRegister superclass: AsmStackMapLocation; definition: {
    __Meta__ definition: {
        public method for: (register: AsmRegister) ::=> self
            := self new register: register; yourself.
    }.

    public field register => AsmRegister.
}.

public final class AsmStackMapLocationFrameOffset superclass: AsmStackMapLocation; definition: {
    public field offset => Int64.
}.

public final class AsmStackMapLocationCaptureOffset superclass: AsmStackMapLocation; definition: {
    public field captureVectorPointer => AsmStackMapLocation.
    public field offset => Int64.
}.

public final class AsmSymbolBindingLocationMap superclass: Object; definition: {
    public field binding => SymbolBinding.
    public field isMutable => Boolean.
    public field locations => OrderedCollection.

    public override method initialize => Void := {
        locations := OrderedCollection new.
    }.

    public method addLocation: (location: AsmStackMapLocation) ::=> Void := {
        locations add: location
    }.
}.

AsmStackMap definition: {
    public field frameBase => AsmStackMapLocation.
    public field captureBase => AsmStackMapLocation.

    public field bindingDictionary => ObjectPointerDictionary.
    public field bindings => OrderedCollection.
    public field arguments => OrderedCollection.
    public field captures => OrderedCollection.
    public field locals => OrderedCollection.

    public override method initialize => Void := {
        super initialize.
        bindingDictionary := ObjectPointerDictionary new.
        bindings := OrderedCollection new.
        arguments := OrderedCollection new.
        captures := OrderedCollection new.
        locals := OrderedCollection new.
    }.

    public method getMapOrNilForBinding: (binding: SymbolBinding) ::=> AsmSymbolBindingLocationMap
        := bindingDictionary atOrNil: binding.

    public method setBinding: (binding: SymbolBinding) isMutable: (isMutable: Boolean) location: (location: AsmStackMapLocation) ::=> AsmSymbolBindingLocationMap := {
        let map => AsmSymbolBindingLocationMap := bindingDictionary at: binding ifAbsentPut: {:: AsmSymbolBindingLocationMap |
            let newMap := AsmSymbolBindingLocationMap new
                binding: binding;
                isMutable: isMutable;
                yourself.
            bindings add: newMap.
            newMap
        }.

        map addLocation: location.
        map
    }.

    public method setBinding: (binding: SymbolBinding) location: (location: AsmStackMapLocation) ::=> AsmSymbolBindingLocationMap
        := self setBinding: binding isMutable: false location: location.

    public method addArgumentBindingMap: (bindingMap: AsmSymbolBindingLocationMap) ::=> Void := {
        arguments add: bindingMap
    }.

    public method addCaptureBindingMap: (bindingMap: AsmSymbolBindingLocationMap) ::=> Void := {
        captures add: bindingMap
    }.

    public method addLocalBindingMap: (bindingMap: AsmSymbolBindingLocationMap) ::=> Void := {
        locals add: bindingMap
    }.

    public method setLocalBinding: (binding: SymbolBinding) isMutable: (isMutable: Boolean) location: (location: AsmStackMapLocation) ::=> Void := {
        let isExistingMap := bindingDictionary includesKey: binding.
        let map := self setBinding: binding isMutable: isMutable location: location.
        isExistingMap ifFalse: {
            self addLocalBindingMap: map
        }
    }.

}.

AsmCompilationTarget definition: {
    __Meta__ definition: {
        public virtual method isDefault => Boolean
            := false.

        public method default => AsmCompilationTarget
            := nil.
    }.
}.