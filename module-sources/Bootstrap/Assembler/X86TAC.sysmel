TACPhysicalLocation extend: {
    public virtual method x86::int8For: (codegen: TACAsmCodeGenerator) ::=> AsmInstructionOperand
        := self error: "Not a x86 register with int8 section.".

    public virtual method x86::int16For: (codegen: TACAsmCodeGenerator) ::=> AsmInstructionOperand
        := self error: "Not a x86 register with int16 section.".

    public virtual method x86::int32For: (codegen: TACAsmCodeGenerator) ::=> AsmInstructionOperand
        := self error: "Not a x86 register with int32 section.".

    public virtual method x86::int64For: (codegen: TACAsmCodeGenerator) ::=> AsmInstructionOperand
        := self error: "Not a x86 register with int64 section.".

    public virtual method x86::rel32OrInt32For: (codegen: TACAsmCodeGenerator) ::=> AsmInstructionOperand
        := self error: "Not a x86 relative32 immediate or int32 register".

    public virtual method x86::rel32OrInt64For: (codegen: TACAsmCodeGenerator) ::=> AsmInstructionOperand
        := self error: "Not a x86 relative32 immediate or int64 register".

    public virtual method x86::loadFromLocal: (local: TACLocalVariable) with: (codegen: TACFunctionAsmCodeGenerator) ::=> Void
        := self shouldBeImplemented.

    public virtual method x86::storeInLocal: (local: TACLocalVariable) with: (codegen: TACFunctionAsmCodeGenerator) ::=> Void
        := self shouldBeImplemented.

    public virtual method x86_64::loadFromLocal: (local: TACLocalVariable) with: (codegen: TACFunctionAsmCodeGenerator) ::=> Void
        := self shouldBeImplemented.

    public virtual method x86_64::storeInLocal: (local: TACLocalVariable) with: (codegen: TACFunctionAsmCodeGenerator) ::=> Void
        := self shouldBeImplemented.
}.

TACPhysicalLocationImmediate extend: {
    public override method x86::int32For: (codegen: TACAsmCodeGenerator) ::=> AsmInstructionOperand
        := value asm::immediate32For: codegen.

    public override method x86::int64For: (codegen: TACAsmCodeGenerator) ::=> AsmInstructionOperand
        := value asm::immediate64For: codegen.

    public override method x86::rel32OrInt32For: (codegen: TACAsmCodeGenerator) ::=> AsmInstructionOperand
        := value asm::immediate32For: codegen.

    public override method x86::rel32OrInt64For: (codegen: TACAsmCodeGenerator) ::=> AsmInstructionOperand
        := value asm::immediate32For: codegen.
}.

public final class TACX86IntegerRegister superclass: TACPhysicalIntegerRegister; definition: {
    public field int8 => AsmX86Int8Register.
    public field int16 => AsmX86Int16Register.
    public field int32 => AsmX86Int32Register.

    public override method x86::int8 => AsmX86Int8Register := int8.
    public override method x86::int16 => AsmX86Int16Register := int16.
    public override method x86::int32 => AsmX86Int32Register := int32.
    
    public override method x86::int8For: (codegen: TACAsmCodeGenerator) ::=> AsmInstructionOperand := int8.
    public override method x86::int16For: (codegen: TACAsmCodeGenerator) ::=> AsmInstructionOperand := int16.
    public override method x86::int32For: (codegen: TACAsmCodeGenerator) ::=> AsmInstructionOperand := int32.

    public override method x86::rel32OrInt32For: (codegen: TACAsmCodeGenerator) ::=> AsmInstructionOperand := int32.

    __Meta__ definition: {
        public method int8: (int8: AsmX86Int8Register) int16: (int16: AsmX86Int16Register) int32: (int32: AsmX86Int32Register) ::=> self
            := self new int8: int8; int16: int16; int32: int32; yourself.
    }.

    public override method x86_64::loadFromLocal: (local: TACLocalVariable) with: (codegen: TACFunctionAsmCodeGenerator) ::=> Void := {
        let localSize := local size.
        let isSignedExtended := local isSignedExtended.
        self assert: (localSize = 1sz) || (localSize = 2sz) || (localSize = 4sz).

        ## TODO: Support the lambda captures.
        let localPointer := AsmX86RegisterAddress base: X86::EBP size: localSize asUInt8 displacement: local offset asInt32 asAsmImmediate.
        localSize = 1u64 && isSignedExtended ifTrue: (codegen textSection x86::movsx: self x86::int32 src: localPointer).
        localSize = 1u64 && isSignedExtended not ifTrue: (codegen textSection x86::movzx: self x86::int32 src: localPointer).
        localSize = 2u64 && isSignedExtended ifTrue: (codegen textSection x86::movsx: self x86::int32 src: localPointer).
        localSize = 2u64 && isSignedExtended not ifTrue: (codegen textSection x86::movzx: self x86::int32 src: localPointer).
        localSize = 4u64 ifTrue: (codegen textSection x86::mov: self x86::int32 src: localPointer).
    }.

    public override method x86_64::storeInLocal: (local: TACLocalVariable) with: (codegen: TACFunctionAsmCodeGenerator) ::=> Void := {
        let localSize := local size.
        self assert: (localSize = 1u64) || (localSize = 2u64) || (localSize = 4u64).
        
        ## TODO: Support the lambda captures.
        let localPointer := AsmX86RegisterAddress base: X86::EBP size: localSize asUInt8 displacement: local offset asInt32 asAsmImmediate.
        localSize = 1u64 ifTrue: (codegen textSection x86::mov: localPointer src: self x86::int8).
        localSize = 2u64 ifTrue: (codegen textSection x86::mov: localPointer src: self x86::int16).
        localSize = 4u64 ifTrue: (codegen textSection x86::mov: localPointer src: self x86::int32).
    }.
}.

public final class TACX86_64IntegerRegister superclass: TACPhysicalIntegerRegister; definition: {
    public field int8 => AsmX86Int8Register.
    public field int16 => AsmX86Int16Register.
    public field int32 => AsmX86Int32Register.
    public field int64 => AsmX86Int64Register.

    public override method x86::int8 => AsmX86Int8Register := int8.
    public override method x86::int16 => AsmX86Int16Register := int16.
    public override method x86::int32 => AsmX86Int32Register := int32.
    public override method x86::int64 => AsmX86Int64Register := int64.

    public override method x86::int8For: (codegen: TACAsmCodeGenerator) ::=> AsmInstructionOperand := int8.
    public override method x86::int16For: (codegen: TACAsmCodeGenerator) ::=> AsmInstructionOperand := int16.
    public override method x86::int32For: (codegen: TACAsmCodeGenerator) ::=> AsmInstructionOperand := int32.
    public override method x86::int64For: (codegen: TACAsmCodeGenerator) ::=> AsmInstructionOperand := int64.

    public override method x86::rel32OrInt64For: (codegen: TACAsmCodeGenerator) ::=> AsmInstructionOperand
        := int64.

    __Meta__ definition: {
        public method int8: (int8: AsmX86Int8Register) int16: (int16: AsmX86Int16Register) int32: (int32: AsmX86Int32Register) int64: (int64: AsmX86Int64Register) ::=> self
            := self new int8: int8; int16: int16; int32: int32; int64: int64; yourself.
    }.

    public override method x86_64::loadFromLocal: (local: TACLocalVariable) with: (codegen: TACFunctionAsmCodeGenerator) ::=> Void := {
        let localSize := local size.
        let isSignedExtended := local isSignedExtended.
        self assert: (localSize = 1sz) || (localSize = 2sz) || (localSize = 4sz) || (localSize = 8sz).

        ## TODO: Support the lambda captures.
        let localPointer := AsmX86RegisterAddress base: X86::RBP size: localSize asUInt8 displacement: local offset asInt32 asAsmImmediate.
        localSize = 1u64 && isSignedExtended ifTrue: (codegen textSection x86::movsx: self x86::int32 src: localPointer).
        localSize = 1u64 && isSignedExtended not ifTrue: (codegen textSection x86::movzx: self x86::int32 src: localPointer).
        localSize = 2u64 && isSignedExtended ifTrue: (codegen textSection x86::movsx: self x86::int32 src: localPointer).
        localSize = 2u64 && isSignedExtended not ifTrue: (codegen textSection x86::movzx: self x86::int32 src: localPointer).
        localSize = 4u64 ifTrue: (codegen textSection x86::mov: self x86::int32 src: localPointer).
        localSize = 8u64 ifTrue: (codegen textSection x86::mov: self x86::int64 src: localPointer).
    }.

    public override method x86_64::storeInLocal: (local: TACLocalVariable) with: (codegen: TACFunctionAsmCodeGenerator) ::=> Void := {
        let localSize := local size.
        self assert: (localSize = 1u64) || (localSize = 2u64) || (localSize = 4u64) || (localSize = 8u64).
        
        ## TODO: Support the lambda captures.
        let localPointer := AsmX86RegisterAddress base: X86::RBP size: localSize asUInt8 displacement: local offset asInt32 asAsmImmediate.
        localSize = 1u64 ifTrue: (codegen textSection x86::mov: localPointer src: self x86::int8).
        localSize = 2u64 ifTrue: (codegen textSection x86::mov: localPointer src: self x86::int16).
        localSize = 4u64 ifTrue: (codegen textSection x86::mov: localPointer src: self x86::int32).
        localSize = 8u64 ifTrue: (codegen textSection x86::mov: localPointer src: self x86::int64).
    }.
}.

public final class TACX86VectorRegister superclass: TACPhysicalLocation; definition: {
    public field register => AsmX86VectorRegister.

    __Meta__ definition: {
        public method register: (reg: AsmX86VectorRegister) ::=> self
            := self new register: reg; yourself.
    }.
}.

public global TAC::X86::EAX => TACX86IntegerRegister := TACX86IntegerRegister int8: X86::AL int16: X86::AX int32: X86::EAX.
public global TAC::X86::ECX => TACX86IntegerRegister := TACX86IntegerRegister int8: X86::CL int16: X86::CX int32: X86::ECX.
public global TAC::X86::EDX => TACX86IntegerRegister := TACX86IntegerRegister int8: X86::DL int16: X86::DX int32: X86::EDX.
public global TAC::X86::EBX => TACX86IntegerRegister := TACX86IntegerRegister int8: X86::BL int16: X86::BX int32: X86::EBX.
public global TAC::X86::ESP => TACX86IntegerRegister := TACX86IntegerRegister int8: nil int16: X86::SP int32: X86::ESP.
public global TAC::X86::EBP => TACX86IntegerRegister := TACX86IntegerRegister int8: nil int16: X86::BP int32: X86::EBP.
public global TAC::X86::ESI => TACX86IntegerRegister := TACX86IntegerRegister int8: nil int16: X86::SI int32: X86::ESI.
public global TAC::X86::EDI => TACX86IntegerRegister := TACX86IntegerRegister int8: nil int16: X86::DI int32: X86::EDI.

public global TAC::X86::XMM0 => TACX86VectorRegister := TACX86VectorRegister register: X86::XMM0.
public global TAC::X86::XMM1 => TACX86VectorRegister := TACX86VectorRegister register: X86::XMM1.
public global TAC::X86::XMM2 => TACX86VectorRegister := TACX86VectorRegister register: X86::XMM2.
public global TAC::X86::XMM3 => TACX86VectorRegister := TACX86VectorRegister register: X86::XMM3.
public global TAC::X86::XMM4 => TACX86VectorRegister := TACX86VectorRegister register: X86::XMM4.
public global TAC::X86::XMM5 => TACX86VectorRegister := TACX86VectorRegister register: X86::XMM5.
public global TAC::X86::XMM6 => TACX86VectorRegister := TACX86VectorRegister register: X86::XMM6.
public global TAC::X86::XMM7 => TACX86VectorRegister := TACX86VectorRegister register: X86::XMM7.

public global TAC::X86::IntegerRegisters => Array := (TAC::X86::EAX, TAC::X86::ECX, TAC::X86::EDX, TAC::X86::EBX, TAC::X86::ESP, TAC::X86::EBP, TAC::X86::ESI, TAC::X86::EDI).
public global TAC::X86::AllocableIntegerRegisters => Array := (TAC::X86::EAX, TAC::X86::ECX, TAC::X86::EDX, TAC::X86::EBX, TAC::X86::ESI, TAC::X86::EDI).

public global TAC::X86::VectorRegisters => Array := (TAC::X86::XMM0, TAC::X86::XMM1, TAC::X86::XMM2, TAC::X86::XMM3, TAC::X86::XMM4, TAC::X86::XMM5, TAC::X86::XMM6, TAC::X86::XMM7).
public global TAC::X86::AllocableVectorRegisters => Array := TAC::X86::VectorRegisters.

public global TAC::X86_64::RAX => TACX86_64IntegerRegister := TACX86_64IntegerRegister int8: X86::RAXB int16: X86::AX int32: X86::EAX int64: X86::RAX.
public global TAC::X86_64::RCX => TACX86_64IntegerRegister := TACX86_64IntegerRegister int8: X86::RCXB int16: X86::CX int32: X86::ECX int64: X86::RCX.
public global TAC::X86_64::RDX => TACX86_64IntegerRegister := TACX86_64IntegerRegister int8: X86::RDXB int16: X86::DX int32: X86::EDX int64: X86::RDX.
public global TAC::X86_64::RBX => TACX86_64IntegerRegister := TACX86_64IntegerRegister int8: X86::RBXB int16: X86::BX int32: X86::EBX int64: X86::RBX.
public global TAC::X86_64::RSP => TACX86_64IntegerRegister := TACX86_64IntegerRegister int8: X86::RSPB int16: X86::SP int32: X86::ESP int64: X86::RSP.
public global TAC::X86_64::RBP => TACX86_64IntegerRegister := TACX86_64IntegerRegister int8: X86::RBPB int16: X86::BP int32: X86::EBP int64: X86::RBP.
public global TAC::X86_64::RSI => TACX86_64IntegerRegister := TACX86_64IntegerRegister int8: X86::RSIB int16: X86::SI int32: X86::ESI int64: X86::RSI.
public global TAC::X86_64::RDI => TACX86_64IntegerRegister := TACX86_64IntegerRegister int8: X86::RDIB int16: X86::DI int32: X86::EDI int64: X86::RDI.
public global TAC::X86_64::R8 => TACX86_64IntegerRegister := TACX86_64IntegerRegister int8: X86::R8B int16: X86::R8W int32: X86::R8D int64: X86::R8.
public global TAC::X86_64::R9 => TACX86_64IntegerRegister := TACX86_64IntegerRegister int8: X86::R9B int16: X86::R9W int32: X86::R9D int64: X86::R9.
public global TAC::X86_64::R10 => TACX86_64IntegerRegister := TACX86_64IntegerRegister int8: X86::R10B int16: X86::R10W int32: X86::R10D int64: X86::R10.
public global TAC::X86_64::R11 => TACX86_64IntegerRegister := TACX86_64IntegerRegister int8: X86::R11B int16: X86::R11W int32: X86::R11D int64: X86::R11.
public global TAC::X86_64::R12 => TACX86_64IntegerRegister := TACX86_64IntegerRegister int8: X86::R12B int16: X86::R12W int32: X86::R12D int64: X86::R12.
public global TAC::X86_64::R13 => TACX86_64IntegerRegister := TACX86_64IntegerRegister int8: X86::R13B int16: X86::R13W int32: X86::R13D int64: X86::R13.
public global TAC::X86_64::R14 => TACX86_64IntegerRegister := TACX86_64IntegerRegister int8: X86::R14B int16: X86::R14W int32: X86::R14D int64: X86::R14.
public global TAC::X86_64::R15 => TACX86_64IntegerRegister := TACX86_64IntegerRegister int8: X86::R15B int16: X86::R15W int32: X86::R15D int64: X86::R15.

public global TAC::X86_64::XMM8 => TACX86VectorRegister := TACX86VectorRegister register: X86::XMM8.
public global TAC::X86_64::XMM9 => TACX86VectorRegister := TACX86VectorRegister register: X86::XMM9.
public global TAC::X86_64::XMM10 => TACX86VectorRegister := TACX86VectorRegister register: X86::XMM10.
public global TAC::X86_64::XMM11 => TACX86VectorRegister := TACX86VectorRegister register: X86::XMM11.
public global TAC::X86_64::XMM12 => TACX86VectorRegister := TACX86VectorRegister register: X86::XMM12.
public global TAC::X86_64::XMM13 => TACX86VectorRegister := TACX86VectorRegister register: X86::XMM13.
public global TAC::X86_64::XMM14 => TACX86VectorRegister := TACX86VectorRegister register: X86::XMM14.
public global TAC::X86_64::XMM15 => TACX86VectorRegister := TACX86VectorRegister register: X86::XMM15.

public global TAC::X86_64::VectorRegisters => Array := (
    TAC::X86::XMM0, TAC::X86::XMM1, TAC::X86::XMM2, TAC::X86::XMM3,
    TAC::X86::XMM4, TAC::X86::XMM5, TAC::X86::XMM6, TAC::X86::XMM7,
    TAC::X86_64::XMM8, TAC::X86_64::XMM9, TAC::X86_64::XMM10, TAC::X86_64::XMM11,
    TAC::X86_64::XMM12, TAC::X86_64::XMM13, TAC::X86_64::XMM14, TAC::X86_64::XMM15).
public global TAC::X86_64::AllocableVectorRegisters => Array := TAC::X86_64::VectorRegisters.

public global TAC::X86_64::IntegerRegisters => Array := (
    TAC::X86_64::RAX, TAC::X86_64::RCX, TAC::X86_64::RDX, TAC::X86_64::RBX,
    TAC::X86_64::RSP, TAC::X86_64::RBP, TAC::X86_64::RSI, TAC::X86_64::RDI,
    TAC::X86_64::R8, TAC::X86_64::R9, TAC::X86_64::R10, TAC::X86_64::R11,
    TAC::X86_64::R12, TAC::X86_64::R13, TAC::X86_64::R14, TAC::X86_64::R15
).

public global TAC::X86_64::AllocableIntegerRegisters => Array := (
    TAC::X86_64::RAX, TAC::X86_64::RCX, TAC::X86_64::RDX, TAC::X86_64::RBX,
    TAC::X86_64::RSI, TAC::X86_64::RDI,
    TAC::X86_64::R8, TAC::X86_64::R9, TAC::X86_64::R10, TAC::X86_64::R11,
    TAC::X86_64::R12, TAC::X86_64::R13, TAC::X86_64::R14, TAC::X86_64::R15
).

public abstract class TACSX86StackBasedCallingConvention superclass: TACCallingConvention; definition: {
    public override method computeRegisterConstraintsOf: (instruction: TACInstruction) with: (allocator: TACRegisterAllocator) ::=> Void := {
        allocator
            allocateRegister: TAC::X86_64::RAX forInstructionResult: instruction;
            allocateRegisterOrRelativeImmediate32ForInstruction: instruction operandAt: 0sz.
        1sz until: instruction operands size do: {:(Size)operandIndex :: Void |
            allocator
                allocateMemoryForInstruction: instruction operandAt: operandIndex
        }.
    }.

    public override method asm::generateCall: (instruction: TACInstruction) with: (codegen: TACFunctionAsmCodeGenerator) ::=> Void := {
        codegen textSection
            x86::call: (instruction firstOperandRegister x86::rel32OrInt32For: codegen)
    }.
}.

public final class TACSX86CDeclCallingConvention superclass: TACSX86StackBasedCallingConvention; definition: {
}.

public global TAC::X86::CDeclCallingConvention := TACSX86CDeclCallingConvention new.

public final class TACX86CompilationTarget superclass: TACAsmCompilationTarget; definition: {
    public override method name => Symbol
        := #x86.

    public override method allIntegerRegisters => Array
        := TAC::X86::IntegerRegisters.

    public override method allocableIntegerRegisters => Array
        := TAC::X86::AllocableIntegerRegisters.

    public override method allVectorRegisters => Array
        := TAC::X86::VectorRegisters.

    public override method allocableVectorRegisters => Array
        := TAC::X86::AllocableVectorRegisters.

    public override method defaultCallingConvention => TACCallingConvention
        := TAC::X86::CDeclCallingConvention.

    public override method emitFunctionPrologueWith: (generator: TACFunctionAsmCodeGenerator) ::=> Void := {
        generator textSection
            x86::endbr32;
            x86::push: X86::EBP;
            x86::mov: X86::EBP src: X86::ESP
    }.

    public override method emitStackFrameConstructionWith: (generator: TACFunctionAsmCodeGenerator) ::=> Void := {

    }.

    public override method emitFunctionEpilogueWith: (codegen: TACFunctionAsmCodeGenerator) ::=> Void := {
        codegen textSection
            x86::mov: X86::ESP src: X86::EBP;
            x86::pop: X86::EBP.
    }.

    public override method emitMoveValue: (value: TACValue) intoLocation: (register: TACPhysicalLocation) with: (codegen: TACFunctionAsmCodeGenerator) ::=> Void := {
        value x86::moveIntoRegister: register with: codegen
    }.

    public override method emitMoveRegister: (register: TACPhysicalLocation) intoValue: (value: TACValue) with: (codegen: TACFunctionAsmCodeGenerator) ::=> Void := {
        value x86::moveFromRegister: register with: codegen
    }.
}.

public global X86_64::SysV::IntegerArgumentRegisters := (
    TAC::X86_64::RDI, TAC::X86_64::RSI, TAC::X86_64::RDX, TAC::X86_64::RCX, TAC::X86_64::R8, TAC::X86_64::R9
).

public global X86_64::SysV::VectorArgumentRegisters := (
    TAC::X86::XMM0, TAC::X86::XMM1, TAC::X86::XMM2, TAC::X86::XMM3, TAC::X86::XMM4, TAC::X86::XMM5, TAC::X86::XMM6, TAC::X86::XMM7
).

public final class TACSysVX86_64RegisterAssignmentState superclass: Object; definition: {
    public field usedIntegerRegisterCount => Size.
    public field usedVectorRegisterCount => Size.

    public method allocateIntegerRegister => TACPhysicalLocation := {
        usedIntegerRegisterCount < X86_64::SysV::IntegerArgumentRegisters size ifTrue: {
            let register := X86_64::SysV::IntegerArgumentRegisters at: usedIntegerRegisterCount.
            usedIntegerRegisterCount := usedIntegerRegisterCount + 1sz.
            register
        } ifFalse: {
            nil
        }
    }.

    public method allocateVectorRegister => TACPhysicalLocation := {
        usedVectorRegisterCount < X86_64::SysV::IntegerArgumentRegisters size ifTrue: {
            let register := X86_64::SysV::VectorArgumentRegisters at: usedVectorRegisterCount.
            usedVectorRegisterCount := usedVectorRegisterCount + 1sz.
            register
        } ifFalse: {
            nil
        }
    }.

    public method allocateIntegerOfSize: (size: Size) alignment: (alignment: Size) ::=> TACPhysicalLocation
        := size <= 8sz ifTrue: (self allocateIntegerRegister) ifFalse: nil.

    public method allocateVectorOfSize: (size: Size) alignment: (alignment: Size) ::=> TACPhysicalLocation
        := size <= 16sz ifTrue: (self allocateVectorRegister) ifFalse: nil.

    public method assignRegisterToValue: (value: TACValue) ::=> TACPhysicalLocation := {
        (value isFloatingPoint || value isVector)
            ifTrue: (self allocateVectorOfSize: value size alignment: value alignment)
            ifFalse: (self allocateIntegerOfSize: value size alignment: value alignment).
    }.
}.

public final class TACSysVX86_64CallingConvention superclass: TACCallingConvention; definition: {
    public method registerConstraintsOfCall: (instruction: TACInstruction) with: (allocator: TACRegisterAllocator) ::=> Void := {
        allocator allocateRegisterOrRelativeImmediate32ForInstruction: instruction operandAt: 0sz.
        
        let registerAssignmentState := TACSysVX86_64RegisterAssignmentState new.
        1sz until: instruction operands size do: {:(Size)operandIndex :: Void |
            let operand := instruction operands at: operandIndex.
            let register := registerAssignmentState assignRegisterToValue: operand.
            register
                ifNotNil: (allocator allocateRegister: register forInstruction: instruction operandAt: operandIndex)
                ifNil: (allocator allocateMemoryForInstruction: instruction operandAt: operandIndex)
        }.
    }.

    public override method registerConstraintsOfCallInt32: (instruction: TACInstruction) with: (allocator: TACRegisterAllocator) ::=> Void := {
        self registerConstraintsOfCall: instruction with: allocator.
        allocator allocateRegister: TAC::X86_64::RAX forInstructionResult: instruction.
    }.

    public override method registerConstraintsOfCallInt64: (instruction: TACInstruction) with: (allocator: TACRegisterAllocator) ::=> Void := {
        self registerConstraintsOfCall: instruction with: allocator.
        allocator allocateRegister: TAC::X86_64::RAX forInstructionResult: instruction.
    }.

    public override method registerConstraintsOfCallFloat32: (instruction: TACInstruction) with: (allocator: TACRegisterAllocator) ::=> Void := {
        self registerConstraintsOfCall: instruction with: allocator.
        allocator allocateRegister: TAC::X86::XMM0 forInstructionResult: instruction.
    }.

    public override method registerConstraintsOfCallFloat64: (instruction: TACInstruction) with: (allocator: TACRegisterAllocator) ::=> Void := {
        self registerConstraintsOfCall: instruction with: allocator.
        allocator allocateRegister: TAC::X86::XMM0 forInstructionResult: instruction.
    }.

    public override method registerConstraintsOfCallStruct: (instruction: TACInstruction) with: (allocator: TACRegisterAllocator) ::=> Void := {
        self registerConstraintsOfCall: instruction with: allocator.
        allocator allocateMemoryForInstructionResult: instruction.
    }.

    public override method registerConstraintsOfCallVoid: (instruction: TACInstruction) with: (allocator: TACRegisterAllocator) ::=> Void := {
        self registerConstraintsOfCall: instruction with: allocator
    }.

    public method asm::generateCall: (instruction: TACInstruction) with: (codegen: TACFunctionAsmCodeGenerator) ::=> Void := {
        let stackArguments := ArrayList new.
        let stackArgumentAlignment := 8u64.
        let stackSize mutable := 0u64.
        let stackAlignment mutable := 16u64.

        ## Select the arguments that are passed through the stack.
        1sz until: instruction operands size do: {:(Size)operandIndex :: Void |
            let argument => TACValue := instruction operands at: operandIndex.
            let register => TACPhysicalLocation := instruction operandRegisters at: operandIndex.
            register isMemory ifTrue: {
                let operandAlignment := argument alignment max: stackArgumentAlignment.
                let operandSize := argument size alignedTo: operandAlignment.
                let argumentOffset := stackSize alignedTo: operandAlignment.

                stackSize := argumentOffset + operandSize.
                stackAlignment := stackAlignment max: operandAlignment.
                
                stackArguments add: argument
            }.
        }.

        ## Compute the required argument padding.
        let alignedStackSize := stackSize alignedTo: stackAlignment.
        let stackPadding := alignedStackSize - stackSize.
        stackPadding > 0u64 ifTrue: {
            codegen textSection x86::sub: X86::RSP with: stackPadding asInt32 asAsmImmediate
        }.

        ## Push the arguments onto the stack.
        stackArguments reverseDo: {:(TACValue)argument :: Void |
            argument x86_64::pushWith: codegen
        }.

        ## Perform the call.
        codegen textSection x86::call: (instruction firstOperandRegister x86::rel32OrInt64For: codegen).

        ## Clear the stack arguments.
        alignedStackSize > 0u64 ifTrue: {
            codegen textSection x86::add: X86::RSP with: alignedStackSize asInt32 asAsmImmediate
        }.
    }.

    public override method asm::generateCallInt32: (instruction: TACInstruction) with: (codegen: TACFunctionAsmCodeGenerator) ::=> Void := {
        self asm::generateCall: instruction with: codegen
    }.

    public override method asm::generateCallInt64: (instruction: TACInstruction) with: (codegen: TACFunctionAsmCodeGenerator) ::=> Void := {
        self asm::generateCall: instruction with: codegen
    }.

    public override method asm::generateCallFloat32: (instruction: TACInstruction) with: (codegen: TACFunctionAsmCodeGenerator) ::=> Void := {
        self asm::generateCall: instruction with: codegen
    }.

    public override method asm::generateCallFloat64: (instruction: TACInstruction) with: (codegen: TACFunctionAsmCodeGenerator) ::=> Void := {
        self asm::generateCall: instruction with: codegen
    }.

    public override method asm::generateCallStruct: (instruction: TACInstruction) with: (codegen: TACFunctionAsmCodeGenerator) ::=> Void := {
        self asm::generateCall: instruction with: codegen
    }.

    public override method asm::generateCallVoid: (instruction: TACInstruction) with: (codegen: TACFunctionAsmCodeGenerator) ::=> Void := {
        self asm::generateCall: instruction with: codegen
    }.
}.

public global TAC::X86_64::SysVCallingConvention := TACSysVX86_64CallingConvention new.

public final class TACX86_64CompilationTarget superclass: TACAsmCompilationTarget; definition: {
    public override method name => Symbol
        := #x86_64.

    public override method allIntegerRegisters => Array
        := TAC::X86_64::IntegerRegisters.

    public override method allocableIntegerRegisters => Array
        := TAC::X86_64::AllocableIntegerRegisters.

    public override method allVectorRegisters => Array
        := TAC::X86::VectorRegisters.

    public override method allocableVectorRegisters => Array
        := TAC::X86::AllocableVectorRegisters.

    public override method defaultCallingConvention => TACCallingConvention
        := TAC::X86_64::SysVCallingConvention.

    public override method emitFunctionPrologueWith: (codegen: TACFunctionAsmCodeGenerator) ::=> Void := {
        codegen textSection x86::endbr64.

        let stackFrameLayout := codegen stackFrameLayout.
        stackFrameLayout isRequired ifTrue: {
            codegen textSection
                x86::push: X86::RBP;
                x86::mov: X86::RBP src: X86::RSP.

        }.
    }.

    public override method emitStackFrameConstructionWith: (codegen: TACFunctionAsmCodeGenerator) ::=> Void := {
        let stackFrameLayout := codegen stackFrameLayout.
        stackFrameLayout temporaryFrameSize > 0u64 ifTrue: {
            codegen textSection
                x86::sub: X86::RSP with: codegen stackFrameLayout temporaryFrameSize asInt32 asAsmImmediate
        }.
    }.

    public override method emitFunctionEpilogueWith: (codegen: TACFunctionAsmCodeGenerator) ::=> Void := {
        let stackFrameLayout := codegen stackFrameLayout.
        stackFrameLayout isRequired ifTrue: {
            codegen textSection
                x86::mov: X86::RSP src: X86::RBP;
                x86::pop: X86::RBP.
        }.
    }.

    public override method emitMoveValue: (value: TACValue) intoLocation: (register: TACPhysicalLocation) with: (codegen: TACFunctionAsmCodeGenerator) ::=> Void := {
        value x86_64::moveIntoRegister: register with: codegen
    }.

    public override method emitMoveRegister: (register: TACPhysicalLocation) intoValue: (value: TACValue) with: (codegen: TACFunctionAsmCodeGenerator) ::=> Void := {
        value x86_64::moveFromRegister: register with: codegen
    }.
}.

TACValue extend: {
    public abstract method x86::moveIntoRegister: (register: TACPhysicalLocation) with: (codegen: TACFunctionAsmCodeGenerator) ::=> Void
        := self subclassResponsibility.

    public abstract method x86::moveFromRegister: (register: TACPhysicalLocation) with: (codegen: TACFunctionAsmCodeGenerator) ::=> Void
        := self subclassResponsibility.

    public abstract method x86::pushWith: (codegen: TACFunctionAsmCodeGenerator) ::=> Void
        := self subclassResponsibility.

    public abstract method x86_64::moveIntoRegister: (register: TACPhysicalLocation) with: (codegen: TACFunctionAsmCodeGenerator) ::=> Void
        := self x86::moveIntoRegister: register with: codegen.

    public abstract method x86_64::moveFromRegister: (register: TACPhysicalLocation) with: (codegen: TACFunctionAsmCodeGenerator) ::=> Void
        := self x86::moveFromRegister: register with: codegen.

    public abstract method x86_64::pushWith: (codegen: TACFunctionAsmCodeGenerator) ::=> Void
        := self x86::pushWith: codegen.
}.

TACProgramEntity extend: {
    public override method x86::moveIntoRegister: (register: TACPhysicalLocation) with: (codegen: TACFunctionAsmCodeGenerator) ::=> Void := {
        codegen textSection x86::mov: (register x86::int32For: codegen) src: (codegen symbolForProgramEntity: self) dword
    }.

    public override method x86_64::moveIntoRegister: (register: TACPhysicalLocation) with: (codegen: TACFunctionAsmCodeGenerator) ::=> Void := {
        codegen textSection x86::lea: (register x86::int64For: codegen) src: (codegen symbolForProgramEntity: self) x86::qwordPtr
    }.
}.

TACLocalVariable extend: {
    public override method x86::moveIntoRegister: (register: TACPhysicalLocation) with: (codegen: TACFunctionAsmCodeGenerator) ::=> Void := {
        register x86::loadFromLocal: self with: codegen
    }.

    public override method x86::moveFromRegister: (register: TACPhysicalLocation) with: (codegen: TACFunctionAsmCodeGenerator) ::=> Void := {
        register x86::storeInLocal: self with: codegen
    }.

    public override method x86_64::moveIntoRegister: (register: TACPhysicalLocation) with: (codegen: TACFunctionAsmCodeGenerator) ::=> Void := {
        register x86_64::loadFromLocal: self with: codegen
    }.

    public override method x86_64::moveFromRegister: (register: TACPhysicalLocation) with: (codegen: TACFunctionAsmCodeGenerator) ::=> Void := {
        register x86_64::storeInLocal: self with: codegen
    }.
}.

TACConstant extend: {
    public override method x86_64::moveFromRegister: (register: TACPhysicalLocation) with: (codegen: TACFunctionAsmCodeGenerator) ::=> Void
        := self error: "Cannot move into constant.".
}.

TACConstantInt8 extend: {
    public override method x86::moveIntoRegister: (register: TACPhysicalLocation) with: (codegen: TACFunctionAsmCodeGenerator) ::=> Void := {
        codegen textSection x86::mov: (register x86::int32For: codegen) src: value asUInt32 asAsmImmediate.
    }.

    public override method x86_64::pushWith: (codegen: TACFunctionAsmCodeGenerator) ::=> Void := {
        codegen textSection x86::push: value asInt32 asAsmImmediate
    }.
}.

TACConstantUInt8 extend: {
    public override method x86::moveIntoRegister: (register: TACPhysicalLocation) with: (codegen: TACFunctionAsmCodeGenerator) ::=> Void := {
        codegen textSection x86::mov: (register x86::int32For: codegen) src: value asUInt32 asAsmImmediate.
    }.

    public override method x86_64::pushWith: (codegen: TACFunctionAsmCodeGenerator) ::=> Void := {
        codegen textSection x86::push: value asInt32 asAsmImmediate
    }.
}.

TACConstantInt16 extend: {
    public override method x86::moveIntoRegister: (register: TACPhysicalLocation) with: (codegen: TACFunctionAsmCodeGenerator) ::=> Void := {
        codegen textSection x86::mov: (register x86::int32For: codegen) src: value asUInt32 asAsmImmediate.
    }.

    public override method x86_64::pushWith: (codegen: TACFunctionAsmCodeGenerator) ::=> Void := {
        codegen textSection x86::push: value asInt32 asAsmImmediate
    }.
}.

TACConstantUInt16 extend: {
    public override method x86::moveIntoRegister: (register: TACPhysicalLocation) with: (codegen: TACFunctionAsmCodeGenerator) ::=> Void := {
        codegen textSection x86::mov: (register x86::int32For: codegen) src: value asUInt32 asAsmImmediate.
    }.

    public override method x86_64::pushWith: (codegen: TACFunctionAsmCodeGenerator) ::=> Void := {
        codegen textSection x86::push: value asInt32 asAsmImmediate
    }.
}.

TACConstantInt32 extend: {
    public override method x86::moveIntoRegister: (register: TACPhysicalLocation) with: (codegen: TACFunctionAsmCodeGenerator) ::=> Void := {
        codegen textSection x86::mov: (register x86::int32For: codegen) src: value asAsmImmediate.
    }.

    public override method x86_64::pushWith: (codegen: TACFunctionAsmCodeGenerator) ::=> Void := {
        codegen textSection x86::push: value asAsmImmediate
    }.
}.

TACConstantUInt32 extend: {
    public override method x86::moveIntoRegister: (register: TACPhysicalLocation) with: (codegen: TACFunctionAsmCodeGenerator) ::=> Void := {
        codegen textSection x86::mov: (register x86::int32For: codegen) src: value asAsmImmediate.
    }.

    public override method x86_64::pushWith: (codegen: TACFunctionAsmCodeGenerator) ::=> Void := {
        codegen textSection x86::push: value asAsmImmediate
    }.
}.

TACConstantInt64 extend: {
    public override method x86_64::moveIntoRegister: (register: TACPhysicalLocation) with: (codegen: TACFunctionAsmCodeGenerator) ::=> Void := {
        codegen textSection x86::mov: (register x86::int64For: codegen) src: value asAsmImmediate.
    }.
}.

TACConstantUInt64 extend: {
    public override method x86_64::moveIntoRegister: (register: TACPhysicalLocation) with: (codegen: TACFunctionAsmCodeGenerator) ::=> Void := {
        codegen textSection x86::mov: (register x86::int64For: codegen) src: value asAsmImmediate.
    }.
}.

TACConstantFloat32 extend: {
    public override method x86_64::pushWith: (codegen: TACFunctionAsmCodeGenerator) ::=> Void := {
        codegen textSection x86::push: value asIEEEFloat32Encoding asAsmImmediate
    }.
}.

let x86::integerAluInt32RegisterConstraints := {:(TACInstruction)instruction :(TACRegisterAllocator)allocator :: Void |
    allocator
        allocateRegisterForInstructionResult: instruction;
        allocateRegisterOrImmediate32ForInstruction: instruction operandAt: 0sz;
        allocateRegisterOrImmediate32ForInstruction: instruction operandAt: 1sz
}.

TAC::Operation::AddInt32
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerAluInt32RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(TACInstruction)instruction :(TACFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::mov: (instruction resultRegister x86::int32For: codegen) src: (instruction firstOperandRegister x86::int32For: codegen);
            x86::add: (instruction resultRegister x86::int32For: codegen) with: (instruction secondOperandRegister x86::int32For: codegen)
    }.

TAC::Operation::Branch
    forTargets: #(x86 x86_64) registerConstraintsWith: {:(TACInstruction)instruction :(TACRegisterAllocator)allocator :: Void |
        allocator allocateRegisterOrRelativeImmediate32ForInstruction: instruction operandAt: 0sz
    };
    forTarget: #x86_64 generateWith: {:(TACInstruction)instruction :(TACFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection x86::jmp: (instruction firstOperandRegister x86::rel32OrInt32For: codegen)
    };
    forTarget: #x86_64 generateWith: {:(TACInstruction)instruction :(TACFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection x86::jmp: (instruction firstOperandRegister x86::rel32OrInt64For: codegen)
    }.

TAC::Operation::CallInt32
    forTargets: #(x86 x86_64) registerConstraintsWith: {:(TACInstruction)instruction :(TACRegisterAllocator)allocator :: Void |
        instruction callingConvention registerConstraintsOfCallInt32: instruction with: allocator
    };
    forTargets: #(x86 x86_64) generateWith: {:(TACInstruction)instruction :(TACFunctionAsmCodeGenerator)codegen :: Void |
        instruction callingConvention asm::generateCallInt32: instruction with: codegen
    }.

TAC::Operation::CallInt64
    forTargets: #(x86 x86_64) registerConstraintsWith: {:(TACInstruction)instruction :(TACRegisterAllocator)allocator :: Void |
        instruction callingConvention registerConstraintsOfCallInt64: instruction with: allocator
    };
    forTargets: #(x86 x86_64) generateWith: {:(TACInstruction)instruction :(TACFunctionAsmCodeGenerator)codegen :: Void |
        instruction callingConvention asm::generateCallInt64: instruction with: codegen
    }.

TAC::Operation::CallFloat32
    forTargets: #(x86 x86_64) registerConstraintsWith: {:(TACInstruction)instruction :(TACRegisterAllocator)allocator :: Void |
        instruction callingConvention registerConstraintsOfCallFloat32: instruction with: allocator
    };
    forTargets: #(x86 x86_64) generateWith: {:(TACInstruction)instruction :(TACFunctionAsmCodeGenerator)codegen :: Void |
        instruction callingConvention asm::generateCallFloat32: instruction with: codegen
    }.

TAC::Operation::CallFloat64
    forTargets: #(x86 x86_64) registerConstraintsWith: {:(TACInstruction)instruction :(TACRegisterAllocator)allocator :: Void |
        instruction callingConvention registerConstraintsOfCallFloat64: instruction with: allocator
    };
    forTargets: #(x86 x86_64) generateWith: {:(TACInstruction)instruction :(TACFunctionAsmCodeGenerator)codegen :: Void |
        instruction callingConvention asm::generateCallFloat64: instruction with: codegen
    }.

TAC::Operation::CallFloat64
    forTargets: #(x86 x86_64) registerConstraintsWith: {:(TACInstruction)instruction :(TACRegisterAllocator)allocator :: Void |
        instruction callingConvention registerConstraintsOfCallStruct: instruction with: allocator
    };
    forTargets: #(x86 x86_64) generateWith: {:(TACInstruction)instruction :(TACFunctionAsmCodeGenerator)codegen :: Void |
        instruction callingConvention asm::generateCallStruct: instruction with: codegen
    }.

TAC::Operation::CallVoid
    forTargets: #(x86 x86_64) registerConstraintsWith: {:(TACInstruction)instruction :(TACRegisterAllocator)allocator :: Void |
        instruction callingConvention registerConstraintsOfCallVoid: instruction with: allocator
    };
    forTargets: #(x86 x86_64) generateWith: {:(TACInstruction)instruction :(TACFunctionAsmCodeGenerator)codegen :: Void |
        instruction callingConvention asm::generateCallVoid: instruction with: codegen
    }.

TAC::Operation::ReturnInt32
    forTarget: #x86_64 registerConstraintsWith: {:(TACInstruction)instruction :(TACRegisterAllocator)allocator :: Void |
        allocator allocateRegister: TAC::X86_64::RAX forInstruction: instruction operandAt: 0sz
    };
    forTarget: #x86_64 generateWith: {:(TACInstruction)instruction :(TACFunctionAsmCodeGenerator)codegen :: Void |
        codegen emitEpilogue.
        codegen textSection x86::ret
    }.

TAC::Operation::ReturnInt64
    forTarget: #x86_64 registerConstraintsWith: {:(TACInstruction)instruction :(TACRegisterAllocator)allocator :: Void |
        allocator allocateRegister: TAC::X86_64::RAX forInstruction: instruction operandAt: 0sz
    };
    forTarget: #x86_64 generateWith: {:(TACInstruction)instruction :(TACFunctionAsmCodeGenerator)codegen :: Void |
        codegen emitEpilogue.
        codegen textSection x86::ret
    }.

TAC::Operation::ReturnFloat32
    forTarget: #x86_64 registerConstraintsWith: {:(TACInstruction)instruction :(TACRegisterAllocator)allocator :: Void |
        allocator allocateRegister: TAC::X86::XMM0 forInstruction: instruction operandAt: 0sz
    };
    forTarget: #x86_64 generateWith: {:(TACInstruction)instruction :(TACFunctionAsmCodeGenerator)codegen :: Void |
        codegen emitEpilogue.
        codegen textSection x86::ret
    }.

TAC::Operation::ReturnFloat64
    forTarget: #x86_64 registerConstraintsWith: {:(TACInstruction)instruction :(TACRegisterAllocator)allocator :: Void |
        allocator allocateRegister: TAC::X86::XMM0 forInstruction: instruction operandAt: 0sz
    };
    forTarget: #x86_64 generateWith: {:(TACInstruction)instruction :(TACFunctionAsmCodeGenerator)codegen :: Void |
        codegen emitEpilogue.
        codegen textSection x86::ret
    }.

TAC::Operation::ReturnVoid
    forTargets: #(x86 x86_64) registerConstraintsWith: {:(TACInstruction)instruction :(TACRegisterAllocator)allocator :: Void | };
    forTargets: #(x86 x86_64) generateWith: {:(TACInstruction)instruction :(TACFunctionAsmCodeGenerator)codegen :: Void |
        codegen emitEpilogue.
        codegen textSection x86::ret
    }.

AsmX86CompilationTarget extend: {
    public method asTacCompilationTarget => TACX86CompilationTarget
        := TACX86CompilationTarget new asmCompilationTarget: self; yourself
}.

AsmX86_64CompilationTarget extend: {
    public method asTacCompilationTarget => TACX86_64CompilationTarget
        := TACX86_64CompilationTarget new asmCompilationTarget: self; yourself.
}.
