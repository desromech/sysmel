public class AsmX86Instruction superclass: AsmStreamElement.
public final class AsmX86RegisterAddress superclass: AsmRegisterAddress.

let X86NopPatterns := #(
    #[16r90]
    #[16r66 16r90]                        ##2 - xchg ax ax (o16 nop)
    #[16r0f 16r1f 16r00]                         ##3 - nop(3)
    #[16r0f 16r1f 16r40 16r00]                   ##4 - nop(4)
    #[16r0f 16r1f 16r44 16r00 16r00]             ##5 - nop(5)
    #[16r66 16r0f 16r1f 16r44 16r00 16r00]       ##6 - nop(6)
    #[16r0f 16r1f 16r80 16r00 16r00 16r00 16r00] ##7 - nop(7)
    #[16r0f 16r1f 16r84 16r00 16r00 16r00 16r00  ##8 - nop(8)
        16r00]
    #[16r66 16r0f 16r1f 16r84 16r00 16r00 16r00  ##9 - nop(9)
        16r00 16r00]
    #[16r66 16r2e 16r0f 16r1f 16r84 16r00 16r00  ##10 - o16 cs nop
        16r00 16r00 16r00]
    #[16r66 16r66 16r2e 16r0f 16r1f 16r84 16r00  ##11 - 2x o16 cs nop
        16r00 16r00 16r00 16r00]
    #[16r66 16r66 16r66 16r2e 16r0f 16r1f 16r84  ##12 - 3x o16 cs nop
        16r00 16r00 16r00 16r00 16r00]
    #[16r66 16r66 16r66 16r66 16r2e 16r0f 16r1f  ##13 - 4x o16 cs nop
        16r84 16r00 16r00 16r00 16r00 16r00]
    #[16r66 16r66 16r66 16r66 16r66 16r2e 16r0f  ##14 - 5x o16 cs nop
        16r1f 16r84 16r00 16r00 16r00 16r00 16r00]
    #[16r66 16r66 16r66 16r66 16r66 16r66 16r2e  ##15 - 6x o16 cs nop
        16r0f 16r1f 16r84 16r00 16r00 16r00 16r00 16r00]
).

public abstract class AsmAbstractX86CompilationTarget superclass: AsmCompilationTarget; definition: {
    public override method padCodeSectionData: (data: ByteArray) at: (offset: Size) size: (size: Size) unreachable: (unreachable: Boolean) ::=> Void := {
        let writeOffset mutable := offset.
        let endWriteOffset := writeOffset + size.

        unreachable ifTrue: {
            while: writeOffset < endWriteOffset do: (
                data at: writeOffset put: 16rCC u8 ## X86: Int3
            ) continueWith: (writeOffset := writeOffset + 1sz).

        } ifFalse: {
            let remainingSize mutable := size.
            while: (remainingSize > 0sz) do: {
                let paddingPattern => ByteArray := X86NopPatterns at: (remainingSize min: X86NopPatterns size) - 1sz.
                let paddingPatternSize := paddingPattern size.
                data replaceFrom: writeOffset until: writeOffset + paddingPatternSize with: paddingPattern.
                remainingSize := remainingSize - paddingPatternSize.
                writeOffset := writeOffset + paddingPatternSize
            }.
        }.
    }.
}.

public final class AsmX86CompilationTarget superclass: AsmAbstractX86CompilationTarget; definition: {
    public override method pointerSize => Size
        := 4sz.

    public override method indirectBranchTargetAlignment => Size
        := 16sz.

    public override method uintPointerType => Type
        := UInt32.

    public override method elfMachine => UInt16
        := Elf::Machine::I386.

    public override method usesElfRelStyleRelocations => Boolean
        := true.

    public override method convertRelocationIntoElf32Rel: (relocation: AsmObjectCodeRelocation) withSymbolTable: (symbolTable: Elf32::SymbolTable) ::=> Elf32::Rel
        := relocation convertIntoX86RelWithSymbolTable: symbolTable.
}.

public final class AsmX86_64CompilationTarget superclass: AsmAbstractX86CompilationTarget; definition: {
    public override method pointerSize => Size
        := 8sz.

    public override method uintPointerType => Type
        := UInt64.

    public override method indirectBranchTargetAlignment => Size
        := 16sz.

    public override method elfMachine => UInt16
        := Elf::Machine::X86_64.

    public override method usesElfRelStyleRelocations => Boolean
        := false.

    public override method convertRelocationIntoElf64Rela: (relocation: AsmObjectCodeRelocation) withSymbolTable: (symbolTable: Elf64::SymbolTable) ::=> Elf64::Rela
        := relocation convertIntoX86_64RelaWithSymbolTable: symbolTable.
}.

AsmCompilationTarget extend: {
    __Meta__ extend: {
        public method x86 => AsmX86CompilationTarget
            := AsmX86CompilationTarget new.

        public method x86_64 => AsmX86_64CompilationTarget
            := AsmX86_64CompilationTarget new.

        public method default => AsmCompilationTarget
            := self x86_64.
    }.
}.

AsmInstructionOperand extend: {
    public virtual method x86::isByteRegister => Boolean := false.
    public virtual method x86::isWordRegister => Boolean := false.
    public virtual method x86::isRegisterAddress => Boolean := false.

    public virtual method x86::valueLow => UInt8
        := self error: "Not a x86 register.".

    public virtual method x86::rexRegBit => UInt8 := 0u8.
    public virtual method x86::rexBaseBit => UInt8 := 0u8.
    public virtual method x86::rexIndexBit => UInt8 := 0u8.

    public virtual method x86::encodeModRMWithRegOpcode: (opcode: UInt8) immediateSize: (immediateSize: Size)
        longMode: (longMode: Boolean) into: (codeStream: AsmObjectCodeStream) ::=> Void
        := self subclassResponsibility.

    public method x86::encodeModRMWithReg: (reg: AsmInstructionOperand) immediateSize: (immediateSize: Size)
        longMode: (longMode: Boolean) into: (codeStream: AsmObjectCodeStream) ::=> Void := {
        self x86::encodeModRMWithRegOpcode: reg x86::valueLow immediateSize: immediateSize longMode: longMode into: codeStream
    }.
}.

public class AsmX86Register superclass: AsmRegister; definition: {
    public field name => Symbol.
    public field value => UInt8.

    __Meta__ definition: {
        public method name: (name: Symbol) value: (value: UInt8) ::=> self
            := self new name: name; value: value; yourself.
    }.

    public override method x86::valueLow => UInt8
        := value & 7u8.

    public method isHighRegister => Boolean
        := value >= 8u8.

    public method isLowRegister => Boolean
        := value < 8u8.

    public override method x86::rexRegBit => UInt8
        := if: self isHighRegister then: 1u8 else: 0u8.

    public override method x86::rexBaseBit => UInt8
        := if: self isHighRegister then: 1u8 else: 0u8.

    public method printOn: (stream: Stream) ::=> Void := {
        stream string: name
    }.

    public override method x86::encodeModRMWithRegOpcode: (opcode: UInt8) immediateSize: (immediateSize: Size)
        longMode: (longMode: Boolean) into: (codeStream: AsmObjectCodeStream) ::=> Void := {
        codeStream nextPut: ((3u8 << 6u8) | (opcode << 3u8)) | self x86::valueLow
    }.

    public method * (scale: UInt8) ::=> AsmX86RegisterAddress
        := AsmX86RegisterAddress new
            index: self;
            scale: scale;
            yourself.
}.

AsmX86RegisterAddress definition: {
    public field scaleShift => UInt8.
    public field size => UInt8.

    public field base => AsmX86Register.
    public field index => AsmX86Register.
    public field displacement => AsmImmediate.

    __Meta__ definition: {
        public method size: (size: UInt8) displacement: (displacement: AsmImmediate) ::=> self
            := self new
                size: size;
                displacement: displacement;
                yourself.

        public method base: (base: AsmX86Register) size: (size: UInt8) displacement: (displacement: AsmImmediate) ::=> self
            := self new
                base: base;
                size: size;
                displacement: displacement;
                yourself.
    }.

    public override method x86::isRegisterAddress => Boolean
        := true.

    public override method x86::rexBaseBit => UInt8
        := base ifNil: 0u8 ifNotNil: base x86::rexRegBit.

    public override method x86::rexIndexBit => UInt8
        := index ifNil: 0u8 ifNotNil: index x86::rexRegBit.

    __Meta__ definition: {
        public method base: (base: AsmX86Register) size: (size: UInt8) ::=> self
            := self new base: base; size: size; yourself.
    }.

    let sizeNameTable := #{
        1u8 : "byte ptr".
        2u8 : "word ptr".
        4u8 : "dword ptr".
        8u8 : "qword ptr".
        16u8 : "oword ptr".
    }.

    public method scale => UInt8
        := 1u8 << scaleShift.

    public method scale: (scale: UInt8) ::=> Void := {
        scale = 1u8 ifTrue: (scaleShift := 0u8).
        scale = 2u8 ifTrue: (scaleShift := 1u8).
        scale = 4u8 ifTrue: (scaleShift := 2u8).
    }.

    public method needsSibByte => Boolean
        := (base isNotNil && (base x86::valueLow = #* ESP *# 4u8)) || index isNotNil.

    public method hasSmallDisplacement => Boolean
        := displacement isNil || displacement isImmediateSigned8.

    public override method x86::encodeModRMWithRegOpcode: (opcode: UInt8) immediateSize: (immediateSize: Size)
        longMode: (longMode: Boolean) into: (codeStream: AsmObjectCodeStream) ::=> Void := {

        let needsSib := self needsSibByte.
        let sibByte mutable := 0u8.

        needsSib ifTrue: {
            let baseValue := base ifNil: (5u8) ifNotNil: (base x86::valueLow).
            let indexValue := index ifNil: (4u8) ifNotNil: (index x86::valueLow).
            sibByte := (scaleShift << 6u8) | (indexValue << 3u8) | baseValue.
        }.

        let hasDisplacement mutable => Boolean := false.
        let hasSmallDisplacement mutable => Boolean := false.
        let modBaseValue mutable := 0u8.
        let mod mutable := 0u8.

        needsSib && (base x86::valueLow = #* EBP *# 5u8) ifTrue: {
            hasDisplacement := true.
            hasSmallDisplacement := self hasSmallDisplacement.
            mod := hasSmallDisplacement ifTrue: 1u8 ifFalse: 2u8
        } ifFalse: {
            displacement isNil && (base x86::valueLow ~= 5u8) ifTrue: {
                mod := 0u8
            } ifFalse: {
                hasDisplacement := true.
                hasSmallDisplacement := self hasSmallDisplacement.
                mod := hasSmallDisplacement ifTrue: 1u8 ifFalse: 2u8.
                base isNil && hasSmallDisplacement not && needsSib not ifTrue: (mod := 0u8)
            }
        }.

        needsSib ifTrue: {
            modBaseValue := 4u8
        } ifFalse: {
            base ifNotNil: {
                modBaseValue := base x86::valueLow
            } ifNil: {
                hasSmallDisplacement := false.
                self assert: displacement isNotNil.
                modBaseValue := 5u8
            }
        }.

        codeStream nextPut: (mod << 6u8) | (opcode << 3u8) | modBaseValue.
        needsSib ifTrue: (codeStream nextPut: sibByte).

        hasDisplacement ifTrue: {
            hasSmallDisplacement ifTrue: {
                displacement ifNil: {
                    codeStream nextPut: 0u8
                } ifNotNil: {
                    codeStream nextPutImmediate8: displacement
                }.
            } ifFalse: {
                (mod = 0u8) && longMode ifTrue: {
                    codeStream nextPutIPRelativeI32: displacement extraOffset: immediateSize asInt32 + 4i32
                } ifFalse: {
                    codeStream nextPutImmediate32: displacement
                }
            }
        }.
    }.

    public method + (nextComponent: AsmInstructionOperand) ::=> SelfType := {
        nextComponent x86::isRegisterAddress ifTrue: {
            let nextRegisterAddress := nextComponent downCastTo: AsmX86RegisterAddress.
            self copy
                index: nextRegisterAddress index;
                scaleShift: nextRegisterAddress scaleShift;
                displacement: nextRegisterAddress displacement;
                yourself
        } ifFalse: {
            self copy
                displacement: (nextComponent downCastTo: AsmImmediate);
                yourself
        }
    }.

    public method printOn: (stream: Stream) ::=> Void := {
        stream nextPutAll: (sizeNameTable at: size); nextPutAll: " [".
        let hasPrevious mutable => Boolean := false.
        base ifNotNil: {
            stream print: base.
            hasPrevious := true.
        }.
        index ifNotNil: {
            hasPrevious ifTrue: (stream nextPutAll: " + ").
            stream print: index; nextPut: '*'; print: self scale.
            hasPrevious := true.
        }.
        displacement ifNotNil: {
            hasPrevious ifTrue: (stream nextPutAll: " + ").
            stream print: displacement.
        }.

        stream nextPutAll: "]".
    }.
}.

AsmSymbol extend: {
    public method x86::bytePtr => AsmRegisterAddress
        := AsmX86RegisterAddress size: 1u8 displacement: self dword.

    public method x86::wordPtr => AsmRegisterAddress
        := AsmX86RegisterAddress size: 2u8 displacement: self dword.

    public method x86::dwordPtr => AsmRegisterAddress
        := AsmX86RegisterAddress size: 4u8 displacement: self dword.

    public method x86::qwordPtr => AsmRegisterAddress
        := AsmX86RegisterAddress size: 8u8 displacement: self dword.
}.

public class AsmX86IntRegister superclass: AsmX86Register; definition: {
    public override method x86::isWordRegister => Boolean := true.

    public method x86::byte => AsmX86RegisterAddress
        := AsmX86RegisterAddress base: self size: 1u8.

    public method x86::word => AsmX86RegisterAddress
        := AsmX86RegisterAddress base: self size: 2u8.

    public method x86::dword => AsmX86RegisterAddress
        := AsmX86RegisterAddress base: self size: 4u8.

    public method x86::qword => AsmX86RegisterAddress
        := AsmX86RegisterAddress base: self size: 8u8.
}.

public class AsmX86Int8Register superclass: AsmX86IntRegister; definition: {
    public override method x86::isByteRegister => Boolean := true.
    public override method x86::isWordRegister => Boolean := false.

    public override method size => Size := 1sz.
}.

public class AsmX86Int16Register superclass: AsmX86IntRegister; definition: {
    public override method size => Size := 2sz.
}.

public class AsmX86Int32Register superclass: AsmX86IntRegister; definition: {
    public override method size => Size := 4sz.
}.

public class AsmX86Int64Register superclass: AsmX86IntRegister; definition: {
    public override method size => Size := 8sz.
}.

public class AsmX86VectorRegister superclass: AsmX86IntRegister; definition: {
    public override method size => Size := 16sz.
}.

public global X86::AL := AsmX86Int8Register name: #AL value: 0u8.
public global X86::CL := AsmX86Int8Register name: #CL value: 1u8.
public global X86::DL := AsmX86Int8Register name: #DL value: 2u8.
public global X86::BL := AsmX86Int8Register name: #BL value: 3u8.
public global X86::AH := AsmX86Int8Register name: #AH value: 4u8.
public global X86::CH := AsmX86Int8Register name: #CH value: 5u8.
public global X86::DH := AsmX86Int8Register name: #DH value: 6u8.
public global X86::BH := AsmX86Int8Register name: #BH value: 7u8.

public global X86::RAXB := AsmX86Int8Register name: #RAXB value: 0u8.
public global X86::RCXB := AsmX86Int8Register name: #RCXB value: 1u8.
public global X86::RDXB := AsmX86Int8Register name: #RDXB value: 2u8.
public global X86::RBXB := AsmX86Int8Register name: #RBXB value: 3u8.
public global X86::RSPB := AsmX86Int8Register name: #RSPB value: 4u8.
public global X86::RBPB := AsmX86Int8Register name: #RBPB value: 5u8.
public global X86::RSIB := AsmX86Int8Register name: #RSIB value: 6u8.
public global X86::RDIB := AsmX86Int8Register name: #RDIB value: 7u8.
public global X86::R8B := AsmX86Int8Register name: #R8B value: 8u8.
public global X86::R9B := AsmX86Int8Register name: #R9B value: 9u8.
public global X86::R10B := AsmX86Int8Register name: #R10B value: 10u8.
public global X86::R11B := AsmX86Int8Register name: #R11B value: 11u8.
public global X86::R12B := AsmX86Int8Register name: #R12B value: 12u8.
public global X86::R13B := AsmX86Int8Register name: #R13B value: 13u8.
public global X86::R14B := AsmX86Int8Register name: #R14B value: 14u8.
public global X86::R15B := AsmX86Int8Register name: #R15B value: 15u8.

public global X86::AX := AsmX86Int16Register name: #AX value: 0u8.
public global X86::CX := AsmX86Int16Register name: #CX value: 1u8.
public global X86::DX := AsmX86Int16Register name: #DX value: 2u8.
public global X86::BX := AsmX86Int16Register name: #BX value: 3u8.
public global X86::SP := AsmX86Int16Register name: #SP value: 4u8.
public global X86::BP := AsmX86Int16Register name: #BP value: 5u8.
public global X86::SI := AsmX86Int16Register name: #SI value: 6u8.
public global X86::DI := AsmX86Int16Register name: #DI value: 7u8.
public global X86::R8W := AsmX86Int16Register name: #R8W value: 8u8.
public global X86::R9W := AsmX86Int16Register name: #R9W value: 9u8.
public global X86::R10W := AsmX86Int16Register name: #R10W value: 10u8.
public global X86::R11W := AsmX86Int16Register name: #R11W value: 11u8.
public global X86::R12W := AsmX86Int16Register name: #R12W value: 12u8.
public global X86::R13W := AsmX86Int16Register name: #R13W value: 13u8.
public global X86::R14W := AsmX86Int16Register name: #R14W value: 14u8.
public global X86::R15W := AsmX86Int16Register name: #R15W value: 15u8.

public global X86::EAX := AsmX86Int32Register name: #EAX value: 0u8.
public global X86::ECX := AsmX86Int32Register name: #ECX value: 1u8.
public global X86::EDX := AsmX86Int32Register name: #EDX value: 2u8.
public global X86::EBX := AsmX86Int32Register name: #EBX value: 3u8.
public global X86::ESP := AsmX86Int32Register name: #ESP value: 4u8.
public global X86::EBP := AsmX86Int32Register name: #EBP value: 5u8.
public global X86::ESI := AsmX86Int32Register name: #ESI value: 6u8.
public global X86::EDI := AsmX86Int32Register name: #EDI value: 7u8.
public global X86::R8D := AsmX86Int32Register name: #R8D value: 8u8.
public global X86::R9D := AsmX86Int32Register name: #R9D value: 9u8.
public global X86::R10D := AsmX86Int32Register name: #R10D value: 10u8.
public global X86::R11D := AsmX86Int32Register name: #R11D value: 11u8.
public global X86::R12D := AsmX86Int32Register name: #R12D value: 12u8.
public global X86::R13D := AsmX86Int32Register name: #R13D value: 13u8.
public global X86::R14D := AsmX86Int32Register name: #R14D value: 14u8.
public global X86::R15D := AsmX86Int32Register name: #R15D value: 15u8.

public global X86::RAX := AsmX86Int64Register name: #RAX value: 0u8.
public global X86::RCX := AsmX86Int64Register name: #RCX value: 1u8.
public global X86::RDX := AsmX86Int64Register name: #RDX value: 2u8.
public global X86::RBX := AsmX86Int64Register name: #RBX value: 3u8.
public global X86::RSP := AsmX86Int64Register name: #RSP value: 4u8.
public global X86::RBP := AsmX86Int64Register name: #RBP value: 5u8.
public global X86::RSI := AsmX86Int64Register name: #RSI value: 6u8.
public global X86::RDI := AsmX86Int64Register name: #RDI value: 7u8.
public global X86::R8 := AsmX86Int64Register name: #R8 value: 8u8.
public global X86::R9 := AsmX86Int64Register name: #R9 value: 9u8.
public global X86::R10 := AsmX86Int64Register name: #R10 value: 10u8.
public global X86::R11 := AsmX86Int64Register name: #R11 value: 11u8.
public global X86::R12 := AsmX86Int64Register name: #R12 value: 12u8.
public global X86::R13 := AsmX86Int64Register name: #R13 value: 13u8.
public global X86::R14 := AsmX86Int64Register name: #R14 value: 14u8.
public global X86::R15 := AsmX86Int64Register name: #R15 value: 15u8.

public global X86::XMM0 := AsmX86VectorRegister name: #XMM0 value: 0u8.
public global X86::XMM1 := AsmX86VectorRegister name: #XMM1 value: 1u8.
public global X86::XMM2 := AsmX86VectorRegister name: #XMM2 value: 2u8.
public global X86::XMM3 := AsmX86VectorRegister name: #XMM3 value: 3u8.
public global X86::XMM4 := AsmX86VectorRegister name: #XMM4 value: 4u8.
public global X86::XMM5 := AsmX86VectorRegister name: #XMM5 value: 5u8.
public global X86::XMM6 := AsmX86VectorRegister name: #XMM6 value: 6u8.
public global X86::XMM7 := AsmX86VectorRegister name: #XMM7 value: 7u8.
public global X86::XMM8 := AsmX86VectorRegister name: #XMM8 value: 8u8.
public global X86::XMM9 := AsmX86VectorRegister name: #XMM9 value: 9u8.
public global X86::XMM10 := AsmX86VectorRegister name: #XMM10 value: 10u8.
public global X86::XMM11 := AsmX86VectorRegister name: #XMM11 value: 11u8.
public global X86::XMM12 := AsmX86VectorRegister name: #XMM12 value: 12u8.
public global X86::XMM13 := AsmX86VectorRegister name: #XMM13 value: 13u8.
public global X86::XMM14 := AsmX86VectorRegister name: #XMM14 value: 14u8.
public global X86::XMM15 := AsmX86VectorRegister name: #XMM15 value: 15u8.

public final class AsmX86InstructionDefinition superclass: Object; definition: {
    public field mnemonic => Symbol.
    public field operandNames => Array.
    public field description => String.
    public field alternatives => Array.
}.

public final class AsmX86InstructionTemplate superclass: Object; definition: {
    public field when => ((AsmX86InstructionTemplate, AsmX86Instruction) => Boolean).
    public field whenIfShortDistance => ((AsmX86InstructionTemplate, AsmX86Instruction) => Boolean).
    public field writeWith => ((AsmX86InstructionTemplate, AsmX86Instruction, AsmObjectCodeStream) => Void).

    public field mandatoryPrefix => ByteArray.
    public field opcode => ByteArray.
    public field registerOpcode => UInt8.

    public method initialize => Void := {
        mandatoryPrefix := #[].
        opcode := #[].
        registerOpcode := 0u8.
    }.

    public method parseDescription: (description: Array) ::=> Void := {
        mandatoryPrefix := description second.
        opcode := description third.
        description size >= 4sz ifTrue: (registerOpcode := description fourth u8).
    }.

    public method canWriteInstruction: (instruction: AsmX86Instruction) ::=> Boolean
        := when(self, instruction).

    public method canWriteInstructionIfShort: (instruction: AsmX86Instruction) ::=> Boolean
        := (whenIfShortDistance ~~ nil) && whenIfShortDistance(self, instruction).

    public method writeInstruction: (instruction: AsmX86Instruction) onObjectCodeStream: (stream: AsmObjectCodeStream) ::=> Void
        := writeWith(self, instruction, stream).
}.

AsmObjectCodeStream definition: {
    public method nextPutX86RexSize: (operandSize: Size) rm: (rm: AsmInstructionOperand) reg: (reg: AsmInstructionOperand) ::=> Void := {
        let wBit := if: operandSize = 8sz then: 1u8 else: 0u8.
        let regBit := reg x86::rexRegBit.
        let baseBit := rm x86::rexBaseBit.
        let indexBit := rm x86::rexIndexBit.

        let lowBits := ((wBit << 3u8) | (regBit << 2u8)) | ((indexBit << 1u8) | (baseBit)).
        lowBits ~= 0 ifTrue: { 
            self assert: self isInX86LongMode.
            self nextPut: 16r40 u8 | lowBits
        }
    }.

    public method nextPutX86RexSize: (operandSize: Size) rm: (rm: AsmInstructionOperand) ::=> Void := {
        let wBit := if: operandSize = 8sz then: 1u8 else: 0u8.
        let baseBit := rm x86::rexBaseBit.
        let indexBit := rm x86::rexIndexBit.

        let lowBits := (wBit << 3u8) | ((indexBit << 1u8) | (baseBit)).
        lowBits ~= 0 ifTrue: { 
            self assert: self isInX86LongMode.
            self nextPut: 16r40 u8 | lowBits
        }
    }.

    public method nextPutX86RexRM: (rm: AsmInstructionOperand) ::=> Void := {
        let baseBit := rm x86::rexBaseBit.
        let indexBit := rm x86::rexIndexBit.
        let lowBits := (indexBit << 1u8) | baseBit.

        lowBits ~= 0 ifTrue: {
            self assert: self isInX86LongMode.
            self nextPut: 16r40 u8 | lowBits
        }
    }.

    public method nextPutX86Opcode: (opcode: UInt8) plusRegister: (register: AsmInstructionOperand) ::=> Void := {
        self nextPut: opcode + register x86::valueLow
    }.

    public method nextPutX86ModRM: (rm: AsmInstructionOperand) reg: (register: AsmInstructionOperand) immediateSize: (immediateSize: Size) ::=> Void := {
        rm x86::encodeModRMWithReg: register immediateSize: immediateSize longMode: self isInX86LongMode into: self
    }.

    public method nextPutX86ModRM: (rm: AsmInstructionOperand) reg: (register: AsmInstructionOperand) ::=> Void
        := self nextPutX86ModRM: rm reg: register immediateSize: 0sz.

    public method nextPutX86ModRM: (rm: AsmInstructionOperand) regOpcode: (opcode: UInt8) immediateSize: (immediateSize: Size) ::=> Void := {
        rm x86::encodeModRMWithRegOpcode: opcode immediateSize: immediateSize longMode: self isInX86LongMode into: self
    }.

    public method nextPutX86ModRM: (rm: AsmInstructionOperand) regOpcode: (opcode: UInt8) ::=> Void
        := self nextPutX86ModRM: rm regOpcode: opcode immediateSize: 0sz.

    public method nextPutX86ImmediateWord: (immediate: AsmInstructionOperand) ::=> Void := {
        self assert: immediate size <= 4sz.
        self nextPutImmediate: immediate
    }.

}.

AsmX86Instruction definition: {
    public field definition => AsmX86InstructionDefinition.
    public field activeAlternative => AsmX86InstructionTemplate.
    public field longAlternative => AsmX86InstructionTemplate.
    public field shortAlternative => AsmX86InstructionTemplate.

    public abstract method operandCount => Size
        := self subclassResponsibility.

    public abstract method firstOperand => AsmInstructionOperand
        := self error: "Operand not present.".

    public abstract method secondOperand => AsmInstructionOperand
        := self error: "Operand not present.".

    public override method selectEncodingAlternatives => Void := {
        definition alternatives do: {:(AsmX86InstructionTemplate)eachAlternative :: Void |
            shortAlternative isNil && (eachAlternative canWriteInstructionIfShort: self) ifTrue: {
                shortAlternative := eachAlternative.
            }.
            longAlternative isNil && (eachAlternative canWriteInstruction: self) ifTrue: {
                longAlternative := eachAlternative.
            }.
        }.

        activeAlternative := longAlternative.
        activeAlternative ifNil: {
            self error: "Failed to select encoding alternative for: " -- self fullPrintString
        }

        ## TODO: Add support for the different spanning options.
    }.

    public override method writeOnObjectCodeStream: (stream: AsmObjectCodeStream) ::=> Void := {
        self assert: activeAlternative isNotNil.
        activeAlternative writeInstruction: self onObjectCodeStream: stream
    }.
}.

public final class AsmX86InstructionWithoutOperands superclass: AsmX86Instruction; definition: {
    public method fullPrintOn: (stream: Stream) ::=> Void := {
        stream nextPutAll: definition mnemonic.
    }.

    public override method operandCount => Size := 0sz.
}.

public final class AsmX86InstructionWithSingleOperand superclass: AsmX86Instruction; definition: {
    public field firstOperand => AsmInstructionOperand.

    public override method operandCount => Size := 1sz.

    public method fullPrintOn: (stream: Stream) ::=> Void := {
        stream nextPutAll: definition mnemonic; space; print: firstOperand.
    }.
}.

public final class AsmX86InstructionWithTwoOperands superclass: AsmX86Instruction; definition: {
    public field firstOperand => AsmInstructionOperand.
    public field secondOperand => AsmInstructionOperand.

    public override method operandCount => Size := 2sz.

    public method fullPrintOn: (stream: Stream) ::=> Void := {
        stream nextPutAll: definition mnemonic; space; print: firstOperand; nextPutAll: ", "; print: secondOperand.
    }.
}.

AsmX86InstructionDefinition definition: {
    public method generateStreamBuilderMethod => Void := {
        let selectorBuilder := StringStream new.
        let directSelectorBuilder := StringStream new.
        selectorBuilder nextPutAll: "x86::"; nextPutAll: mnemonic.
        directSelectorBuilder nextPutAll: "x86::direct::"; nextPutAll: mnemonic.
        operandNames doWithIndex: {:(Symbol)operandName :(Size)index :: Void |
            if: index ~= 0sz then: {
                selectorBuilder nextPutAll: operandName.
                directSelectorBuilder nextPutAll: operandName.
            }.

            selectorBuilder nextPut: ':'.
            directSelectorBuilder nextPut: ':'.
        }.

        let selector := selectorBuilder asSymbol.
        let directSelector := directSelectorBuilder asSymbol.
        let operandCount := operandNames size.

        ## Zero operand case.
        if: operandCount = 0sz then: {
            let method := {:(AsmStreamBuilder)builder :: AsmX86InstructionWithoutOperands |
                builder addElement: (AsmX86InstructionWithoutOperands new
                    definition: self;
                    yourself)
            }.

            AsmStreamBuilder
                withSelector: directSelector addMethod: method;
                withSelector: selector addMethod: method
        }.

        ## Single operand case.
        if: operandCount = 1sz then: {
            let method := {:(AsmStreamBuilder)builder :(AsmInstructionOperand)operand :: AsmX86InstructionWithSingleOperand |
                builder addElement: (AsmX86InstructionWithSingleOperand new
                    definition: self;
                    firstOperand: operand;
                    yourself)
            }.

            AsmStreamBuilder
                withSelector: directSelector addMethod: method;
                withSelector: selector addMethod: method.
        }.

        ## Two operand case.
        if: operandCount = 2sz then: {
            let method := {:(AsmStreamBuilder)builder :(AsmInstructionOperand)firstOperand :(AsmInstructionOperand)secondOperand :: AsmX86InstructionWithTwoOperands |
                builder addElement: (AsmX86InstructionWithTwoOperands new
                    definition: self;
                    firstOperand: firstOperand;
                    secondOperand: secondOperand;
                    yourself)
            }..

            AsmStreamBuilder
                withSelector: directSelector addMethod: method;
                withSelector: selector addMethod: method.
        }.
    }.
}.

let instructionTemplateTable := #{
    Op: (AsmX86InstructionTemplate new
        when: {:(AsmX86InstructionTemplate)templ :(AsmX86Instruction)instruction :: Boolean | 
            instruction operandCount = 0sz
        };
        writeWith: {:(AsmX86InstructionTemplate)templ :(AsmX86Instruction)instruction :(AsmObjectCodeStream)stream :: Void |
            stream nextPutAll: templ mandatoryPrefix; nextPutAll: templ opcode.
        };
        yourself).
    OpBranch32: (AsmX86InstructionTemplate new
        when: {:(AsmX86InstructionTemplate)templ :(AsmX86Instruction)instruction :: Boolean | 
            (instruction operandCount = 1sz) && instruction firstOperand isImmediate
        };
        writeWith: {:(AsmX86InstructionTemplate)templ :(AsmX86Instruction)instruction :(AsmObjectCodeStream)stream :: Void |
            stream nextPutAll: templ mandatoryPrefix; nextPutAll: templ opcode.
            stream nextPutIPRelativeI32: instruction firstOperand
        };
        yourself).
    OpS8: (AsmX86InstructionTemplate new
        when: {:(AsmX86InstructionTemplate)templ :(AsmX86Instruction)instruction :: Boolean | 
            (instruction operandCount = 1sz) && instruction firstOperand isImmediateSigned8
        };
        writeWith: {:(AsmX86InstructionTemplate)templ :(AsmX86Instruction)instruction :(AsmObjectCodeStream)stream :: Void |
            stream nextPutAll: templ mandatoryPrefix; nextPutAll: templ opcode; nextPutImmediate: instruction firstOperand
        };
        yourself).
    OpIw: (AsmX86InstructionTemplate new
        when: {:(AsmX86InstructionTemplate)templ :(AsmX86Instruction)instruction :: Boolean | 
            (instruction operandCount = 1sz) && instruction firstOperand isImmediate
        };
        writeWith: {:(AsmX86InstructionTemplate)templ :(AsmX86Instruction)instruction :(AsmObjectCodeStream)stream :: Void |
            stream nextPutAll: templ mandatoryPrefix; nextPutAll: templ opcode; nextPutX86ImmediateWord: instruction firstOperand
        };
        yourself).
    OppR: (AsmX86InstructionTemplate new
        when: {:(AsmX86InstructionTemplate)templ :(AsmX86Instruction)instruction :: Boolean | 
            (instruction operandCount = 1sz) && instruction firstOperand x86::isWordRegister
        };
        writeWith: {:(AsmX86InstructionTemplate)templ :(AsmX86Instruction)instruction :(AsmObjectCodeStream)stream :: Void |
            let register := instruction firstOperand.
            stream 
                nextPutAll: templ mandatoryPrefix;
                nextPutX86RexRM: register;
                nextPutX86Opcode: templ opcode first plusRegister: register.
        };
        yourself).
    OppRwIww: (AsmX86InstructionTemplate new
        when: {:(AsmX86InstructionTemplate)templ :(AsmX86Instruction)instruction :: Boolean | 
            (instruction operandCount = 2sz) &&
            instruction firstOperand x86::isWordRegister &&
            instruction secondOperand isImmediate &&
            (instruction firstOperand size = instruction secondOperand size)
        };
        writeWith: {:(AsmX86InstructionTemplate)templ :(AsmX86Instruction)instruction :(AsmObjectCodeStream)stream :: Void |
            let register := instruction firstOperand.
            let immediate := instruction secondOperand.
            stream 
                nextPutAll: templ mandatoryPrefix;
                nextPutX86RexSize: register size rm: register;
                nextPutX86Opcode: templ opcode first plusRegister: register;
                nextPutImmediate: immediate
        };
        yourself).

    OpRmwS8: (AsmX86InstructionTemplate new
        when: {:(AsmX86InstructionTemplate)templ :(AsmX86Instruction)instruction :: Boolean |
            (instruction operandCount = 2sz) &&
                instruction firstOperand isRegisterOrRegisterAddress && 
                instruction secondOperand isImmediateSigned8
        };
        writeWith: {:(AsmX86InstructionTemplate)templ :(AsmX86Instruction)instruction :(AsmObjectCodeStream)stream :: Void |
            let registerAddress := instruction firstOperand.
            let immediate := instruction secondOperand.
            let operandSize := registerAddress size.
            stream 
                nextPutAll: templ mandatoryPrefix;
                nextPutX86RexSize: operandSize rm: registerAddress;
                nextPutAll: templ opcode;
                nextPutX86ModRM: registerAddress regOpcode: templ registerOpcode immediateSize: immediate size;
                nextPutImmediate: immediate
        };
        yourself).
    OpRmwIw: (AsmX86InstructionTemplate new
        when: {:(AsmX86InstructionTemplate)templ :(AsmX86Instruction)instruction :: Boolean |
            (instruction operandCount = 2sz) &&
                instruction firstOperand isRegisterOrRegisterAddress && 
                instruction secondOperand isImmediate32
        };
        writeWith: {:(AsmX86InstructionTemplate)templ :(AsmX86Instruction)instruction :(AsmObjectCodeStream)stream :: Void |
            let registerAddress := instruction firstOperand.
            let immediate := instruction secondOperand.
            let operandSize := registerAddress size.
            stream 
                nextPutAll: templ mandatoryPrefix;
                nextPutX86RexSize: operandSize rm: registerAddress;
                nextPutAll: templ opcode;
                nextPutX86ModRM: registerAddress regOpcode: templ registerOpcode immediateSize: immediate size;
                nextPutX86ImmediateWord: immediate
        };
        yourself).
    OpRmqIsd: (AsmX86InstructionTemplate new
        when: {:(AsmX86InstructionTemplate)templ :(AsmX86Instruction)instruction :: Boolean |
            (instruction operandCount = 2sz) &&
                instruction firstOperand isRegisterOrRegisterAddress && 
                (instruction firstOperand size = 8sz) &&
                instruction secondOperand isImmediateSigned32
        };
        writeWith: {:(AsmX86InstructionTemplate)templ :(AsmX86Instruction)instruction :(AsmObjectCodeStream)stream :: Void |
            let registerAddress := instruction firstOperand.
            let immediate := instruction secondOperand.
            let operandSize := registerAddress size.
            stream 
                nextPutAll: templ mandatoryPrefix;
                nextPutX86RexSize: operandSize rm: registerAddress;
                nextPutAll: templ opcode;
                nextPutX86ModRM: registerAddress regOpcode: templ registerOpcode immediateSize: immediate size;
                nextPutImmediate: immediate
        };
        yourself).

    OpRmwRw: (AsmX86InstructionTemplate new
        when: {:(AsmX86InstructionTemplate)templ :(AsmX86Instruction)instruction :: Boolean | 
            (instruction operandCount = 2sz) &&
                instruction firstOperand isRegisterOrRegisterAddress && 
                instruction secondOperand isRegister
        };
        writeWith: {:(AsmX86InstructionTemplate)templ :(AsmX86Instruction)instruction :(AsmObjectCodeStream)stream :: Void |
            let registerAddress := instruction firstOperand.
            let register := instruction secondOperand.
            let operandSize := register size.
            stream 
                nextPutAll: templ mandatoryPrefix;
                nextPutX86RexSize: operandSize rm: registerAddress reg: register;
                nextPutAll: templ opcode;
                nextPutX86ModRM: registerAddress reg: register
        };
        yourself).

    OpRwRmw: (AsmX86InstructionTemplate new
        when: {:(AsmX86InstructionTemplate)templ :(AsmX86Instruction)instruction :: Boolean | 
            (instruction operandCount = 2sz) &&
                instruction firstOperand isRegister && 
                instruction secondOperand isRegisterOrRegisterAddress
        };
        writeWith: {:(AsmX86InstructionTemplate)templ :(AsmX86Instruction)instruction :(AsmObjectCodeStream)stream :: Void |
            let register := instruction firstOperand.
            let registerAddress := instruction secondOperand.
            let operandSize := register size.
            stream 
                nextPutAll: templ mandatoryPrefix;
                nextPutX86RexSize: operandSize rm: registerAddress reg: register;
                nextPutAll: templ opcode;
                nextPutX86ModRM: registerAddress reg: register
        };
        yourself).

    OpRm: (AsmX86InstructionTemplate new
        when: {:(AsmX86InstructionTemplate)templ :(AsmX86Instruction)instruction :: Boolean | 
            (instruction operandCount = 1sz) &&
                instruction firstOperand isRegisterOrRegisterAddress
        };
        writeWith: {:(AsmX86InstructionTemplate)templ :(AsmX86Instruction)instruction :(AsmObjectCodeStream)stream :: Void |
            let registerAddress := instruction firstOperand.
            let operandSize := registerAddress size.
            stream 
                nextPutAll: templ mandatoryPrefix;
                nextPutX86RexRM: registerAddress;
                nextPutAll: templ opcode;
                nextPutX86ModRM: registerAddress regOpcode: templ registerOpcode
        };
        yourself).
}.

AsmObjectCodeRelocation extend: {
    public virtual method convertIntoX86RelWithSymbolTable: (symbolTable: Elf32::SymbolTable) ::=> Elf32::Rel
        := self subclassResponsibility.

    public virtual method convertIntoX86_64RelaWithSymbolTable: (symbolTable: Elf64::SymbolTable) ::=> Elf64::Rela
        := self subclassResponsibility.
}.

AsmObjectCodeRelocationRelativeInt32 extend: {
    public override method convertIntoX86RelWithSymbolTable: (symbolTable: Elf32::SymbolTable) ::=> Elf32::Rel
        := Elf32::Rel new
            offset: offset asUInt32;
            symbol: (symbolTable indexOfSymbol: symbol) type: Elf::I386::Rel::PC32;
            yourself.

    public override method convertIntoX86_64RelaWithSymbolTable: (symbolTable: Elf64::SymbolTable) ::=> Elf64::Rela
        := Elf64::Rela new
            offset: offset;
            symbol: (symbolTable indexOfSymbol: symbol) type: Elf::X86_64::Rel::PC32;
            addend: addend asInt64 + symbol privateAddend;
            yourself.
}.

AsmObjectCodeRelocationRelativeInt32AtPLT extend: {
    public override method convertIntoX86_64RelaWithSymbolTable: (symbolTable: Elf64::SymbolTable) ::=> Elf64::Rela
        := Elf64::Rela new
            offset: offset;
            symbol: (symbolTable indexOfSymbol: symbol) type: Elf::X86_64::Rel::PLT32;
            addend: addend asInt64 + symbol privateAddend;
            yourself.
}.

AsmObjectCodeRelocationRelativeInt32AtGOT extend: {
    public override method convertIntoX86_64RelaWithSymbolTable: (symbolTable: Elf64::SymbolTable) ::=> Elf64::Rela
        := Elf64::Rela new
            offset: offset;
            symbol: (symbolTable indexOfSymbol: symbol) type: Elf::X86_64::Rel::GOTPCREL;
            addend: addend asInt64 + symbol privateAddend;
            yourself.
}.

AsmObjectCodeRelocationAbsoluteInt64 extend: {
    public override method convertIntoX86_64RelaWithSymbolTable: (symbolTable: Elf64::SymbolTable) ::=> Elf64::Rela
        := Elf64::Rela new
            offset: offset;
            symbol: (symbolTable indexOfSymbol: symbol) type: Elf::X86_64::Rel::A64;
            addend: addend asInt64 + symbol privateAddend;
            yourself.
}.

let instructionDefinitionTable := #(
    (add (dst with) "Integer addition."
        (OpRmwS8 #[] #[16r83] 0)
        (OpRmwIw #[] #[16r81] 0)

		(OpRmwRw #[] #[16r01])
		(OpRwRmw #[] #[16r03])
    )

    (call (target) "Call the function in the specified address."
        (OpBranch32 #[] #[16rE8])
        (OpRm #[] #[16rFF] 2)
    )

    (cmp (dst src) "Compares by subtracting the specified values."
        (OpRmwS8 #[] #[16r83] 7)
        (OpRmwIw #[] #[16r81] 7)

		(OpRmwRw #[] #[16r39])
		(OpRwRmw #[] #[16r3B])
    )

    (endbr32 () "Ends indirect branch in 32 mode"
        (Op #[] #[16rF3 16r0F 16r1E 16rFB])
    )

    (endbr64 () "Ends indirect branch in 64 mode"
        (Op #[] #[16rF3 16r0F 16r1E 16rFA])
    )

    (imul (dst with) "Integer multiplication"
		(OpRwRmw #[] #[16r0F 16rAF])
    )

    (lea (dst src) "Load effective address."
        (OpRwRmw #[] #[16r8D])
    )

	(lock () "Lock prefix"
		(Op #[] #[16rF0])
	)

    (nop () "No operation"
        (Op #[] #[16r90])
    )

    (mov (dst src) "Move values"
		(OpRmqIsd #[] #[16rC7] 0)
		(OppRwIww #[] #[16rB8])
		(OpRmwIw #[] #[16rC7] 0)

        (OpRmwRw #[] #[16r89])
        (OpRwRmw #[] #[16r8B])
    )

    (movsx (dst src) "Move with sign extension"
		##(OpRwRmb #[] #[16r0F 16rBE])
		(OpRwRmw #[] #[16r0F 16rBF])
    )
    (movsxd (dst src) "Move with sign extension into double-word"
		(OpRwRmw #[] #[16r63])
    )
    (movzx (dst src) "Move with zero extension"
		##(OpRwRmb #[] #[16r0F 16rB6])
		(OpRwRmw #[] #[16r0F 16rB7])
    )

    (jmp (target) "Jumps into the specified address"
        (OpBranch32 #[] #[16rE9])
        (OpRm #[] #[16rFF] 4)
    )

    (int (number) "Software interruption"
        ##(OpI8 #[] #[16rCD])
    )

    (int3 () "Software interruption 3 (Breakpoint)"
        (Op #[] #[16rCC])
    )

    (pop (dst) "Pops a value from the stack"
        (OppR #[] #[16r58])
    )

    (push (src) "Pushes a value onto the stack"
        (OppR #[] #[16r50])
        (OpRm #[] #[16rFF] 6)
		(OpS8 #[] #[16r6A])
		(OpIw #[] #[16r68])
    )

	(rep () "Rep prefix"
		(Op #[] #[16rF3])
	)

    (ret () "Return from function"
        (Op #[] #[16rC3])
    )

    (sub (dst with) "Integer subtraction"
        (OpRmwS8 #[] #[16r83] 5)
        (OpRmwIw #[] #[16r81] 5)

		(OpRmwRw #[] #[16r29])
		(OpRwRmw #[] #[16r2B])
    )
).

public global AsmX86InstructionDefinition::Table := Dictionary new.

instructionDefinitionTable do: {:instructionDescription :: Void |
    let mnemonic := instructionDescription first.
    let operandNames := instructionDescription second.
    let description := instructionDescription third.
    let alternatives := instructionDescription allButFirst: 3.
    let parsedAlternatives := alternatives collect: {:(Array)alternativeDescription :: AsmX86InstructionTemplate |
        let alternativeName := alternativeDescription first.
        let instructionTemplate := instructionTemplateTable at: alternativeName.
        instructionTemplate copy
            parseDescription: alternativeDescription;
            yourself
    }.
    let definition := AsmX86InstructionDefinition new
        mnemonic: mnemonic;
        operandNames: operandNames;
        description: description;
        alternatives: parsedAlternatives;
        yourself.

    definition generateStreamBuilderMethod.
    AsmX86InstructionDefinition::Table at: definition mnemonic put: definition.
}.

AsmStreamBuilder extend: {
    public method x86::mov: (destination: AsmInstructionOperand) src: (source: AsmInstructionOperand) ::=> AsmX86InstructionWithTwoOperands := {
        destination ~= source
            ifTrue: (self x86::direct::mov: destination src: source)
            ifFalse: (nil)        
    }.
}.
