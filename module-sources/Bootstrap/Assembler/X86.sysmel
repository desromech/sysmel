public class AsmX86Instruction superclass: AsmStreamElement.

AsmInstructionOperand extend: {
    public virtual method isX86WordRegister => Boolean := false.

    public virtual method x86::valueLow => UInt8
        := self error: "Not a x86 register.".

    public virtual method x86::rexRegBit => UInt8 := 0u8.
    public virtual method x86::rexBaseBit => UInt8 := 0u8.
    public virtual method x86::rexIndexBit => UInt8 := 0u8.

    public virtual method x86::encodeModRMWithReg: (reg: AsmInstructionOperand) immediateSize: (immediateSize: Size)
        longMode: (longMode: Boolean) into: (codeStream: AsmObjectCodeStream) ::=> Void
        := self subclassResponsibility.
}.

public class AsmX86Register superclass: AsmRegister; definition: {
    public field name => Symbol.
    public field value => UInt8.

    __Meta__ definition: {
        public method name: (name: Symbol) value: (value: UInt8) ::=> self
            := self new name: name; value: value; yourself.
    }.

    public method initialize => Void := {
        value := 0u8
    }.

    public override method x86::valueLow => UInt8
        := value & 7u8.

    public method isHighRegister => Boolean
        := value >= 8u8.

    public method isLowRegister => Boolean
        := value < 8u8.

    public override method x86::rexRegBit => UInt8
        := if: self isHighRegister then: 1u8 else: 0u8.

    public override method x86::rexBaseBit => UInt8
        := if: self isHighRegister then: 1u8 else: 0u8.

    public method printOn: (stream: Stream) ::=> Void := {
        stream nextPutAll: name
    }.

    public override method x86::encodeModRMWithReg: (reg: AsmInstructionOperand) immediateSize: (immediateSize: Size)
        longMode: (longMode: Boolean) into: (codeStream: AsmObjectCodeStream) ::=> Void := {
        codeStream nextPut: ((3u8 << 6u8) | (reg x86::valueLow << 3u8)) | self x86::valueLow
    }.
}.

public class AsmX86IntRegister superclass: AsmX86Register; definition: {
    public override method isX86WordRegister => Boolean := true.
}.

public class AsmX86Int8Register superclass: AsmX86IntRegister; definition: {
    public override method isX86WordRegister => Boolean := false.

    public override method size => Size := 1sz.
}.

public class AsmX86Int16Register superclass: AsmX86IntRegister; definition: {
    public override method size => Size := 2sz.
}.

public class AsmX86Int32Register superclass: AsmX86IntRegister; definition: {
    public override method size => Size := 4sz.
}.

public class AsmX86Int64Register superclass: AsmX86IntRegister; definition: {
    public override method size => Size := 8sz.
}.

public class AsmX86VectorRegister superclass: AsmX86IntRegister; definition: {
    public override method size => Size := 16sz.
}.

public global X86::RAX := AsmX86Int64Register name: #RAX value: 0u8.
public global X86::RCX := AsmX86Int64Register name: #RCX value: 1u8.
public global X86::RDX := AsmX86Int64Register name: #RDX value: 2u8.
public global X86::RBX := AsmX86Int64Register name: #RBX value: 3u8.
public global X86::RSP := AsmX86Int64Register name: #RSP value: 4u8.
public global X86::RBP := AsmX86Int64Register name: #RBP value: 5u8.
public global X86::RSI := AsmX86Int64Register name: #RSI value: 6u8.
public global X86::RDI := AsmX86Int64Register name: #RDI value: 7u8.
public global X86::R8 := AsmX86Int64Register name: #R8 value: 8u8.
public global X86::R9 := AsmX86Int64Register name: #R9 value: 9u8.
public global X86::R10 := AsmX86Int64Register name: #R10 value: 10u8.
public global X86::R11 := AsmX86Int64Register name: #R11 value: 11u8.
public global X86::R12 := AsmX86Int64Register name: #R12 value: 12u8.
public global X86::R13 := AsmX86Int64Register name: #R13 value: 13u8.
public global X86::R14 := AsmX86Int64Register name: #R14 value: 14u8.
public global X86::R15 := AsmX86Int64Register name: #R15 value: 15u8.

public final class AsmX86InstructionDefinition superclass: Object; definition: {
    public field mnemonic => Symbol.
    public field operandNames => Array.
    public field description => String.
    public field alternatives => Array.
}.

public final class AsmX86InstructionTemplate superclass: Object; definition: {
    public field when => ((AsmX86InstructionTemplate, AsmX86Instruction) => Boolean).
    public field whenIfShortDistance => ((AsmX86InstructionTemplate, AsmX86Instruction) => Boolean).
    public field writeWith => ((AsmX86InstructionTemplate, AsmX86Instruction, AsmObjectCodeStream) => Void).

    public field mandatoryPrefix => ByteArray.
    public field opcode => ByteArray.
    public field registerOpcode => UInt8.

    public method initialize => Void := {
        mandatoryPrefix := #[].
        opcode := #[].
        registerOpcode := 0u8.
    }.

    public method parseDescription: (description: Array) ::=> Void := {
        mandatoryPrefix := description second.
        opcode := description third.
        description size >= 4sz ifTrue: (registerOpcode := description fourth asUInt8).
    }.

    public method canWriteInstruction: (instruction: AsmX86Instruction) ::=> Boolean
        := when(self, instruction).

    public method canWriteInstructionIfShort: (instruction: AsmX86Instruction) ::=> Boolean
        := (whenIfShortDistance ~~ nil) && whenIfShortDistance(self, instruction).

    public method writeInstruction: (instruction: AsmX86Instruction) onObjectCodeStream: (stream: AsmObjectCodeStream) ::=> Void
        := writeWith(self, instruction, stream).
}.

AsmObjectCodeStream definition: {
    public method nextPutX86RexSize: (operandSize: Size) rm: (rm: AsmInstructionOperand) reg: (reg: AsmInstructionOperand) ::=> Void := {
        let wBit := if: operandSize = 8sz then: 1u8 else: 0u8.
        let regBit := reg x86::rexRegBit.
        let baseBit := rm x86::rexBaseBit.
        let indexBit := rm x86::rexIndexBit.

        let lowBits := ((wBit << 3u8) | (regBit << 2u8)) | ((indexBit << 1u8) | (baseBit)).
        lowBits ~= 0 ifTrue: { 
            self assert: self isInX86LongMode.
            self nextPut: 16r40 u8 | lowBits
        }
    }.

    public method nextPutX86RexRM: (rm: AsmInstructionOperand) ::=> Void := {
        let baseBit := rm x86::rexBaseBit.
        let indexBit := rm x86::rexIndexBit.
        let lowBits := (indexBit << 1u8) | baseBit.

        lowBits ~= 0 ifTrue: {
            self assert: self isInX86LongMode.
            self nextPut: 16r40 u8 | lowBits
        }
    }.

    public method nextPutX86Opcode: (opcode: UInt8) plusRegister: (register: AsmX86Register) ::=> Void := {
        self nextPut: opcode + register x86::valueLow
    }.

    public method nextPutX86ModRM: (rm: AsmInstructionOperand) reg: (register: AsmInstructionOperand) immediateSize: (immediateSize: Size) ::=> Void := {
        rm x86::encodeModRMWithReg: register immediateSize: immediateSize longMode: self isInX86LongMode into: self
    }.

    public method nextPutX86ModRM: (rm: AsmInstructionOperand) reg: (register: AsmInstructionOperand) ::=> Void
        := self nextPutX86ModRM: rm reg: register immediateSize: 0sz.

}.

AsmX86Instruction definition: {
    public field definition => AsmX86InstructionDefinition.
    public field activeAlternative => AsmX86InstructionTemplate.
    public field longAlternative => AsmX86InstructionTemplate.
    public field shortAlternative => AsmX86InstructionTemplate.

    public abstract method operandCount => Size
        := self subclassResponsibility.

    public abstract method firstOperand => AsmInstructionOperand
        := self error: "Operand not present.".

    public abstract method secondOperand => AsmInstructionOperand
        := self error: "Operand not present.".

    public override method selectEncodingAlternatives => Void := {
        definition alternatives do: {:(AsmX86InstructionTemplate)eachAlternative :: Void |
            shortAlternative isNil && (eachAlternative canWriteInstructionIfShort: self) ifTrue: {
                shortAlternative := eachAlternative.
            }.
            longAlternative isNil && (eachAlternative canWriteInstruction: self) ifTrue: {
                longAlternative := eachAlternative.
            }.
        }.

        activeAlternative := longAlternative.
        ## TODO: Add support for the different spanning options.
    }.

    public override method writeOnObjectCodeStream: (stream: AsmObjectCodeStream) ::=> Void := {
        self assert: activeAlternative isNotNil.
        activeAlternative writeInstruction: self onObjectCodeStream: stream
    }.
}.

public final class AsmX86InstructionWithoutOperands superclass: AsmX86Instruction; definition: {
    public method fullPrintOn: (stream: Stream) ::=> Void := {
        stream nextPutAll: definition mnemonic.
    }.

    public override method operandCount => Size := 0sz.
}.

public final class AsmX86InstructionWithSingleOperand superclass: AsmX86Instruction; definition: {
    public field firstOperand => AsmInstructionOperand.

    public override method operandCount => Size := 1sz.

    public method fullPrintOn: (stream: Stream) ::=> Void := {
        stream nextPutAll: definition mnemonic; space; print: firstOperand.
    }.
}.

public final class AsmX86InstructionWithTwoOperands superclass: AsmX86Instruction; definition: {
    public field firstOperand => AsmInstructionOperand.
    public field secondOperand => AsmInstructionOperand.

    public override method operandCount => Size := 2sz.

    public method fullPrintOn: (stream: Stream) ::=> Void := {
        stream nextPutAll: definition mnemonic; space; print: firstOperand; nextPutAll: ", "; print: secondOperand.
    }.
}.

AsmX86InstructionDefinition definition: {
    public method generateStreamBuilderMethod => Void := {
        let selectorBuilder := StringStream new.
        selectorBuilder nextPutAll: "x86::"; nextPutAll: mnemonic.
        operandNames doWithIndex: {:(Symbol)operandName :(Size)index :: Void |
            if: index ~= 0sz then: (selectorBuilder nextPutAll: operandName).
            selectorBuilder nextPut: ':'
        }.

        let selector := selectorBuilder asSymbol.
        let operandCount := operandNames size.

        ## Zero operand case.
        if: operandCount = 0sz then: {
            AsmStreamBuilder withSelector: selector addMethod: {:(AsmStreamBuilder)builder :: AsmX86InstructionWithoutOperands |
                builder addElement: (AsmX86InstructionWithoutOperands new
                    definition: self;
                    yourself)
            }. 
        }.

        ## Single operand case.
        if: operandCount = 1sz then: {
            AsmStreamBuilder withSelector: selector addMethod: {:(AsmStreamBuilder)builder :(AsmInstructionOperand)operand :: AsmX86InstructionWithSingleOperand |
                builder addElement: (AsmX86InstructionWithSingleOperand new
                    definition: self;
                    firstOperand: operand;
                    yourself)
            }. 
        }.

        ## Two operand case.
        if: operandCount = 2sz then: {
            AsmStreamBuilder withSelector: selector addMethod: {:(AsmStreamBuilder)builder :(AsmInstructionOperand)firstOperand :(AsmInstructionOperand)secondOperand :: AsmX86InstructionWithTwoOperands |
                builder addElement: (AsmX86InstructionWithTwoOperands new
                    definition: self;
                    firstOperand: firstOperand;
                    secondOperand: secondOperand;
                    yourself)
            }. 
        }.
    }.
}.

let instructionTemplateTable := #{
    Op: (AsmX86InstructionTemplate new
        when: {:(AsmX86InstructionTemplate)templ :(AsmX86Instruction)instruction :: Boolean | 
            instruction operandCount = 0sz
        };
        writeWith: {:(AsmX86InstructionTemplate)templ :(AsmX86Instruction)instruction :(AsmObjectCodeStream)stream :: Void |
            stream nextPutAll: templ mandatoryPrefix; nextPutAll: templ opcode.
        };
        yourself).
    OppR: (AsmX86InstructionTemplate new
        when: {:(AsmX86InstructionTemplate)templ :(AsmX86Instruction)instruction :: Boolean | 
            (instruction operandCount = 1sz) && instruction firstOperand isX86WordRegister
        };
        writeWith: {:(AsmX86InstructionTemplate)templ :(AsmX86Instruction)instruction :(AsmObjectCodeStream)stream :: Void |
            let register := instruction firstOperand downCastTo: AsmX86Register.
            stream 
                nextPutAll: templ mandatoryPrefix;
                nextPutX86RexRM: register;
                nextPutX86Opcode: templ opcode first plusRegister: register.
        };
        yourself).

    OpRmwRw: (AsmX86InstructionTemplate new
        when: {:(AsmX86InstructionTemplate)templ :(AsmX86Instruction)instruction :: Boolean | 
            (instruction operandCount = 2sz) &&
                (instruction firstOperand isRegisterOrRegisterAddress && 
                instruction secondOperand isRegister)
        };
        writeWith: {:(AsmX86InstructionTemplate)templ :(AsmX86Instruction)instruction :(AsmObjectCodeStream)stream :: Void |
            let registerAddress := instruction firstOperand.
            let register := instruction secondOperand.
            let operandSize := register size.
            stream 
                nextPutAll: templ mandatoryPrefix;
                nextPutX86RexSize: operandSize rm: registerAddress reg: register;
                nextPutAll: templ opcode;
                nextPutX86ModRM: registerAddress reg: register
        };
        yourself).

    OpRwRmw: (AsmX86InstructionTemplate new
        when: {:(AsmX86InstructionTemplate)templ :(AsmX86Instruction)instruction :: Boolean | 
            (instruction operandCount = 2sz) &&
                (instruction firstOperand isRegister && 
                instruction secondOperand isRegisterOrRegisterAddress)
        };
        writeWith: {:(AsmX86InstructionTemplate)templ :(AsmX86Instruction)instruction :(AsmObjectCodeStream)stream :: Void |
            let register := instruction firstOperand.
            let registerAddress := instruction secondOperand.
            let operandSize := register size.
            stream 
                nextPutAll: templ mandatoryPrefix;
                nextPutX86RexSize: operandSize rm: registerAddress reg: register;
                nextPutAll: templ opcode;
                nextPutX86ModRM: registerAddress reg: register
        };
        yourself).
}.

let instructionDefinitionTable := #(
    (add (dst src) "Integer addition."
    )

    (call (target) "Call the function in the specified address."
    )

    (cmp (dst src) "Compares by subtracting the specified values."
    )

    (endbr32 () "Ends indirect branch in 32 mode"
        (Op #[] #[16rF3 16r0F 16r1E 16rFB])
    )

    (endbr64 () "Ends indirect branch in 64 mode"
        (Op #[] #[16rF3 16r0F 16r1E 16rFA])
    )

    (lea (dst src) "Load effective address."
    )

    (mov (dst src) "Move values."
        (OpRmwRw #[] #[16r89])
        (OpRwRmw #[] #[16r8B])
    )

    (jmp (target) "Jumps into the specified address."
    )

    (int (number) "Software interruption."
        ##(OpI8 #[] #[16rCD])
    )

    (int3 () "Software interruption 3 (Breakpoint)."
        (Op #[] #[16rCC])
    )

    (pop (dst) "Pops a value from the stack"
        (OppR #[] #[16r58])
    )

    (push (src) "Pushes a value onto the stack"
        (OppR #[] #[16r50])
    )

    (ret () "Return from function."
        (Op #[] #[16rC3])
    )

    (sub (dst src) "Integer subtraction."
    )
).

public global AsmX86InstructionDefinition::Table := Dictionary new.

instructionDefinitionTable do: {:instructionDescription :: Void |
    let mnemonic := instructionDescription first.
    let operandNames := instructionDescription second.
    let description := instructionDescription third.
    let alternatives := instructionDescription allButFirst: 3.
    let parsedAlternatives := alternatives collect: {:(Array)alternativeDescription :: AsmX86InstructionTemplate |
        let alternativeName := alternativeDescription first.
        let instructionTemplate := instructionTemplateTable at: alternativeName.
        instructionTemplate copy
            parseDescription: alternativeDescription;
            yourself
    }.
    let definition := AsmX86InstructionDefinition new
        mnemonic: mnemonic;
        operandNames: operandNames;
        description: description;
        alternatives: parsedAlternatives;
        yourself.

    definition generateStreamBuilderMethod.
    AsmX86InstructionDefinition::Table at: definition mnemonic put: definition.
}.
