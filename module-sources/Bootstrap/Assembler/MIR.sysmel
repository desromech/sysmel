AsmStreamBuilder extend: {
    public method useDebugInfoOfMIRValue: (value: MIRValue) ::=> Void := {
        debugSourcePosition := value debugSourcePosition.
        debugSourceNode := value debugSourceNode.
        debugSourceEnvironment := value debugSourceEnvironment.
    }
}.

public abstract class MIRAsmCompilationTarget superclass: MIRCompilationTarget; definition: {
    public field asmCompilationTarget => AsmCompilationTarget.

    public method hasPositionIndependentCode => Boolean
        := asmCompilationTarget hasPositionIndependentCode.

    public override method passesReturnPointerThroughStack => Boolean
        := asmCompilationTarget passesReturnPointerThroughStack.

    public override method pointerSize => Size
        := asmCompilationTarget pointerSize.

    public override method pointerAlignment => Size
        := asmCompilationTarget pointerSize.

    public override method uintPointerType => Type
        := asmCompilationTarget uintPointerType.

    public override method stackFrameAlignment => Size
        := asmCompilationTarget stackFrameAlignment.

    public override method callPreservedVectorSize => Size
        := asmCompilationTarget callPreservedVectorSize.

    public override method callPreservedVectorAlignment => Size
        := asmCompilationTarget callPreservedVectorAlignment.

    public override method usesThreadLocalSegmentPointer => Boolean
        := asmCompilationTarget usesThreadLocalSegmentPointer.

    public override method generateTargetIRForMIRModule: (module: MIRModule) ::=> AnyValue := {
        let codeGenerator := MIRModuleAsmCodeGenerator new
            target: self;
            asmTarget: asmCompilationTarget;
            targetModule: (AsmProgramEntity new
                compilationTarget: asmCompilationTarget;
                yourself);
            compileModule: module;
            targetModule
    }.

    public override method generateTargetNativeCodeIRForMIRModule: (module: MIRModule) ::=> AnyValue := {
        let codeGenerator := MIRModuleAsmCodeGenerator new
            target: self;
            asmTarget: asmCompilationTarget;
            usePerObjectSymbolsInsteadOfHeap: true;
            targetModule: (AsmProgramEntity new
                compilationTarget: asmCompilationTarget;
                yourself);
            compileModule: module;
            targetModule
    }.
}.

public abstract class MIRAsmCodeGenerator superclass: Object; definition: {
    public field target => MIRAsmCompilationTarget.

    public abstract method symbolForProgramEntity: (programEntity: MIRProgramEntity) ::=> AsmSymbol
        := self subclassResponsibility.

    public abstract method symbolForBasicBlock: (basicBlock: MIRBasicBlock) ::=> AsmSymbol
        := self subclassResponsibility.

    public virtual method captureVectorPointerStackMapLocation => AsmStackMapLocation
        := nil.

    public abstract method captureVectorDataOffset => Size
        := self subclassResponsibility.
}.

public final class MIRModuleAsmCodeGenerator superclass: MIRAsmCodeGenerator; definition: {
    public field sourceModule => MIRModule.
    public field targetModule => AsmProgramEntity.
    protected field asmTarget => AsmCompilationTarget.
    public field programEntitySymbolMap => ObjectPointerDictionary.
    public field compiledProgramEntitySymbolMap => ObjectPointerDictionary.
    public field usePerObjectSymbolsInsteadOfHeap => Boolean.

    protected field gcRootPointerSymbolTable => ObjectPointerDictionary.

    protected field stringTableList => OrderedCollection.
    protected field stringTableDictionary => Dictionary.

    protected field objectHeap => AsmObjectHeap.

    protected field picTableDictionary => ObjectPointerDictionary.
    protected field picTableSymbol => AsmSymbol.

    protected field gcStackFrameRecordLastActiveSymbol => AsmSymbol.

    protected field tlsIndexSymbol => AsmSymbol.
    protected field tlsArraySymbol => AsmSymbol.

    public override method initialize => Void := {
        programEntitySymbolMap := ObjectPointerDictionary new.
        compiledProgramEntitySymbolMap := ObjectPointerDictionary new.
        objectHeap := AsmObjectHeap new.
        stringTableList := OrderedCollection new.
        stringTableDictionary := Dictionary new.
        picTableDictionary := ObjectPointerDictionary new. 
        gcRootPointerSymbolTable := ObjectPointerDictionary new.
    }.

    public method asmTarget => AsmCompilationTarget := asmTarget.
    public method asmTarget: (target: AsmCompilationTarget) ::=> Void := {
        asmTarget := target.
        objectHeap compilationTarget: target.
    }.

    public override method symbolForProgramEntity: (programEntity: MIRProgramEntity) ::=> AsmSymbol := {
        programEntitySymbolMap at: programEntity ifAbsentPut: {:: AsmSymbol |
            programEntity generateAssemblySymbolWith: self
        }
    }.

    public method symbolOfStringLiteral: (string: String) nullTerminated: (nullTerminated: Boolean) ::=> AsmSymbol := {
        let key := Array with: string with: nullTerminated.
        stringTableDictionary at: key ifAbsentPut: {:: AsmSymbol |
            let stringSymbol := AsmSymbol new
                makePrivate;
                yourself.

            stringTableList add: (Array with: stringSymbol with: key).
            stringSymbol
        }
    }.

    public method compileProgramEntity: (programEntity: MIRProgramEntity) ::=> AsmSymbol := {
        let existentSymbol => AsmSymbol := compiledProgramEntitySymbolMap atOrNil: programEntity.
        existentSymbol ifNil: {
            let symbol := self symbolForProgramEntity: programEntity.
            compiledProgramEntitySymbolMap at: programEntity put: symbol.
            programEntity generateAssemblyWith: self symbol: symbol.
            symbol
        }.
    }.

    public method imageObjectTrace => ImageObjectTrace
        := objectHeap objectTrace.

    public method compileModule: (module: MIRModule) ::=> Void := {
        ## Use the module image base object trace for constructing the object heap.
        sourceModule := module.
        objectHeap
            baseObjectTracer: module baseObjectTracer;
            setSpecialSymbolsWithMirModuleGenerator: self.

        usePerObjectSymbolsInsteadOfHeap ifFalse: {
            targetModule contentSymbol ifNil: {
                let compileUnitSymbol := AsmSymbol new name: #compileUnit; makePrivate; yourself.
                targetModule newStreamBuilder
                    textSection;
                    label: compileUnitSymbol.
                targetModule newEndStreamBuilder
                    textSection;
                    endLabel: compileUnitSymbol.
                targetModule contentSymbol: compileUnitSymbol.
            }.
        }.

        module programEntities do: {:(MIRProgramEntity)eachProgramEntity :: Void |
            self compileProgramEntity: eachProgramEntity
        }.

        usePerObjectSymbolsInsteadOfHeap ifTrue: {
            module functionDefinitionPatches do: {:(MIRFunctionDefinitionPatch)mirPatch :: Void |
                targetModule addFunctionDefinitionEntryPoints: (FunctionDefinitionAsmObjectCode new
                    functionDefinition: mirPatch functionDefinition;
                    checkedEntryPoint: (compiledProgramEntitySymbolMap atOrNil: mirPatch checkedEntryPoint);
                    uncheckedEntryPoint: (compiledProgramEntitySymbolMap atOrNil: mirPatch uncheckedEntryPoint);
                    uncheckedCapturelessEntryPoint: (compiledProgramEntitySymbolMap atOrNil: mirPatch uncheckedCapturelessEntryPoint);
                    yourself
                )
            }
        } ifFalse: {
            module functionDefinitionPatches do: {:(MIRFunctionDefinitionPatch)mirPatch :: Void |
                objectHeap tracer addObject: mirPatch functionDefinition patch: (ImageFunctionDefinitionEntryPointAsmPatch new
                    functionDefinition: mirPatch functionDefinition;
                    checkedEntryPoint: (compiledProgramEntitySymbolMap atOrNil: mirPatch checkedEntryPoint);
                    uncheckedEntryPoint: (compiledProgramEntitySymbolMap atOrNil: mirPatch uncheckedEntryPoint);
                    uncheckedCapturelessEntryPoint: (compiledProgramEntitySymbolMap atOrNil: mirPatch uncheckedCapturelessEntryPoint);
                    yourself)
            }.
        }.

        self buildPICTable.
        self buildStringLiterals.
        usePerObjectSymbolsInsteadOfHeap ifFalse: {
            asmTarget debugInformationGenerator ifNotNil: {:(AsmObjectDebugInformationGenerator class)generatorClass :: Void |
                let generator := generatorClass new.
                targetModule debugInformationGenerator: generator.
                generator generateDebugInformationForModule: targetModule
            }.
        }.
        
        usePerObjectSymbolsInsteadOfHeap ifFalse: {
            {|
                objectHeap buildIn: targetModule.
            } printTimeToRunInMillisecondsWithTitle: "Assembler object heap"
        }.
    }.

    public method getOrCreateGCRootPointerSymbolFor: (object: Untyped) ::=> AsmSymbol
        := gcRootPointerSymbolTable untypedAt: object ifAbsentPut: {:: AsmSymbol |
            AsmSymbol new
                objectValue: object;
                makePrivate;
                makeGCPointerTable;
                yourself
        }.

    public method offsetOfGCRootObjectTableEntryFor: (object: Untyped) ::=> Size
        := objectHeap offsetOfGCRootObjectTableEntryFor: object.

    public method gcRootObjectTableSymbol ::=> AsmSymbol
        := objectHeap objectPointerTableStartSymbol.

    public method picTableSymbol ::=> AsmSymbol
        := picTableSymbol ifNil: { picTableSymbol := AsmSymbol new
            name: #sysmelPICTable;
            makePublic;
            yourself
        }.

    public method offsetOfPICTableEntryFor: (picEntry: MIRPolymorphicInlineCache) ::=> Size
        := picTableDictionary at: picEntry ifAbsentPut: { :: Size |
            picTableDictionary size * ObjectModel::PolymorphicInlineCache instanceSize
        }.

    public method buildPICTable => Void := {
        picTableDictionary isEmpty ifTrue: (return: void).

        let picTable := targetModule newProgramEntity.
        let picTableSection := picTable newStreamBuilder
            bssSection;
            align: ObjectModel::PolymorphicInlineCache instanceAlignment;
            label: self picTableSymbol;
            reserveBytes: picTableDictionary size * ObjectModel::PolymorphicInlineCache instanceSize;
            endLabel: self picTableSymbol
    }.

    public method getSymbolForSourceProgramEntityOrNil: (sourceProgramEntity: ProgramEntity) ::=> AsmSymbol := {
        let mirProgramEntity => MIRProgramEntity := (sourceModule sourceProgramEntityDictionary atOrNil: sourceProgramEntity).
        mirProgramEntity ifNotNil: {
            self compileProgramEntity: mirProgramEntity.
        }
    }.

    public method getSymbolForSourceProgramEntity: (sourceProgramEntity: ProgramEntity) orCreateTLSNamed: (name: Symbol) ::=> AsmSymbol := {
        let mirProgramEntity => MIRProgramEntity := (sourceModule sourceProgramEntityDictionary atOrNil: sourceProgramEntity).
        mirProgramEntity ifNotNil: {
            self compileProgramEntity: mirProgramEntity.
        } ifNil: {
            let result := AsmSymbol new
                name: (sourceProgramEntity
                    ifNotNil: sourceProgramEntity programEntityQualifiedNameSymbol
                    ifNil: name);
                makePublic;
                makeTLS;
                yourself.
            targetModule addImportedSymbol: result.
            result
        }
    }.

    public method gcStackFrameRecordLastActiveSymbol => AsmSymbol := {
        gcStackFrameRecordLastActiveSymbol ifNil: {
            gcStackFrameRecordLastActiveSymbol := self getSymbolForSourceProgramEntity: (__Global__ lookLocalSymbol: #GCStackFrameRecord::LastActive) orCreateTLSNamed: #__sysmel_gcStackFrameRecordLastActive
        }
    }.

    public method tlsIndexSymbol ::=> AsmSymbol
        := tlsIndexSymbol ifNil: {
            tlsIndexSymbol := AsmSymbol new
                name: #_tls_index;
                makePublic;
                yourself.
            targetModule addImportedSymbol: tlsIndexSymbol.
            tlsIndexSymbol
        }.

    public method tlsArraySymbol ::=> AsmSymbol
        := tlsArraySymbol ifNil: {
            tlsArraySymbol := AsmSymbol new
                name: #_tls_array;
                makePublic;
                yourself.
            targetModule addImportedSymbol: tlsArraySymbol.
            tlsArraySymbol
        }.

    public method buildStringLiterals => Void := {
        stringTableList size = 0sz ifTrue: (return: void).

        let stringTable := targetModule newProgramEntity.
        let stringTableSection := stringTable newStreamBuilder
            rodataSection;
            yourself.

        stringTableList do: {:(Array)each :: Void |
            let symbol := each first.
            let string => String := each second first.
            let nullTerminated => Boolean := each second second.
            stringTableSection
                label: symbol;
                string: string nullTerminated: nullTerminated;
                endLabel: symbol.
        }
    }.
}.

AsmObjectHeap extend: {
    public method setSpecialSymbolsWithMirModuleGenerator: (codegen: MIRModuleAsmCodeGenerator) ::=> Void := {
        objectPointerTableStartSymbol := codegen getSymbolForSourceProgramEntityOrNil: (__Global__ lookLocalSymbol: #GarbageCollector::StaticRootPointerTableStart).
        objectPointerTableEndSymbol := codegen getSymbolForSourceProgramEntityOrNil: (__Global__ lookLocalSymbol: #GarbageCollector::StaticRootPointerTableEnd).

        objectFatPointerTableStartSymbol := codegen getSymbolForSourceProgramEntityOrNil: (__Global__ lookLocalSymbol: #GarbageCollector::StaticRootFatPointerTableStart).
        objectFatPointerTableEndSymbol := codegen getSymbolForSourceProgramEntityOrNil: (__Global__ lookLocalSymbol: #GarbageCollector::StaticRootFatPointerTableEnd).

        objectSectionStartSymbol := codegen getSymbolForSourceProgramEntityOrNil: (__Global__ lookLocalSymbol: #GarbageCollector::StaticObjectSegmentStart).
        objectSectionEndSymbol := codegen getSymbolForSourceProgramEntityOrNil: (__Global__ lookLocalSymbol: #GarbageCollector::StaticObjectSegmentEnd).
    }.
}.

public final class MIRFunctionAsmCodeGenerator superclass: MIRAsmCodeGenerator; definition: {
    public field moduleGenerator => MIRModuleAsmCodeGenerator.
    public field function => MIRFunction.
    public field asmFunction => AsmProgramEntity.
    public field stackMap => AsmStackMap.
    private field activeLocationLiveIntervals => MIRLiveIntervalSortedList.
    private field stackMapLocationDictionary => ObjectPointerDictionary.
    private field basicBlockSymbolDictionary => ObjectPointerDictionary.

    public field registerAllocator => MIRRegisterAllocator.
    public field stackFrameLayout => MIRStackFrameLayout.
    private field constantSymbolDictionary => Dictionary.

    public method asmTarget => AsmCompilationTarget
        := moduleGenerator asmTarget.

    protected field textSection => AsmStreamBuilder.
    public method textSection => AsmStreamBuilder
        := textSection ifNil: (textSection := asmFunction newStreamBuilder
            textSection;
            yourself).

    protected field rodataSection => AsmStreamBuilder.
    public method rodataSection => AsmStreamBuilder
        := rodataSection ifNil: (rodataSection := asmFunction newStreamBuilder
            rodataSection;
            yourself).

    protected field captureVectorPointerRegister => MIRPhysicalLocation.

    public method validCaptureVectorPointerRegister => MIRPhysicalLocation := {
        captureVectorPointerRegister ifNil: (self error: "Cannot use unloaded capture vector pointer register.").
        captureVectorPointerRegister
    }.

    protected field gotPointerRegister => MIRPhysicalLocation.

    public method validGotPointerRegister => MIRPhysicalLocation := {
        gotPointerRegister ifNil: (self error: "Cannot use unloaded got pointer register.").
        gotPointerRegister
    }.

    protected field threadLocalSegmentPointerRegister => MIRPhysicalLocation.

    public method validThreadLocalSegmentPointerRegister => MIRPhysicalLocation := {
        threadLocalSegmentPointerRegister ifNil: (self error: "Cannot use unloaded thread local data segment pointer register.").
        threadLocalSegmentPointerRegister
    }.

    public field closureArgument => MIRArgumentValue.
    public field captureVectorDataOffset => Size.
    public field closureCaptureVectorMemberOffset => Size.

    public method generateFunction: (functionToGenerate: MIRFunction) withSymbol: (symbol: AsmSymbol) ::=> Void := {
        function := functionToGenerate.
        asmFunction := moduleGenerator targetModule newProgramEntity.
        stackMap := AsmStackMap new.
        constantSymbolDictionary := Dictionary new.
        stackMapLocationDictionary := ObjectPointerDictionary new.
        asmFunction
            debugSourcePosition: functionToGenerate debugSourcePosition;
            debugSourceNode: functionToGenerate debugSourceNode;
            debugSourceEnvironment: functionToGenerate debugSourceEnvironment;
            stackMap: stackMap;
            sourceProgramEntity: functionToGenerate sourceProgramEntity;
            contentSymbol: symbol.

        functionToGenerate trampolineTarget ifNotNil: {
            asmFunction trampolineTarget: (moduleGenerator symbolForProgramEntity: functionToGenerate trampolineTarget)
        }.

        self prepareToGenerateFunction.

        self textSection
            align: moduleGenerator asmTarget indirectBranchTargetAlignment unreachable: true;
            useDebugInfoOfMIRValue: functionToGenerate;
            label: symbol;
            yourself.

        let exportedSymbols := functionToGenerate exportedSymbols collect: {:(Symbol)symbol :: AsmSymbol |
            AsmSymbol new
                name: symbol;
                makePublic;
                makeFunction;
                yourself
        }.

        exportedSymbols do: {:(AsmSymbol)eachSymbol :: Void |
            self textSection label: eachSymbol
        }.

        self textSection cfiBeginProcedure.

        activeLocationLiveIntervals := MIRLiveIntervalSortedList new.

        self
            generateStackMap;
            emitPrologue;
            emitStackFrameConstruction.

        function basicBlocksDo: {:(MIRBasicBlock)basicBlock :: Void |
            self generateBasicBlock: basicBlock
        }.

        self endAllActiveLiveIntervals.
        self textSection
            cfiEndProcedure;
            endLabel: symbol.
        exportedSymbols do: {:(AsmSymbol)eachSymbol :: Void |
            self textSection endLabel: eachSymbol
        }.
    }.

    MIRAsmCompilationTarget extend: {
        public abstract method emitFunctionPrologueWith: (generator: MIRFunctionAsmCodeGenerator) ::=> Void
            := self subclassResponsibility.

        public abstract method emitStackFrameConstructionWith: (generator: MIRFunctionAsmCodeGenerator) ::=> Void
            := self subclassResponsibility.

        public abstract method emitStackFrameClearWith: (generator: MIRFunctionAsmCodeGenerator) ::=> Void
            := self subclassResponsibility.

        public abstract method emitGCStackFrameRecordLinkWith: (generator: MIRFunctionAsmCodeGenerator) ::=> Void
            := self subclassResponsibility.

        public abstract method emitGCStackFrameRecordUnlinkWith: (generator: MIRFunctionAsmCodeGenerator) ::=> Void
            := self subclassResponsibility.

        public abstract method emitFunctionEpilogueWith: (generator: MIRFunctionAsmCodeGenerator) ::=> Void
            := self subclassResponsibility.
        
        public virtual method emitInstruction: (instruction: MIRInstruction) with: (generator: MIRFunctionAsmCodeGenerator) ::=> Void
            := instruction operation generate: instruction for: self with: generator.
        
        public abstract method emitMoveValue: (value: MIRValue) intoLocation: (register: MIRPhysicalLocation) with: (generator: MIRFunctionAsmCodeGenerator) ::=> Void
            := self subclassResponsibility.

        public abstract method emitMoveValue: (value: MIRValue) intoSpecificMemoryLocation: (memoryLocation: MIRSpecificPhysicalMemoryLocation) with: (generator: MIRFunctionAsmCodeGenerator) ::=> Void
            := self subclassResponsibility.

        public abstract method emitUnspillValue: (value: MIRValue) intoLocation: (register: MIRPhysicalLocation) with: (generator: MIRFunctionAsmCodeGenerator) ::=> Void
            := self subclassResponsibility.

        public abstract method emitMoveValuePointer: (value: MIRValue) intoLocation: (register: MIRPhysicalLocation) with: (generator: MIRFunctionAsmCodeGenerator) ::=> Void
            := self subclassResponsibility.

        public abstract method emitMoveRegister: (register: MIRPhysicalLocation) intoValue: (value: MIRValue) with: (generator: MIRFunctionAsmCodeGenerator) ::=> Void
            := self subclassResponsibility.

        public abstract method emitMoveRegister: (register: MIRPhysicalLocation) intoValueStackPointer: (value: MIRValue) with: (generator: MIRFunctionAsmCodeGenerator) ::=> Void
            := self subclassResponsibility.

        public abstract method emitLoadCaptureVectorPointerFromClosure: (closurePointer: MIRPhysicalLocation) intoRegister: (register: MIRPhysicalLocation) with: (generator: MIRFunctionAsmCodeGenerator) ::=> Void
            := self subclassResponsibility.

        public abstract method emitLoadGotPointerValueIntoRegister: (register: MIRPhysicalLocation) with: (generator: MIRFunctionAsmCodeGenerator) ::=> Void
            := self subclassResponsibility.

        public abstract method emitLoadThreadLocalSegmentPointerRegisters: (tlsPointerValue: MIRThreadLocalSegmentPointerValue) with: (generator: MIRFunctionAsmCodeGenerator) ::=> Void
            := self subclassResponsibility.
    }.

    MIRCallingConvention extend: {
        public abstract method asm::generateCallInt8: (instruction: MIRInstruction) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void
            := self subclassResponsibility.

        public abstract method asm::generateCallInt16: (instruction: MIRInstruction) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void
            := self subclassResponsibility.

        public abstract method asm::generateCallInt32: (instruction: MIRInstruction) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void
            := self subclassResponsibility.

        public abstract method asm::generateCallInt64: (instruction: MIRInstruction) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void
            := self subclassResponsibility.

        public abstract method asm::generateCallPointer: (instruction: MIRInstruction) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void
            := self subclassResponsibility.

        public abstract method asm::generateCallFatPointer: (instruction: MIRInstruction) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void
            := self subclassResponsibility.

        public abstract method asm::generateCallFloat32: (instruction: MIRInstruction) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void
            := self subclassResponsibility.

        public abstract method asm::generateCallFloat64: (instruction: MIRInstruction) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void
            := self subclassResponsibility.

        public abstract method asm::generateCallStruct: (instruction: MIRInstruction) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void
            := self subclassResponsibility.

        public abstract method asm::generateCallVoid: (instruction: MIRInstruction) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void
            := self subclassResponsibility.

        public abstract method asm::allocateExceptionLongjmpRegistersFor: (instruction: MIRInstruction) with: (allocator: MIRRegisterAllocator) ::=> Void
            := self subclassResponsibility.

        public abstract method asm::generateExceptionLongjmpRegistersFor: (instruction: MIRInstruction) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void
            := self subclassResponsibility.

        public abstract method asm::allocateExceptionSetjmpRegistersFor: (instruction: MIRInstruction) with: (allocator: MIRRegisterAllocator) ::=> Void
            := self subclassResponsibility.

        public abstract method asm::generateExceptionSetjmpRegistersFor: (instruction: MIRInstruction) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void
            := self subclassResponsibility.
    }.

    public method computeArgumentPassingLayout => Void := {
        function callingConvention computeArgumentPassingLayoutOf: function
    }.

    public method performRegisterAllocation => Void := {
        registerAllocator := MIRLinearScanRegisterAllocator new.
        registerAllocator allocateRegistersIn: function withTarget: moduleGenerator target.
    }.

    public method buildStackFrameLayout => Void := {
        stackFrameLayout := MIRStackFrameLayout new.
        stackFrameLayout buildLayoutForFunction: function withTarget: moduleGenerator target
    }.

    public method prepareToGenerateFunction => Void := {
        function captures isNotEmpty ifTrue: {
            closureArgument := function arguments first.
            captureVectorDataOffset := function compilationTarget objectModel objectHeaderSize.
            ## FIXME: Delegate this offset computation onto the compilation target.
            closureCaptureVectorMemberOffset := function compilationTarget objectModel objectHeaderSize + (Function lookupSlot: #captureVector) validOffset.
        }.

        self
            computeArgumentPassingLayout;
            performRegisterAllocation;
            buildStackFrameLayout.

        ## Generate a private label per basic block.
        basicBlockSymbolDictionary := ObjectPointerDictionary new.
        function basicBlocksDo: {:(MIRBasicBlock)basicBlock :: Void |
            basicBlockSymbolDictionary at: basicBlock put: (AsmSymbol new
                name: basicBlock name;
                makePrivate;
                yourself).
        }.
    }.

    public method emitPrologue => Void := {
        moduleGenerator target emitFunctionPrologueWith: self
    }.

    public method emitEpilogue => Void := {
        moduleGenerator target emitFunctionEpilogueWith: self
    }.

    public method emitStackFrameConstruction => Void := {
        moduleGenerator target emitStackFrameConstructionWith: self
    }.

    public method emitStackFrameClear => Void := {
        moduleGenerator target emitStackFrameClearWith: self
    }.

    public method emitGCStackFrameRecordLink => Void := {
        moduleGenerator target emitGCStackFrameRecordLinkWith: self
    }.

    public method emitGCStackFrameRecordUnlink => Void := {
        moduleGenerator target emitGCStackFrameRecordUnlinkWith: self
    }.

    protected field captureVectorPointerStackMapLocation => AsmStackMapLocation.
    
    public override method captureVectorPointerStackMapLocation => AsmStackMapLocation := captureVectorPointerStackMapLocation.

    public method validStackMapLocationForValue: (value: MIRValue) ::=> AsmStackMapLocation
        := stackMapLocationDictionary at: value ifAbsentPut: {:: AsmStackMapLocation | 
            value asm::makeStackMapLocationWith: self
        }.

    public method generateStackMap => Void := {
        function arguments do: {:(MIRLocalValue)eachLocal :: Void |
            eachLocal sourceBinding ifNotNil: {:(SymbolBinding)binding :: Void |
                let location := self validStackMapLocationForValue: eachLocal.
                location ifNotNil: {
                    stackMap addArgumentBindingMap: (stackMap setBinding: binding location: location)
                }.
            }
        }.

        ## Make the capture vector pointer stack map location.
        function captureVectorPointerValue ifNotNil: {
            captureVectorPointerStackMapLocation := self validStackMapLocationForValue: function captureVectorPointerValue.
        }.

        function captures do: {:(MIRLocalValue)eachLocal :: Void |
            eachLocal sourceBinding ifNotNil: {:(SymbolBinding)binding :: Void |
                let location := self validStackMapLocationForValue: eachLocal.
                location ifNotNil: {
                    stackMap addCaptureBindingMap: (stackMap setBinding: binding location: location)
                }.
            }
        }.
    }.

    public method emitSpillRegisterArgumentsInStackFrame => Void := {
        function arguments do: {:(MIRArgumentValue)eachArgument :: Void |
            let passingRegister := eachArgument passingRegister.
            passingRegister ifNotNil: {
                eachArgument needsStackAllocation ifTrue: {
                    eachArgument stackValueIsPointer ifTrue: {
                        self emitMoveRegister: passingRegister intoValueStackPointer: eachArgument
                    } ifFalse: {
                        self emitMoveRegister: passingRegister intoValue: eachArgument
                    }.
                }.

                self beginEntryPointLocationIntervalForLocalValue: eachArgument.
            }.
        }.
    }.

    public method emitUnspillEntryValuesFromStackFrame => Void := {
        let unspillValue := {:(MIRLocalValue)eachLocal :: Void |
            eachLocal isArgumentVariable ifTrue: {
                let argument := eachLocal downCastTo: MIRArgumentValue.
                argument passingRegister ifNotNil: {
                    ## Case already handled by emitSpillRegisterArgumentsInStackFrame
                    return: void
                }.
            }.

            eachLocal coalescedAssignedRegister ifNil: {
                self beginEntryPointLocationIntervalForLocalValue: eachLocal.
                return: void
            }.

            self emitUnspillValue: eachLocal intoLocation: eachLocal coalescedAssignedRegister.
            self beginEntryPointLocationIntervalForLocalValue: eachLocal.
        }.

        function arguments do: unspillValue.

        function captureVectorPointerValue ifNotNil: {
            let captureVectorPointer := function captureVectorPointerValue.
            self emitMoveValue: function arguments first intoLocation: captureVectorPointer closureRegister.
            moduleGenerator target emitLoadCaptureVectorPointerFromClosure: captureVectorPointer closureRegister intoRegister: captureVectorPointer loadRegister with: self.
            self emitMoveRegister: captureVectorPointer loadRegister intoValue: captureVectorPointer.
            captureVectorPointerRegister := captureVectorPointer loadRegister.
            self beginEntryPointLocationIntervalForLocalValue: function captureVectorPointerValue.
        }.

        function captures do: unspillValue.
        captureVectorPointerRegister := nil.

        function gotPointerValue ifNotNil: {
            let gotPointerValue := function gotPointerValue.
            moduleGenerator target emitLoadGotPointerValueIntoRegister: gotPointerValue loadRegister with: self.
            self emitMoveRegister: gotPointerValue loadRegister intoValue: gotPointerValue.
        }.

        function threadLocalSegmentPointerValue ifNotNil: {
            let threadLocalSegmentPointerValue := function threadLocalSegmentPointerValue.
            moduleGenerator target emitLoadThreadLocalSegmentPointerRegisters: threadLocalSegmentPointerValue with: self.
            self emitMoveRegister: threadLocalSegmentPointerValue loadRegister intoValue: threadLocalSegmentPointerValue.
        }.

        gotPointerRegister := nil.
        threadLocalSegmentPointerRegister := nil.
    }.

    protected field firstPhiMoveInstruction => MIRInstruction.

    public method generateBasicBlock: (basicBlock: MIRBasicBlock) ::=> Void := {
        let blockSymbol := basicBlockSymbolDictionary at: basicBlock.

        let alignment := basicBlock hasBackEdge ifTrue: {
            moduleGenerator asmTarget loopEntryBranchTargetAlignment
        } ifFalse: {
            moduleGenerator asmTarget directBranchTargetAlignment
        }.

        alignment > 1sz ifTrue: {
            self textSection align: alignment unreachable: false
        }.

        self textSection
            useDebugInfoOfMIRValue: basicBlock;
            label: blockSymbol.
        firstPhiMoveInstruction := nil.
        basicBlock instructionsDo: {:(MIRInstruction)eachInstruction :: Void |
            self generateInstruction: eachInstruction
        }.

        self textSection
            useDebugInfoOfMIRValue: basicBlock;
            endLabel: blockSymbol.
    }.

    public method generateInstruction: (instruction: MIRInstruction) ::=> Void := {
        instruction isDebug ifTrue: {
            self processDebugInstruction: instruction.
            return: void
        }.

        self textSection useDebugInfoOfMIRValue: instruction.

        instruction isPhiInstruction ifTrue: {return: void}.

        instruction targetPhi ifNil: {
            firstPhiMoveInstruction ifNotNil: {
                self generatePhiMoves
            }
        } ifNotNil: {
            firstPhiMoveInstruction ifNil: {
                firstPhiMoveInstruction := instruction
            }.
        }.

        captureVectorPointerRegister := instruction captureVectorPointerRegister.
        captureVectorPointerRegister ifNotNil: {
            self emitMoveValue: instruction captureVectorPointerValue intoLocation: captureVectorPointerRegister.
        }.
        gotPointerRegister := instruction gotPointerRegister.
        gotPointerRegister ifNotNil: {
            self emitMoveValue: instruction gotPointerValue intoLocation: gotPointerRegister.
        }.
        threadLocalSegmentPointerRegister := instruction threadLocalSegmentPointerRegister.
        threadLocalSegmentPointerRegister ifNotNil: {
            self emitMoveValue: instruction threadLocalSegmentPointerValue intoLocation: threadLocalSegmentPointerRegister.
        }.
        instruction resultRegister isNotNil && instruction resultRegister isRegisterWithPointer ifTrue: {
            self emitMoveValue: instruction intoLocation: instruction resultRegister
        }.
        self emitMoveValues: instruction operands intoRegisters: instruction operandRegisters.

        moduleGenerator target emitInstruction: instruction with: self.

        ## Do we need to support multiple result values?
        instruction resultRegister isNotNil && instruction resultRegister isRegisterWithPointer not
        && instruction hasValidType && (instruction userCount > 0sz) ifTrue: {
            self emitMoveRegister: instruction resultRegister intoValue: instruction
        }.

        captureVectorPointerRegister := nil.
        gotPointerRegister := nil.
        threadLocalSegmentPointerRegister := nil.
        self endActiveLiveIntervalsAt: instruction index
    }.

    public method generatePhiMoves => Void := {
        let position mutable := firstPhiMoveInstruction.
        while: (position isNotNil && position targetPhi isNotNil) do: {
            self copyFrom: position intoPhi: position targetPhi.
            position := position next
        }.

        firstPhiMoveInstruction := nil.
    }.

    public method copyFrom: (sourceValue: MIRInstruction) intoPhi: (targetPhi: MIRInstruction) ::=> Void := {
        targetPhi resultRegister ifNil: {
            ## Memory - Memory copy.
            self error: "TODO: Phi memory memory copy".
        }.

        sourceValue assignedRegister ifNotNil: {
            self emitMoveRegister: sourceValue assignedRegister intoValue: targetPhi.
            return: void
        }.

        ## Use the target phi register as a scratch register.
        self emitMoveValue: sourceValue intoLocation: targetPhi resultRegister.
        targetPhi assignedRegister ifNil: {
            self emitMoveRegister: targetPhi resultRegister intoValue: targetPhi.
        }.
    }.

    public method processDebugInstruction: (debugInstruction: MIRInstruction) ::=> Void := {
        self assert: (debugInstruction operation = MIR::Operation::DebugSetBindingValue)
            || (debugInstruction operation = MIR::Operation::DebugSetMutableBindingValue)
            || (debugInstruction operation = MIR::Operation::DebugSetMutableBindingSpecificValue).
        let value := debugInstruction firstOperand.
        let binding := debugInstruction sourceBinding.

        let location := self validStackMapLocationForValue: value.
        location ifNotNil: {
            stackMap setLocalBinding: binding isMutable: debugInstruction operation ~= MIR::Operation::DebugSetBindingValue location: location.
            value isLocalValue ifTrue: {
                self beginStackMapLocation: location intervalForLocalValue: (value downCastTo: MIRLocalValue)
            }
        }.
    }.

    public method beginEntryPointLocationIntervalForLocalValue: (localValue: MIRLocalValue) ::=> Void := {
        (stackMapLocationDictionary includesKey: localValue) ifTrue: {
            self beginStackMapLocation: (stackMapLocationDictionary at: localValue) intervalForLocalValue: localValue
        }
    }.

    public method beginStackMapLocation: (location: AsmStackMapLocation) intervalForLocalValue: (localValue: MIRLocalValue) ::=> Void := {
        location ifNil: {return: void}.

        let liveInterval := localValue liveInterval.
        liveInterval ifNil: {return: void}.

        (activeLocationLiveIntervals includes: liveInterval) ifTrue: {return: void}.
        activeLocationLiveIntervals add: liveInterval.

        self textSection stackMapLocationLiveIntervalStart: location.
    }.

    public method endActiveLiveIntervalsAt: (localValueIndex: UInt32) ::=> Void := {
        activeLocationLiveIntervals expireAt: localValueIndex doing: {:(MIRLiveInterval)interval :: Void |
            self endStackMapLocationForLocalValue: interval value
        }.
    }.

    public method endAllActiveLiveIntervals => Void := {
        activeLocationLiveIntervals elements do: {:(MIRLiveInterval)interval :: Void |
            self endStackMapLocationForLocalValue: interval value
        }.
    }.

    public method endStackMapLocationForLocalValue: (localValue: MIRLocalValue) ::=> Void := {
        localValue ifNil: {
            return: void
        }.

        (stackMapLocationDictionary includesKey: localValue) ifTrue: {
            let location => AsmStackMapLocation := (stackMapLocationDictionary at: localValue).
            self textSection stackMapLocationLiveIntervalEnd: location.
        }
    }.

    public method emitMoveValues: (values: Array) intoRegisters: (registers: Array) ::=> Void := {
        values doWithIndex: {:(MIRValue)eachValue :(Size)valueIndex :: Void |
            let targetLocation => MIRPhysicalLocation := registers at: valueIndex.
            targetLocation isSpecificMemoryLocation ifTrue: {
                self emitMoveValue: eachValue intoLocation: targetLocation
            }
        }.

        values doWithIndex: {:(MIRValue)eachValue :(Size)valueIndex :: Void |
            let targetLocation => MIRPhysicalLocation := registers at: valueIndex.
            targetLocation isSpecificMemoryLocation ifFalse: {
                self emitMoveValue: eachValue intoLocation: targetLocation
            }
        }
    }.

    public method emitMoveValue: (value: MIRValue) intoLocation: (location: MIRPhysicalLocation) ::=> Void := {
        ## FIXME: Use a double dispatch here.
        location isRegisterOrSequence ifTrue: {
            moduleGenerator target emitMoveValue: value intoLocation: location with: self.
        }.
        location isRegisterWithPointer ifTrue: {
            moduleGenerator target emitMoveValuePointer: value intoLocation: (location downCastTo: MIRPhysicalLocationRegisterWithPointer) register with: self.
        }.
        location isSpecificMemoryLocation ifTrue: {
            moduleGenerator target emitMoveValue: value intoSpecificMemoryLocation: (location downCastTo: MIRSpecificPhysicalMemoryLocation) with: self.
        }.
    }.

    public method emitUnspillValue: (value: MIRValue) intoLocation: (location: MIRPhysicalLocation) ::=> Void := {
        self assert: location isRegisterOrSequence.
        moduleGenerator target emitUnspillValue: value intoLocation: location with: self.
    }.

    public method emitMoveRegister: (location: MIRPhysicalLocation) intoValue: (value: MIRValue) ::=> Void := {
        location isRegisterOrSequence ifTrue: {
            moduleGenerator target emitMoveRegister: location intoValue: value with: self.
        }
    }.

    public method emitMoveRegister: (location: MIRPhysicalLocation) intoValueStackPointer: (value: MIRValue) ::=> Void := {
        location isRegisterOrSequence ifTrue: {
            moduleGenerator target emitMoveRegister: location intoValueStackPointer: value with: self.
        }
    }.

    public override method symbolForProgramEntity: (programEntity: MIRProgramEntity) ::=> AsmSymbol := {
        basicBlockSymbolDictionary at: programEntity ifAbsent: {|
            moduleGenerator symbolForProgramEntity: programEntity
        }
    }.

    public override method symbolForBasicBlock: (basicBlock: MIRBasicBlock) ::=> AsmSymbol
        := basicBlockSymbolDictionary at: basicBlock.

    public method symbolOfStringLiteral: (string: String) nullTerminated: (nullTerminated: Boolean) ::=> AsmSymbol
        := moduleGenerator symbolOfStringLiteral: string nullTerminated: nullTerminated.

    public method symbolOfStructureConstant: (structureConstant: MIRStructureConstant) ::=> AsmSymbol
        := constantSymbolDictionary at: (#uint8, structureConstant) ifAbsentPut: {:: AsmSymbol |
            let symbol := AsmSymbol new
                name: #structConstant;
                yourself.
            self rodataSection
                align: structureConstant alignment;
                label: symbol;
                structure: structureConstant value size: structureConstant size.
            symbol
        }.

    public method symbolForUInt8Constant: (constant: UInt8) ::=> AsmSymbol
        := constantSymbolDictionary at: (#uint8, constant) ifAbsentPut: {:: AsmSymbol |
            let symbol := AsmSymbol new
                name: #uint32Constant;
                yourself.
            self rodataSection label: symbol; byte: constant.
            symbol
        }.

    public method symbolForInt8Constant: (constant: Int8) ::=> AsmSymbol
        := constantSymbolDictionary at: (#int8, constant) ifAbsentPut: {:: AsmSymbol |
            let symbol := AsmSymbol new
                name: #int8Constant;
                yourself.
            self rodataSection label: symbol; sbyte: constant.
            symbol
        }.

    public method symbolForUInt16Constant: (constant: UInt16) ::=> AsmSymbol
        := constantSymbolDictionary at: (#uint32, constant) ifAbsentPut: {:: AsmSymbol |
            let symbol := AsmSymbol new
                name: #uint32Constant;
                yourself.
            self rodataSection align: 2sz; label: symbol; word: constant.
            symbol
        }.

    public method symbolForInt16Constant: (constant: Int16) ::=> AsmSymbol
        := constantSymbolDictionary at: (#int32, constant) ifAbsentPut: {:: AsmSymbol |
            let symbol := AsmSymbol new
                name: #uint16Constant;
                yourself.
            self rodataSection align: 2sz; label: symbol; sword: constant.
            symbol
        }.

    public method symbolForUInt32Constant: (constant: UInt32) ::=> AsmSymbol
        := constantSymbolDictionary at: (#uint32, constant) ifAbsentPut: {:: AsmSymbol |
            let symbol := AsmSymbol new
                name: #uint32Constant;
                yourself.
            self rodataSection align: 4sz; label: symbol; dword: constant.
            symbol
        }.

    public method symbolForInt32Constant: (constant: Int32) ::=> AsmSymbol
        := constantSymbolDictionary at: (#int32, constant) ifAbsentPut: {:: AsmSymbol |
            let symbol := AsmSymbol new
                name: #int32Constant;
                yourself.
            self rodataSection align: 4sz; label: symbol; sdword: constant.
            symbol
        }.

    public method symbolForUInt64Constant: (constant: UInt64) ::=> AsmSymbol
        := constantSymbolDictionary at: (#uint64, constant) ifAbsentPut: {:: AsmSymbol |
            let symbol := AsmSymbol new
                name: #uint64Constant;
                yourself.
            self rodataSection align: 8sz; label: symbol; qword: constant.
            symbol
        }.

    public method symbolForInt64Constant: (constant: Int64) ::=> AsmSymbol
        := constantSymbolDictionary at: (#int64, constant) ifAbsentPut: {:: AsmSymbol |
            let symbol := AsmSymbol new
                name: #int64Constant;
                yourself.
            self rodataSection align: 8sz; label: symbol; sqword: constant.
            symbol
        }.

    public method symbolForFloat32Constant: (constant: Float32) ::=> AsmSymbol
        := constantSymbolDictionary at: (#float32, constant) ifAbsentPut: {:: AsmSymbol |
            let symbol := AsmSymbol new
                name: #float32Constant;
                yourself.
            self rodataSection align: 4sz; label: symbol; float: constant.
            symbol
        }.

    public method symbolForFloat64Constant: (constant: Float64) ::=> AsmSymbol
        := constantSymbolDictionary at: (#float64, constant) ifAbsentPut: {:: AsmSymbol |
            let symbol := AsmSymbol new
                name: #float64Constant;
                yourself.
            self rodataSection align: 8sz; label: symbol; double: constant.
            symbol
        }.

    public method symbolForGCStackFrameDescriptorFor: (stackFrameLayout: MIRStackFrameLayout) ::=> AsmSymbol := {
        let symbol := AsmSymbol new
                name: #gcStackFrameDescriptor;
                yourself.
        
        let metadataOffset := stackFrameLayout frameMetadata offset.

        self rodataSection
            align: 4sz;
            label: symbol;

            sdword: (stackFrameLayout temporaryGCZone offset - metadataOffset) asInt32; ## temporaryGCZoneOffset
            dword: stackFrameLayout temporaryGCZone values size asUInt32; ## temporaryGCZoneEntryCount

            sdword: (stackFrameLayout temporaryGCFatPointerZone offset - metadataOffset) asInt32; ## temporaryGCFatPointerZoneOffset
            dword: stackFrameLayout temporaryGCFatPointerZone values size asUInt32; ## temporaryGCFatPointerZoneEntryCount

            sdword: (stackFrameLayout gcObjectAllocationZone offset - metadataOffset) asInt32; ## gcObjectAllocationZoneOffset
            dword: stackFrameLayout gcObjectAllocationZone values size asUInt32; ## gcObjectAllocationZoneEntryCount

            sdword: (stackFrameLayout argumentPassingZone offset - metadataOffset) asInt32; ## argumentPassingZoneOffset
            dword: stackFrameLayout argumentPassingZone values size asUInt32. ## argumentPassingZoneEntryCount

        ## Object allocation zone layout.
        stackFrameLayout gcObjectAllocationZone values do: {:(MIRLocalValue)stackAllocatedObject :: Void |
            self assert: stackAllocatedObject isValueInstance.
            self assert: stackAllocatedObject hasValidStackSegmentOffset.
            self rodataSection
                dword: stackAllocatedObject stackSegmentOffset asUInt32;
                dword: stackAllocatedObject size asUInt32.
        }.

        ## Argument passign zone layout.
        stackFrameLayout argumentPassingZone values do: {:(MIRArgumentValue)argument :: Void |
            self assert: argument hasValidStackSegmentOffset.

            let argumentDescriptor := (argument stackSegmentOffset asInt16 << 2i16) | argument gcRootEntryType asInt16.
            self rodataSection sword: argumentDescriptor
        }.

        symbol
    }.
}.

public final class MIRGlobalDataAsmCodeGenerator superclass: MIRAsmCodeGenerator; definition: {
    public field moduleGenerator => MIRModuleAsmCodeGenerator.
    public field isThreadLocal => Boolean.
    public field hasInitialValue => Boolean.
    public field asmVariable => AsmProgramEntity.
    public field dataStream => AsmStreamBuilder.

    public method generateGlobalVariable: (globalToGenerate: MIRGlobalVariable) withSymbol: (symbol: AsmSymbol) ::=> Void := {
        globalToGenerate isExternal ifTrue: {
            globalToGenerate sourceProgramEntity ifNotNil: {
                moduleGenerator targetModule addSourceProgramEntity: globalToGenerate sourceProgramEntity importedSymbol: symbol
            }.
            moduleGenerator targetModule addImportedSymbol: symbol.
            return: void
        }.

        asmVariable := moduleGenerator targetModule newProgramEntity.
        asmVariable
            debugSourcePosition: globalToGenerate debugSourcePosition;
            debugSourceNode: globalToGenerate debugSourceNode;
            debugSourceEnvironment: globalToGenerate debugSourceEnvironment;
            sourceProgramEntity: globalToGenerate sourceProgramEntity;
            contentSymbol: symbol. 

        isThreadLocal := globalToGenerate isThreadLocal.
        hasInitialValue := globalToGenerate initialValue isNotNil.

        dataStream := asmVariable newStreamBuilder.
        self selectDataSection.
        dataStream
            align: globalToGenerate valueAlignment;
            label: symbol.
        hasInitialValue ifTrue: {
            error("TODO: generateGlobalVariable initial value")
        } ifFalse: {
            dataStream reserveBytes: globalToGenerate valueSize
        }.

        dataStream endLabel: symbol.
    }.

    public method selectDataSection => Void := {
        isThreadLocal ifTrue: {
            moduleGenerator asmTarget isWindows ifTrue: {
                dataStream tlsSection
            } ifFalse: {
                hasInitialValue ifTrue: {
                    dataStream tdataSection.
                } ifFalse: {
                    dataStream tbssSection.
                }
            }.
        } ifFalse: {
            hasInitialValue ifTrue: {
                dataStream dataSection.
            } ifFalse: {
                dataStream bssSection.
            }.
        }.
    }
}.

MIROperation extend: {
    public method forTarget: (target: Symbol) generateWith: (codeGenerationBlock: (MIRInstruction, MIRFunctionAsmCodeGenerator) => Void) ::=> Void := {
        let targetSpecific => MIROperationTargetSpecific := self perform: target.
        targetSpecific codeGenerator: codeGenerationBlock
    }.
    
    public method forTargets: (targets: Array) generateWith: (codeGenerationBlock: (MIRInstruction, MIRFunctionAsmCodeGenerator) => Void) ::=> Void := {
        targets do: {:(Symbol)eachTarget :: Void |
            self forTarget: eachTarget generateWith: codeGenerationBlock
        }
    }.

    let CodegenFunctionType := (MIRInstruction, MIRFunctionAsmCodeGenerator) => Void.
    public method generate: (instruction: MIRInstruction) for: (target: MIRAsmCompilationTarget) with: (functionGenerator: MIRFunctionAsmCodeGenerator) ::=> Void := {
        let targetSpecific := target getTargetSpecificBlockFor: self.
        targetSpecific isNil || targetSpecific codeGenerator isNil ifTrue: {
            self error: "Missing code generation for MIR operation '" -- name printString -- "' in " -- target name asString -- "."
        }.
        
        let codegen => CodegenFunctionType := targetSpecific codeGenerator.
        codegen(instruction, functionGenerator).
    }.
}.

MIRValue definition: {
    public virtual method asm::immediate8For: (codegen: MIRAsmCodeGenerator) ::=> AsmImmediate
        := self error: "Not an immediate 8 value.".

    public virtual method asm::immediate16For: (codegen: MIRAsmCodeGenerator) ::=> AsmImmediate
        := self error: "Not an immediate 16 value.".

    public virtual method asm::immediate32For: (codegen: MIRAsmCodeGenerator) ::=> AsmImmediate
        := self error: "Not an immediate 32 value.".

    public virtual method asm::immediateS32For: (codegen: MIRAsmCodeGenerator) ::=> AsmImmediate
        := self error: "Not an immediate signed 32 value.".

    public virtual method asm::immediateCall32For: (codegen: MIRAsmCodeGenerator) ::=> AsmImmediate
        := self asm::immediate32For: codegen.

    public virtual method asm::immediate64For: (codegen: MIRAsmCodeGenerator) ::=> AsmImmediate
        := self error: self printString -- " is not an immediate 64 value.".

    public virtual method asm::makeStackMapLocationWith: (codegen: MIRAsmCodeGenerator) ::=> AsmStackMapLocation
        := nil.
}.

MIRProgramEntity definition: {
    public virtual method generateAssemblySymbolWith: (moduleGenerator: MIRModuleAsmCodeGenerator) ::=> AsmSymbol := {
        let symbol := AsmSymbol new
            name: name;
            yourself.
        name ifNotNil: {
            symbol makePublic.
            self isWeak ifTrue: (symbol makeWeak).
            self isPrivate ifTrue: (symbol makePrivate).
        }.
        self isThreadLocal ifTrue: (symbol makeTLS).
        
        symbol
    }.

    public abstract method generateAssemblyWith: (moduleGenerator: MIRModuleAsmCodeGenerator) symbol: (symbol: AsmSymbol) ::=> Void
        := self subclassResponsibility.

    public override method asm::immediate32For: (codegen: MIRAsmCodeGenerator) ::=> AsmImmediate
        := (codegen symbolForProgramEntity: self) dword.

    public override method asm::immediate64For: (codegen: MIRAsmCodeGenerator) ::=> AsmImmediate
        := (codegen symbolForProgramEntity: self) qword.
}.

MIRImportedProgramEntity definition: {
    public override method generateAssemblyWith: (moduleGenerator: MIRModuleAsmCodeGenerator) symbol: (symbol: AsmSymbol) ::=> Void := {
        sourceProgramEntity ifNotNil: {
            moduleGenerator targetModule addSourceProgramEntity: sourceProgramEntity importedSymbol: symbol
        }.

        moduleGenerator targetModule addImportedSymbol: symbol
    }.

    public override method asm::immediateCall32For: (codegen: MIRAsmCodeGenerator) ::=> AsmImmediate := {
        codegen target hasPositionIndependentCode ifTrue: {
            (codegen symbolForProgramEntity: self) dword
                makeAtPLT;
                yourself.
        } ifFalse: {
            (codegen symbolForProgramEntity: self) dword
        }.
    }.
}.

MIRBasicBlock definition: {
    public override method asm::immediateCall32For: (codegen: MIRAsmCodeGenerator) ::=> AsmImmediate
        := (codegen symbolForBasicBlock: self) dword.
}.

MIRFunction definition: {
    public override method generateAssemblySymbolWith: (moduleGenerator: MIRModuleAsmCodeGenerator) ::=> AsmSymbol := {
        (super generateAssemblySymbolWith: moduleGenerator)
            makeFunction;
            yourself
    }.

    public override method generateAssemblyWith: (moduleGenerator: MIRModuleAsmCodeGenerator) symbol: (symbol: AsmSymbol) ::=> Void := {
        MIRFunctionAsmCodeGenerator new
            target: moduleGenerator target;
            moduleGenerator: moduleGenerator;
            generateFunction: self withSymbol: symbol
    }.
}.

MIRGlobalVariable definition: {
    public override method generateAssemblyWith: (moduleGenerator: MIRModuleAsmCodeGenerator) symbol: (symbol: AsmSymbol) ::=> Void := {
        MIRGlobalDataAsmCodeGenerator new
            target: moduleGenerator target;
            moduleGenerator: moduleGenerator;
            generateGlobalVariable: self withSymbol: symbol
    }.
}.

MIRConstantUInt8 definition: {
    public override method asm::immediate8For: (codegen: MIRAsmCodeGenerator) ::=> AsmImmediate
        := value asAsmImmediate.

    public override method asm::immediate16For: (codegen: MIRAsmCodeGenerator) ::=> AsmImmediate
        := value asUInt16 asAsmImmediate.

    public override method asm::immediate32For: (codegen: MIRAsmCodeGenerator) ::=> AsmImmediate
        := value asUInt32 asAsmImmediate.

    public override method asm::immediateS32For: (codegen: MIRAsmCodeGenerator) ::=> AsmImmediate
        := value asInt32 asAsmImmediate.

    public override method asm::immediate64For: (codegen: MIRAsmCodeGenerator) ::=> AsmImmediate
        := value asUInt64 asAsmImmediate.
}.

MIRConstantInt8 definition: {
    public override method asm::immediate8For: (codegen: MIRAsmCodeGenerator) ::=> AsmImmediate
        := value asAsmImmediate.

    public override method asm::immediate16For: (codegen: MIRAsmCodeGenerator) ::=> AsmImmediate
        := value asInt16 asAsmImmediate.

    public override method asm::immediate32For: (codegen: MIRAsmCodeGenerator) ::=> AsmImmediate
        := value asInt32 asAsmImmediate.

    public override method asm::immediateS32For: (codegen: MIRAsmCodeGenerator) ::=> AsmImmediate
        := value asInt32 asAsmImmediate.

    public override method asm::immediate64For: (codegen: MIRAsmCodeGenerator) ::=> AsmImmediate
        := value asInt64 asAsmImmediate.
}.

MIRConstantUInt16 definition: {
    public override method asm::immediate8For: (codegen: MIRAsmCodeGenerator) ::=> AsmImmediate
        := value asUInt8 asAsmImmediate.

    public override method asm::immediate16For: (codegen: MIRAsmCodeGenerator) ::=> AsmImmediate
        := value asAsmImmediate.

    public override method asm::immediate32For: (codegen: MIRAsmCodeGenerator) ::=> AsmImmediate
        := value asUInt32 asAsmImmediate.

    public override method asm::immediateS32For: (codegen: MIRAsmCodeGenerator) ::=> AsmImmediate
        := value asInt32 asAsmImmediate.

    public override method asm::immediate64For: (codegen: MIRAsmCodeGenerator) ::=> AsmImmediate
        := value asUInt64 asAsmImmediate.
}.

MIRConstantInt16 definition: {
    public override method asm::immediate8For: (codegen: MIRAsmCodeGenerator) ::=> AsmImmediate
        := value asUInt8 asAsmImmediate.

    public override method asm::immediate16For: (codegen: MIRAsmCodeGenerator) ::=> AsmImmediate
        := value asAsmImmediate.

    public override method asm::immediate32For: (codegen: MIRAsmCodeGenerator) ::=> AsmImmediate
        := value asInt32 asAsmImmediate.

    public override method asm::immediateS32For: (codegen: MIRAsmCodeGenerator) ::=> AsmImmediate
        := value asInt32 asAsmImmediate.

    public override method asm::immediate64For: (codegen: MIRAsmCodeGenerator) ::=> AsmImmediate
        := value asInt64 asAsmImmediate.
}.

MIRConstantUInt32 definition: {
    public override method asm::immediate8For: (codegen: MIRAsmCodeGenerator) ::=> AsmImmediate
        := value asUInt8 asAsmImmediate.

    public override method asm::immediate32For: (codegen: MIRAsmCodeGenerator) ::=> AsmImmediate
        := value asAsmImmediate.

    public override method asm::immediate64For: (codegen: MIRAsmCodeGenerator) ::=> AsmImmediate
        := value asUInt64 asAsmImmediate.
}.

MIRConstantInt32 definition: {
    public override method asm::immediate8For: (codegen: MIRAsmCodeGenerator) ::=> AsmImmediate
        := value asUInt8 asAsmImmediate.

    public override method asm::immediate32For: (codegen: MIRAsmCodeGenerator) ::=> AsmImmediate
        := value asAsmImmediate.

    public override method asm::immediateS32For: (codegen: MIRAsmCodeGenerator) ::=> AsmImmediate
        := value asAsmImmediate.

    public override method asm::immediate64For: (codegen: MIRAsmCodeGenerator) ::=> AsmImmediate
        := value asInt64 asAsmImmediate.
}.

MIRConstantUInt64 definition: {
    public override method asm::immediate8For: (codegen: MIRAsmCodeGenerator) ::=> AsmImmediate
        := value asUInt8 asAsmImmediate.

    public override method asm::immediateS32For: (codegen: MIRAsmCodeGenerator) ::=> AsmImmediate := {
        self assert: value asInt32 asInt64 asUInt64 = value.
        value asInt32 asAsmImmediate
    }.

    public override method asm::immediate64For: (codegen: MIRAsmCodeGenerator) ::=> AsmImmediate
        := value asAsmImmediate.
}.

MIRConstantInt64 definition: {
    public override method asm::immediate8For: (codegen: MIRAsmCodeGenerator) ::=> AsmImmediate
        := value asUInt8 asAsmImmediate.

    public override method asm::immediateS32For: (codegen: MIRAsmCodeGenerator) ::=> AsmImmediate := {
        self assert: value asInt32 asInt64 = value.
        value asInt32 asAsmImmediate
    }.

    public override method asm::immediate64For: (codegen: MIRAsmCodeGenerator) ::=> AsmImmediate
        := value asAsmImmediate.
}.

MIRPhysicalLocation definition: {
    public virtual method asm::canonicalRegister => AsmRegister
        := self error: self printString -- " is not a register location.".

    public virtual method makeStackMapLocation => AsmStackMapLocation
        := nil.
}.

MIRPhysicalLocationRegister definition: {
    public override method makeStackMapLocation => AsmStackMapLocation
        := AsmStackMapLocationRegister new register: (self asm::canonicalRegister); yourself
}.

MIRPhysicalLocationRegisterPair definition: {
    public override method makeStackMapLocation => AsmStackMapLocation
        := AsmStackMapLocationRegister new register: (firstComponent asm::canonicalRegister); yourself
}.

MIRLocalValue definition: {
    public override method asm::makeStackMapLocationWith: (codegen: MIRAsmCodeGenerator) ::=> AsmStackMapLocation := {
        let coalescedAssignedRegister := self coalescedAssignedRegister.
        coalescedAssignedRegister ifNotNil: {
            coalescedAssignedRegister makeStackMapLocation
        } ifNil: {
            self needsStackAllocation ifTrue: {
                AsmStackMapLocationFrameOffset new offset: offset; yourself
            } ifFalse: {
                nil
            }
        }
    }
}.

MIRValuePointer definition: {
    public override method asm::makeStackMapLocationWith: (codegen: MIRAsmCodeGenerator) ::=> AsmStackMapLocation
        := value asm::makeStackMapLocationWith: codegen.
}.

MIRCaptureVariable definition: {
    public override method asm::makeStackMapLocationWith: (codegen: MIRAsmCodeGenerator) ::=> AsmStackMapLocation := {
        let coalescedAssignedRegister := self coalescedAssignedRegister.
        coalescedAssignedRegister ifNotNil: {
            coalescedAssignedRegister makeStackMapLocation
        } ifNil: {
            let captureVectorPointerLocation := codegen captureVectorPointerStackMapLocation.
            captureVectorPointerLocation ifNotNil: {
                AsmStackMapLocationCaptureOffset new
                    captureVectorPointer: captureVectorPointerLocation;
                    offset: codegen captureVectorDataOffset asInt64 + offset;
                    yourself
            }
        }
    }
}.
