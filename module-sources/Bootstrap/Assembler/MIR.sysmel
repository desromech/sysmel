AsmStreamBuilder extend: {
    public method useDebugInfoOfMIRValue: (value: MIRValue) ::=> Void := {
        debugSourcePosition := value debugSourcePosition.
        debugSourceNode := value debugSourceNode.
        debugSourceEnvironment := value debugSourceEnvironment.
    }
}.

public abstract class MIRAsmCompilationTarget superclass: MIRCompilationTarget; definition: {
    public field asmCompilationTarget => AsmCompilationTarget.

    public override method pointerSize => Size
        := asmCompilationTarget pointerSize.

    public override method pointerAlignment => Size
        := asmCompilationTarget pointerSize.

    public override method uintPointerType => Type
        := asmCompilationTarget uintPointerType.

    public override method stackFrameAlignment => Size
        := asmCompilationTarget stackFrameAlignment.

    public override method generateTargetIRForMIRModule: (module: MIRModule) ::=> AnyValue := {
        let codeGenerator := MIRModuleAsmCodeGenerator new
            target: self;
            asmTarget: asmCompilationTarget;
            targetModule: (AsmProgramEntity new
                compilationTarget: asmCompilationTarget;
                yourself);
            compileModule: module;
            targetModule
    }.
}.

public abstract class MIRAsmCodeGenerator superclass: Object; definition: {
    public field target => MIRAsmCompilationTarget.

    public abstract method symbolForProgramEntity: (programEntity: MIRProgramEntity) ::=> AsmSymbol
        := self subclassResponsibility.

    public abstract method symbolForBasicBlock: (basicBlock: MIRBasicBlock) ::=> AsmSymbol
        := self subclassResponsibility.

    public virtual method captureVectorPointerStackMapLocation => AsmStackMapLocation
        := nil.

    public abstract method captureVectorDataOffset => Size
        := self subclassResponsibility.
}.

public final class MIRModuleAsmCodeGenerator superclass: MIRAsmCodeGenerator; definition: {
    public field targetModule => AsmProgramEntity.
    protected field asmTarget => AsmCompilationTarget.
    public field programEntitySymbolMap => Dictionary.
    public field compiledProgramEntitySymbolMap => Dictionary.

    protected field stringTableList => OrderedCollection.
    protected field stringTableDictionary => Dictionary.

    protected field objectHeap => AsmObjectHeap.

    protected field picTableDictionary => Dictionary.
    protected field picTableSymbol => AsmSymbol.

    public override method initialize => Void := {
        programEntitySymbolMap := Dictionary new.
        compiledProgramEntitySymbolMap := Dictionary new.
        objectHeap := AsmObjectHeap new.
        stringTableList := OrderedCollection new.
        stringTableDictionary := Dictionary new.
        picTableDictionary := IdentityDictionary new. 
    }.

    public method asmTarget => AsmCompilationTarget := asmTarget.
    public method asmTarget: (target: AsmCompilationTarget) ::=> Void := {
        asmTarget := target.
        objectHeap compilationTarget: target.
    }.

    public override method symbolForProgramEntity: (programEntity: MIRProgramEntity) ::=> AsmSymbol := {
        programEntitySymbolMap at: programEntity ifAbsentPut: {:: AsmSymbol |
            programEntity generateAssemblySymbolWith: self
        }
    }.

    public method symbolOfStringLiteral: (string: String) nullTerminated: (nullTerminated: Boolean) ::=> AsmSymbol := {
        let key := Array with: string with: nullTerminated.
        stringTableDictionary at: key ifAbsentPut: {:: AsmSymbol |
            let stringSymbol := AsmSymbol new
                makePrivate;
                yourself.

            stringTableList add: (Array with: stringSymbol with: key).
            stringSymbol
        }
    }.

    public method compileProgramEntity: (programEntity: MIRProgramEntity) ::=> AsmSymbol := {
        compiledProgramEntitySymbolMap at: programEntity ifAbsent: {:: AsmSymbol |
            let symbol := self symbolForProgramEntity: programEntity.
            compiledProgramEntitySymbolMap at: programEntity put: symbol.
            programEntity generateAssemblyWith: self symbol: symbol.
            symbol
        }
    }.

    public method imageObjectTrace => ImageObjectTrace
        := objectHeap objectTrace.

    public method compileModule: (module: MIRModule) ::=> Void := {
        ## Use the module image base object trace for constructing the object heap.
        objectHeap baseObjectTracer: module baseObjectTracer.

        targetModule contentSymbol ifNil: {
            let compileUnitSymbol := AsmSymbol new name: #compileUnit; makePrivate; yourself.
            targetModule newStreamBuilder
                textSection;
                label: compileUnitSymbol.
            targetModule newEndStreamBuilder
                textSection;
                endLabel: compileUnitSymbol.
            targetModule contentSymbol: compileUnitSymbol.
        }.

        module programEntities do: {:(MIRProgramEntity)eachProgramEntity :: Void |
            self compileProgramEntity: eachProgramEntity
        }.

        module functionDefinitionPatches do: {:(MIRFunctionDefinitionPatch)tacPatch :: Void |
            objectHeap tracer addObject: tacPatch functionDefinition patch: (ImageFunctionDefinitionEntryPointAsmPatch new
                functionDefinition: tacPatch functionDefinition;
                checkedEntryPoint: (compiledProgramEntitySymbolMap atOrNil: tacPatch checkedEntryPoint);
                uncheckedEntryPoint: (compiledProgramEntitySymbolMap atOrNil: tacPatch uncheckedEntryPoint);
                uncheckedCapturelessEntryPoint: (compiledProgramEntitySymbolMap atOrNil: tacPatch uncheckedCapturelessEntryPoint);
                yourself)
        }.

        self buildPICTable.
        self buildStringLiterals.
        asmTarget debugInformationGenerator ifNotNil: {:(AsmObjectDebugInformationGenerator class)generatorClass :: Void |
            let generator := generatorClass new.
            targetModule debugInformationGenerator: generator.
            generator generateDebugInformationForModule: targetModule
        }.
        
        {|
            objectHeap buildIn: targetModule.
        } printTimeToRunInMicrosecondsWithTitle: "Assembler object heap"
    }.

    public method offsetOfGCRootObjectTableEntryFor: (object: Untyped) ::=> Size
        := objectHeap offsetOfGCRootObjectTableEntryFor: object.

    public method gcRootObjectTableSymbol ::=> AsmSymbol
        := objectHeap rootObjectTableSymbol.

    public method picTableSymbol ::=> AsmSymbol
        := picTableSymbol ifNil: { picTableSymbol := AsmSymbol new
            name: #sysmelPICTable;
            makePublic;
            yourself
        }.

    public method offsetOfPICTableEntryFor: (picEntry: MIRPolymorphicInlineCache) ::=> Size
        := picTableDictionary at: picEntry ifAbsentPut: { :: Size |
            picTableDictionary size * ObjectModel::PolymorphicInlineCache instanceSize
        }.

    public method buildPICTable => Void := {
        picTableDictionary isEmpty ifTrue: (return: void).

        let picTable := targetModule newProgramEntity.
        let picTableSection := picTable newStreamBuilder
            bssSection;
            align: ObjectModel::PolymorphicInlineCache instanceAlignment;
            label: self picTableSymbol;
            reserveBytes: picTableDictionary size * ObjectModel::PolymorphicInlineCache instanceSize;
            endLabel: self picTableSymbol
    }.

    public method buildStringLiterals => Void := {
        stringTableList size = 0sz ifTrue: (return: void).

        let stringTable := targetModule newProgramEntity.
        let stringTableSection := stringTable newStreamBuilder
            rodataSection;
            yourself.

        stringTableList do: {:(Array)each :: Void |
            let symbol := each first.
            let string => String := each second first.
            let nullTerminated => Boolean := each second second.
            stringTableSection
                label: symbol;
                string: string nullTerminated: nullTerminated;
                endLabel: symbol.
        }
    }.
}.

public final class MIRFunctionAsmCodeGenerator superclass: MIRAsmCodeGenerator; definition: {
    public field moduleGenerator => MIRModuleAsmCodeGenerator.
    public field function => MIRFunction.
    public field asmFunction => AsmProgramEntity.
    public field stackMap => AsmStackMap.
    private field basicBlockSymbolDictionary => IdentityDictionary.

    public field registerAllocator => MIRRegisterAllocator.
    public field stackFrameLayout => MIRStackFrameLayout.
    private field constantSymbolDictionary => Dictionary.

    protected field textSection => AsmStreamBuilder.
    public method textSection => AsmStreamBuilder
        := textSection ifNil: (textSection := asmFunction newStreamBuilder
            textSection;
            yourself).

    protected field rodataSection => AsmStreamBuilder.
    public method rodataSection => AsmStreamBuilder
        := rodataSection ifNil: (rodataSection := asmFunction newStreamBuilder
            rodataSection;
            yourself).

    protected field captureVectorPointerRegister => MIRPhysicalLocation.

    public method validCaptureVectorPointerRegister => MIRPhysicalLocation := {
        captureVectorPointerRegister ifNil: (self error: "Cannot use unloaded capture vector pointer register").
        captureVectorPointerRegister
    }.

    public field closureArgument => MIRArgumentValue.
    public field captureVectorDataOffset => Size.
    public field closureCaptureVectorMemberOffset => Size.

    public method generateFunction: (functionToGenerate: MIRFunction) withSymbol: (symbol: AsmSymbol) ::=> Void := {
        function := functionToGenerate.
        asmFunction := moduleGenerator targetModule newProgramEntity.
        stackMap := AsmStackMap new.
        constantSymbolDictionary := Dictionary new.
        asmFunction
            debugSourcePosition: functionToGenerate debugSourcePosition;
            debugSourceNode: functionToGenerate debugSourceNode;
            debugSourceEnvironment: functionToGenerate debugSourceEnvironment;
            stackMap: stackMap;
            sourceProgramEntity: functionToGenerate sourceProgramEntity;
            contentSymbol: symbol.

        functionToGenerate trampolineTarget ifNotNil: {
            asmFunction trampolineTarget: (moduleGenerator symbolForProgramEntity: functionToGenerate trampolineTarget)
        }.

        self prepareToGenerateFunction.

        self textSection
            align: moduleGenerator asmTarget indirectBranchTargetAlignment unreachable: true;
            useDebugInfoOfMIRValue: functionToGenerate;
            label: symbol;
            yourself.

        let exportedSymbols := functionToGenerate exportedSymbols collect: {:(Symbol)symbol :: AsmSymbol |
            AsmSymbol new
                name: symbol;
                makePublic;
                makeFunction;
                yourself
        }.

        exportedSymbols do: {:(AsmSymbol)eachSymbol :: Void |
            self textSection label: eachSymbol
        }.

        self textSection cfiBeginProcedure.

        self
            emitPrologue;
            emitStackFrameConstruction;
            generateStackMap.

        function basicBlocksDo: {:(MIRBasicBlock)basicBlock :: Void |
            self generateBasicBlock: basicBlock
        }.

        self textSection
            cfiEndProcedure;
            endLabel: symbol.
        exportedSymbols do: {:(AsmSymbol)eachSymbol :: Void |
            self textSection endLabel: eachSymbol
        }.
    }.

    MIRAsmCompilationTarget extend: {
        public abstract method emitFunctionPrologueWith: (generator: MIRFunctionAsmCodeGenerator) ::=> Void
            := self subclassResponsibility.

        public abstract method emitStackFrameConstructionWith: (generator: MIRFunctionAsmCodeGenerator) ::=> Void
            := self subclassResponsibility.

        public abstract method emitFunctionEpilogueWith: (generator: MIRFunctionAsmCodeGenerator) ::=> Void
            := self subclassResponsibility.
        
        public virtual method emitInstruction: (instruction: MIRInstruction) with: (generator: MIRFunctionAsmCodeGenerator) ::=> Void
            := instruction operation generate: instruction for: self with: generator.
        
        public abstract method emitMoveValue: (value: MIRValue) intoLocation: (register: MIRPhysicalLocation) with: (generator: MIRFunctionAsmCodeGenerator) ::=> Void
            := self subclassResponsibility.

        public abstract method emitUnspillValue: (value: MIRValue) intoLocation: (register: MIRPhysicalLocation) with: (generator: MIRFunctionAsmCodeGenerator) ::=> Void
            := self subclassResponsibility.

        public abstract method emitMoveValuePointer: (value: MIRValue) intoLocation: (register: MIRPhysicalLocation) with: (generator: MIRFunctionAsmCodeGenerator) ::=> Void
            := self subclassResponsibility.

        public abstract method emitMoveRegister: (register: MIRPhysicalLocation) intoValue: (value: MIRValue) with: (generator: MIRFunctionAsmCodeGenerator) ::=> Void
            := self subclassResponsibility.

        public abstract method emitLoadCaptureVectorPointerFromClosure: (closurePointer: MIRPhysicalLocation) intoRegister: (register: MIRPhysicalLocation) with: (generator: MIRFunctionAsmCodeGenerator) ::=> Void
            := self subclassResponsibility.
    }.

    MIRCallingConvention extend: {
        public abstract method asm::generateCallInt8: (instruction: MIRInstruction) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void
            := self subclassResponsibility.

        public abstract method asm::generateCallInt16: (instruction: MIRInstruction) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void
            := self subclassResponsibility.

        public abstract method asm::generateCallInt32: (instruction: MIRInstruction) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void
            := self subclassResponsibility.

        public abstract method asm::generateCallInt64: (instruction: MIRInstruction) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void
            := self subclassResponsibility.

        public abstract method asm::generateCallPointer: (instruction: MIRInstruction) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void
            := self subclassResponsibility.

        public abstract method asm::generateCallFloat32: (instruction: MIRInstruction) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void
            := self subclassResponsibility.

        public abstract method asm::generateCallFloat64: (instruction: MIRInstruction) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void
            := self subclassResponsibility.

        public abstract method asm::generateCallStruct: (instruction: MIRInstruction) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void
            := self subclassResponsibility.

        public abstract method asm::generateCallVoid: (instruction: MIRInstruction) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void
            := self subclassResponsibility.
    }.

    public method computeArgumentPassingLayout => Void := {
        function callingConvention computeArgumentPassingLayoutOf: function
    }.

    public method performRegisterAllocation => Void := {
        registerAllocator := MIRLinearScanRegisterAllocator new.
        registerAllocator allocateRegistersIn: function withTarget: moduleGenerator target.
    }.

    public method buildStackFrameLayout => Void := {
        stackFrameLayout := MIRStackFrameLayout new.
        stackFrameLayout buildLayoutForFunction: function withTarget: moduleGenerator target
    }.

    public method prepareToGenerateFunction => Void := {
        function captures isNotEmpty ifTrue: {
            closureArgument := function arguments first.
            captureVectorDataOffset := function compilationTarget objectModel objectHeaderSize.
            ## FIXME: Delegate this offset computation onto the compilation target.
            closureCaptureVectorMemberOffset := function compilationTarget objectModel objectHeaderSize + (Function lookupSlot: #captureVector) validOffset.
        }.

        self
            computeArgumentPassingLayout;
            performRegisterAllocation;
            buildStackFrameLayout.

        ## Generate a private label per basic block.
        basicBlockSymbolDictionary := IdentityDictionary new.
        function basicBlocksDo: {:(MIRBasicBlock)basicBlock :: Void |
            basicBlockSymbolDictionary at: basicBlock put: (AsmSymbol new
                name: basicBlock name;
                makePrivate;
                yourself).
        }.
    }.

    public method emitPrologue => Void := {
        moduleGenerator target emitFunctionPrologueWith: self
    }.

    public method emitEpilogue => Void := {
        moduleGenerator target emitFunctionEpilogueWith: self
    }.

    public method emitStackFrameConstruction => Void := {
        moduleGenerator target emitStackFrameConstructionWith: self
    }.

    protected field captureVectorPointerStackMapLocation => AsmStackMapLocation.
    
    public override method captureVectorPointerStackMapLocation => AsmStackMapLocation := captureVectorPointerStackMapLocation.

    public method generateStackMap => Void := {
        function arguments do: {:(MIRLocalValue)eachLocal :: Void |
            eachLocal sourceBinding ifNotNil: {:(SymbolBinding)binding :: Void |
                let location := eachLocal asm::makeStackMapLocationWith: self.
                location ifNotNil: {
                    stackMap addArgumentBindingMap: (stackMap setBinding: binding location: location)
                }.
            }
        }.

        ## Make the capture vector pointer stack map location.
        function captureVectorPointerValue ifNotNil: {
            captureVectorPointerStackMapLocation := function captureVectorPointerValue asm::makeStackMapLocationWith: self.
        }.

        function captures do: {:(MIRLocalValue)eachLocal :: Void |
            eachLocal sourceBinding ifNotNil: {:(SymbolBinding)binding :: Void |
                let location := eachLocal asm::makeStackMapLocationWith: self.
                location ifNotNil: {
                    stackMap addCaptureBindingMap: (stackMap setBinding: binding location: location)
                }.
            }
        }.
    }.

    public method emitSpillRegisterArgumentsInStackFrame => Void := {
        function arguments do: {:(MIRArgumentValue)eachArgument :: Void |
            let passingRegister := eachArgument passingRegister.
            passingRegister isNotNil && eachArgument needsStackAllocation ifTrue: {
                self emitMoveRegister: passingRegister intoValue: eachArgument
            }.
        }.
    }.

    public method emitUnspillEntryValuesFromStackFrame => Void := {
        let unspillValue := {:(MIRLocalValue)eachLocal :: Void |
            eachLocal coalescedAssignedRegister ifNil: {return: void}.

            eachLocal isArgumentVariable ifTrue: {
                let argument := eachLocal downCastTo: MIRArgumentValue.
                argument passingRegister ifNotNil: {
                    ## Case already handled by emitSpillRegisterArgumentsInStackFrame
                    return: void
                }.
            }.

            self emitUnspillValue: eachLocal intoLocation: eachLocal coalescedAssignedRegister.
        }.

        function arguments do: unspillValue.
        function captureVectorPointerValue ifNotNil: {
            let captureVectorPointer := function captureVectorPointerValue.
            self emitMoveValue: function arguments first intoLocation: captureVectorPointer closureRegister.
            moduleGenerator target emitLoadCaptureVectorPointerFromClosure: captureVectorPointer closureRegister intoRegister: captureVectorPointer loadRegister with: self.
            self emitMoveRegister: captureVectorPointer loadRegister intoValue: captureVectorPointer.
            captureVectorPointerRegister := captureVectorPointer loadRegister.
        }.
        function captures do: unspillValue.
        captureVectorPointerRegister := nil.
    }.

    protected field firstPhiMoveInstruction => MIRInstruction.

    public method generateBasicBlock: (basicBlock: MIRBasicBlock) ::=> Void := {
        let blockSymbol := basicBlockSymbolDictionary at: basicBlock.
        self textSection
            useDebugInfoOfMIRValue: basicBlock;
            label: blockSymbol.
        firstPhiMoveInstruction := nil.
        basicBlock instructionsDo: {:(MIRInstruction)eachInstruction :: Void |
            self generateInstruction: eachInstruction
        }.

        self textSection
            useDebugInfoOfMIRValue: basicBlock;
            endLabel: blockSymbol.
    }.

    public method generateInstruction: (instruction: MIRInstruction) ::=> Void := {
        instruction isDebug ifTrue: {
            self processDebugInstruction: instruction.
            return: void
        }.

        self textSection useDebugInfoOfMIRValue: instruction.

        instruction isPhiInstruction ifTrue: {return: void}.

        instruction targetPhi ifNil: {
            firstPhiMoveInstruction ifNotNil: {
                self generatePhiMoves
            }
        } ifNotNil: {
            firstPhiMoveInstruction ifNil: {
                firstPhiMoveInstruction := instruction
            }
        }.

        captureVectorPointerRegister := instruction captureVectorPointerRegister.
        captureVectorPointerRegister ifNotNil: {
            self emitMoveValue: instruction captureVectorPointerValue intoLocation: captureVectorPointerRegister.
        }.
        instruction resultRegister isNotNil && instruction resultRegister isRegisterWithPointer ifTrue: {
            self emitMoveValue: instruction intoLocation: instruction resultRegister
        }.
        self emitMoveValues: instruction operands intoRegisters: instruction operandRegisters.

        moduleGenerator target emitInstruction: instruction with: self.

        ## Do we need to support multiple result values?
        instruction resultRegister isNotNil && instruction resultRegister isRegisterWithPointer not
        && instruction hasValidType && (instruction userCount > 0sz) ifTrue: {
            self emitMoveRegister: instruction resultRegister intoValue: instruction
        }.

        captureVectorPointerRegister := nil.
    }.

    public method generatePhiMoves => Void := {
        let position mutable := firstPhiMoveInstruction.
        while: (position isNotNil && position targetPhi isNotNil) do: {
            self copyFrom: position intoPhi: position targetPhi.
            position := position next
        }.

        firstPhiMoveInstruction := nil.
    }.

    public method copyFrom: (sourceValue: MIRInstruction) intoPhi: (targetPhi: MIRInstruction) ::=> Void := {
        ## Register into value case.
        (sourceValue resultRegister isNotNil && sourceValue resultRegister isRegisterWithPointer not) ifTrue: {
            sourceValue assignedRegister ifNil: {
                self emitMoveValue: sourceValue intoLocation: sourceValue resultRegister
            }.

            self emitMoveRegister: sourceValue resultRegister intoValue: targetPhi.
            return: void.
        }.

        ## Value into register case.
        (targetPhi resultRegister isNotNil && targetPhi resultRegister isRegisterWithPointer not) ifTrue: {
            self emitMoveValue: sourceValue intoLocation: targetPhi resultRegister.
            return: void.
        }.

        ## Memory - Memory copy.
        self error: "TODO: Phi memory memory copy".
    }.

    public method processDebugInstruction: (debugInstruction: MIRInstruction) ::=> Void := {
        self assert: (debugInstruction operation = MIR::Operation::DebugSetBindingValue)
            || (debugInstruction operation = MIR::Operation::DebugSetMutableBindingValue)
            || (debugInstruction operation = MIR::Operation::DebugSetMutableBindingSpecificValue).
        let value := debugInstruction operands first.
        let binding := debugInstruction sourceBinding.

        let location := value asm::makeStackMapLocationWith: self.
        location ifNotNil: {
            stackMap setLocalBinding: binding isMutable: debugInstruction operation ~= MIR::Operation::DebugSetBindingValue location: location
        }.
    }.

    public method emitMoveValues: (values: Array) intoRegisters: (registers: Array) ::=> Void := {
        values doWithIndex: {:(MIRValue)eachValue :(Size)valueIndex :: Void |
            self emitMoveValue: eachValue intoLocation: (registers at: valueIndex)
        }
    }.

    public method emitMoveValue: (value: MIRValue) intoLocation: (location: MIRPhysicalLocation) ::=> Void := {
        location isRegister ifTrue: {
            moduleGenerator target emitMoveValue: value intoLocation: location with: self.
        }.
        location isRegisterWithPointer ifTrue: {
            moduleGenerator target emitMoveValuePointer: value intoLocation: (location downCastTo: MIRPhysicalLocationRegisterWithPointer) register with: self.
        }.
    }.

    public method emitUnspillValue: (value: MIRValue) intoLocation: (location: MIRPhysicalLocation) ::=> Void := {
        self assert: location isRegister.
        moduleGenerator target emitUnspillValue: value intoLocation: location with: self.
    }.

    public method emitMoveRegister: (location: MIRPhysicalLocation) intoValue: (value: MIRValue) ::=> Void := {
        location isRegister ifTrue: {
            moduleGenerator target emitMoveRegister: location intoValue: value with: self.
        }
    }.

    public override method symbolForProgramEntity: (programEntity: MIRProgramEntity) ::=> AsmSymbol := {
        basicBlockSymbolDictionary at: programEntity ifAbsent: {|
            moduleGenerator symbolForProgramEntity: programEntity
        }
    }.

    public override method symbolForBasicBlock: (basicBlock: MIRBasicBlock) ::=> AsmSymbol
        := basicBlockSymbolDictionary at: basicBlock.

    public method symbolOfStringLiteral: (string: String) nullTerminated: (nullTerminated: Boolean) ::=> AsmSymbol
        := moduleGenerator symbolOfStringLiteral: string nullTerminated: nullTerminated.

    public method symbolOfStructureConstant: (structureConstant: MIRStructureConstant) ::=> AsmSymbol
        := constantSymbolDictionary at: (#uint8, structureConstant) ifAbsentPut: {:: AsmSymbol |
            let symbol := AsmSymbol new
                name: #structConstant;
                yourself.
            self rodataSection
                align: structureConstant alignment;
                label: symbol;
                structure: structureConstant value size: structureConstant size.
            symbol
        }.

    public method symbolForUInt8Constant: (constant: UInt8) ::=> AsmSymbol
        := constantSymbolDictionary at: (#uint8, constant) ifAbsentPut: {:: AsmSymbol |
            let symbol := AsmSymbol new
                name: #uint32Constant;
                yourself.
            self rodataSection label: symbol; byte: constant.
            symbol
        }.

    public method symbolForInt8Constant: (constant: Int8) ::=> AsmSymbol
        := constantSymbolDictionary at: (#int8, constant) ifAbsentPut: {:: AsmSymbol |
            let symbol := AsmSymbol new
                name: #int8Constant;
                yourself.
            self rodataSection label: symbol; sbyte: constant.
            symbol
        }.

    public method symbolForUInt16Constant: (constant: UInt16) ::=> AsmSymbol
        := constantSymbolDictionary at: (#uint32, constant) ifAbsentPut: {:: AsmSymbol |
            let symbol := AsmSymbol new
                name: #uint32Constant;
                yourself.
            self rodataSection align: 2sz; label: symbol; word: constant.
            symbol
        }.

    public method symbolForInt16Constant: (constant: Int16) ::=> AsmSymbol
        := constantSymbolDictionary at: (#int32, constant) ifAbsentPut: {:: AsmSymbol |
            let symbol := AsmSymbol new
                name: #uint16Constant;
                yourself.
            self rodataSection align: 2sz; label: symbol; sword: constant.
            symbol
        }.

    public method symbolForUInt32Constant: (constant: UInt32) ::=> AsmSymbol
        := constantSymbolDictionary at: (#uint32, constant) ifAbsentPut: {:: AsmSymbol |
            let symbol := AsmSymbol new
                name: #uint32Constant;
                yourself.
            self rodataSection align: 4sz; label: symbol; dword: constant.
            symbol
        }.

    public method symbolForInt32Constant: (constant: Int32) ::=> AsmSymbol
        := constantSymbolDictionary at: (#int32, constant) ifAbsentPut: {:: AsmSymbol |
            let symbol := AsmSymbol new
                name: #int32Constant;
                yourself.
            self rodataSection align: 4sz; label: symbol; sdword: constant.
            symbol
        }.

    public method symbolForUInt64Constant: (constant: UInt64) ::=> AsmSymbol
        := constantSymbolDictionary at: (#uint64, constant) ifAbsentPut: {:: AsmSymbol |
            let symbol := AsmSymbol new
                name: #uint64Constant;
                yourself.
            self rodataSection align: 8sz; label: symbol; qword: constant.
            symbol
        }.

    public method symbolForInt64Constant: (constant: Int64) ::=> AsmSymbol
        := constantSymbolDictionary at: (#int64, constant) ifAbsentPut: {:: AsmSymbol |
            let symbol := AsmSymbol new
                name: #int64Constant;
                yourself.
            self rodataSection align: 8sz; label: symbol; sqword: constant.
            symbol
        }.

    public method symbolForFloat32Constant: (constant: Float32) ::=> AsmSymbol
        := constantSymbolDictionary at: (#float32, constant) ifAbsentPut: {:: AsmSymbol |
            let symbol := AsmSymbol new
                name: #float32Constant;
                yourself.
            self rodataSection align: 4sz; label: symbol; float: constant.
            symbol
        }.

    public method symbolForFloat64Constant: (constant: Float64) ::=> AsmSymbol
        := constantSymbolDictionary at: (#float64, constant) ifAbsentPut: {:: AsmSymbol |
            let symbol := AsmSymbol new
                name: #float64Constant;
                yourself.
            self rodataSection align: 8sz; label: symbol; double: constant.
            symbol
        }.
}.

MIRInstructionSurroundingOperation definition: {
    public virtual method emitAssemblyWith: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {

    }.
}.

public final class MIRGlobalDataAsmCodeGenerator superclass: MIRAsmCodeGenerator; definition: {
    public field moduleGenerator => MIRModuleAsmCodeGenerator.
    public field asmVariable => AsmProgramEntity.
    public field dataStream => AsmStreamBuilder.

    public method generateGlobalVariable: (globalToGenerate: MIRGlobalVariable) withSymbol: (symbol: AsmSymbol) ::=> Void := {
        asmVariable := moduleGenerator targetModule newProgramEntity.
        asmVariable
            debugSourcePosition: globalToGenerate debugSourcePosition;
            debugSourceNode: globalToGenerate debugSourceNode;
            debugSourceEnvironment: globalToGenerate debugSourceEnvironment;
            sourceProgramEntity: globalToGenerate sourceProgramEntity;
            contentSymbol: symbol. 

        dataStream := asmVariable newStreamBuilder.
        self selectDataSection.
        dataStream label: symbol.

        dataStream endLabel: symbol.
    }.

    public method selectDataSection => Void := {
        dataStream dataSection.
    }
}.

MIROperation extend: {
    public method forTarget: (target: Symbol) generateWith: (codeGenerationBlock: (MIRInstruction, MIRFunctionAsmCodeGenerator) => Void) ::=> Void := {
        perTargetCodeGenerators at: target put: codeGenerationBlock
    }.
    
    public method forTargets: (targets: Array) generateWith: (codeGenerationBlock: (MIRInstruction, MIRFunctionAsmCodeGenerator) => Void) ::=> Void := {
        targets do: {:(Symbol)eachTarget :: Void |
            self forTarget: eachTarget generateWith: codeGenerationBlock
        }
    }.

    public method generate: (instruction: MIRInstruction) for: (target: MIRAsmCompilationTarget) with: (functionGenerator: MIRFunctionAsmCodeGenerator) ::=> Void := {
        let targetName := target name.
        (perTargetCodeGenerators at: targetName ifAbsent: {|
            self error: "Missing code generation for MIR operation '" -- name printString -- "' in " -- targetName asString -- "."
        }) (instruction, functionGenerator).
    }.
}.

MIRValue definition: {
    public virtual method asm::immediate8For: (codegen: MIRAsmCodeGenerator) ::=> AsmImmediate
        := self error: "Not an immediate 8 value.".

    public virtual method asm::immediate16For: (codegen: MIRAsmCodeGenerator) ::=> AsmImmediate
        := self error: "Not an immediate 16 value.".

    public virtual method asm::immediate32For: (codegen: MIRAsmCodeGenerator) ::=> AsmImmediate
        := self error: "Not an immediate 32 value.".

    public virtual method asm::immediateS32For: (codegen: MIRAsmCodeGenerator) ::=> AsmImmediate
        := self error: "Not an immediate signed 32 value.".

    public virtual method asm::immediateCall32For: (codegen: MIRAsmCodeGenerator) ::=> AsmImmediate
        := self asm::immediate32For: codegen.

    public virtual method asm::immediate64For: (codegen: MIRAsmCodeGenerator) ::=> AsmImmediate
        := self error: self printString -- " is not an immediate 64 value.".

    public virtual method asm::makeStackMapLocationWith: (codegen: MIRAsmCodeGenerator) ::=> AsmStackMapLocation
        := nil.
}.

MIRProgramEntity definition: {
    public virtual method generateAssemblySymbolWith: (moduleGenerator: MIRModuleAsmCodeGenerator) ::=> AsmSymbol := {
        let symbol := AsmSymbol new
            name: name;
            yourself.
        name ifNotNil: {
            symbol makePublic.
            self isWeak ifTrue: (symbol makeWeak).
            self isPrivate ifTrue: (symbol makePrivate).
        }.
        
        symbol
    }.

    public abstract method generateAssemblyWith: (moduleGenerator: MIRModuleAsmCodeGenerator) symbol: (symbol: AsmSymbol) ::=> Void
        := self subclassResponsibility.

    public override method asm::immediate32For: (codegen: MIRAsmCodeGenerator) ::=> AsmImmediate
        := (codegen symbolForProgramEntity: self) dword.

    public override method asm::immediate64For: (codegen: MIRAsmCodeGenerator) ::=> AsmImmediate
        := (codegen symbolForProgramEntity: self) qword.
}.

MIRImportedProgramEntity definition: {
    public override method generateAssemblyWith: (moduleGenerator: MIRModuleAsmCodeGenerator) symbol: (symbol: AsmSymbol) ::=> Void := {
        moduleGenerator targetModule addImportedSymbol: symbol
    }.

    public override method asm::immediateCall32For: (codegen: MIRAsmCodeGenerator) ::=> AsmImmediate
        := (codegen symbolForProgramEntity: self) dword makeAtPLT; yourself.
}.

MIRBasicBlock definition: {
    public override method asm::immediateCall32For: (codegen: MIRAsmCodeGenerator) ::=> AsmImmediate
        := (codegen symbolForBasicBlock: self) dword.
}.

MIRFunction definition: {
    public override method generateAssemblySymbolWith: (moduleGenerator: MIRModuleAsmCodeGenerator) ::=> AsmSymbol := {
        (super generateAssemblySymbolWith: moduleGenerator)
            makeFunction;
            yourself
    }.

    public override method generateAssemblyWith: (moduleGenerator: MIRModuleAsmCodeGenerator) symbol: (symbol: AsmSymbol) ::=> Void := {
        MIRFunctionAsmCodeGenerator new
            target: moduleGenerator target;
            moduleGenerator: moduleGenerator;
            generateFunction: self withSymbol: symbol
    }.
}.

MIRGlobalVariable definition: {
    public override method generateAssemblyWith: (moduleGenerator: MIRModuleAsmCodeGenerator) symbol: (symbol: AsmSymbol) ::=> Void := {
        MIRGlobalDataAsmCodeGenerator new
            target: moduleGenerator target;
            moduleGenerator: moduleGenerator;
            generateGlobalVariable: self withSymbol: symbol
    }.
}.

MIRConstantUInt8 definition: {
    public override method asm::immediate8For: (codegen: MIRAsmCodeGenerator) ::=> AsmImmediate
        := value asAsmImmediate.

    public override method asm::immediate16For: (codegen: MIRAsmCodeGenerator) ::=> AsmImmediate
        := value asUInt16 asAsmImmediate.

    public override method asm::immediate32For: (codegen: MIRAsmCodeGenerator) ::=> AsmImmediate
        := value asUInt32 asAsmImmediate.

    public override method asm::immediateS32For: (codegen: MIRAsmCodeGenerator) ::=> AsmImmediate
        := value asInt32 asAsmImmediate.

    public override method asm::immediate64For: (codegen: MIRAsmCodeGenerator) ::=> AsmImmediate
        := value asUInt64 asAsmImmediate.
}.

MIRConstantInt8 definition: {
    public override method asm::immediate8For: (codegen: MIRAsmCodeGenerator) ::=> AsmImmediate
        := value asAsmImmediate.

    public override method asm::immediate16For: (codegen: MIRAsmCodeGenerator) ::=> AsmImmediate
        := value asInt16 asAsmImmediate.

    public override method asm::immediate32For: (codegen: MIRAsmCodeGenerator) ::=> AsmImmediate
        := value asInt32 asAsmImmediate.

    public override method asm::immediateS32For: (codegen: MIRAsmCodeGenerator) ::=> AsmImmediate
        := value asInt32 asAsmImmediate.

    public override method asm::immediate64For: (codegen: MIRAsmCodeGenerator) ::=> AsmImmediate
        := value asInt64 asAsmImmediate.
}.

MIRConstantUInt16 definition: {
    public override method asm::immediate8For: (codegen: MIRAsmCodeGenerator) ::=> AsmImmediate
        := value asUInt8 asAsmImmediate.

    public override method asm::immediate16For: (codegen: MIRAsmCodeGenerator) ::=> AsmImmediate
        := value asAsmImmediate.

    public override method asm::immediate32For: (codegen: MIRAsmCodeGenerator) ::=> AsmImmediate
        := value asUInt32 asAsmImmediate.

    public override method asm::immediateS32For: (codegen: MIRAsmCodeGenerator) ::=> AsmImmediate
        := value asInt32 asAsmImmediate.

    public override method asm::immediate64For: (codegen: MIRAsmCodeGenerator) ::=> AsmImmediate
        := value asUInt64 asAsmImmediate.
}.

MIRConstantInt16 definition: {
    public override method asm::immediate8For: (codegen: MIRAsmCodeGenerator) ::=> AsmImmediate
        := value asUInt8 asAsmImmediate.

    public override method asm::immediate16For: (codegen: MIRAsmCodeGenerator) ::=> AsmImmediate
        := value asAsmImmediate.

    public override method asm::immediate32For: (codegen: MIRAsmCodeGenerator) ::=> AsmImmediate
        := value asInt32 asAsmImmediate.

    public override method asm::immediateS32For: (codegen: MIRAsmCodeGenerator) ::=> AsmImmediate
        := value asInt32 asAsmImmediate.

    public override method asm::immediate64For: (codegen: MIRAsmCodeGenerator) ::=> AsmImmediate
        := value asInt64 asAsmImmediate.
}.

MIRConstantUInt32 definition: {
    public override method asm::immediate8For: (codegen: MIRAsmCodeGenerator) ::=> AsmImmediate
        := value asUInt8 asAsmImmediate.

    public override method asm::immediate32For: (codegen: MIRAsmCodeGenerator) ::=> AsmImmediate
        := value asAsmImmediate.

    public override method asm::immediate64For: (codegen: MIRAsmCodeGenerator) ::=> AsmImmediate
        := value asUInt64 asAsmImmediate.
}.

MIRConstantInt32 definition: {
    public override method asm::immediate8For: (codegen: MIRAsmCodeGenerator) ::=> AsmImmediate
        := value asUInt8 asAsmImmediate.

    public override method asm::immediate32For: (codegen: MIRAsmCodeGenerator) ::=> AsmImmediate
        := value asAsmImmediate.

    public override method asm::immediateS32For: (codegen: MIRAsmCodeGenerator) ::=> AsmImmediate
        := value asAsmImmediate.

    public override method asm::immediate64For: (codegen: MIRAsmCodeGenerator) ::=> AsmImmediate
        := value asInt64 asAsmImmediate.
}.

MIRConstantUInt64 definition: {
    public override method asm::immediate8For: (codegen: MIRAsmCodeGenerator) ::=> AsmImmediate
        := value asUInt8 asAsmImmediate.

    public override method asm::immediateS32For: (codegen: MIRAsmCodeGenerator) ::=> AsmImmediate := {
        self assert: value asInt32 asInt64 asUInt64 = value.
        value asInt32 asAsmImmediate
    }.

    public override method asm::immediate64For: (codegen: MIRAsmCodeGenerator) ::=> AsmImmediate
        := value asAsmImmediate.
}.

MIRConstantInt64 definition: {
    public override method asm::immediate8For: (codegen: MIRAsmCodeGenerator) ::=> AsmImmediate
        := value asUInt8 asAsmImmediate.

    public override method asm::immediateS32For: (codegen: MIRAsmCodeGenerator) ::=> AsmImmediate := {
        self assert: value asInt32 asInt64 = value.
        value asInt32 asAsmImmediate
    }.

    public override method asm::immediate64For: (codegen: MIRAsmCodeGenerator) ::=> AsmImmediate
        := value asAsmImmediate.
}.

MIRPhysicalLocation definition: {
    public virtual method asm::canonicalRegister => AsmRegister
        := self error: "Not a register location."
}.

MIRLocalValue definition: {
    public override method asm::makeStackMapLocationWith: (codegen: MIRAsmCodeGenerator) ::=> AsmStackMapLocation := {
        let coalescedAssignedRegister := self coalescedAssignedRegister.
        coalescedAssignedRegister ifNotNil: {
            AsmStackMapLocationRegister new register: (coalescedAssignedRegister asm::canonicalRegister); yourself
        } ifNil: {
            self needsStackAllocation ifTrue: {
                AsmStackMapLocationFrameOffset new offset: offset; yourself
            } ifFalse: {
                nil
            }
        }
    }
}.

MIRValuePointer definition: {
    public override method asm::makeStackMapLocationWith: (codegen: MIRAsmCodeGenerator) ::=> AsmStackMapLocation
        := value asm::makeStackMapLocationWith: codegen.
}.

MIRCaptureVariable definition: {
    public override method asm::makeStackMapLocationWith: (codegen: MIRAsmCodeGenerator) ::=> AsmStackMapLocation := {
        let coalescedAssignedRegister := self coalescedAssignedRegister.
        coalescedAssignedRegister ifNotNil: {
            AsmStackMapLocationRegister new register: (coalescedAssignedRegister asm::canonicalRegister); yourself
        } ifNil: {
            let captureVectorPointerLocation := codegen captureVectorPointerStackMapLocation.
            captureVectorPointerLocation ifNotNil: {
                AsmStackMapLocationCaptureOffset new
                    captureVectorPointer: captureVectorPointerLocation;
                    offset: codegen captureVectorDataOffset asInt64 + offset;
                    yourself
            }
        }
    }
}.
