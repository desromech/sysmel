public final class AsmObjectHeap.

public abstract class AsmObjectHeapRootTableEntry superclass: Object; definition: {
    public abstract method writeIn: (asmHeap: AsmObjectHeap) rootTableOffset: (offset: Size) ::=> Void
        := self subclassResponsibility.

}.

public abstract class AsmObjectHeapRootTableEntryObjectPointer superclass: AsmObjectHeapRootTableEntry; definition: {
    public field index => Size.
}.

public final class AsmObjectHeapRootTableEntryObjectPointer32 superclass: AsmObjectHeapRootTableEntryObjectPointer; definition: {
    public override method writeIn: (asmHeap: AsmObjectHeap) rootTableOffset: (offset: Size) ::=> Void := {
        let objectOffset := asmHeap offsetForRootTableElementWithIndex: index.
        asmHeap serializedRootTableRelocations add: (AsmObjectCodeRelocationAbsoluteInt32 new
            symbol: asmHeap objectSectionStartSymbol;
            offset: offset;
            addend: objectOffset asInt32;
            yourself)
    }.
}.

public final class AsmObjectHeapRootTableEntryObjectPointer64 superclass: AsmObjectHeapRootTableEntryObjectPointer; definition: {
    public override method writeIn: (asmHeap: AsmObjectHeap) rootTableOffset: (offset: Size) ::=> Void := {
        let objectOffset := asmHeap offsetForRootTableElementWithIndex: index.
        asmHeap serializedRootTableRelocations add: (AsmObjectCodeRelocationAbsoluteInt64 new
            symbol: asmHeap objectSectionStartSymbol;
            offset: offset;
            addend: objectOffset asInt64;
            yourself)
    }.
}.

public final class AsmObjectHeapRootTableEntryImmediate32 superclass: AsmObjectHeapRootTableEntry; definition: {
    public field value => UInt32.

    public override method writeIn: (asmHeap: AsmObjectHeap) rootTableOffset: (offset: Size) ::=> Void := {
        asmHeap serializedRootTable uint32At: offset put: value
    }.
}.

public final class AsmObjectHeapRootTableEntryImmediate64 superclass: AsmObjectHeapRootTableEntry; definition: {
    public field value => UInt64.

    public override method writeIn: (asmHeap: AsmObjectHeap) rootTableOffset: (offset: Size) ::=> Void := {
        asmHeap serializedRootTable uint64At: offset put: value
    }.
}.

AsmObjectHeap definition: {
    public field compilationTarget => AsmCompilationTarget.
    public field hasFullRTTI => Boolean.

    protected field objectSectionStartSymbol => AsmSymbol.
    protected field objectSectionEndSymbol => AsmSymbol.
    public field tracer => ImageTracer.
    public field objectTrace => ImageObjectTrace.
    public field objectOffsetList => Array.

    public field serializedObjectData => ByteArray.
    public field serializedObjectDataRelocations => OrderedCollection.

    public field serializedRootTable => ByteArray.
    public field serializedRootTableRelocations => OrderedCollection.

    protected field objectPointerTableStartSymbol => AsmSymbol.
    protected field objectPointerTableEndSymbol => AsmSymbol.

    protected field objectFatPointerTableStartSymbol => AsmSymbol.
    protected field objectFatPointerTableEndSymbol => AsmSymbol.

    public field rootObjectList => OrderedCollection.
    public field rootTableEntries => OrderedCollection.
    protected field rootOffsetTable => IdentityDictionary.

    public override method initialize => Void := {
        rootObjectList := OrderedCollection new.
        rootTableEntries := OrderedCollection new.
        rootOffsetTable := IdentityDictionary new.
        self baseObjectTracer: nil.
    }.

    public method baseObjectTracer: (baseTracer: ImageTracer) ::=> Void := {
        tracer := tracer
            ifNil: (ImageTracer new)
            ifNotNil: (baseTracer copy)
    }.

    public method buildIn: (targetModule: AsmProgramEntity) ::=> Void := {
        rootTableEntries isEmpty ifTrue: {return: void}.

        ## (Pontentially second) object trace that includes the code literal objects.
        objectTrace ifNil: {
            objectTrace := tracer
                addUntypedRootObjects: rootObjectList;
                traceObjectSet;
                emitTraceReport;
                objectTrace.
        }.

        self
            serializeObjects;
            serializeRootTable;
            buildGCObjectDataSectionIn: targetModule;
            buildGCPointerTableIn: targetModule;
            buildGCFatPointerTableIn: targetModule.
    }.

    public method serializeObjects => Void := {
        let objectModel := compilationTarget objectModel.

        let heapSize mutable := 0u64.
        let heapAlignment mutable := objectModel minimalObjectAlignment.

        objectOffsetList := Array new: objectTrace objectList size.
        objectTrace objectList doWithIndex: {:(Untyped)eachObject :(Size)index :: Void |
            let objectSize := objectModel computeSizeOfObjectInstance: eachObject.
            let objectAlignment := objectModel computeAlignmentOfObjectInstance: eachObject.

            heapSize := heapSize alignedTo: objectAlignment.
            heapAlignment := heapAlignment max: objectAlignment.
            objectOffsetList at: index put: heapSize asSize.

            heapSize := heapSize + objectSize.
        }.

        heapSize := heapSize alignedTo: heapAlignment.
        serializedObjectData := ByteArray new: heapSize asSize.
        serializedObjectDataRelocations := OrderedCollection new.

        objectTrace objectList doWithIndex: {:(Untyped)eachObject :(Size)index :: Void |
            let offset => Size := objectOffsetList at: index.
            objectModel serializeObject: eachObject inAsmHeap: self at: offset
        }.
    }.

    public method serializeRootTable => Void := {
        serializedRootTable := ByteArray new: rootTableEntries size * compilationTarget pointerSize.
        serializedRootTableRelocations := OrderedCollection new.
        let pointerSize := compilationTarget pointerSize.
        let offset mutable := 0sz.
        rootTableEntries do: {:(AsmObjectHeapRootTableEntry)entry :: Void |
            entry writeIn: self rootTableOffset: offset.
            offset := offset + pointerSize 
        }
    }.

    public method offsetForRootTableElementWithIndex: (index: Size) ::=> UInt64 := {
        let objectIndex => UInt32 := objectTrace objectIndexDictionary untypedAt: (rootObjectList untypedAt: index).
        objectOffsetList at: objectIndex asSize
    }.

    public method offsetOfGCRootObjectTableEntryFor: (object: Untyped) ::=> Size := {
        rootOffsetTable untypedAt: object ifAbsentPut: { :: Size |
            let tableOffset := (rootTableEntries size * compilationTarget pointerSize) asSize.
            rootObjectList untypedAdd: object.
            rootTableEntries add: (compilationTarget objectModel makeObject: object asmHeapRootTableEntryWithIndex: rootTableEntries size).
            tableOffset
        }.
    }.

    public method objectPointerTableStartSymbol ::=> AsmSymbol := {
        objectPointerTableStartSymbol ifNil: (objectPointerTableStartSymbol := AsmSymbol new
            name: #__sysmel_objectPointerTableStart;
            makePublic;
            yourself)
    }.

    public method objectPointerTableEndSymbol ::=> AsmSymbol := {
        objectPointerTableEndSymbol ifNil: (objectPointerTableEndSymbol := AsmSymbol new
            name: #__sysmel_objectPointerTableEnd;
            makePublic;
            yourself)
    }.

    public method objectFatPointerTableStartSymbol ::=> AsmSymbol := {
        objectFatPointerTableStartSymbol ifNil: (objectPointerTableStartSymbol := AsmSymbol new
            name: #__sysmel_objectFatPointerTableStart;
            makePublic;
            yourself)
    }.

    public method objectFatPointerTableEndSymbol ::=> AsmSymbol := {
        objectFatPointerTableEndSymbol ifNil: (objectFatPointerTableEndSymbol := AsmSymbol new
            name: #__sysmel_objectPointerTableEnd;
            makePublic;
            yourself)
    }.

    public method objectSectionStartSymbol ::=> AsmSymbol := {
        objectSectionStartSymbol ifNil: (objectSectionStartSymbol := AsmSymbol new
            name: #__sysmel_objectSectionStart;
            makePublic;
            yourself)
    }.

    public method objectSectionEndSymbol ::=> AsmSymbol := {
        objectSectionEndSymbol ifNil: (objectSectionEndSymbol := AsmSymbol new
            name: #__sysmel_objectSectionEnd;
            makePublic;
            yourself)
    }.

    public method buildGCObjectDataSectionIn: (targetModule: AsmProgramEntity) ::=> Void := {
        objectTrace objectList isEmpty && objectSectionStartSymbol isNil ifTrue: (return: void).

        let objectDataProgramEntity := targetModule newProgramEntity.
        let objectSection := objectDataProgramEntity newStreamBuilder
            dataSection;
            align: 16sz;
            label: self objectSectionStartSymbol;
            addElement: (AsmObjectSectionDirective new
                heap: self;
                yourself);
            endLabel: self objectSectionStartSymbol;
            label: self objectSectionEndSymbol;
            endLabel: self objectSectionEndSymbol.
    }.

    public method buildGCPointerTableIn: (targetModule: AsmProgramEntity) ::=> Void := {
        objectPointerTableStartSymbol ifNil: (return: void).

        let pointerTableProgramEntity := targetModule newProgramEntity.
        let pointerTableSection := pointerTableProgramEntity newStreamBuilder
            dataSection;
            align: compilationTarget pointerAlignment;
            label: objectPointerTableStartSymbol;
            addElement: (AsmRootObjectPointerTableDirective new
                heap: self;
                yourself);
            endLabel: objectPointerTableStartSymbol;
            label: self objectPointerTableEndSymbol
    }.


    public method buildGCFatPointerTableIn: (targetModule: AsmProgramEntity) ::=> Void := {
        objectFatPointerTableStartSymbol ifNil: (return: void).

        let fatPointerTableProgramEntity := targetModule newProgramEntity.
        let fatPointerTableSection := fatPointerTableProgramEntity newStreamBuilder
            dataSection;
            align: compilationTarget pointerAlignment;
            label: objectFatPointerTableStartSymbol;
            endLabel: objectFatPointerTableStartSymbol;
            label: self objectFatPointerTableEndSymbol
    }.

    public method writeReference32: (value: Untyped) at: (offset: Size) extraAddend: (extraAddend: UInt32) ::=> Void := {
        let objectModel := compilationTarget objectModel.
        (objectModel isImmediateReference: value) ifTrue: {
            let immediateValue := RawTuple::type(value) encodeImmediateReference32: value.
            serializedObjectData uint32At: offset put: immediateValue
        } ifFalse: {
            (objectTrace objectIndexDictionary untypedIncludesKey: value) ifTrue: {
                let objectIndex => UInt32 := objectTrace objectIndexDictionary at: value.
                let objectOffset => UInt64 := objectOffsetList at: objectIndex asSize.
                serializedObjectDataRelocations add: (AsmObjectCodeRelocationAbsoluteInt32 new
                    symbol: self objectSectionStartSymbol;
                    offset: offset;
                    addend: objectOffset asInt32 + extraAddend asInt32;
                    yourself)
            }
        }
    }.

    public method writeReference64: (value: Untyped) at: (offset: Size) ::=> Void := {
        self writeReference64: value at: offset extraAddend: 0u64
    }.

    public method writeReference64: (value: Untyped) at: (offset: Size) extraAddend: (extraAddend: UInt64) ::=> Void := {
        let objectModel := compilationTarget objectModel.
        (objectModel isImmediateReference: value) ifTrue: {
            let immediateValue := RawTuple::type(value) encodeImmediateReference64: value.
            serializedObjectData uint64At: offset put: immediateValue
        } ifFalse: {
            (objectTrace objectIndexDictionary untypedIncludesKey: value) ifTrue: {
                let objectIndex => UInt32 := objectTrace objectIndexDictionary untypedAt: value.
                let objectOffset => Size := objectOffsetList at: objectIndex asSize.
                serializedObjectDataRelocations add: (AsmObjectCodeRelocationAbsoluteInt64 new
                    symbol: self objectSectionStartSymbol;
                    offset: offset;
                    addend: objectOffset asInt64 + extraAddend asInt64;
                    yourself)
            }
        }
    }.

    public method writeReference64OrTombstone: (value: Untyped) at: (offset: Size) ::=> Void := {
        let objectModel := compilationTarget objectModel.
        (objectModel isImmediateReference: value) ifTrue: {
            let immediateValue := RawTuple::type(value) encodeImmediateReference64: value.
            serializedObjectData uint64At: offset put: immediateValue
        } ifFalse: {
            (objectTrace objectIndexDictionary untypedIncludesKey: value) ifTrue: {
                let objectIndex => UInt32 := objectTrace objectIndexDictionary untypedAt: value.
                let objectOffset => Size := objectOffsetList at: objectIndex asSize.
                serializedObjectDataRelocations add: (AsmObjectCodeRelocationAbsoluteInt64 new
                    symbol: self objectSectionStartSymbol;
                    offset: offset;
                    addend: objectOffset asInt64;
                    yourself)
            } ifFalse: {
                let immediateValue := ObjectTombstone encodeImmediateReference64: __tombstone__.
                serializedObjectData uint64At: offset put: immediateValue
            }
        }
    }.
    public method writeSymbolReference64: (symbol: AsmSymbol) at: (offset: Size) ::=> Void := {
        serializedObjectDataRelocations add: (AsmObjectCodeRelocationAbsoluteInt64 new
            symbol: symbol;
            offset: offset;
            yourself)
    }.

    public method writeReference64: (value: Untyped) at: (offset: Size) ::=> Void := {
        self writeReference64: value at: offset extraAddend: 0u64
    }.
}.

Type extend: {

}.

TypeSlot extend: {
    public method writeReference64OrValueOf: (object: Untyped) inAsmHeap: (heap: AsmObjectHeap) at: (objectBaseOffset: Size) ::=> Void := {
        self isJitSpecific ifTrue: {return: void}.
        self isTargetGenerated ifTrue: {return: void}.

        let slotValue => Untyped := (RawTuple::typeSlotAt:)(object, self).

        type isNil || type isValueType not ifTrue: {
            heap writeReference64: slotValue at: objectBaseOffset + offset.
        } ifFalse: {
            type encodeValue: slotValue inBytes: heap serializedObjectData atOffset: objectBaseOffset + offset
        }
    }.
}.

ObjectModelVariant extend: {
    public abstract method serializeObject: (object: Untyped) inAsmHeap: (heap: AsmObjectHeap) at: (offset: Size) ::=> Void
        := self subclassResponsibility.

    public abstract method makeObject: (object: Untyped) asmHeapRootTableEntryWithIndex: (tableIndex: Size) ::=> AsmObjectHeapRootTableEntry
        := self subclassResponsibility.
}.

ImageObjectTracePatch extend: {
    public virtual method writeSlot: (slot: TypeSlot) reference64OrValueOf: (object: Untyped) inAsmHeap: (heap: AsmObjectHeap) at: (offset: Size) ::=> Void := {
        slot writeReference64OrValueOf: object inAsmHeap: heap at: offset
    }.
}.

ObjectModelVariant64 extend: {
    public method saveLayoutDataOfObject: (object: Untyped) inAsmHeap: (heap: AsmObjectHeap) at: (offset: Size) ::=> Size := {
        let type => Type := RawTuple::type(object).
        let patch => ImageObjectTracePatch := heap objectTrace patchDictionary untypedAtOrNil: object.
        let vtableLayout => VirtualTableLayout := heap objectTrace vtableSet getVirtualTableLayoutOrNilOf: object.
        let vtable => VirtualTable := heap objectTrace vtableSet getVirtualTableOrNilOf: object.
        type ifNil: {
            0sz
        } ifNotNil: {
            type allSlotsDo: {:(TypeSlot)eachSlot :: Void |
                patch ifNotNil: {
                    patch writeSlot: eachSlot reference64OrValueOf: object inAsmHeap: heap at: offset.
                    return: void.
                }.

                vtableLayout isNotNil && (eachSlot name == #virtualTableLayout) ifTrue: {
                    heap writeReference64: vtableLayout at: offset + eachSlot offset.
                    return: void
                }.
                vtable isNotNil && (eachSlot name == #virtualTable) ifTrue: {
                    heap writeReference64: vtable at: offset + eachSlot offset.
                    return: void
                }.

                eachSlot writeReference64OrValueOf: object inAsmHeap: heap at: offset
            }.
            type totalSlotCount
        }
    }.

    public method fixedInstanceSizeOfObject: (object: Untyped) ::=> Size := {
        let type => Type := RawTuple::type(object).
        type ifNil: (0sz) ifNotNil: (type validInstanceSize)
    }.

    public override method serializeObject: (object: Untyped) inAsmHeap: (heap: AsmObjectHeap) at: (offset: Size) ::=> Void := {
        let type := RawTuple::type(object).
        let isBytes := RawTuple::isBytes(object).
        let isWeak := RawTuple::isWeak(object).
        let isDummyValue := RawTuple::isDummyValue(object).
        let headerSize := ObjectModel::TupleHeader64 valueSize.
        let destination := heap serializedObjectData.

        let header mutable := ObjectModel::TupleHeader64 basicNew.
        header
            objectType: (isBytes ifTrue: ObjectModel::ObjectType::Bytes
                ifFalse: (isWeak ifTrue: ObjectModel::ObjectType::WeakPointers
                ifFalse: ObjectModel::ObjectType::Pointers));
            isDummyValue: isDummyValue;
            identityHashValue: Untyped::identityHash(object) asUInt32;
            objectSize: (self computeSizeOfObjectInstanceContent: object) asUInt32.

        type ifNotNil: {
            heap writeReference64: type at: offset.
        }.

        ObjectModel::isLogical() ifTrue: {
            header encodeInBytes: destination atOffset: offset.
        } ifFalse: {
            memcpy(
                (destination __rawContentsBytePointer__ + offset asIntPointer) reinterpretCastTo: Void pointer,
                header address reinterpretCastTo: Void pointer,
                ObjectModel::TupleHeader64 valueSize
            )
        }.

        isDummyValue ifTrue: {return: void}.

        isBytes ifTrue: {
            let byteSize := RawTuple::byteSize(object).
            let i mutable := 0sz.
            while: i < byteSize do: {
                destination at: offset + headerSize + i put: (RawTuple::byteSlotAt:)(object, i).
            } continueWith: (i := i + 1sz).
        } ifFalse: {
            let slotCount := RawTuple::size(object).
            let i mutable := self saveLayoutDataOfObject: object inAsmHeap: heap at: offset + headerSize.
            let slotOffset mutable := offset + headerSize + (self fixedInstanceSizeOfObject: object).

            while: i < slotCount do: {
                let value => Untyped := (RawTuple::slotAt:) (object, i).
                isWeak ifTrue: {
                    heap writeReference64OrTombstone: value at: slotOffset.
                } ifFalse: {
                    heap writeReference64: value at: slotOffset.
                }.
                slotOffset := slotOffset + 8sz.
            } continueWith: (i := i + 1sz)
        }.
    }.

    public override method makeObject: (object: Untyped) asmHeapRootTableEntryWithIndex: (tableIndex: Size) ::=> AsmObjectHeapRootTableEntry := {
        AsmObjectHeapRootTableEntryObjectPointer64 new
            index: tableIndex;
            yourself
    }.

}.

public final class AsmObjectSectionDirective superclass: AsmStreamElement; definition: {
    public field heap => AsmObjectHeap.

    public method sectionSize => Size := heap serializedObjectData size.

    public override method fullPrintOn: (stream: Stream) ::=> Void := {
        stream nextPutAll: ".objectSection "; print: self sectionSize.
    }.

    public override method writeOnObjectCodeStream: (stream: AsmObjectCodeStream) ::=> Void := {
        stream
            recordRelocations: heap serializedObjectDataRelocations;
            nextPutAll: heap serializedObjectData.
    }.
}.

public final class AsmRootObjectPointerTableDirective superclass: AsmStreamElement; definition: {
    public field heap => AsmObjectHeap.

    public method tableSize => Size := heap rootTableEntries size.

    public override method fullPrintOn: (stream: Stream) ::=> Void := {
        stream nextPutAll: ".rootObjectPointerTable "; print: self tableSize.
    }.

    public override method writeOnObjectCodeStream: (stream: AsmObjectCodeStream) ::=> Void := {
        stream
            recordRelocations: heap serializedRootTableRelocations;
            nextPutAll: heap serializedRootTable.
    }.
}.