public final class AsmObjectHeap.

public abstract class AsmObjectHeapRootTableEntry superclass: Object; definition: {
    public abstract method writeIn: (asmHeap: AsmObjectHeap) rootTableOffset: (offset: Size) ::=> Void
        := self subclassResponsibility.

}.

public abstract class AsmObjectHeapRootTableEntryObjectPointer superclass: AsmObjectHeapRootTableEntry; definition: {
    public field objectIndex => Size.
}.

public final class AsmObjectHeapRootTableEntryObjectPointer32 superclass: AsmObjectHeapRootTableEntryObjectPointer; definition: {
    public override method writeIn: (asmHeap: AsmObjectHeap) rootTableOffset: (offset: Size) ::=> Void := {
        let objectOffset := asmHeap objectOffsetList at: objectIndex.
        asmHeap serializedRootTableRelocations add: (AsmObjectCodeRelocationAbsoluteInt32 new
            symbol: asmHeap objectSectionSymbol;
            offset: offset;
            addend: objectOffset asInt32;
            yourself)
    }.
}.

public final class AsmObjectHeapRootTableEntryObjectPointer64 superclass: AsmObjectHeapRootTableEntryObjectPointer; definition: {
    public override method writeIn: (asmHeap: AsmObjectHeap) rootTableOffset: (offset: Size) ::=> Void := {
        let objectOffset := asmHeap objectOffsetList at: objectIndex.
        asmHeap serializedRootTableRelocations add: (AsmObjectCodeRelocationAbsoluteInt64 new
            symbol: asmHeap objectSectionSymbol;
            offset: offset;
            addend: objectOffset asInt64;
            yourself)
    }.
}.

public final class AsmObjectHeapRootTableEntryImmediate32 superclass: AsmObjectHeapRootTableEntry; definition: {
    public field value => UInt32.

    public override method writeIn: (asmHeap: AsmObjectHeap) rootTableOffset: (offset: Size) ::=> Void := {
        asmHeap serializedRootTable uint32At: offset put: value
    }.
}.

public final class AsmObjectHeapRootTableEntryImmediate64 superclass: AsmObjectHeapRootTableEntry; definition: {
    public field value => UInt64.

    public override method writeIn: (asmHeap: AsmObjectHeap) rootTableOffset: (offset: Size) ::=> Void := {
        asmHeap serializedRootTable uint64At: offset put: value
    }.
}.

AsmObjectHeap definition: {
    public field compilationTarget => AsmCompilationTarget.
    public field hasFullRTTI => Boolean.

    protected field objectSectionSymbol => AsmSymbol.
    protected field objectSectionEndSymbol => AsmSymbol.
    public field objectTrace => ImageObjectTrace.
    public field objectOffsetList => Array.

    public field serializedObjectData => ByteArray.
    public field serializedObjectDataRelocations => OrderedCollection.

    public field serializedRootTable => ByteArray.
    public field serializedRootTableRelocations => OrderedCollection.

    protected field rootObjectTableSymbol => AsmSymbol.
    public field rootObjectList => OrderedCollection.
    protected field rootOffsetTable => IdentityDictionary.

    public override method initialize => Void := {
        objectTrace := ImageObjectTrace new.

        rootObjectList := OrderedCollection new.
        rootOffsetTable := IdentityDictionary new.
    }.

    public method buildIn: (targetModule: AsmProgramEntity) ::=> Void := {
        objectTrace isLocked ifFalse: {
            ## TODO: remove this part when is not gonna be needed anymore.
            self traceObjectSet
        }.

        self
            serializeObjects;
            serializeRootTable;
            buildGCObjectDataSectionIn: targetModule;
            buildGCObjectRootTableIn: targetModule.
    }.

    public method traceObjectSet => Void := {
        let objectModel := compilationTarget objectModel.

        objectTrace objectList do: {:(Untyped)eachObject :: Void |
            objectModel traceReferencesOfObject: eachObject forAsmHeap: self
        }.
    }.

    public method traceReference: (reference: Untyped) ::=> Void := {
        (compilationTarget objectModel isImmediateReference: reference) ifFalse: {
            self indexOfGCObjectEntryFor: reference
        }
    }.

    public method traceType: (type: Type) ::=> Void := {
        self traceReference: type
    }.

    public method serializeObjects => Void := {
        let objectModel := compilationTarget objectModel.

        let heapSize mutable := 0u64.
        let heapAlignment mutable := objectModel minimalObjectAlignment.

        objectOffsetList := Array new: objectTrace objectList size.
        objectTrace objectList doWithIndex: {:(Untyped)eachObject :(Size)index :: Void |
            let objectSize := objectModel computeSizeOfObjectInstance: eachObject.
            let objectAlignment := objectModel computeAlignmentOfObjectInstance: eachObject.

            heapSize := heapSize alignedTo: objectAlignment.
            heapAlignment := heapAlignment max: objectAlignment.
            objectOffsetList at: index put: heapSize asSize.

            heapSize := heapSize + objectSize.
        }.

        heapSize := heapSize alignedTo: heapAlignment.
        serializedObjectData := ByteArray new: heapSize asSize.
        serializedObjectDataRelocations := OrderedCollection new.

        objectTrace objectList doWithIndex: {:(Untyped)eachObject :(Size)index :: Void |
            let offset => Size := objectOffsetList at: index.
            objectModel serializeObject: eachObject inAsmHeap: self at: offset
        }.
    }.

    public method serializeRootTable => Void := {
        serializedRootTable := ByteArray new: rootObjectList size * compilationTarget pointerSize.
        serializedRootTableRelocations := OrderedCollection new.
        let pointerSize := compilationTarget pointerSize.
        let offset mutable := 0sz.
        rootObjectList do: {:(AsmObjectHeapRootTableEntry)entry :: Void |
            entry writeIn: self rootTableOffset: offset.
            offset := offset + pointerSize 
        }
    }.

    public method indexOfGCObjectEntryFor: (object: Untyped) ::=> Size := {
        objectTrace isLocked ifTrue: {
            let index => UInt32 := objectTrace objectIndexDictionary untypedAt: object.
            index asSize
        } ifFalse: {
            (objectTrace addObject: object) asSize
        }
    }.

    public method offsetOfGCRootObjectTableEntryFor: (object: Untyped) ::=> Size := {
        rootOffsetTable untypedAt: object ifAbsentPut: { :: Size |
            let tableOffset := (rootObjectList size * compilationTarget pointerSize) asSize.
            rootObjectList add: (compilationTarget objectModel makeObject: object asmHeapRootTableEntryIn: self).
            tableOffset
        }.
    }.

    public method rootObjectTableSymbol ::=> AsmSymbol := {
        rootObjectTableSymbol ifNil: (rootObjectTableSymbol := AsmSymbol new
            name: #rootObjectTable;
            makePrivate;
            yourself)
    }.

    public method objectSectionSymbol ::=> AsmSymbol := {
        objectSectionSymbol ifNil: (objectSectionSymbol := AsmSymbol new
            name: #objectSection;
            makePrivate;
            yourself)
    }.

    public method objectSectionEndSymbol ::=> AsmSymbol := {
        objectSectionEndSymbol ifNil: (objectSectionEndSymbol := AsmSymbol new
            name: #objectSectionEnd;
            makePrivate;
            yourself)
    }.

    public method buildGCObjectDataSectionIn: (targetModule: AsmProgramEntity) ::=> Void := {
        objectTrace objectList isEmpty ifTrue: (return: void).

        let objectDataProgramEntity := targetModule newProgramEntity.
        let objectSection := objectDataProgramEntity newStreamBuilder
            dataSection;
            align: 16sz;
            label: self objectSectionSymbol;
            addElement: (AsmObjectSectionDirective new
                heap: self;
                yourself);
            endLabel: self objectSectionSymbol;
            label: self objectSectionEndSymbol;
            endLabel: self objectSectionEndSymbol.
    }.

    public method buildGCObjectRootTableIn: (targetModule: AsmProgramEntity) ::=> Void := {
        rootObjectTableSymbol ifNil: (return: void).

        let rootTableProgramEntity := targetModule newProgramEntity.
        let rootTableSection := rootTableProgramEntity newStreamBuilder
            dataSection;
            align: compilationTarget pointerAlignment;
            label: rootObjectTableSymbol;
            addElement: (AsmRootObjectPointerTableDirective new
                heap: self;
                yourself);
            endLabel: rootObjectTableSymbol
    }.

    public method writeReference32: (value: Untyped) at: (offset: Size) extraAddend: (extraAddend: UInt32) ::=> Void := {
        let objectModel := compilationTarget objectModel.
        (objectModel isImmediateReference: value) ifTrue: {
            let immediateValue := RawTuple::type(value) encodeImmediateReference32: value.
            serializedObjectData uint32At: offset put: immediateValue
        } ifFalse: {
            (objectTrace objectIndexDictionary untypedIncludesKey: value) ifTrue: {
                let objectIndex => UInt32 := objectTrace objectIndexDictionary at: value.
                let objectOffset => UInt64 := objectOffsetList at: objectIndex asSize.
                serializedObjectDataRelocations add: (AsmObjectCodeRelocationAbsoluteInt32 new
                    symbol: self objectSectionSymbol;
                    offset: offset;
                    addend: objectOffset asInt32 + extraAddend asInt32;
                    yourself)
            }
        }
    }.

    public method writeReference64: (value: Untyped) at: (offset: Size) ::=> Void := {
        self writeReference64: value at: offset extraAddend: 0u64
    }.

    public method writeReference64: (value: Untyped) at: (offset: Size) extraAddend: (extraAddend: UInt64) ::=> Void := {
        let objectModel := compilationTarget objectModel.
        (objectModel isImmediateReference: value) ifTrue: {
            let immediateValue := RawTuple::type(value) encodeImmediateReference64: value.
            serializedObjectData uint64At: offset put: immediateValue
        } ifFalse: {
            (objectTrace objectIndexDictionary untypedIncludesKey: value) ifTrue: {
                let objectIndex => UInt32 := objectTrace objectIndexDictionary untypedAt: value.
                let objectOffset => Size := objectOffsetList at: objectIndex asSize.
                serializedObjectDataRelocations add: (AsmObjectCodeRelocationAbsoluteInt64 new
                    symbol: self objectSectionSymbol;
                    offset: offset;
                    addend: objectOffset asInt64 + extraAddend asInt64;
                    yourself)
            }
        }
    }.

    public method writeSymbolReference64: (symbol: AsmSymbol) at: (offset: Size) ::=> Void := {
        serializedObjectDataRelocations add: (AsmObjectCodeRelocationAbsoluteInt64 new
            symbol: symbol;
            offset: offset;
            yourself)
    }.

    public method writeReference64: (value: Untyped) at: (offset: Size) ::=> Void := {
        self writeReference64: value at: offset extraAddend: 0u64
    }.
}.

Type extend: {

}.

TypeSlot extend: {
    public method traceReferenceOfObject: (object: Untyped) forAsmHeap: (heap: AsmObjectHeap) ::=> Void := {
        self isMinRTTIExcluded not || heap hasFullRTTI ifTrue: {
            type isNil || type isValueType not ifTrue: {
                let referenceValue => Untyped := (RawTuple::typeSlotAt:)(object, self).
                heap traceReference: referenceValue
            }
        }
    }.

    public method writeReference64OrValueOf: (object: Untyped) inAsmHeap: (heap: AsmObjectHeap) at: (objectBaseOffset: Size) ::=> Void := {
        self isJitSpecific ifTrue: {return: void}.

        let slotValue => Untyped := (RawTuple::typeSlotAt:)(object, self).

        type isNil || type isValueType not ifTrue: {
            heap writeReference64: slotValue at: objectBaseOffset + offset.
        } ifFalse: {
            type encodeValue: slotValue inBytes: heap serializedObjectData atOffset: objectBaseOffset + offset
        }
    }.
}.

ObjectModelVariant extend: {
    public virtual method traceLayoutReferencesOfObject: (object: Untyped) forAsmHeap: (heap: AsmObjectHeap) ::=> Size := {
        let type => Type := RawTuple::type(object).
        type ifNil: {
            0sz
        } ifNotNil: {
            type allSlotsDo: {:(TypeSlot)eachSlot :: Void |
                eachSlot traceReferenceOfObject: object forAsmHeap: heap
            }.
            type totalSlotCount
        }
    }.

    public virtual method traceReferencesOfObject: (object: Untyped) forAsmHeap: (heap: AsmObjectHeap) ::=> Void := {
        heap traceType: RawTuple::type(object).
        let isBytes := RawTuple::isBytes(object).
        isBytes ifFalse: {
            let slotCount := RawTuple::size(object).
            let fixedLayoutSlotCount := self traceLayoutReferencesOfObject: object forAsmHeap: heap.

            ## Trace the variant references.
            let i mutable := fixedLayoutSlotCount.
            while: (i < slotCount) do: {
                heap traceReference: (RawTuple::slotAt:)(object, i)
            } continueWith: (i := i + 1sz)
        }.
    }.

    public abstract method serializeObject: (object: Untyped) inAsmHeap: (heap: AsmObjectHeap) at: (offset: Size) ::=> Void
        := self subclassResponsibility.

    public abstract method makeObject: (object: Untyped) asmHeapRootTableEntryIn: (heap: AsmObjectHeap) ::=> AsmObjectHeapRootTableEntry
        := self subclassResponsibility.
}.

ImageObjectTracePatch extend: {
    public virtual method writeSlot: (slot: TypeSlot) reference64OrValueOf: (object: Untyped) inAsmHeap: (heap: AsmObjectHeap) at: (offset: Size) ::=> Void := {
        slot writeReference64OrValueOf: object inAsmHeap: heap at: offset
    }.
}.

ObjectModelVariant64 extend: {
    public method saveLayoutDataOfObject: (object: Untyped) inAsmHeap: (heap: AsmObjectHeap) at: (offset: Size) ::=> Size := {
        let type => Type := RawTuple::type(object).
        let patch => ImageObjectTracePatch := heap objectTrace patchDictionary untypedAtOrNil: object.
        type ifNil: {
            0sz
        } ifNotNil: {
            type allSlotsDo: {:(TypeSlot)eachSlot :: Void |
                patch ifNotNil: {
                    patch writeSlot: eachSlot reference64OrValueOf: object inAsmHeap: heap at: offset
                } ifNil: {
                    eachSlot writeReference64OrValueOf: object inAsmHeap: heap at: offset
                }
            }.
            type totalSlotCount
        }
    }.

    public method fixedInstanceSizeOfObject: (object: Untyped) ::=> Size := {
        let type => Type := RawTuple::type(object).
        type ifNil: (0sz) ifNotNil: (type validInstanceSize)
    }.

    public override method serializeObject: (object: Untyped) inAsmHeap: (heap: AsmObjectHeap) at: (offset: Size) ::=> Void := {
        let type := RawTuple::type(object).
        let isBytes := RawTuple::isBytes(object).
        let isWeak := RawTuple::isWeak(object).
        let isDummyValue := RawTuple::isDummyValue(object).
        let headerSize := ObjectModel::TupleHeader64 valueSize.
        let destination := heap serializedObjectData.

        let header mutable => ObjectModel::TupleHeader64 := ObjectModel::TupleHeader64 new.
        header
            isBytes: isBytes;
            isWeak: isWeak;
            isDummyValue: isDummyValue;
            identityHashValue: identityHash(object) asUInt64;
            objectSize: (self computeSizeOfObjectInstanceContent: object).

        type ifNotNil: {
            let typePointerFlags := header typePointerAndFlags.
            header typePointerAndFlags: 0u64.
            heap writeReference64: type at: offset extraAddend: typePointerFlags asUInt64.
        }.

        header encodeInBytes: destination atOffset: offset.

        isDummyValue ifTrue: {return: void}.

        isBytes ifTrue: {
            let byteSize := RawTuple::byteSize(object).
            let i mutable := 0sz.
            while: i < byteSize do: {
                destination at: offset + headerSize + i put: (RawTuple::slotAt:)(object, i).
            } continueWith: (i := i + 1sz).
        } ifFalse: {
            let slotCount := RawTuple::size(object).
            let i mutable := self saveLayoutDataOfObject: object inAsmHeap: heap at: offset + headerSize.
            let slotOffset mutable := offset + headerSize + (self fixedInstanceSizeOfObject: object).

            while: i < slotCount do: {
                let value => Untyped := (RawTuple::slotAt:) (object, i).
                heap writeReference64: value at: slotOffset.
                slotOffset := slotOffset + 8sz.
            } continueWith: (i := i + 1sz)
        }.
    }.

    public override method makeObject: (object: Untyped) asmHeapRootTableEntryIn: (heap: AsmObjectHeap) ::=> AsmObjectHeapRootTableEntry := {
        AsmObjectHeapRootTableEntryObjectPointer64 new
            objectIndex: (heap indexOfGCObjectEntryFor: object);
            yourself
    }.

}.

public final class AsmObjectSectionDirective superclass: AsmStreamElement; definition: {
    public field heap => AsmObjectHeap.

    public method sectionSize => Size := heap serializedObjectData size.

    public override method fullPrintOn: (stream: Stream) ::=> Void := {
        stream nextPutAll: ".objectSection "; print: self sectionSize.
    }.

    public override method writeOnObjectCodeStream: (stream: AsmObjectCodeStream) ::=> Void := {
        stream
            recordRelocations: heap serializedObjectDataRelocations;
            nextPutAll: heap serializedObjectData.
    }.
}.

public final class AsmRootObjectPointerTableDirective superclass: AsmStreamElement; definition: {
    public field heap => AsmObjectHeap.

    public method tableSize => Size := heap rootObjectList size.

    public override method fullPrintOn: (stream: Stream) ::=> Void := {
        stream nextPutAll: ".rootObjectPointerTable "; print: self tableSize.
    }.

    public override method writeOnObjectCodeStream: (stream: AsmObjectCodeStream) ::=> Void := {
        stream
            recordRelocations: heap serializedRootTableRelocations;
            nextPutAll: heap serializedRootTable.
    }.
}.