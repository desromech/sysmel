public final class AsmObjectCodeSection superclass: Object.
public abstract class AsmObjectCodeStream superclass: Object.
public final class AsmObjectCodeSizeStream superclass: AsmObjectCodeStream.
public final class AsmObjectCodeWriteStream superclass: AsmObjectCodeStream.
public final class AsmSymbol superclass: Object.

AsmObjectCodeSection definition: {
    public field name => Symbol.
    public field data => ByteArray.
    public field alignment => Size.
    public field size => Size.
    public field writeOffset => Size.

    public field executable => Boolean.
    public field writeable => Boolean.
    public field readable => Boolean.
    public field loaded => Boolean.

    public field relocations => Array.

    public field offsetOfEncodedElementInByteStream => Size.

    public method initialize => Void := {
        data := #[].
        size := 0sz.
        alignment := 1sz.
        writeOffset := 0sz.
        relocations := #().
    }.

    public method increaseSizeBy: (extraSize: Size) ::=> Void := {
        size := size + extraSize
    }.

    public method alignSizeTo: (requiredAlignment: Size) ::=> Void := {
        alignment := alignment max: requiredAlignment.
        size := size alignedTo: requiredAlignment.
    }.

    public method alignWriteOffsetTo: (requiredAlignment: Size) ::=> Void := {
        writeOffset := writeOffset alignedTo: requiredAlignment.
    }.

    public method addExecutable: (flag: Boolean) ::=> Boolean := {
        executable := executable || flag
    }.

    public method addWriteable: (flag: Boolean) ::=> Boolean := {
        writeable := writeable || flag
    }.

    public method addReadable: (flag: Boolean) ::=> Boolean := {
        readable := readable || flag
    }.

    public method addLoaded: (flag: Boolean) ::=> Boolean := {
        loaded := loaded || flag
    }.

    public method nextPut: (value: UInt8) ::=> Void := {
        data at: writeOffset put: value.
        writeOffset := writeOffset + 1sz.
    }.

    public method nextPutAll: (bytes: ByteArray) ::=> Void := {
        let i mutable := 0sz.
        let byteCount := bytes size.
        while: i < byteCount do: (
            data at: writeOffset + i put: (bytes at: i)
        ) continueWith: (i := i + 1sz).
        writeOffset := writeOffset + byteCount.
    }.

    public method nextPutInt8: (value: Int8) ::=> Void := {
        data int8At: writeOffset put: value.
        writeOffset := writeOffset + 1sz.
    }.

    public method nextPutUInt16: (value: UInt16) ::=> Void := {
        data uint16At: writeOffset put: value.
        writeOffset := writeOffset + 2sz.
    }.

    public method nextPutInt16: (value: Int16) ::=> Void := {
        data int16At: writeOffset put: value.
        writeOffset := writeOffset + 2sz.
    }.

    public method nextPutUInt32: (value: UInt32) ::=> Void := {
        data uint32At: writeOffset put: value.
        writeOffset := writeOffset + 4sz.
    }.

    public method nextPutInt32: (value: Int32) ::=> Void := {
        data int32At: writeOffset put: value.
        writeOffset := writeOffset + 4sz.
    }.

    public method nextPutUInt64: (value: UInt64) ::=> Void := {
        data uint64At: writeOffset put: value.
        writeOffset := writeOffset + 8sz.
    }.

    public method nextPutInt64: (value: Int64) ::=> Void := {
        data int64At: writeOffset put: value.
        writeOffset := writeOffset + 8sz.
    }.

    public method nextPutFloat32: (value: Float32) ::=> Void := {
        data float32At: writeOffset put: value.
        writeOffset := writeOffset + 4sz.
    }.

    public method nextPutFloat64: (value: Float64) ::=> Void := {
        data float64At: writeOffset put: value.
        writeOffset := writeOffset + 8sz.
    }.

    public method fullPrintOn: (stream: Stream) ::=> Void := {
        stream
            nextPutAll: "section: "; print: name;
            nextPutAll: " size: "; print: size;
            nextPutAll: " alignment: "; print: alignment;
            nextPutAll: " data: "; print: data.
    }.

    public method allocateMemoryForWriting => Void := {
        data := ByteArray new: size.
        writeOffset := 0sz.
    }.

    public method sizeOfByteEncoding => Size := data size.
    public method canEncodeInBytes => Boolean := true.

    public method encodeInBytes: (destination: ByteArray) atOffset: (destinationOffset) ::=> Void := {
        destination replaceFrom: destinationOffset until: destinationOffset + data size with: data
    }.
}.

public final class AsmObjectCode superclass: Object; definition: {
    public field sections => Array.
    public field symbols => Array.

    public method fullPrintOn: (stream: Stream) ::=> Void := {
        sections do: {:(AsmObjectCodeSection)each :: Void |
            stream fullPrint: each
        }.
        symbols do: {:(AsmSymbol)each :: Void |
            stream fullPrint: each
        }.
    }.
}.

public final class AsmObjectCodeCStringTable superclass: Object; definition: {
    public field stringStream => StringStream.
    public field stringIndexTable => Dictionary.
    
    public field size => Size.
    public field data => ByteArray.
    
    public field offsetOfEncodedElementInByteStream => Size.

    public method initialize => Void := {
        stringStream := StringStream new.
        stringIndexTable := Dictionary new.
        self addString: "".
    }.

    public method addString: (string: String) ::=> Size
        := stringIndexTable at: string ifAbsentPut: {:: Size |
            let index := size.
            stringStream nextPutAll: string; nextPut: 0c8.
            size := size + (string size + 1sz).
            index
        }.

    public method addSymbol: (symbol: Symbol) ::=> Size
        := stringIndexTable at: symbol ifAbsentPut: {:: Size |
            self addString: symbol asString
        }.

    public method finish => Void := {
        data := stringStream asByteArray.
        size := data size.
    }.

    public method sizeOfByteEncoding => Size := size.
    public method canEncodeInBytes => Boolean := true.

    public method encodeInBytes: (destination: ByteArray) atOffset: (destinationOffset) ::=> Void := {
        destination replaceFrom: destinationOffset until: destinationOffset + data size with: data
    }.
}.

public global AsmSymbol::Visibility::Private := 0u8.
public global AsmSymbol::Visibility::Public := 1u8.
public global AsmSymbol::Visibility::Weak := 2u8.

public global AsmSymbol::Type::None := 0u8.
public global AsmSymbol::Type::Function := 1u8.
public global AsmSymbol::Type::Variable := 2u8.

AsmSymbol definition: {
    public field name => Symbol.
    public field section => AsmObjectCodeSection.
    public field value => UInt64.
    public field size => UInt64.
    public field visibility => UInt8.
    public field type => UInt8.

    public method makePublic => Void := {
        visibility := AsmSymbol::Visibility::Public.
    }.

    public method isPublic => Boolean
        := visibility = AsmSymbol::Visibility::Public.

    public method makeFunction => Void := {
        type := AsmSymbol::Type::Function.
    }.

    public method printOn: (stream: Stream) ::=> Void := {
        name ifNotNil: {
            stream nextPutAll: name.
        } ifNil: {
            stream nextPutAll: "anon".
        }
    }.
}.

public final class AsmObjectCodeBuilder superclass: Object; definition: {
    public field sections => ArrayList.
    public field sectionNameTable => Dictionary.
    public field symbols => ArrayList.

    public method initialize => Void := {
        sections := ArrayList new.
        sectionNameTable := Dictionary new.
        symbols := ArrayList new.
    }.

    public method recordSymbol: (symbol: AsmSymbol) ::=> Void := {
        ## Filter the symbols by using a set.
        symbols add: symbol
    }.

    public method getOrCreateSectionNamed: (name: Symbol) ::=> AsmObjectCodeSection
        := sectionNameTable at: name ifAbsentPut: {:: AsmObjectCodeSection |
            let newSection := AsmObjectCodeSection new
                name: name;
                yourself.
            sections add: newSection.
            newSection
        }.

    public method finish => AsmObjectCode 
        := AsmObjectCode new
            sections: sections asArray;
            symbols: symbols asArray;
            yourself.

    public method newSizeStream => AsmObjectCodeSizeStream
        := AsmObjectCodeSizeStream new
            objectCodeBuilder: self;
            yourself.

    public method allocateMemoryForWriting => Void := {
        sections do: {:(AsmObjectCodeSection)each :: Void |
            each allocateMemoryForWriting
        }
    }.

    public method newWriteStream => AsmObjectCodeWriteStream
        := AsmObjectCodeWriteStream new
            objectCodeBuilder: self;
            yourself.
}.

AsmObjectCodeStream definition: {
    public field objectCodeBuilder => AsmObjectCodeBuilder.
    public field activeSection => AsmObjectCodeSection.

    public method isInX86LongMode => Boolean
        := true.

    public abstract method alignTo: (requiredAlignment: Size) ::=> Void
        := self subclassResponsibility.

    public method enterSectionNamed: (name: Symbol) ::=> AsmObjectCodeSection := {
        activeSection := objectCodeBuilder getOrCreateSectionNamed: name
    }.

    public abstract method nextPut: (value: UInt8) ::=> Void
        := self subclassResponsibility.

    public method nextPutAll: (bytes: ByteArray) ::=> Void := {
        bytes do: {:(UInt8)each :: Void | self nextPut: each}
    }.

    public abstract method nextPutInt8: (value: Int8) ::=> Void
        := self subclassResponsibility.

    public abstract method nextPutUInt16: (value: UInt16) ::=> Void
        := self subclassResponsibility.

    public abstract method nextPutInt16: (value: Int16) ::=> Void
        := self subclassResponsibility.

    public abstract method nextPutUInt32: (value: UInt32) ::=> Void
        := self subclassResponsibility.

    public abstract method nextPutInt32: (value: Int32) ::=> Void
        := self subclassResponsibility.

    public abstract method nextPutUInt64: (value: UInt64) ::=> Void
        := self subclassResponsibility.

    public abstract method nextPutInt64: (value: Int64) ::=> Void
        := self subclassResponsibility.

    public abstract method nextPutFloat32: (value: Float32) ::=> Void
        := self subclassResponsibility.

    public abstract method nextPutFloat64: (value: Float64) ::=> Void
        := self subclassResponsibility.

    public abstract method recordSymbol: (symbol: AsmSymbol) ::=> Void
        := self subclassResponsibility.

    public abstract method recordSymbolEnd: (symbol: AsmSymbol) ::=> Void
        := self subclassResponsibility.
}.

AsmObjectCodeSizeStream definition: {
    public override method alignTo: (requiredAlignment: Size) ::=> Void := {
        activeSection alignSizeTo: requiredAlignment.
    }.

    public override method nextPut: (value: UInt8) ::=> Void := {
        activeSection increaseSizeBy: 1sz
    }.

    public override method nextPutAll: (bytes: ByteArray) ::=> Void := {
        activeSection increaseSizeBy: bytes size
    }.

    public override method nextPutInt8: (value: Int8) ::=> Void := {
        activeSection increaseSizeBy: 1sz
    }.

    public override method nextPutUInt16: (value: UInt16) ::=> Void := {
        activeSection increaseSizeBy: 2sz
    }.

    public override method nextPutInt16: (value: Int16) ::=> Void := {
        activeSection increaseSizeBy: 2sz
    }.

    public override method nextPutUInt32: (value: UInt32) ::=> Void := {
        activeSection increaseSizeBy: 4sz
    }.

    public override method nextPutInt32: (value: Int32) ::=> Void := {
        activeSection increaseSizeBy: 4sz
    }.

    public override method nextPutUInt64: (value: UInt64) ::=> Void := {
        activeSection increaseSizeBy: 8sz
    }.

    public override method nextPutInt64: (value: Int64) ::=> Void := {
        activeSection increaseSizeBy: 8sz
    }.

    public override method nextPutFloat32: (value: Float32) ::=> Void := {
        activeSection increaseSizeBy: 4sz
    }.

    public override method nextPutFloat64: (value: Float64) ::=> Void := {
        activeSection increaseSizeBy: 8sz
    }.

    public override method recordSymbol: (symbol: AsmSymbol) ::=> Void := {
        objectCodeBuilder recordSymbol: symbol.
        symbol
            section: activeSection;
            value: activeSection size asUInt64.
    }.

    public override method recordSymbolEnd: (symbol: AsmSymbol) ::=> Void := {
        symbol size: activeSection size asUInt64 - symbol value.
    }.
}.

AsmObjectCodeWriteStream definition: {
    public override method alignTo: (requiredAlignment: Size) ::=> Void := {
        activeSection alignWriteOffsetTo: requiredAlignment.
    }.

    public override method nextPut: (value: UInt8) ::=> Void := {
        activeSection nextPut: value
    }.

    public override method nextPutInt8: (value: Int8) ::=> Void := {
        activeSection nextPutInt8: value
    }.

    public override method nextPutUInt16: (value: UInt16) ::=> Void := {
        activeSection nextPutUInt16: value
    }.

    public override method nextPutInt16: (value: Int16) ::=> Void := {
        activeSection nextPutInt16: value
    }.

    public override method nextPutUInt32: (value: UInt32) ::=> Void := {
        activeSection nextPutUInt32: value
    }.

    public override method nextPutInt32: (value: Int32) ::=> Void := {
        activeSection nextPutInt32: value
    }.

    public override method nextPutUInt64: (value: UInt64) ::=> Void := {
        activeSection nextPutUInt64: value
    }.

    public override method nextPutInt64: (value: Int64) ::=> Void := {
        activeSection nextPutInt64: value
    }.

    public override method nextPutFloat32: (value: Float32) ::=> Void := {
        activeSection nextPutFloat32: value
    }.

    public override method nextPutFloat64: (value: Float64) ::=> Void := {
        activeSection nextPutFloat64: value
    }.

    public override method nextPutAll: (bytes: ByteArray) ::=> Void := {
        activeSection nextPutAll: bytes
    }.

    public abstract method recordSymbol: (symbol: AsmSymbol) ::=> Void := {
        symbol
            section: activeSection;
            value: activeSection writeOffset asUInt64.
    }.

    public abstract method recordSymbolEnd: (symbol: AsmSymbol) ::=> Void := {
        symbol size: activeSection size asUInt64 - symbol value.
    }.
}.
