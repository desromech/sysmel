let TrackingFullDebugInfoTuple := false.

public final class AsmObjectCodeSection superclass: Object.
public abstract class AsmObjectCodeStream superclass: Object.
public final class AsmObjectCodeSizeStream superclass: AsmObjectCodeStream.
public final class AsmObjectCodeWriteStream superclass: AsmObjectCodeStream.
public abstract class AsmObjectCodeRelocation superclass: Object.
public abstract class AsmObjectFileWriter superclass: Object.
public abstract class AsmObjectDebugInformationGenerator superclass: Object.
public final class AsmSymbol superclass: Object.
public class AsmInstructionOperand superclass: Object.
public class AsmRegister superclass: AsmInstructionOperand.

public abstract class AsmCompilationTarget superclass: Object; definition: {
    public field platformDescription => PlatformDescription.
    public field operatingSystemName => Symbol.
    public field executable => Boolean.
    public field objectFileWriter => AsmObjectFileWriter.
    public field debugInformationGenerator => AsmObjectDebugInformationGenerator class.

    public virtual method hasPositionIndependentCode => Boolean
        := false.

    public virtual method passesReturnPointerThroughStack => Boolean
        := false.

    public abstract method pointerSize => Size
        := self subclassResponsibility.

    public virtual method pointerAlignment => Size
        := self pointerSize.

    public abstract method uintPointerType => Type
        := self subclassResponsibility.

    public virtual method objectModel => ObjectModelVariant
        := self pointerSize = 4sz ifTrue: ObjectModelVariant32 uniqueInstance ifFalse: ObjectModelVariant64 uniqueInstance.

    public virtual method stackFrameAlignment => Size
        := 16sz.

    public virtual method indirectBranchTargetAlignment => Size
        := 1sz.

    public virtual method directBranchTargetAlignment => Size
        := 1sz.

    public virtual method loopEntryBranchTargetAlignment => Size
        := 1sz.
        
    public virtual method functionEntryPointAlignment => Size
        := self indirectBranchTargetAlignment.

    public abstract method padCodeSectionData: (data: ByteArray) at: (writeOffset: Size) size: (size: Size) unreachable: (unreachable: Boolean) ::=> Void
        := self subclassResponsibility.

    public method setupForPlatform: (thePlatformDescription: PlatformDescription) ::=> Void := {
        platformDescription := thePlatformDescription.

        let osNameString := platformDescription osName asString.
        let setForOSNameSelector := ("setFor" -- (osNameString first: 1sz) asUppercase -- osNameString allButFirst) asSymbol.
        self perform: setForOSNameSelector.
    }.
}.

public abstract class AsmCallFrameInformationInstruction superclass: Object; definition: {
    public field address => UInt64.
}.

public final class AsmCallFrameInformationEndPrologueInstruction superclass: AsmCallFrameInformationInstruction.
public final class AsmCallFrameInformationBeginEpilogueInstruction superclass: AsmCallFrameInformationInstruction.
public final class AsmCallFrameInformationEndEpilogueInstruction superclass: AsmCallFrameInformationInstruction.

public final class AsmCallFrameInformationPushRegisterInstruction superclass: AsmCallFrameInformationInstruction; definition: {
    public field register => AsmRegister.
}.

public final class AsmCallFrameInformationPopRegisterInstruction superclass: AsmCallFrameInformationInstruction; definition: {
    public field register => AsmRegister.
}.

public final class AsmCallFrameInformationSaveFramePointerInstruction superclass: AsmCallFrameInformationInstruction; definition: {
    public field register => AsmRegister.
    public field offset => Int64.
}.

public final class AsmCallFrameInformationRestoreFramePointerInstruction superclass: AsmCallFrameInformationInstruction; definition: {
    public field register => AsmRegister.
    public field offset => Int64.
}.

public final class AsmCallFrameInformationStackSizeAdvanceInstruction superclass: AsmCallFrameInformationInstruction; definition: {
    public field increment => Int64.
}.

public final class AsmFrameDescriptionInformation superclass: Object; definition: {
    public field startOffset => Size.
    public field endOffset => Size.

    public field instructions => OrderedCollection.

    public override method initialize => Void := {
        instructions := OrderedCollection new.
    }.
}.

AsmObjectCodeSection definition: {
    public field name => Symbol.
    public field machoSectionName => Symbol.
    public field machoSegmentName => Symbol.
    public field data => ByteArray.
    public field alignment => Size.
    public field size => Size.
    public field writeOffset => Size.

    public field executable => Boolean.
    public field writeable => Boolean.
    public field readable => Boolean.
    public field loaded => Boolean.
    public field nobits => Boolean.
    public field tls => Boolean.

    public field relocations => Array.
    public field frameDescriptions => Array.

    public field offsetOfEncodedElementInByteStream => Size.
    public field newRelocations => OrderedCollection.
    public field newFrameDescriptions => OrderedCollection.
    public field currentFrameDescription => AsmFrameDescriptionInformation.

    public field debugSourcePositions => Array.
    public field debugSourceNodes => Array.
    public field debugSourceEnvironments => Array.
    public field pcToDebugListTable => Array.

    public field newDebugTuples => OrderedCollection.
    public field newDebugListsDictionary => Dictionary.
    public field newPCToDebugListTable => OrderedCollection.

    public field lastDebugSourcePosition => SourcePosition.
    public field lastDebugSourceNode => ASTNode.
    public field lastDebugSourceEnvironment => Environment.

    public override method initialize => Void := {
        data := #[].
        size := 0sz.
        alignment := 1sz.
        writeOffset := 0sz.
        relocations := #().
        frameDescriptions := #().
    }.

    public method increaseSizeBy: (extraSize: Size) ::=> Void := {
        size := size + extraSize
    }.

    public method alignSizeTo: (requiredAlignment: Size) ::=> Void := {
        alignment := alignment max: requiredAlignment.
        size := size alignedTo: requiredAlignment.
    }.

    public method alignWriteOffsetTo: (requiredAlignment: Size) unreachable: (unreachable: Boolean) compilationTarget: (compilationTarget: AsmCompilationTarget) ::=> Void := {
        ## FIXME: Delegate this onto the target machine.
        let newWriteOffset := writeOffset alignedTo: requiredAlignment.
        executable ifTrue: {
            let paddingSize mutable := newWriteOffset - writeOffset.
            compilationTarget padCodeSectionData: data at: writeOffset size: paddingSize unreachable: unreachable.
        }.
        
        writeOffset := newWriteOffset.
    }.

    public method addExecutable: (flag: Boolean) ::=> Boolean := {
        executable := executable || flag
    }.

    public method addWriteable: (flag: Boolean) ::=> Boolean := {
        writeable := writeable || flag
    }.

    public method addReadable: (flag: Boolean) ::=> Boolean := {
        readable := readable || flag
    }.

    public method addLoaded: (flag: Boolean) ::=> Boolean := {
        loaded := loaded || flag
    }.

    public method addNoBits: (flag: Boolean) ::=> Boolean := {
        nobits := nobits || flag
    }.

    public method addTLS: (flag: Boolean) ::=> Boolean := {
        tls := tls || flag
    }.

    public method nextPut: (value: UInt8) ::=> Void := {
        data at: writeOffset put: value.
        writeOffset := writeOffset + 1sz.
    }.

    public method nextPutString: (string: String) ::=> Void := {
        let byteCount := string size.
        data ifNotNil: (data replaceBytesFrom: writeOffset count: byteCount with: string startingAt: 0sz).
        writeOffset := writeOffset + byteCount.
    }.

    public method nextPutStructure: (structure: AnyValue) withSize: (structureSize: Size) ::=> Void := {
        structure __type__ encodeValue: structure inBytes: data atOffset: writeOffset.
        writeOffset := writeOffset + structureSize
    }.

    public method nextReserveBytes: (size: Size) ::=> Void := {
        writeOffset := writeOffset + size
    }.

    public method nextPutAll: (bytes: ByteArray) ::=> Void := {
        let byteCount := bytes size.
        data ifNotNil: (data replaceBytesFrom: writeOffset count: byteCount with: bytes startingAt: 0sz).
        writeOffset := writeOffset + byteCount.
    }.

    public method nextPutInt8: (value: Int8) ::=> Void := {
        data ifNotNil: (data int8At: writeOffset put: value).
        writeOffset := writeOffset + 1sz.
    }.

    public method nextPutUInt16: (value: UInt16) ::=> Void := {
        data ifNotNil: (data uint16At: writeOffset put: value).
        writeOffset := writeOffset + 2sz.
    }.

    public method nextPutInt16: (value: Int16) ::=> Void := {
        data ifNotNil: (data int16At: writeOffset put: value).
        writeOffset := writeOffset + 2sz.
    }.

    public method nextPutUInt32: (value: UInt32) ::=> Void := {
        data ifNotNil: (data uint32At: writeOffset put: value).
        writeOffset := writeOffset + 4sz.
    }.

    public method nextPutInt32: (value: Int32) ::=> Void := {
        data ifNotNil: (data int32At: writeOffset put: value).
        writeOffset := writeOffset + 4sz.
    }.

    public method nextPutUInt64: (value: UInt64) ::=> Void := {
        data ifNotNil: (data uint64At: writeOffset put: value).
        writeOffset := writeOffset + 8sz.
    }.

    public method nextPutInt64: (value: Int64) ::=> Void := {
        data ifNotNil: (data int64At: writeOffset put: value).
        writeOffset := writeOffset + 8sz.
    }.

    public method nextPutFloat32: (value: Float32) ::=> Void := {
        data ifNotNil: (data float32At: writeOffset put: value).
        writeOffset := writeOffset + 4sz.
    }.

    public method nextPutFloat64: (value: Float64) ::=> Void := {
        data ifNotNil: (data float64At: writeOffset put: value).
        writeOffset := writeOffset + 8sz.
    }.

    public override method fullPrintOn: (stream: Stream) ::=> Void := {
        stream
            nextPutAll: "section: "; print: name;
            nextPutAll: " size: "; print: size;
            nextPutAll: " alignment: "; print: alignment;
            nextPutAll: " data: "; print: data.
    }.

    public method allocateMemoryForWriting => Void := {
        size := size alignedTo: alignment.
        nobits ifFalse: {
            data := ByteArray new: size.
        }.
        newRelocations := OrderedCollection new.
        newFrameDescriptions := OrderedCollection new.
        writeOffset := 0sz.
    }.

    public method writeUnallocatedBytes: (bytes: ByteArray) ::=> Void := {
        self assert: writeOffset = size.
        let extraSize := bytes size.
        size := size + extraSize.
        writeOffset := writeOffset + extraSize.
        data := data -- bytes.
    }.

    public method finishWritingWithTarget: (compilationTarget: AsmCompilationTarget) ::=> Void := {
        self alignWriteOffsetTo: alignment unreachable: true compilationTarget: compilationTarget.
        relocations := newRelocations asArray.
        newRelocations := nil.
    }.

    public override method sizeOfByteEncoding => Size := data size.
    public override method canEncodeInBytes => Boolean := true.

    public override method encodeInBytes: (destination: ByteArray) atOffset: (destinationOffset: Size) ::=> Void := {
        destination replaceBytesFrom: destinationOffset count: data size with: data
    }.

    public method entryIndexForDebugSourcePosition: (sourcePosition: SourcePosition) ::=> UInt32 := {
        newDebugTuples ifNil: {
            newDebugTuples := OrderedCollection new.
            newDebugListsDictionary := Dictionary new.
            newPCToDebugListTable := OrderedCollection new.
        }.

        sourcePosition isNil ifTrue: {
            0u32
        } ifFalse: {
            newDebugListsDictionary at: sourcePosition ifAbsentPut: {:: UInt32 |
                newDebugTuples add: sourcePosition.
                newDebugTuples size asUInt32
            }
        }
    }.

    public method entryIndexForDebugSourcePosition: (sourcePosition: SourcePosition) node: (node: ASTNode) environment: (environment: Environment) ::=> UInt32 := {
        newDebugTuples ifNil: {
            newDebugTuples := OrderedCollection new.
            newDebugListsDictionary := Dictionary new.
            newPCToDebugListTable := OrderedCollection new.
        }.

        sourcePosition isNil && node isNil && environment isNil ifTrue: {
            0u32
        } ifFalse: {
            let tuple := (sourcePosition, node, environment).
            newDebugListsDictionary at: tuple ifAbsentPut: {:: UInt32 |
                newDebugTuples add: tuple.
                newDebugTuples size asUInt32
            }
        }
    }.

    public method recordDebugSourcePosition: (sourcePosition: SourcePosition) node: (node: ASTNode) environment: (environment: Environment) ::=> Void := {
        let debugListEntryIndex := TrackingFullDebugInfoTuple ifTrue: {
            (lastDebugSourcePosition = sourcePosition) && (lastDebugSourceNode = node) && (lastDebugSourceEnvironment = environment) ifTrue: {
                return: void
            }.
            lastDebugSourcePosition := sourcePosition.
            lastDebugSourceNode := node.
            lastDebugSourceEnvironment := environment.

            self entryIndexForDebugSourcePosition: sourcePosition node: node environment: environment.
        } ifFalse: {
            lastDebugSourcePosition = sourcePosition ifTrue: {
                return: void
            }.
            lastDebugSourcePosition := sourcePosition.

            self entryIndexForDebugSourcePosition: sourcePosition.
        }.

        let pc := writeOffset asUInt32.
        (newPCToDebugListTable isNotEmpty && (pc = newPCToDebugListTable nextToLast)) ifTrue: {
            newPCToDebugListTable at: newPCToDebugListTable size - 1sz put: debugListEntryIndex
        } ifFalse: {
            newPCToDebugListTable isEmpty || (debugListEntryIndex ~= newPCToDebugListTable last) ifTrue: {
                newPCToDebugListTable add: pc; add: debugListEntryIndex
            }
        }
    }.

    public method finishDebugAndUnwindInfo => Void := {
        frameDescriptions := newFrameDescriptions asArray.
        newFrameDescriptions := nil.

        newDebugTuples ifNil: {
            return: void.
        }.

        TrackingFullDebugInfoTuple ifTrue: {
            debugSourcePositions := Array new: newDebugTuples size.
            debugSourceNodes := Array new: newDebugTuples size.
            debugSourceEnvironments := Array new: newDebugTuples size.
            newDebugTuples doWithIndex: {:(Array)tuple :(Size)index :: Void |
                debugSourcePositions at: index put: tuple first.
                debugSourceNodes at: index put: tuple second.
                debugSourceEnvironments at: index put: tuple third.
            }.
        } ifFalse: {
            debugSourcePositions := newDebugTuples asArray
        }.

        pcToDebugListTable := newPCToDebugListTable asArray.

        newDebugTuples := nil.
        newDebugListsDictionary := nil.
        newPCToDebugListTable := nil.

        lastDebugSourcePosition := nil.
        lastDebugSourceNode := nil.
        lastDebugSourceEnvironment := nil.
    }.

    public method cfiBeginProcedure => Void := {
        currentFrameDescription := AsmFrameDescriptionInformation new
            startOffset: writeOffset;
            yourself.
        newFrameDescriptions add: currentFrameDescription.
    }.

    public method cfiEndProcedure => Void := {
        currentFrameDescription endOffset: writeOffset.
        currentFrameDescription := nil.
    }.

    public method cfiEndPrologue => Void := {
        currentFrameDescription instructions add: (AsmCallFrameInformationEndPrologueInstruction new
            address: writeOffset asUInt64;
            yourself).
    }.

    public method cfiBeginEpilogue => Void := {
        currentFrameDescription instructions add: (AsmCallFrameInformationBeginEpilogueInstruction new
            address: writeOffset asUInt64;
            yourself).
    }.

    public method cfiEndEpilogue => Void := {
        currentFrameDescription instructions add: (AsmCallFrameInformationEndEpilogueInstruction new
            address: writeOffset asUInt64;
            yourself).
    }.

    public method cfiPushRegister: (register: AsmRegister) ::=> Void := {
        currentFrameDescription instructions add: (AsmCallFrameInformationPushRegisterInstruction new
            address: writeOffset asUInt64;
            register: register;
            yourself).
    }.

    public method cfiPopRegister: (register: AsmRegister) ::=> Void := {
        currentFrameDescription instructions add: (AsmCallFrameInformationPopRegisterInstruction new
            address: writeOffset asUInt64;
            register: register;
            yourself).
    }.

    public method cfiSaveFramePointer: (register: AsmRegister) offset: (offset: Int64) ::=> Void := {
        currentFrameDescription instructions add: (AsmCallFrameInformationSaveFramePointerInstruction new
            address: writeOffset asUInt64;
            register: register;
            offset: offset;
            yourself).
    }.

    public method cfiRestoreFramePointer: (register: AsmRegister) offset: (offset: Int64) ::=> Void := {
        currentFrameDescription instructions add: (AsmCallFrameInformationRestoreFramePointerInstruction new
            address: writeOffset asUInt64;
            register: register;
            offset: offset;
            yourself).
    }.

    public method cfiStackSizeAdvance: (increment: Int64) ::=> Void := {
        currentFrameDescription instructions add: (AsmCallFrameInformationStackSizeAdvanceInstruction new
            address: writeOffset asUInt64;
            increment: increment;
            yourself).
    }.
}.

public final class AsmObjectCode superclass: Object; definition: {
    public field compilationTarget => AsmCompilationTarget.

    public field sections => Array.
    public field symbols => Array.

    public override method fullPrintOn: (stream: Stream) ::=> Void := {
        sections do: {:(AsmObjectCodeSection)each :: Void |
            stream fullPrint: each
        }.
        symbols do: {:(AsmSymbol)each :: Void |
            stream fullPrint: each
        }.
    }.

    public method encodeAsObjectFile ::=> ByteArray
        := compilationTarget objectFileWriter encodeObjectCode: self.

    public method writeObjectToFileNamed: (fileName: String) ::=> Boolean
        := compilationTarget objectFileWriter writeObjectCode: self toFileNamed: fileName.
}.

AsmObjectFileWriter definition: {
    public abstract method encodeObjectCode: (objectCode: AsmObjectCode) ::=> ByteArray
        := self subclassResponsibility.

    public method writeObjectCode: (objectCode: AsmObjectCode) toFileNamed: (fileName: String) ::=> Boolean
        := IO::writeWholeFileNamedWithByteArray(fileName, self encodeObjectCode: objectCode).
}.

public final class AsmObjectCodeCStringTable superclass: Object; definition: {
    public field stringStream => StringStream.
    public field stringIndexTable => Dictionary.
    
    public field size => Size.
    public field data => ByteArray.
    
    public field offsetOfEncodedElementInByteStream => Size.

    public override method initialize => Void := {
        stringStream := StringStream new.
        stringIndexTable := Dictionary new.
        self addString: "".
    }.

    public method addString: (string: String) ::=> Size
        := stringIndexTable at: string ifAbsentPut: {:: Size |
            let index := size.
            stringStream nextPutAll: string; nextPut: 0c8.
            size := size + (string size + 1sz).
            index
        }.

    public method addSymbol: (symbol: Symbol) ::=> Size
        := stringIndexTable at: symbol ifAbsentPut: {:: Size |
            self addString: symbol asString
        }.

    public method finish => Void := {
        data := stringStream asByteArray.
        size := data size.
    }.

    public override method sizeOfByteEncoding => Size := size.
    public override method canEncodeInBytes => Boolean := true.

    public override method encodeInBytes: (destination: ByteArray) atOffset: (destinationOffset: Size) ::=> Void := {
        destination replaceBytesFrom: destinationOffset count: data size with: data
    }.
}.

public global AsmSymbol::Visibility::Private := 0u8.
public global AsmSymbol::Visibility::Internal := 1u8.
public global AsmSymbol::Visibility::Public := 2u8.
public global AsmSymbol::Visibility::Weak := 3u8.

public global AsmSymbol::Type::None := 0u8.
public global AsmSymbol::Type::Function := 1u8.
public global AsmSymbol::Type::Variable := 2u8.

AsmSymbol definition: {
    public field name => Symbol.
    public field section => AsmObjectCodeSection.
    public field value => UInt64.
    public field size => UInt64.
    public field visibility => UInt8.
    public field type => UInt8.

    public method makePrivate => Void := {
        visibility := AsmSymbol::Visibility::Private.
    }.

    public method isPrivate => Boolean
        := visibility = AsmSymbol::Visibility::Private.

    public method makeInternal => Void := {
        visibility := AsmSymbol::Visibility::Internal.
    }.

    public method isInternal => Boolean
        := visibility = AsmSymbol::Visibility::Internal.

    public method makePublic => Void := {
        visibility := AsmSymbol::Visibility::Public.
    }.

    public method isWeak => Boolean
        := visibility = AsmSymbol::Visibility::Weak.

    public method makeWeak => Void := {
        visibility := AsmSymbol::Visibility::Weak.
    }.

    public method isPublic => Boolean
        := visibility = AsmSymbol::Visibility::Public.

    public method makeFunction => Void := {
        type := AsmSymbol::Type::Function.
    }.

    public method isFunction => Boolean
        := type = AsmSymbol::Type::Function.

    public override method printOn: (stream: Stream) ::=> Void := {
        self isPrivate ifTrue: (stream nextPut: '.'c8).
        name ifNotNil: {
            stream string: name.
        } ifNil: {
            stream nextPutAll: "anon".
        }
    }.

    public method privateAddend => Int64
        := self isPrivate ifTrue: (value asInt64) ifFalse: (0i64).
}.

public final class AsmObjectCodeBuilder superclass: Object; definition: {
    public field compilationTarget => AsmCompilationTarget.

    public field sections => OrderedCollection.
    public field sectionNameTable => Dictionary.
    public field symbols => OrderedCollection.

    public override method initialize => Void := {
        sections := OrderedCollection new.
        sectionNameTable := Dictionary new.
        symbols := OrderedCollection new.
    }.

    public method addImportedSymbols: (importedSymbols: Collection) ::=> Void := {
        symbols addAll: importedSymbols
    }.

    public method recordSymbol: (symbol: AsmSymbol) ::=> Void := {
        ## Filter the symbols by using a set.
        symbols add: symbol
    }.

    public method getSectionNamed: (name: Symbol) ::=> AsmObjectCodeSection
        := sectionNameTable at: name.

    public method getOrCreateSectionNamed: (name: Symbol) machoSectionName: (machoSectionName: Symbol) machoSegmentName: (machoSegmentName: Symbol) ::=> AsmObjectCodeSection
        := sectionNameTable at: name ifAbsentPut: {:: AsmObjectCodeSection |
            let newSection := AsmObjectCodeSection new
                name: name;
                machoSectionName: machoSectionName;
                machoSegmentName: machoSegmentName;
                yourself.
            sections add: newSection.
            newSection
        }.

    public method finishDebugAndUnwindInfo => Void := {
        sections do: {:(AsmObjectCodeSection)each :: Void |
            each finishDebugAndUnwindInfo
        }
    }.

    public method finish => AsmObjectCode := {
        sections do: {:(AsmObjectCodeSection)each :: Void |
            each finishWritingWithTarget: compilationTarget
        }.

        AsmObjectCode new
            compilationTarget: compilationTarget;
            sections: sections asArray;
            symbols: symbols asArray;
            yourself
    }.

    public method newSizeStream => AsmObjectCodeSizeStream
        := AsmObjectCodeSizeStream new
            objectCodeBuilder: self;
            yourself.

    public method allocateMemoryForWriting => Void := {
        sections do: {:(AsmObjectCodeSection)each :: Void |
            each allocateMemoryForWriting
        }
    }.

    public method newWriteStream => AsmObjectCodeWriteStream
        := AsmObjectCodeWriteStream new
            objectCodeBuilder: self;
            yourself.
}.

AsmObjectCodeRelocation definition: {
    public field symbol => AsmSymbol.
    public field offset => Size.

    public virtual method isSectionRelative => Boolean := false.

    public abstract method applyAddendInTargetSection: (targetSection: AsmObjectCodeSection) withExtraAddend: (extraAddend: Int64) ::=> Void
        := self subclassResponsibility.

    public method applyAddendInTargetSection: (targetSection: AsmObjectCodeSection)::=> Void := {
        self applyAddendInTargetSection: targetSection withExtraAddend: 0i64
    }.
}.

public final class AsmObjectCodeRelocationAbsoluteInt8 superclass: AsmObjectCodeRelocation; definition: {
    public field addend => Int8.

    public override method applyAddendInTargetSection: (targetSection: AsmObjectCodeSection) withExtraAddend: (extraAddend: Int64) ::=> Void
        := targetSection data int8At: offset put: addend + extraAddend asInt8.
}.

public final class AsmObjectCodeRelocationAbsoluteInt16 superclass: AsmObjectCodeRelocation; definition: {
    public field addend => Int16.

    public override method applyAddendInTargetSection: (targetSection: AsmObjectCodeSection) withExtraAddend: (extraAddend: Int64) ::=> Void
        := targetSection data int16At: offset put: addend + extraAddend asInt16.
}.

public final class AsmObjectCodeRelocationTPOffset32 superclass: AsmObjectCodeRelocation; definition: {
    public field addend => Int32.

    public override method applyAddendInTargetSection: (targetSection: AsmObjectCodeSection) withExtraAddend: (extraAddend: Int64) ::=> Void
        := targetSection data int32At: offset put: addend + extraAddend asInt32.
}.

public final class AsmObjectCodeRelocationAbsoluteInt32 superclass: AsmObjectCodeRelocation; definition: {
    public field addend => Int32.

    public override method applyAddendInTargetSection: (targetSection: AsmObjectCodeSection) withExtraAddend: (extraAddend: Int64) ::=> Void
        := targetSection data int32At: offset put: addend + extraAddend asInt32.
}.

public final class AsmObjectCodeRelocationAbsoluteInt64 superclass: AsmObjectCodeRelocation; definition: {
    public field addend => Int64.

    public override method applyAddendInTargetSection: (targetSection: AsmObjectCodeSection) withExtraAddend: (extraAddend: Int64) ::=> Void
        := targetSection data int64At: offset put: addend + extraAddend asInt64.
}.

public final class AsmObjectCodeRelocationSectionRelativeInt32 superclass: AsmObjectCodeRelocation; definition: {
    public field addend => Int32.

    public override method isSectionRelative => Boolean := true.

    public override method applyAddendInTargetSection: (targetSection: AsmObjectCodeSection) withExtraAddend: (extraAddend: Int64) ::=> Void
        := targetSection data int32At: offset put: addend + extraAddend asInt32.
}.

public final class AsmObjectCodeRelocationSectionRelativeInt64 superclass: AsmObjectCodeRelocation; definition: {
    public field addend => Int64.

    public override method isSectionRelative => Boolean := true.

    public override method applyAddendInTargetSection: (targetSection: AsmObjectCodeSection) withExtraAddend: (extraAddend: Int64) ::=> Void
        := targetSection data int64At: offset put: addend + extraAddend.
}.

public final class AsmObjectCodeRelocationRelativeInt8 superclass: AsmObjectCodeRelocation; definition: {
    public field addend => Int8.

    public override method applyAddendInTargetSection: (targetSection: AsmObjectCodeSection) withExtraAddend: (extraAddend: Int64) ::=> Void
        := targetSection data int8At: offset put: addend + extraAddend asInt8.
}.

public final class AsmObjectCodeRelocationRelativeInt16 superclass: AsmObjectCodeRelocation; definition: {
    public field addend => Int16.

    public override method applyAddendInTargetSection: (targetSection: AsmObjectCodeSection) withExtraAddend: (extraAddend: Int64) ::=> Void
        := targetSection data int16At: offset put: addend + extraAddend asInt16.
}.

public final class AsmObjectCodeRelocationRelativeInt32 superclass: AsmObjectCodeRelocation; definition: {
    public field addend => Int32.

    public override method applyAddendInTargetSection: (targetSection: AsmObjectCodeSection) withExtraAddend: (extraAddend: Int64) ::=> Void
        := targetSection data int32At: offset put: addend + extraAddend asInt32.
}.

public final class AsmObjectCodeRelocationRelativeInt32AtPLT superclass: AsmObjectCodeRelocation; definition: {
    public field addend => Int32.

    public override method applyAddendInTargetSection: (targetSection: AsmObjectCodeSection) withExtraAddend: (extraAddend: Int64) ::=> Void
        := targetSection data int32At: offset put: addend + extraAddend asInt32.
}.

public final class AsmObjectCodeRelocationRelativeInt32AtGOT superclass: AsmObjectCodeRelocation; definition: {
    public field addend => Int32.

    public override method applyAddendInTargetSection: (targetSection: AsmObjectCodeSection) withExtraAddend: (extraAddend: Int64) ::=> Void
        := targetSection data int32At: offset put: addend + extraAddend asInt32.
}.

public final class AsmObjectCodeRelocationRelativeInt64 superclass: AsmObjectCodeRelocation; definition: {
    public field addend => Int64.
}.

AsmObjectCodeStream definition: {
    public field objectCodeBuilder => AsmObjectCodeBuilder.
    public field activeSection => AsmObjectCodeSection.

    public method isInX86LongMode => Boolean
        := objectCodeBuilder compilationTarget pointerSize = 8sz.

    public abstract method alignTo: (requiredAlignment: Size) unreachable: (unreachable: Boolean) ::=> Void
        := self subclassResponsibility.

    public method enterSectionNamed: (name: Symbol) machoSectionName: (machoSectionName: Symbol) machoSegmentName: (machoSegmentName: Symbol) ::=> AsmObjectCodeSection := {
        activeSection := objectCodeBuilder getOrCreateSectionNamed: name machoSectionName: machoSectionName machoSegmentName: machoSegmentName
    }.

    public virtual method recordDebugSourcePosition: (sourcePosition: SourcePosition) node: (node: ASTNode) environment: (environment: Environment) ::=> Void := {
        ## By default do nothing.
    }.

    public abstract method nextPut: (value: UInt8) ::=> Void
        := self subclassResponsibility.

    public abstract method nextPutAll: (bytes: ByteArray) ::=> Void
        := self subclassResponsibility.

    public method nextPutUInt32: (value: UInt32) withSize: (size: Size) ::=> Void := {
        size = 1sz ifTrue: {
            self nextPutUInt8: value asUInt8.
            return: void
        }.
        size = 2sz ifTrue: {
            self nextPutUInt16: value asUInt16.
            return: void
        }.
        size = 4sz ifTrue: {
            self nextPutUInt32: value.
            return: void
        }.
        size = 8sz ifTrue: {
            self nextPutUInt64: value asUInt64.
            return: void
        }.

        self error: "Unsupported size".
    }.

    public method nextPutInt32: (value: Int32) withSize: (size: Size) ::=> Void := {
        size = 1sz ifTrue: {
            self nextPutInt8: value asInt8.
            return: void
        }.
        size = 2sz ifTrue: {
            self nextPutInt16: value asInt16.
            return: void
        }.
        size = 4sz ifTrue: {
            self nextPutInt32: value.
            return: void
        }.
        size = 8sz ifTrue: {
            self nextPutInt64: value asInt64.
            return: void
        }.

        self error: "Unsupported size".
    }.

    public method nextPutUInt64: (value: UInt64) withSize: (size: Size) ::=> Void := {
        size = 1sz ifTrue: {
            self nextPutUInt8: value asUInt8.
            return: void
        }.
        size = 2sz ifTrue: {
            self nextPutUInt16: value asUInt16.
            return: void
        }.
        size = 4sz ifTrue: {
            self nextPutUInt32: value asUInt32.
            return: void
        }.
        size = 8sz ifTrue: {
            self nextPutUInt64: value.
            return: void
        }.

        self error: "Unsupported size".
    }.

    public method nextPutInt64: (value: Int64) withSize: (size: Size) ::=> Void := {
        size = 1sz ifTrue: {
            self nextPutInt8: value asInt8.
            return: void
        }.
        size = 2sz ifTrue: {
            self nextPutInt16: value asInt16.
            return: void
        }.
        size = 4sz ifTrue: {
            self nextPutInt32: value asInt32.
            return: void
        }.
        size = 8sz ifTrue: {
            self nextPutInt64: value.
            return: void
        }.

        self error: "Unsupported size".
    }.

    public method nextPutUInt8: (value: UInt8) ::=> Void
        := self nextPut: value.

    public abstract method nextPutInt8: (value: Int8) ::=> Void
        := self subclassResponsibility.

    public abstract method nextPutUInt16: (value: UInt16) ::=> Void
        := self subclassResponsibility.

    public abstract method nextPutInt16: (value: Int16) ::=> Void
        := self subclassResponsibility.

    public abstract method nextPutUInt32: (value: UInt32) ::=> Void
        := self subclassResponsibility.

    public abstract method nextPutInt32: (value: Int32) ::=> Void
        := self subclassResponsibility.

    public abstract method nextPutUInt64: (value: UInt64) ::=> Void
        := self subclassResponsibility.

    public abstract method nextPutInt64: (value: Int64) ::=> Void
        := self subclassResponsibility.

    public abstract method nextPutFloat32: (value: Float32) ::=> Void
        := self subclassResponsibility.

    public abstract method nextPutFloat64: (value: Float64) ::=> Void
        := self subclassResponsibility.

    public abstract method nextPutString: (string: String) ::=> Void
        := self subclassResponsibility.

    public abstract method nextPutStructure: (structure: AnyValue) withSize: (structureSize: Size) ::=> Void
        := self subclassResponsibility.

    public abstract method nextReserveBytes: (size: Size) ::=> Void
        := self subclassResponsibility.

    public abstract method recordSymbol: (symbol: AsmSymbol) ::=> Void
        := self subclassResponsibility.

    public abstract method recordSymbolEnd: (symbol: AsmSymbol) ::=> Void
        := self subclassResponsibility.

    public abstract method recordRelocation: (relocation: AsmObjectCodeRelocation) ::=> Void
        := self subclassResponsibility.

    public abstract method recordRelocations: (relocations: Collection) ::=> Void
        := self subclassResponsibility.

    public virtual method cfiBeginProcedure => Void := {}.
    public virtual method cfiEndProcedure => Void := {}.
    public virtual method cfiEndPrologue => Void := {}.
    public virtual method cfiBeginEpilogue => Void := {}.
    public virtual method cfiEndEpilogue => Void := {}.
    public virtual method cfiPushRegister: (register: AsmRegister) ::=> Void := {}.
    public virtual method cfiPopRegister: (register: AsmRegister) ::=> Void := {}.
    public virtual method cfiSaveFramePointer: (register: AsmRegister) offset: (offset: Int64) ::=> Void := {}.
    public virtual method cfiRestoreFramePointer: (register: AsmRegister) offset: (offset: Int64) ::=> Void := {}.
    public virtual method cfiStackSizeAdvance: (increment: Int64) ::=> Void := {}.
}.

AsmObjectCodeSizeStream definition: {
    public override method alignTo: (requiredAlignment: Size) unreachable: (unreachable: Boolean) ::=> Void := {
        activeSection alignSizeTo: requiredAlignment.
    }.

    public override method nextPut: (value: UInt8) ::=> Void := {
        activeSection increaseSizeBy: 1sz
    }.

    public override method nextPutAll: (bytes: ByteArray) ::=> Void := {
        activeSection increaseSizeBy: bytes size
    }.

    public override method nextPutInt8: (value: Int8) ::=> Void := {
        activeSection increaseSizeBy: 1sz
    }.

    public override method nextPutUInt16: (value: UInt16) ::=> Void := {
        activeSection increaseSizeBy: 2sz
    }.

    public override method nextPutInt16: (value: Int16) ::=> Void := {
        activeSection increaseSizeBy: 2sz
    }.

    public override method nextPutUInt32: (value: UInt32) ::=> Void := {
        activeSection increaseSizeBy: 4sz
    }.

    public override method nextPutInt32: (value: Int32) ::=> Void := {
        activeSection increaseSizeBy: 4sz
    }.

    public override method nextPutUInt64: (value: UInt64) ::=> Void := {
        activeSection increaseSizeBy: 8sz
    }.

    public override method nextPutInt64: (value: Int64) ::=> Void := {
        activeSection increaseSizeBy: 8sz
    }.

    public override method nextPutFloat32: (value: Float32) ::=> Void := {
        activeSection increaseSizeBy: 4sz
    }.

    public override method nextPutFloat64: (value: Float64) ::=> Void := {
        activeSection increaseSizeBy: 8sz
    }.

    public override method nextPutString: (string: String) ::=> Void := {
        activeSection increaseSizeBy: string size
    }.
    
    public override method nextPutStructure: (structure: AnyValue) withSize: (structureSize: Size) ::=> Void := {
        activeSection increaseSizeBy: structureSize
    }.

    public override method nextReserveBytes: (size: Size) ::=> Void := {
        activeSection increaseSizeBy: size
    }.

    public override method recordSymbol: (symbol: AsmSymbol) ::=> Void := {
        objectCodeBuilder recordSymbol: symbol.
        symbol
            section: activeSection;
            value: activeSection size asUInt64.
    }.

    public override method recordSymbolEnd: (symbol: AsmSymbol) ::=> Void := {
        symbol size: activeSection size asUInt64 - symbol value.
    }.

    public override method recordRelocation: (relocation: AsmObjectCodeRelocation) ::=> Void := {}.
    public override method recordRelocations: (relocations: Collection) ::=> Void := {}.

}.

AsmObjectCodeWriteStream definition: {
    public override method recordDebugSourcePosition: (sourcePosition: SourcePosition) node: (node: ASTNode) environment: (environment: Environment) ::=> Void := {
        activeSection recordDebugSourcePosition: sourcePosition node: node environment: environment
    }.

    public override method alignTo: (requiredAlignment: Size) unreachable: (unreachable: Boolean) ::=> Void := {
        activeSection alignWriteOffsetTo: requiredAlignment unreachable: unreachable compilationTarget: objectCodeBuilder compilationTarget.
    }.

    public override method nextPut: (value: UInt8) ::=> Void := {
        activeSection nextPut: value
    }.

    public override method nextPutInt8: (value: Int8) ::=> Void := {
        activeSection nextPutInt8: value
    }.

    public override method nextPutUInt16: (value: UInt16) ::=> Void := {
        activeSection nextPutUInt16: value
    }.

    public override method nextPutInt16: (value: Int16) ::=> Void := {
        activeSection nextPutInt16: value
    }.

    public override method nextPutUInt32: (value: UInt32) ::=> Void := {
        activeSection nextPutUInt32: value
    }.

    public override method nextPutInt32: (value: Int32) ::=> Void := {
        activeSection nextPutInt32: value
    }.

    public override method nextPutUInt64: (value: UInt64) ::=> Void := {
        activeSection nextPutUInt64: value
    }.

    public override method nextPutInt64: (value: Int64) ::=> Void := {
        activeSection nextPutInt64: value
    }.

    public override method nextPutFloat32: (value: Float32) ::=> Void := {
        activeSection nextPutFloat32: value
    }.

    public override method nextPutFloat64: (value: Float64) ::=> Void := {
        activeSection nextPutFloat64: value
    }.

    public override method nextPutString: (string: String) ::=> Void := {
        activeSection nextPutString: string
    }.

    public override method nextPutStructure: (structure: AnyValue) withSize: (structureSize: Size) ::=> Void := {
        activeSection nextPutStructure: structure withSize: structureSize
    }.

    public override method nextReserveBytes: (size: Size) ::=> Void := {
        activeSection nextReserveBytes: size
    }.

    public override method nextPutAll: (bytes: ByteArray) ::=> Void := {
        activeSection nextPutAll: bytes
    }.

    public override method recordSymbol: (symbol: AsmSymbol) ::=> Void := {
        symbol
            section: activeSection;
            value: activeSection writeOffset asUInt64.
    }.

    public override method recordSymbolEnd: (symbol: AsmSymbol) ::=> Void := {
        symbol size: activeSection writeOffset asUInt64 - symbol value.
    }.

    public override method recordRelocation: (relocation: AsmObjectCodeRelocation) ::=> Void := {
        relocation offset: relocation offset + activeSection writeOffset.
        activeSection newRelocations add: relocation
    }.

    public override method recordRelocations: (relocations: Collection) ::=> Void := {
        relocations do: {:(AsmObjectCodeRelocation)eachRelocation :: Void |
            self recordRelocation: eachRelocation copy
        }
    }.

    public override method cfiBeginProcedure => Void := {
        activeSection cfiBeginProcedure
    }.

    public override method cfiEndProcedure => Void := {
        activeSection cfiEndProcedure
    }.

    public override method cfiEndPrologue => Void := {
        activeSection cfiEndPrologue
    }.

    public override method cfiBeginEpilogue => Void := {
        activeSection cfiBeginEpilogue
    }.

    public override method cfiEndEpilogue => Void := {
        activeSection cfiEndEpilogue
    }.

    public override method cfiPushRegister: (register: AsmRegister) ::=> Void := {
        activeSection cfiPushRegister: register
    }.

    public override method cfiPopRegister: (register: AsmRegister) ::=> Void := {
        activeSection cfiPopRegister: register
    }.

    public override method cfiSaveFramePointer: (register: AsmRegister) offset: (offset: Int64) ::=> Void := {
        activeSection cfiSaveFramePointer: register offset: offset
    }.

    public override method cfiRestoreFramePointer: (register: AsmRegister) offset: (offset: Int64) ::=> Void := {
        activeSection cfiRestoreFramePointer: register offset: offset
    }.

    public override method cfiStackSizeAdvance: (increment: Int64) ::=> Void := {
        activeSection cfiStackSizeAdvance: increment        
    }.
}.
