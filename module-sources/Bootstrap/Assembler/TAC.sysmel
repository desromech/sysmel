
public abstract class TACAsmCompilationTarget superclass: TACCompilationTarget; definition: {
    public field asmCompilationTarget => AsmCompilationTarget.

    public override method pointerSize => Size
        := asmCompilationTarget pointerSize.

    public override method pointerAlignment => Size
        := asmCompilationTarget pointerSize.

    public override method uintPointerType => Type
        := asmCompilationTarget uintPointerType.

    public override method stackFrameAlignment => Size
        := asmCompilationTarget stackFrameAlignment.

    public override method generateTargetIRForTACModule: (module: TACModule) ::=> AnyValue := {
        let codeGenerator := TACModuleAsmCodeGenerator new
            target: self;
            asmTarget: asmCompilationTarget;
            targetModule: (AsmProgramEntity new
                compilationTarget: asmCompilationTarget;
                yourself);
            compileModule: module;
            targetModule
    }.
}.

public abstract class TACAsmCodeGenerator superclass: Object; definition: {
    public field target => TACAsmCompilationTarget.

    public abstract method symbolForProgramEntity: (programEntity: TACProgramEntity) ::=> AsmSymbol
        := self subclassResponsibility.

    public abstract method symbolForBasicBlock: (basicBlock: TACBasicBlock) ::=> AsmSymbol
        := self subclassResponsibility.
}.

public final class TACModuleAsmCodeGenerator superclass: TACAsmCodeGenerator; definition: {
    public field targetModule => AsmProgramEntity.
    protected field asmTarget => AsmCompilationTarget.
    public field programEntitySymbolMap => Dictionary.
    public field compiledProgramEntitySymbolMap => Dictionary.

    protected field stringTableList => OrderedCollection.
    protected field stringTableDictionary => Dictionary.

    protected field objectHeap => AsmObjectHeap.

    public override method initialize => Void := {
        programEntitySymbolMap := Dictionary new.
        compiledProgramEntitySymbolMap := Dictionary new.
        objectHeap := AsmObjectHeap new.
        stringTableList := OrderedCollection new.
        stringTableDictionary := Dictionary new.
    }.

    public method asmTarget => AsmCompilationTarget := asmTarget.
    public method asmTarget: (target: AsmCompilationTarget) ::=> Void := {
        asmTarget := target.
        objectHeap compilationTarget: target.
    }.

    public override method symbolForProgramEntity: (programEntity: TACProgramEntity) ::=> AsmSymbol := {
        programEntitySymbolMap at: programEntity ifAbsentPut: {:: AsmSymbol |
            programEntity generateAssemblySymbolWith: self
        }
    }.

    public method symbolOfStringLiteral: (string: String) nullTerminated: (nullTerminated: Boolean) ::=> AsmSymbol := {
        let key := Array with: string with: nullTerminated.
        stringTableDictionary at: key ifAbsentPut: {:: AsmSymbol |
            let stringSymbol := AsmSymbol new
                makePrivate;
                yourself.

            stringTableList add: (Array with: stringSymbol with: key).
            stringSymbol
        }
    }.

    public method compileProgramEntity: (programEntity: TACProgramEntity) ::=> AsmSymbol := {
        compiledProgramEntitySymbolMap at: programEntity ifAbsent: {:: AsmSymbol |
            let symbol := self symbolForProgramEntity: programEntity.
            compiledProgramEntitySymbolMap at: programEntity put: symbol.
            programEntity generateAssemblyWith: self symbol: symbol.
            symbol
        }
    }.

    public method compileModule: (module: TACModule) ::=> Void := {
        module programEntities do: {:(TACProgramEntity)eachProgramEntity :: Void |
            self compileProgramEntity: eachProgramEntity
        }.

        self buildStringLiterals.
        objectHeap buildIn: targetModule.
    }.

    public method offsetOfGCRootObjectTableEntryFor: (object: Untyped) ::=> Size
        := objectHeap offsetOfGCRootObjectTableEntryFor: object.

    public method gcRootObjectTableSymbol ::=> AsmSymbol
        := objectHeap rootObjectTableSymbol.

    public method buildStringLiterals => Void := {
        stringTableList size = 0sz ifTrue: (return: void).

        let stringTable := targetModule newProgramEntity.
        let stringTableSection := stringTable newStreamBuilder
            rodataSection;
            yourself.

        stringTableList do: {:(Array)each :: Void |
            let symbol := each first.
            let string => String := each second first.
            let nullTerminated => Boolean := each second second.
            stringTableSection
                label: symbol;
                string: string nullTerminated: nullTerminated;
                endLabel: symbol.
        }
    }.
}.

public final class TACFunctionAsmCodeGenerator superclass: TACAsmCodeGenerator; definition: {
    public field moduleGenerator => TACModuleAsmCodeGenerator.
    public field function => TACFunction.
    public field asmFunction => AsmProgramEntity.
    private field basicBlockSymbolDictionary => IdentityDictionary.

    public field registerAllocator => TACRegisterAllocator.
    public field stackFrameLayout => TACStackFrameLayout.

    protected field textSection => AsmStreamBuilder.
    public method textSection => AsmStreamBuilder
        := textSection ifNil: (textSection := asmFunction newStreamBuilder
            textSection;
            yourself).

    protected field rodataSection => AsmStreamBuilder.
    public method rodataSection => AsmStreamBuilder
        := rodataSection ifNil: (rodataSection := asmFunction newStreamBuilder
            rodataSection;
            yourself).

    public method generateFunction: (functionToGenerate: TACFunction) withSymbol: (symbol: AsmSymbol) ::=> Void := {
        function := functionToGenerate.
        asmFunction := moduleGenerator targetModule newProgramEntity.
        self prepareToGenerateFunction.

        self textSection
            align: moduleGenerator asmTarget indirectBranchTargetAlignment unreachable: true;
            label: symbol;
            yourself.
        let exportedSymbols := functionToGenerate exportedSymbols collect: {:(Symbol)symbol :: AsmSymbol |
            AsmSymbol new
                name: symbol;
                makePublic;
                makeFunction;
                yourself
        }.
        exportedSymbols do: {:(AsmSymbol)eachSymbol :: Void |
            self textSection label: eachSymbol
        }.

        self
            emitPrologue;
            emitStackFrameConstruction.

        function basicBlocksDo: {:(TACBasicBlock)basicBlock :: Void |
            self generateBasicBlock: basicBlock
        }.

        self textSection endLabel: symbol.
        exportedSymbols do: {:(AsmSymbol)eachSymbol :: Void |
            self textSection endLabel: eachSymbol
        }.

    }.

    TACAsmCompilationTarget extend: {
        public abstract method emitFunctionPrologueWith: (generator: TACFunctionAsmCodeGenerator) ::=> Void
            := self subclassResponsibility.

        public abstract method emitStackFrameConstructionWith: (generator: TACFunctionAsmCodeGenerator) ::=> Void
            := self subclassResponsibility.

        public abstract method emitFunctionEpilogueWith: (generator: TACFunctionAsmCodeGenerator) ::=> Void
            := self subclassResponsibility.
        
        public virtual method emitInstruction: (instruction: TACInstruction) with: (generator: TACFunctionAsmCodeGenerator) ::=> Void
            := instruction operation generate: instruction for: self with: generator.
        
        public abstract method emitMoveValue: (value: TACValue) intoLocation: (register: TACPhysicalLocation) with: (generator: TACFunctionAsmCodeGenerator) ::=> Void
            := self subclassResponsibility.

        public abstract method emitMoveRegister: (register: TACPhysicalLocation) intoValue: (value: TACValue) with: (generator: TACFunctionAsmCodeGenerator) ::=> Void
            := self subclassResponsibility.
    }.

    TACCallingConvention extend: {
        public abstract method asm::generateCallInt8: (instruction: TACInstruction) with: (codegen: TACFunctionAsmCodeGenerator) ::=> Void
            := self subclassResponsibility.

        public abstract method asm::generateCallInt16: (instruction: TACInstruction) with: (codegen: TACFunctionAsmCodeGenerator) ::=> Void
            := self subclassResponsibility.

        public abstract method asm::generateCallInt32: (instruction: TACInstruction) with: (codegen: TACFunctionAsmCodeGenerator) ::=> Void
            := self subclassResponsibility.

        public abstract method asm::generateCallInt64: (instruction: TACInstruction) with: (codegen: TACFunctionAsmCodeGenerator) ::=> Void
            := self subclassResponsibility.

        public abstract method asm::generateCallFloat32: (instruction: TACInstruction) with: (codegen: TACFunctionAsmCodeGenerator) ::=> Void
            := self subclassResponsibility.

        public abstract method asm::generateCallFloat64: (instruction: TACInstruction) with: (codegen: TACFunctionAsmCodeGenerator) ::=> Void
            := self subclassResponsibility.

        public abstract method asm::generateCallStruct: (instruction: TACInstruction) with: (codegen: TACFunctionAsmCodeGenerator) ::=> Void
            := self subclassResponsibility.

        public abstract method asm::generateCallVoid: (instruction: TACInstruction) with: (codegen: TACFunctionAsmCodeGenerator) ::=> Void
            := self subclassResponsibility.
    }.

    public method computeArgumentPassingLayout => Void := {
        function callingConvention computeArgumentPassingLayoutOf: function
    }.

    public method performRegisterAllocation => Void := {
        registerAllocator := TACTrivialRegisterAllocator new.
        registerAllocator allocateRegistersIn: function withTarget: moduleGenerator target.
    }.

    public method buildStackFrameLayout => Void := {
        stackFrameLayout := TACStackFrameLayout new.
        stackFrameLayout buildLayoutForFunction: function registerAllocator: registerAllocator withTarget: moduleGenerator target
    }.

    public method prepareToGenerateFunction => Void := {
        self
            computeArgumentPassingLayout;
            performRegisterAllocation;
            buildStackFrameLayout.

        ## Generate a private label per basic block.
        basicBlockSymbolDictionary := IdentityDictionary new.
        function basicBlocksDo: {:(TACBasicBlock)basicBlock :: Void |
            basicBlockSymbolDictionary at: basicBlock put: (AsmSymbol new
                name: basicBlock name;
                makePrivate;
                yourself).
        }.
    }.

    public method emitPrologue => Void := {
        moduleGenerator target emitFunctionPrologueWith: self
    }.

    public method emitEpilogue => Void := {
        moduleGenerator target emitFunctionEpilogueWith: self
    }.

    public method emitStackFrameConstruction => Void := {
        moduleGenerator target emitStackFrameConstructionWith: self
    }.

    public method emitSpillRegisterArgumentsInStackFrame => Void := {
        function arguments do: {:(TACArgumentVariable)eachArgument :: Void |
            let passingRegister := eachArgument passingRegister.
            (passingRegister isNotNil && eachArgument needsStackAllocation) ifTrue: {
                self emitMoveRegister: passingRegister intoValue: eachArgument
            }.
        }.
    }.

    public method generateBasicBlock: (basicBlock: TACBasicBlock) ::=> Void := {
        let blockSymbol := basicBlockSymbolDictionary at: basicBlock.
        self textSection label: blockSymbol.
        basicBlock instructionsDo: {:(TACInstruction)eachInstruction :: Void |
            self generateInstruction: eachInstruction
        }.

        self textSection endLabel: blockSymbol.
    }.

    public method generateInstruction: (instruction: TACInstruction) ::=> Void := {
        self emitMoveValues: instruction operands intoRegisters: instruction operandRegisters.

        moduleGenerator target emitInstruction: instruction with: self.

        ## Do we need to support multiple result values?
        instruction resultRegister isNotNil && instruction result isNotNil ifTrue: {
            self emitMoveRegister: instruction resultRegister intoValue: instruction result
        }.
    }.

    public method emitMoveValues: (values: Array) intoRegisters: (registers: Array) ::=> Void := {
        values doWithIndex: {:(TACValue)eachValue :(Size)valueIndex :: Void |
            self emitMoveValue: eachValue intoLocation: (registers at: valueIndex)
        }
    }.

    public method emitMoveValue: (value: TACValue) intoLocation: (location: TACPhysicalLocation) ::=> Void := {
        location isRegister ifTrue: {
            moduleGenerator target emitMoveValue: value intoLocation: location with: self.
        }
    }.

    public method emitMoveRegister: (location: TACPhysicalLocation) intoValue: (value: TACValue) ::=> Void := {
        location isRegister ifTrue: {
            moduleGenerator target emitMoveRegister: location intoValue: value with: self.
        }
    }.

    public override method symbolForProgramEntity: (programEntity: TACProgramEntity) ::=> AsmSymbol := {
        basicBlockSymbolDictionary at: programEntity ifAbsent: {|
            moduleGenerator symbolForProgramEntity: programEntity
        }
    }.

    public override method symbolForBasicBlock: (basicBlock: TACBasicBlock) ::=> AsmSymbol
        := basicBlockSymbolDictionary at: basicBlock.

    public method symbolOfStringLiteral: (string: String) nullTerminated: (nullTerminated: Boolean) ::=> AsmSymbol
        := moduleGenerator symbolOfStringLiteral: string nullTerminated: nullTerminated.
}.

public final class TACGlobalDataAsmCodeGenerator superclass: TACAsmCodeGenerator; definition: {
    public field moduleGenerator => TACModuleAsmCodeGenerator.
    public field asmVariable => AsmProgramEntity.
    public field dataStream => AsmStreamBuilder.

    public method generateGlobalVariable: (globalToGenerate: TACGlobalVariable) withSymbol: (symbol: AsmSymbol) ::=> Void := {
        asmVariable := moduleGenerator targetModule newProgramEntity.

        dataStream := asmVariable newStreamBuilder.
        self selectDataSection.
        dataStream label: symbol.

        dataStream endLabel: symbol.
    }.

    public method selectDataSection => Void := {
        dataStream dataSection.
    }
}.

TACOperation extend: {
    public method forTarget: (target: Symbol) generateWith: (codeGenerationBlock: (TACInstruction, TACFunctionAsmCodeGenerator) => Void) ::=> Void := {
        perTargetCodeGenerators at: target put: codeGenerationBlock
    }.
    
    public method forTargets: (targets: Array) generateWith: (codeGenerationBlock: (TACInstruction, TACFunctionAsmCodeGenerator) => Void) ::=> Void := {
        targets do: {:(Symbol)eachTarget :: Void |
            self forTarget: eachTarget generateWith: codeGenerationBlock
        }
    }.

    public method generate: (instruction: TACInstruction) for: (target: TACAsmCompilationTarget) with: (functionGenerator: TACFunctionAsmCodeGenerator) ::=> Void := {
        let targetName := target name.
        (perTargetCodeGenerators at: targetName ifAbsent: {|
            self error: "Missing code generation for TAC operation '" -- name printString -- "' in " -- targetName -- "."
        }) (instruction, functionGenerator).
    }.
}.

TACValue definition: {
    public virtual method asm::immediate8For: (codegen: TACAsmCodeGenerator) ::=> AsmImmediate
        := self error: "Not an immediate 8 value.".

    public virtual method asm::immediate16For: (codegen: TACAsmCodeGenerator) ::=> AsmImmediate
        := self error: "Not an immediate 16 value.".

    public virtual method asm::immediate32For: (codegen: TACAsmCodeGenerator) ::=> AsmImmediate
        := self error: "Not an immediate 32 value.".

    public virtual method asm::immediateS32For: (codegen: TACAsmCodeGenerator) ::=> AsmImmediate
        := self error: "Not an immediate signed 32 value.".

    public virtual method asm::immediateCall32For: (codegen: TACAsmCodeGenerator) ::=> AsmImmediate
        := self asm::immediate32For: codegen.

    public virtual method asm::immediate64For: (codegen: TACAsmCodeGenerator) ::=> AsmImmediate
        := self error: self printString -- " is not an immediate 64 value.".
}.

TACProgramEntity definition: {
    public virtual method generateAssemblySymbolWith: (moduleGenerator: TACModuleAsmCodeGenerator) ::=> AsmSymbol := {
        let symbol := AsmSymbol new
            name: name;
            yourself.
        ## TODO: Select a much more appropriate visibility.
        name ifNotNil: (symbol makePublic).
        symbol
    }.

    public abstract method generateAssemblyWith: (moduleGenerator: TACModuleAsmCodeGenerator) symbol: (symbol: AsmSymbol) ::=> Void
        := self subclassResponsibility.

    public override method asm::immediate32For: (codegen: TACAsmCodeGenerator) ::=> AsmImmediate
        := (codegen symbolForProgramEntity: self) dword.

    public override method asm::immediate64For: (codegen: TACAsmCodeGenerator) ::=> AsmImmediate
        := (codegen symbolForProgramEntity: self) qword.
}.

TACImportedProgramEntity definition: {
    public override method generateAssemblyWith: (moduleGenerator: TACModuleAsmCodeGenerator) symbol: (symbol: AsmSymbol) ::=> Void := {
        moduleGenerator targetModule addImportedSymbol: symbol
    }.

    public override method asm::immediateCall32For: (codegen: TACAsmCodeGenerator) ::=> AsmImmediate
        := (codegen symbolForProgramEntity: self) dword makeAtPLT; yourself.
}.

TACBasicBlock definition: {
    public override method asm::immediateCall32For: (codegen: TACAsmCodeGenerator) ::=> AsmImmediate
        := (codegen symbolForBasicBlock: self) dword.
}.

TACFunction definition: {
    public override method generateAssemblySymbolWith: (moduleGenerator: TACModuleAsmCodeGenerator) ::=> AsmSymbol := {
        (super generateAssemblySymbolWith: moduleGenerator)
            makeFunction;
            yourself
    }.

    public override method generateAssemblyWith: (moduleGenerator: TACModuleAsmCodeGenerator) symbol: (symbol: AsmSymbol) ::=> Void := {
        TACFunctionAsmCodeGenerator new
            target: moduleGenerator target;
            moduleGenerator: moduleGenerator;
            generateFunction: self withSymbol: symbol
    }.
}.

TACGlobalVariable definition: {
    public override method generateAssemblyWith: (moduleGenerator: TACModuleAsmCodeGenerator) symbol: (symbol: AsmSymbol) ::=> Void := {
        TACGlobalDataAsmCodeGenerator new
            target: moduleGenerator target;
            moduleGenerator: moduleGenerator;
            generateGlobalVariable: self withSymbol: symbol
    }.
}.

TACConstantUInt8 definition: {
    public override method asm::immediate8For: (codegen: TACAsmCodeGenerator) ::=> AsmImmediate
        := value asAsmImmediate.

    public override method asm::immediate16For: (codegen: TACAsmCodeGenerator) ::=> AsmImmediate
        := value asUInt16 asAsmImmediate.

    public override method asm::immediate32For: (codegen: TACAsmCodeGenerator) ::=> AsmImmediate
        := value asUInt32 asAsmImmediate.

    public override method asm::immediateS32For: (codegen: TACAsmCodeGenerator) ::=> AsmImmediate
        := value asInt32 asAsmImmediate.

    public override method asm::immediate64For: (codegen: TACAsmCodeGenerator) ::=> AsmImmediate
        := value asUInt64 asAsmImmediate.
}.

TACConstantInt8 definition: {
    public override method asm::immediate8For: (codegen: TACAsmCodeGenerator) ::=> AsmImmediate
        := value asAsmImmediate.

    public override method asm::immediate16For: (codegen: TACAsmCodeGenerator) ::=> AsmImmediate
        := value asInt16 asAsmImmediate.

    public override method asm::immediate32For: (codegen: TACAsmCodeGenerator) ::=> AsmImmediate
        := value asInt32 asAsmImmediate.

    public override method asm::immediateS32For: (codegen: TACAsmCodeGenerator) ::=> AsmImmediate
        := value asInt32 asAsmImmediate.

    public override method asm::immediate64For: (codegen: TACAsmCodeGenerator) ::=> AsmImmediate
        := value asInt64 asAsmImmediate.
}.

TACConstantUInt16 definition: {
    public override method asm::immediate8For: (codegen: TACAsmCodeGenerator) ::=> AsmImmediate
        := value asUInt8 asAsmImmediate.

    public override method asm::immediate16For: (codegen: TACAsmCodeGenerator) ::=> AsmImmediate
        := value asAsmImmediate.

    public override method asm::immediate32For: (codegen: TACAsmCodeGenerator) ::=> AsmImmediate
        := value asUInt32 asAsmImmediate.

    public override method asm::immediateS32For: (codegen: TACAsmCodeGenerator) ::=> AsmImmediate
        := value asInt32 asAsmImmediate.

    public override method asm::immediate64For: (codegen: TACAsmCodeGenerator) ::=> AsmImmediate
        := value asUInt64 asAsmImmediate.
}.

TACConstantInt16 definition: {
    public override method asm::immediate8For: (codegen: TACAsmCodeGenerator) ::=> AsmImmediate
        := value asUInt8 asAsmImmediate.

    public override method asm::immediate16For: (codegen: TACAsmCodeGenerator) ::=> AsmImmediate
        := value asAsmImmediate.

    public override method asm::immediate32For: (codegen: TACAsmCodeGenerator) ::=> AsmImmediate
        := value asInt32 asAsmImmediate.

    public override method asm::immediateS32For: (codegen: TACAsmCodeGenerator) ::=> AsmImmediate
        := value asInt32 asAsmImmediate.

    public override method asm::immediate64For: (codegen: TACAsmCodeGenerator) ::=> AsmImmediate
        := value asInt64 asAsmImmediate.
}.

TACConstantUInt32 definition: {
    public override method asm::immediate8For: (codegen: TACAsmCodeGenerator) ::=> AsmImmediate
        := value asUInt8 asAsmImmediate.

    public override method asm::immediate32For: (codegen: TACAsmCodeGenerator) ::=> AsmImmediate
        := value asAsmImmediate.

    public override method asm::immediate64For: (codegen: TACAsmCodeGenerator) ::=> AsmImmediate
        := value asUInt64 asAsmImmediate.
}.

TACConstantInt32 definition: {
    public override method asm::immediate8For: (codegen: TACAsmCodeGenerator) ::=> AsmImmediate
        := value asUInt8 asAsmImmediate.

    public override method asm::immediate32For: (codegen: TACAsmCodeGenerator) ::=> AsmImmediate
        := value asAsmImmediate.

    public override method asm::immediateS32For: (codegen: TACAsmCodeGenerator) ::=> AsmImmediate
        := value asAsmImmediate.

    public override method asm::immediate64For: (codegen: TACAsmCodeGenerator) ::=> AsmImmediate
        := value asInt64 asAsmImmediate.
}.

TACConstantUInt64 definition: {
    public override method asm::immediate8For: (codegen: TACAsmCodeGenerator) ::=> AsmImmediate
        := value asUInt8 asAsmImmediate.

    public override method asm::immediateS32For: (codegen: TACAsmCodeGenerator) ::=> AsmImmediate := {
        self assert: value asInt32 asInt64 asUInt64 = value.
        value asInt32 asAsmImmediate
    }.

    public override method asm::immediate64For: (codegen: TACAsmCodeGenerator) ::=> AsmImmediate
        := value asAsmImmediate.
}.

TACConstantInt64 definition: {
    public override method asm::immediate8For: (codegen: TACAsmCodeGenerator) ::=> AsmImmediate
        := value asUInt8 asAsmImmediate.

    public override method asm::immediateS32For: (codegen: TACAsmCodeGenerator) ::=> AsmImmediate := {
        self assert: value asInt32 asInt64 = value.
        value asInt32 asAsmImmediate
    }.

    public override method asm::immediate64For: (codegen: TACAsmCodeGenerator) ::=> AsmImmediate
        := value asAsmImmediate.
}.
