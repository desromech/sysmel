AsmStreamBuilder extend: {
    public method useDebugInfoOfTACValue: (value: TACValue) ::=> Void := {
        debugSourcePosition := value debugSourcePosition.
        debugSourceNode := value debugSourceNode.
        debugSourceEnvironment := value debugSourceEnvironment.
    }
}.

public abstract class TACAsmCompilationTarget superclass: TACCompilationTarget; definition: {
    public field asmCompilationTarget => AsmCompilationTarget.

    public override method pointerSize => Size
        := asmCompilationTarget pointerSize.

    public override method pointerAlignment => Size
        := asmCompilationTarget pointerSize.

    public override method uintPointerType => Type
        := asmCompilationTarget uintPointerType.

    public override method stackFrameAlignment => Size
        := asmCompilationTarget stackFrameAlignment.

    public override method generateTargetIRForTACModule: (module: TACModule) ::=> AnyValue := {
        let codeGenerator := TACModuleAsmCodeGenerator new
            target: self;
            asmTarget: asmCompilationTarget;
            targetModule: (AsmProgramEntity new
                compilationTarget: asmCompilationTarget;
                yourself);
            compileModule: module;
            targetModule
    }.
}.

public abstract class TACAsmCodeGenerator superclass: Object; definition: {
    public field target => TACAsmCompilationTarget.

    public abstract method symbolForProgramEntity: (programEntity: TACProgramEntity) ::=> AsmSymbol
        := self subclassResponsibility.

    public abstract method symbolForBasicBlock: (basicBlock: TACBasicBlock) ::=> AsmSymbol
        := self subclassResponsibility.
}.

public final class TACModuleAsmCodeGenerator superclass: TACAsmCodeGenerator; definition: {
    public field targetModule => AsmProgramEntity.
    protected field asmTarget => AsmCompilationTarget.
    public field programEntitySymbolMap => Dictionary.
    public field compiledProgramEntitySymbolMap => Dictionary.

    protected field stringTableList => OrderedCollection.
    protected field stringTableDictionary => Dictionary.

    protected field objectHeap => AsmObjectHeap.

    public override method initialize => Void := {
        programEntitySymbolMap := Dictionary new.
        compiledProgramEntitySymbolMap := Dictionary new.
        objectHeap := AsmObjectHeap new.
        stringTableList := OrderedCollection new.
        stringTableDictionary := Dictionary new.
    }.

    public method asmTarget => AsmCompilationTarget := asmTarget.
    public method asmTarget: (target: AsmCompilationTarget) ::=> Void := {
        asmTarget := target.
        objectHeap compilationTarget: target.
    }.

    public override method symbolForProgramEntity: (programEntity: TACProgramEntity) ::=> AsmSymbol := {
        programEntitySymbolMap at: programEntity ifAbsentPut: {:: AsmSymbol |
            programEntity generateAssemblySymbolWith: self
        }
    }.

    public method symbolOfStringLiteral: (string: String) nullTerminated: (nullTerminated: Boolean) ::=> AsmSymbol := {
        let key := Array with: string with: nullTerminated.
        stringTableDictionary at: key ifAbsentPut: {:: AsmSymbol |
            let stringSymbol := AsmSymbol new
                makePrivate;
                yourself.

            stringTableList add: (Array with: stringSymbol with: key).
            stringSymbol
        }
    }.

    public method compileProgramEntity: (programEntity: TACProgramEntity) ::=> AsmSymbol := {
        compiledProgramEntitySymbolMap at: programEntity ifAbsent: {:: AsmSymbol |
            let symbol := self symbolForProgramEntity: programEntity.
            compiledProgramEntitySymbolMap at: programEntity put: symbol.
            programEntity generateAssemblyWith: self symbol: symbol.
            symbol
        }
    }.

    public method imageObjectTrace => ImageObjectTrace
        := objectHeap objectTrace.

    public method compileModule: (module: TACModule) ::=> Void := {
        ## Use the module image object trace for the object heap.
        module imageObjectTrace ifNotNil: {
            objectHeap objectTrace: module imageObjectTrace
        }.

        targetModule contentSymbol ifNil: {
            let compileUnitSymbol := AsmSymbol new name: #compileUnit; makePrivate; yourself.
            targetModule newStreamBuilder
                textSection;
                label: compileUnitSymbol.
            targetModule newEndStreamBuilder
                textSection;
                endLabel: compileUnitSymbol.
            targetModule contentSymbol: compileUnitSymbol.
        }.

        module programEntities do: {:(TACProgramEntity)eachProgramEntity :: Void |
            self compileProgramEntity: eachProgramEntity
        }.

        module functionDefinitionPatches do: {:(TACFunctionDefinitionPatch)tacPatch :: Void |
            objectHeap objectTrace addObject: tacPatch functionDefinition patch: (ImageFunctionDefinitionEntryPointAsmPatch new
                functionDefinition: tacPatch functionDefinition;
                checkedEntryPoint: (compiledProgramEntitySymbolMap atOrNil: tacPatch checkedEntryPoint);
                uncheckedEntryPoint: (compiledProgramEntitySymbolMap atOrNil: tacPatch uncheckedEntryPoint);
                uncheckedCapturelessEntryPoint: (compiledProgramEntitySymbolMap atOrNil: tacPatch uncheckedCapturelessEntryPoint);
                yourself)
        }.

        self buildStringLiterals.
        asmTarget debugInformationGenerator ifNotNil: {:(AsmObjectDebugInformationGenerator class)generatorClass :: Void |
            let generator := generatorClass new.
            targetModule debugInformationGenerator: generator.
            generator generateDebugInformationForModule: targetModule
        }.
        
        {|
            objectHeap buildIn: targetModule.
        } printTimeToRunInMicrosecondsWithTitle: "Assembler object heap"
    }.

    public method offsetOfGCRootObjectTableEntryFor: (object: Untyped) ::=> Size
        := objectHeap offsetOfGCRootObjectTableEntryFor: object.

    public method gcRootObjectTableSymbol ::=> AsmSymbol
        := objectHeap rootObjectTableSymbol.

    public method buildStringLiterals => Void := {
        stringTableList size = 0sz ifTrue: (return: void).

        let stringTable := targetModule newProgramEntity.
        let stringTableSection := stringTable newStreamBuilder
            rodataSection;
            yourself.

        stringTableList do: {:(Array)each :: Void |
            let symbol := each first.
            let string => String := each second first.
            let nullTerminated => Boolean := each second second.
            stringTableSection
                label: symbol;
                string: string nullTerminated: nullTerminated;
                endLabel: symbol.
        }
    }.
}.

public final class TACFunctionAsmCodeGenerator superclass: TACAsmCodeGenerator; definition: {
    public field moduleGenerator => TACModuleAsmCodeGenerator.
    public field function => TACFunction.
    public field asmFunction => AsmProgramEntity.
    public field stackMap => AsmStackMap.
    private field basicBlockSymbolDictionary => IdentityDictionary.

    public field registerAllocator => TACRegisterAllocator.
    public field stackFrameLayout => TACStackFrameLayout.
    private field constantSymbolDictionary => Dictionary.

    protected field textSection => AsmStreamBuilder.
    public method textSection => AsmStreamBuilder
        := textSection ifNil: (textSection := asmFunction newStreamBuilder
            textSection;
            yourself).

    protected field rodataSection => AsmStreamBuilder.
    public method rodataSection => AsmStreamBuilder
        := rodataSection ifNil: (rodataSection := asmFunction newStreamBuilder
            rodataSection;
            yourself).

    protected field captureVectorPointerRegister => TACPhysicalLocation.

    public method validCaptureVectorPointerRegister => TACPhysicalLocation := {
        captureVectorPointerRegister ifNil: (self error: "Cannot use unloaded capture vector pointer register").
        captureVectorPointerRegister
    }.

    public field closureArgument => TACArgumentVariable.
    public field captureVectorDataOffset => Size.
    public field closureCaptureVectorMemberOffset => Size.

    public method generateFunction: (functionToGenerate: TACFunction) withSymbol: (symbol: AsmSymbol) ::=> Void := {
        function := functionToGenerate.
        asmFunction := moduleGenerator targetModule newProgramEntity.
        stackMap := AsmStackMap new.
        constantSymbolDictionary := Dictionary new.
        asmFunction
            debugSourcePosition: functionToGenerate debugSourcePosition;
            debugSourceNode: functionToGenerate debugSourceNode;
            debugSourceEnvironment: functionToGenerate debugSourceEnvironment;
            stackMap: stackMap;
            sourceProgramEntity: functionToGenerate sourceProgramEntity;
            contentSymbol: symbol.

        functionToGenerate trampolineTarget ifNotNil: {
            asmFunction trampolineTarget: (moduleGenerator symbolForProgramEntity: functionToGenerate trampolineTarget)
        }.

        self prepareToGenerateFunction.

        self textSection
            align: moduleGenerator asmTarget indirectBranchTargetAlignment unreachable: true;
            useDebugInfoOfTACValue: functionToGenerate;
            label: symbol;
            yourself.

        let exportedSymbols := functionToGenerate exportedSymbols collect: {:(Symbol)symbol :: AsmSymbol |
            AsmSymbol new
                name: symbol;
                makePublic;
                makeFunction;
                yourself
        }.

        exportedSymbols do: {:(AsmSymbol)eachSymbol :: Void |
            self textSection label: eachSymbol
        }.

        self textSection cfiBeginProcedure.

        self
            emitPrologue;
            emitStackFrameConstruction;
            generateStackMap.

        function basicBlocksDo: {:(TACBasicBlock)basicBlock :: Void |
            self generateBasicBlock: basicBlock
        }.

        self textSection
            cfiEndProcedure;
            endLabel: symbol.
        exportedSymbols do: {:(AsmSymbol)eachSymbol :: Void |
            self textSection endLabel: eachSymbol
        }.
    }.

    TACAsmCompilationTarget extend: {
        public abstract method emitFunctionPrologueWith: (generator: TACFunctionAsmCodeGenerator) ::=> Void
            := self subclassResponsibility.

        public abstract method emitStackFrameConstructionWith: (generator: TACFunctionAsmCodeGenerator) ::=> Void
            := self subclassResponsibility.

        public abstract method emitFunctionEpilogueWith: (generator: TACFunctionAsmCodeGenerator) ::=> Void
            := self subclassResponsibility.
        
        public virtual method emitInstruction: (instruction: TACInstruction) with: (generator: TACFunctionAsmCodeGenerator) ::=> Void
            := instruction operation generate: instruction for: self with: generator.
        
        public abstract method emitMoveValue: (value: TACValue) intoLocation: (register: TACPhysicalLocation) with: (generator: TACFunctionAsmCodeGenerator) ::=> Void
            := self subclassResponsibility.

        public abstract method emitMoveRegister: (register: TACPhysicalLocation) intoValue: (value: TACValue) with: (generator: TACFunctionAsmCodeGenerator) ::=> Void
            := self subclassResponsibility.

        public abstract method emitLoadCaptureVectorPointerFromClosure: (closureArgument: TACValue) intoRegister: (register: TACPhysicalLocation) with: (generator: TACFunctionAsmCodeGenerator) ::=> Void
            := self subclassResponsibility.
    }.

    TACCallingConvention extend: {
        public abstract method asm::generateCallInt8: (instruction: TACInstruction) with: (codegen: TACFunctionAsmCodeGenerator) ::=> Void
            := self subclassResponsibility.

        public abstract method asm::generateCallInt16: (instruction: TACInstruction) with: (codegen: TACFunctionAsmCodeGenerator) ::=> Void
            := self subclassResponsibility.

        public abstract method asm::generateCallInt32: (instruction: TACInstruction) with: (codegen: TACFunctionAsmCodeGenerator) ::=> Void
            := self subclassResponsibility.

        public abstract method asm::generateCallInt64: (instruction: TACInstruction) with: (codegen: TACFunctionAsmCodeGenerator) ::=> Void
            := self subclassResponsibility.

        public abstract method asm::generateCallFloat32: (instruction: TACInstruction) with: (codegen: TACFunctionAsmCodeGenerator) ::=> Void
            := self subclassResponsibility.

        public abstract method asm::generateCallFloat64: (instruction: TACInstruction) with: (codegen: TACFunctionAsmCodeGenerator) ::=> Void
            := self subclassResponsibility.

        public abstract method asm::generateCallStruct: (instruction: TACInstruction) with: (codegen: TACFunctionAsmCodeGenerator) ::=> Void
            := self subclassResponsibility.

        public abstract method asm::generateCallVoid: (instruction: TACInstruction) with: (codegen: TACFunctionAsmCodeGenerator) ::=> Void
            := self subclassResponsibility.
    }.

    public method computeArgumentPassingLayout => Void := {
        function callingConvention computeArgumentPassingLayoutOf: function
    }.

    public method performRegisterAllocation => Void := {
        registerAllocator := TACTrivialRegisterAllocator new.
        registerAllocator allocateRegistersIn: function withTarget: moduleGenerator target.
    }.

    public method buildStackFrameLayout => Void := {
        stackFrameLayout := TACStackFrameLayout new.
        stackFrameLayout buildLayoutForFunction: function registerAllocator: registerAllocator withTarget: moduleGenerator target
    }.

    public method prepareToGenerateFunction => Void := {
        function captures isNotEmpty ifTrue: {
            closureArgument := function arguments first.
            captureVectorDataOffset := function compilationTarget objectModel objectHeaderSize.
            ## FIXME: Delegate this offset computation onto the compilation target.
            closureCaptureVectorMemberOffset := function compilationTarget objectModel objectHeaderSize + (Function lookupSlot: #captureVector) validOffset.
        }.

        self
            computeArgumentPassingLayout;
            performRegisterAllocation;
            buildStackFrameLayout.

        ## Generate a private label per basic block.
        basicBlockSymbolDictionary := IdentityDictionary new.
        function basicBlocksDo: {:(TACBasicBlock)basicBlock :: Void |
            basicBlockSymbolDictionary at: basicBlock put: (AsmSymbol new
                name: basicBlock name;
                makePrivate;
                yourself).
        }.
    }.

    public method emitPrologue => Void := {
        moduleGenerator target emitFunctionPrologueWith: self
    }.

    public method emitEpilogue => Void := {
        moduleGenerator target emitFunctionEpilogueWith: self
    }.

    public method emitStackFrameConstruction => Void := {
        moduleGenerator target emitStackFrameConstructionWith: self
    }.

    public method generateStackMap => Void := {
        function arguments do: {:(TACLocalVariable)eachLocal :: Void |
            eachLocal sourceBinding ifNotNil: {:(SymbolBinding)binding :: Void |
                let location := eachLocal asm::makeStackMapLocationWith: self.
                stackMap addArgumentBindingMap: (stackMap setBinding: binding location: location)
            }
        }.

        function captures do: {:(TACLocalVariable)eachLocal :: Void |
            eachLocal sourceBinding ifNotNil: {:(SymbolBinding)binding :: Void |
                let location := eachLocal asm::makeStackMapLocationWith: self.
                stackMap addCaptureBindingMap: (stackMap setBinding: binding location: location)
            }
        }.
    }.

    public method emitSpillRegisterArgumentsInStackFrame => Void := {
        function arguments do: {:(TACArgumentVariable)eachArgument :: Void |
            let passingRegister := eachArgument passingRegister.
            (passingRegister isNotNil && eachArgument needsStackAllocation) ifTrue: {
                self emitMoveRegister: passingRegister intoValue: eachArgument
            }.
        }.
    }.

    public method generateBasicBlock: (basicBlock: TACBasicBlock) ::=> Void := {
        let blockSymbol := basicBlockSymbolDictionary at: basicBlock.
        self textSection
            useDebugInfoOfTACValue: basicBlock;
            label: blockSymbol.
        basicBlock instructionsDo: {:(TACInstruction)eachInstruction :: Void |
            self generateInstruction: eachInstruction
        }.

        self textSection
            useDebugInfoOfTACValue: basicBlock;
            endLabel: blockSymbol.
    }.

    public method generateInstruction: (instruction: TACInstruction) ::=> Void := {
        instruction isDebug ifTrue: {
            self processDebugInstruction: instruction.
            return: void
        }.

        self textSection useDebugInfoOfTACValue: instruction.
        self loadCaptureVectorPointerIfNeededFor: instruction.
        self emitMoveValues: instruction operands intoRegisters: instruction operandRegisters.

        moduleGenerator target emitInstruction: instruction with: self.

        ## Do we need to support multiple result values?
        instruction resultRegister isNotNil && instruction result isNotNil ifTrue: {
            self emitMoveRegister: instruction resultRegister intoValue: instruction result
        }.

        captureVectorPointerRegister := nil.
    }.

    public method loadCaptureVectorPointerIfNeededFor: (instruction: TACInstruction) ::=> Void := {
        captureVectorPointerRegister := instruction captureVectorPointerRegister.
        captureVectorPointerRegister ifNil: {return: void}.

        moduleGenerator target emitLoadCaptureVectorPointerFromClosure: closureArgument intoRegister: captureVectorPointerRegister with: self.
    }.

    public method processDebugInstruction: (debugInstruction: TACInstruction) ::=> Void := {
        self assert: (debugInstruction operation = TAC::Operation::DebugSetBindingValue)
            || (debugInstruction operation = TAC::Operation::DebugSetMutableBindingValue).
        let value := debugInstruction operands first.
        let binding := debugInstruction sourceBinding.

        let location := value asm::makeStackMapLocationWith: self.
        location ifNotNil: {
            stackMap addLocalBindingMap: (stackMap setBinding: binding isMutable: debugInstruction operation = TAC::Operation::DebugSetMutableBindingValue location: location)
        }.
    }.

    public method emitMoveValues: (values: Array) intoRegisters: (registers: Array) ::=> Void := {
        values doWithIndex: {:(TACValue)eachValue :(Size)valueIndex :: Void |
            self emitMoveValue: eachValue intoLocation: (registers at: valueIndex)
        }
    }.

    public method emitMoveValue: (value: TACValue) intoLocation: (location: TACPhysicalLocation) ::=> Void := {
        location isRegister ifTrue: {
            moduleGenerator target emitMoveValue: value intoLocation: location with: self.
        }
    }.

    public method emitMoveRegister: (location: TACPhysicalLocation) intoValue: (value: TACValue) ::=> Void := {
        location isRegister ifTrue: {
            moduleGenerator target emitMoveRegister: location intoValue: value with: self.
        }
    }.

    public override method symbolForProgramEntity: (programEntity: TACProgramEntity) ::=> AsmSymbol := {
        basicBlockSymbolDictionary at: programEntity ifAbsent: {|
            moduleGenerator symbolForProgramEntity: programEntity
        }
    }.

    public override method symbolForBasicBlock: (basicBlock: TACBasicBlock) ::=> AsmSymbol
        := basicBlockSymbolDictionary at: basicBlock.

    public method symbolOfStringLiteral: (string: String) nullTerminated: (nullTerminated: Boolean) ::=> AsmSymbol
        := moduleGenerator symbolOfStringLiteral: string nullTerminated: nullTerminated.

    public method symbolForUInt8Constant: (constant: UInt8) ::=> AsmSymbol
        := constantSymbolDictionary at: (#uint8, constant) ifAbsentPut: {:: AsmSymbol |
            let symbol := AsmSymbol new
                name: #uint32Constant;
                yourself.
            self rodataSection label: symbol; byte: constant.
            symbol
        }.

    public method symbolForInt8Constant: (constant: Int8) ::=> AsmSymbol
        := constantSymbolDictionary at: (#int8, constant) ifAbsentPut: {:: AsmSymbol |
            let symbol := AsmSymbol new
                name: #int8Constant;
                yourself.
            self rodataSection label: symbol; sbyte: constant.
            symbol
        }.

    public method symbolForUInt16Constant: (constant: UInt16) ::=> AsmSymbol
        := constantSymbolDictionary at: (#uint32, constant) ifAbsentPut: {:: AsmSymbol |
            let symbol := AsmSymbol new
                name: #uint32Constant;
                yourself.
            self rodataSection align: 2sz; label: symbol; word: constant.
            symbol
        }.

    public method symbolForInt16Constant: (constant: Int16) ::=> AsmSymbol
        := constantSymbolDictionary at: (#int32, constant) ifAbsentPut: {:: AsmSymbol |
            let symbol := AsmSymbol new
                name: #uint16Constant;
                yourself.
            self rodataSection align: 2sz; label: symbol; sword: constant.
            symbol
        }.

    public method symbolForUInt32Constant: (constant: UInt32) ::=> AsmSymbol
        := constantSymbolDictionary at: (#uint32, constant) ifAbsentPut: {:: AsmSymbol |
            let symbol := AsmSymbol new
                name: #uint32Constant;
                yourself.
            self rodataSection align: 4sz; label: symbol; dword: constant.
            symbol
        }.

    public method symbolForInt32Constant: (constant: Int32) ::=> AsmSymbol
        := constantSymbolDictionary at: (#int32, constant) ifAbsentPut: {:: AsmSymbol |
            let symbol := AsmSymbol new
                name: #int32Constant;
                yourself.
            self rodataSection align: 4sz; label: symbol; sdword: constant.
            symbol
        }.

    public method symbolForUInt64Constant: (constant: UInt64) ::=> AsmSymbol
        := constantSymbolDictionary at: (#uint64, constant) ifAbsentPut: {:: AsmSymbol |
            let symbol := AsmSymbol new
                name: #uint64Constant;
                yourself.
            self rodataSection align: 8sz; label: symbol; qword: constant.
            symbol
        }.

    public method symbolForInt64Constant: (constant: Int64) ::=> AsmSymbol
        := constantSymbolDictionary at: (#int64, constant) ifAbsentPut: {:: AsmSymbol |
            let symbol := AsmSymbol new
                name: #int64Constant;
                yourself.
            self rodataSection align: 8sz; label: symbol; sqword: constant.
            symbol
        }.

    public method symbolForFloat32Constant: (constant: Float32) ::=> AsmSymbol
        := constantSymbolDictionary at: (#float32, constant) ifAbsentPut: {:: AsmSymbol |
            let symbol := AsmSymbol new
                name: #float32Constant;
                yourself.
            self rodataSection align: 4sz; label: symbol; float: constant.
            symbol
        }.

    public method symbolForFloat64Constant: (constant: Float64) ::=> AsmSymbol
        := constantSymbolDictionary at: (#float64, constant) ifAbsentPut: {:: AsmSymbol |
            let symbol := AsmSymbol new
                name: #float64Constant;
                yourself.
            self rodataSection align: 8sz; label: symbol; double: constant.
            symbol
        }.
}.

public final class TACGlobalDataAsmCodeGenerator superclass: TACAsmCodeGenerator; definition: {
    public field moduleGenerator => TACModuleAsmCodeGenerator.
    public field asmVariable => AsmProgramEntity.
    public field dataStream => AsmStreamBuilder.

    public method generateGlobalVariable: (globalToGenerate: TACGlobalVariable) withSymbol: (symbol: AsmSymbol) ::=> Void := {
        asmVariable := moduleGenerator targetModule newProgramEntity.
        asmVariable
            debugSourcePosition: globalToGenerate debugSourcePosition;
            debugSourceNode: globalToGenerate debugSourceNode;
            debugSourceEnvironment: globalToGenerate debugSourceEnvironment;
            sourceProgramEntity: globalToGenerate sourceProgramEntity;
            contentSymbol: symbol. 

        dataStream := asmVariable newStreamBuilder.
        self selectDataSection.
        dataStream label: symbol.

        dataStream endLabel: symbol.
    }.

    public method selectDataSection => Void := {
        dataStream dataSection.
    }
}.

TACOperation extend: {
    public method forTarget: (target: Symbol) generateWith: (codeGenerationBlock: (TACInstruction, TACFunctionAsmCodeGenerator) => Void) ::=> Void := {
        perTargetCodeGenerators at: target put: codeGenerationBlock
    }.
    
    public method forTargets: (targets: Array) generateWith: (codeGenerationBlock: (TACInstruction, TACFunctionAsmCodeGenerator) => Void) ::=> Void := {
        targets do: {:(Symbol)eachTarget :: Void |
            self forTarget: eachTarget generateWith: codeGenerationBlock
        }
    }.

    public method generate: (instruction: TACInstruction) for: (target: TACAsmCompilationTarget) with: (functionGenerator: TACFunctionAsmCodeGenerator) ::=> Void := {
        let targetName := target name.
        (perTargetCodeGenerators at: targetName ifAbsent: {|
            self error: "Missing code generation for TAC operation '" -- name printString -- "' in " -- targetName asString -- "."
        }) (instruction, functionGenerator).
    }.
}.

TACValue definition: {
    public virtual method asm::immediate8For: (codegen: TACAsmCodeGenerator) ::=> AsmImmediate
        := self error: "Not an immediate 8 value.".

    public virtual method asm::immediate16For: (codegen: TACAsmCodeGenerator) ::=> AsmImmediate
        := self error: "Not an immediate 16 value.".

    public virtual method asm::immediate32For: (codegen: TACAsmCodeGenerator) ::=> AsmImmediate
        := self error: "Not an immediate 32 value.".

    public virtual method asm::immediateS32For: (codegen: TACAsmCodeGenerator) ::=> AsmImmediate
        := self error: "Not an immediate signed 32 value.".

    public virtual method asm::immediateCall32For: (codegen: TACAsmCodeGenerator) ::=> AsmImmediate
        := self asm::immediate32For: codegen.

    public virtual method asm::immediate64For: (codegen: TACAsmCodeGenerator) ::=> AsmImmediate
        := self error: self printString -- " is not an immediate 64 value.".

    public virtual method asm::makeStackMapLocationWith: (codegen: TACAsmCodeGenerator) ::=> AsmStackMapLocation
        := nil.
}.

TACProgramEntity definition: {
    public virtual method generateAssemblySymbolWith: (moduleGenerator: TACModuleAsmCodeGenerator) ::=> AsmSymbol := {
        let symbol := AsmSymbol new
            name: name;
            yourself.
        name ifNotNil: {
            symbol makePublic.
            self isWeak ifTrue: (symbol makeWeak).
            self isPrivate ifTrue: (symbol makePrivate).
        }.
        
        symbol
    }.

    public abstract method generateAssemblyWith: (moduleGenerator: TACModuleAsmCodeGenerator) symbol: (symbol: AsmSymbol) ::=> Void
        := self subclassResponsibility.

    public override method asm::immediate32For: (codegen: TACAsmCodeGenerator) ::=> AsmImmediate
        := (codegen symbolForProgramEntity: self) dword.

    public override method asm::immediate64For: (codegen: TACAsmCodeGenerator) ::=> AsmImmediate
        := (codegen symbolForProgramEntity: self) qword.
}.

TACImportedProgramEntity definition: {
    public override method generateAssemblyWith: (moduleGenerator: TACModuleAsmCodeGenerator) symbol: (symbol: AsmSymbol) ::=> Void := {
        moduleGenerator targetModule addImportedSymbol: symbol
    }.

    public override method asm::immediateCall32For: (codegen: TACAsmCodeGenerator) ::=> AsmImmediate
        := (codegen symbolForProgramEntity: self) dword makeAtPLT; yourself.
}.

TACBasicBlock definition: {
    public override method asm::immediateCall32For: (codegen: TACAsmCodeGenerator) ::=> AsmImmediate
        := (codegen symbolForBasicBlock: self) dword.
}.

TACFunction definition: {
    public override method generateAssemblySymbolWith: (moduleGenerator: TACModuleAsmCodeGenerator) ::=> AsmSymbol := {
        (super generateAssemblySymbolWith: moduleGenerator)
            makeFunction;
            yourself
    }.

    public override method generateAssemblyWith: (moduleGenerator: TACModuleAsmCodeGenerator) symbol: (symbol: AsmSymbol) ::=> Void := {
        TACFunctionAsmCodeGenerator new
            target: moduleGenerator target;
            moduleGenerator: moduleGenerator;
            generateFunction: self withSymbol: symbol
    }.
}.

TACGlobalVariable definition: {
    public override method generateAssemblyWith: (moduleGenerator: TACModuleAsmCodeGenerator) symbol: (symbol: AsmSymbol) ::=> Void := {
        TACGlobalDataAsmCodeGenerator new
            target: moduleGenerator target;
            moduleGenerator: moduleGenerator;
            generateGlobalVariable: self withSymbol: symbol
    }.
}.

TACConstantUInt8 definition: {
    public override method asm::immediate8For: (codegen: TACAsmCodeGenerator) ::=> AsmImmediate
        := value asAsmImmediate.

    public override method asm::immediate16For: (codegen: TACAsmCodeGenerator) ::=> AsmImmediate
        := value asUInt16 asAsmImmediate.

    public override method asm::immediate32For: (codegen: TACAsmCodeGenerator) ::=> AsmImmediate
        := value asUInt32 asAsmImmediate.

    public override method asm::immediateS32For: (codegen: TACAsmCodeGenerator) ::=> AsmImmediate
        := value asInt32 asAsmImmediate.

    public override method asm::immediate64For: (codegen: TACAsmCodeGenerator) ::=> AsmImmediate
        := value asUInt64 asAsmImmediate.
}.

TACConstantInt8 definition: {
    public override method asm::immediate8For: (codegen: TACAsmCodeGenerator) ::=> AsmImmediate
        := value asAsmImmediate.

    public override method asm::immediate16For: (codegen: TACAsmCodeGenerator) ::=> AsmImmediate
        := value asInt16 asAsmImmediate.

    public override method asm::immediate32For: (codegen: TACAsmCodeGenerator) ::=> AsmImmediate
        := value asInt32 asAsmImmediate.

    public override method asm::immediateS32For: (codegen: TACAsmCodeGenerator) ::=> AsmImmediate
        := value asInt32 asAsmImmediate.

    public override method asm::immediate64For: (codegen: TACAsmCodeGenerator) ::=> AsmImmediate
        := value asInt64 asAsmImmediate.
}.

TACConstantUInt16 definition: {
    public override method asm::immediate8For: (codegen: TACAsmCodeGenerator) ::=> AsmImmediate
        := value asUInt8 asAsmImmediate.

    public override method asm::immediate16For: (codegen: TACAsmCodeGenerator) ::=> AsmImmediate
        := value asAsmImmediate.

    public override method asm::immediate32For: (codegen: TACAsmCodeGenerator) ::=> AsmImmediate
        := value asUInt32 asAsmImmediate.

    public override method asm::immediateS32For: (codegen: TACAsmCodeGenerator) ::=> AsmImmediate
        := value asInt32 asAsmImmediate.

    public override method asm::immediate64For: (codegen: TACAsmCodeGenerator) ::=> AsmImmediate
        := value asUInt64 asAsmImmediate.
}.

TACConstantInt16 definition: {
    public override method asm::immediate8For: (codegen: TACAsmCodeGenerator) ::=> AsmImmediate
        := value asUInt8 asAsmImmediate.

    public override method asm::immediate16For: (codegen: TACAsmCodeGenerator) ::=> AsmImmediate
        := value asAsmImmediate.

    public override method asm::immediate32For: (codegen: TACAsmCodeGenerator) ::=> AsmImmediate
        := value asInt32 asAsmImmediate.

    public override method asm::immediateS32For: (codegen: TACAsmCodeGenerator) ::=> AsmImmediate
        := value asInt32 asAsmImmediate.

    public override method asm::immediate64For: (codegen: TACAsmCodeGenerator) ::=> AsmImmediate
        := value asInt64 asAsmImmediate.
}.

TACConstantUInt32 definition: {
    public override method asm::immediate8For: (codegen: TACAsmCodeGenerator) ::=> AsmImmediate
        := value asUInt8 asAsmImmediate.

    public override method asm::immediate32For: (codegen: TACAsmCodeGenerator) ::=> AsmImmediate
        := value asAsmImmediate.

    public override method asm::immediate64For: (codegen: TACAsmCodeGenerator) ::=> AsmImmediate
        := value asUInt64 asAsmImmediate.
}.

TACConstantInt32 definition: {
    public override method asm::immediate8For: (codegen: TACAsmCodeGenerator) ::=> AsmImmediate
        := value asUInt8 asAsmImmediate.

    public override method asm::immediate32For: (codegen: TACAsmCodeGenerator) ::=> AsmImmediate
        := value asAsmImmediate.

    public override method asm::immediateS32For: (codegen: TACAsmCodeGenerator) ::=> AsmImmediate
        := value asAsmImmediate.

    public override method asm::immediate64For: (codegen: TACAsmCodeGenerator) ::=> AsmImmediate
        := value asInt64 asAsmImmediate.
}.

TACConstantUInt64 definition: {
    public override method asm::immediate8For: (codegen: TACAsmCodeGenerator) ::=> AsmImmediate
        := value asUInt8 asAsmImmediate.

    public override method asm::immediateS32For: (codegen: TACAsmCodeGenerator) ::=> AsmImmediate := {
        self assert: value asInt32 asInt64 asUInt64 = value.
        value asInt32 asAsmImmediate
    }.

    public override method asm::immediate64For: (codegen: TACAsmCodeGenerator) ::=> AsmImmediate
        := value asAsmImmediate.
}.

TACConstantInt64 definition: {
    public override method asm::immediate8For: (codegen: TACAsmCodeGenerator) ::=> AsmImmediate
        := value asUInt8 asAsmImmediate.

    public override method asm::immediateS32For: (codegen: TACAsmCodeGenerator) ::=> AsmImmediate := {
        self assert: value asInt32 asInt64 = value.
        value asInt32 asAsmImmediate
    }.

    public override method asm::immediate64For: (codegen: TACAsmCodeGenerator) ::=> AsmImmediate
        := value asAsmImmediate.
}.

TACLocalVariable definition: {
    public override method asm::makeStackMapLocationWith: (codegen: TACAsmCodeGenerator) ::=> AsmStackMapLocation := {
        self needsStackAllocation ifTrue: {
            AsmStackMapLocationFrameOffset new offset: offset; yourself
        } ifFalse: {
            nil
        }
    }
}.

TACCaptureVariable definition: {
    public override method asm::makeStackMapLocationWith: (codegen: TACAsmCodeGenerator) ::=> AsmStackMapLocation := {
        ##AsmStackMapLocationCaptureOffset new offset: offset; yourself
        nil
    }
}.
