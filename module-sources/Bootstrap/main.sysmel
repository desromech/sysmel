## ============================================================================
## Bootstrap core runtime
## ============================================================================

Function
    withSelector: #addFlag: addMethod: {:self :(Size)flag :: Void |
        self flags: self flags | flag
    };
    withSelector: #makeMacro addMethod: {:self :: self __type__ |
        self addFlag: (1sz << 0sz).
        self
    }.

AnyValue
    withSelector: #initialize addMethod: {:self :: Void | };
    withSelector: #yourself addMethod: {:self :: self __type__ | self };

    withSelector: #postCopy addMethod: {:self :: Void | };
    withSelector: #shallowCopy addMethod: {:self :: self __type__ | RawTuple::shallowCopy(self) };
    withSelector: #copy addMethod: {:self :: self __type__ | self shallowCopy postCopy; yourself };

    withSelector: #isNil addMethod: {:self :: Boolean | self == nil };
    withSelector: #isNotNil addMethod: {:self :: Boolean | self ~~ nil };

    withSelector: #= addMethod: {:self :other :: Boolean | self == other };
    withSelector: #~= addMethod: {:self :other :: Boolean | self ~~ other };

    withSelector: #&& addMacroMethod: {:macroContext :self :other :: ASTIfNode |
        ASTIfNode new
            sourcePosition: macroContext sourcePosition;
            conditionExpression: self;
            trueExpression: other;
            falseExpression: (ASTLiteralNode new
                sourcePosition: macroContext sourcePosition;
                value: false;
                yourself);
            yourself
    } makeMacro;
    withSelector: #|| addMacroMethod: {:macroContext :self :other :: ASTIfNode |
        ASTIfNode new
            sourcePosition: macroContext sourcePosition;
            conditionExpression: self;
            trueExpression: (ASTLiteralNode new
                sourcePosition: macroContext sourcePosition;
                value: true;
                yourself);
            falseExpression: other;
            yourself
    } makeMacro;

    withSelector: #ifTrue: addMacroMethod: {:macroContext :self :trueExpression :: ASTIfNode |
        ASTIfNode new
            sourcePosition: macroContext sourcePosition;
            conditionExpression: self;
            trueExpression: trueExpression;
            yourself
    } makeMacro;
    withSelector: #ifFalse: addMacroMethod: {:macroContext :self :falseExpression :: ASTIfNode |
        ASTIfNode new
            sourcePosition: macroContext sourcePosition;
            conditionExpression: self;
            falseExpression: falseExpression;
            yourself
    } makeMacro;
    withSelector: #ifTrue:ifFalse: addMacroMethod: {:macroContext :self :trueExpression :falseExpression :: ASTIfNode |
        ASTIfNode new
            sourcePosition: macroContext sourcePosition;
            conditionExpression: self;
            trueExpression: trueExpression;
            falseExpression: falseExpression;
            yourself
    } makeMacro;
    withSelector: #ifFalse:ifTrue: addMacroMethod: {:macroContext :self :falseExpression :trueExpression :: ASTIfNode |
        ASTIfNode new
            sourcePosition: macroContext sourcePosition;
            conditionExpression: self;
            trueExpression: trueExpression;
            falseExpression: falseExpression;
            yourself
    } makeMacro.

Object
    withSelector: #class addMethod: {:self :: self __type__ __type__ | self __type__ };
    withSelector: #species addMethod: {:self :: Class | self class };
    withSelector: #error: addMethod: {:self :(String)errorMessage :: Void | error(errorMessage) };
    withSelector: #subclassResponsibility addMethod: {:self :: Void | self error: "Subclass responsibility." }.

Type
    withSelector: #hasBytesContent addMethod: {:self :: Boolean |
        (self flags & 2sz) ~= 0sz
    };
    withSelector: #basicAllocate addMethod: {:self :: self |
        let: #result with: (if: self hasBytesContent
            then: RawTuple::byteNew(0sz)
            else: RawTuple::new(self totalSlotCount)).
        (RawTuple::type:)(result, self).
        result
    };
    withSelector: #basicAllocate: addMethod: {:self :(Size)variableSize :: self |
        let: #result with: (if: self hasBytesContent
            then: RawTuple::byteNew(variableSize)
            else: RawTuple::new(self totalSlotCount + variableSize)).
        (RawTuple::type:)(result, self).
        result
    };
    withSelector: #basicNew addMethod: {:self :: self |
        self basicAllocate
    };
    withSelector: #basicNew: addMethod: {:self :(Size)variableSlotCount :: self |
        self basicAllocate: variableSlotCount
    };
    withSelector: #new addMethod: {:self :: self |
        self basicNew initialize; yourself
    };
    withSelector: #lookupSelector: addMethod: {:self :selector |
        let: #methodDictionary with: self methodDictionary.
        let: #method with: (if: methodDictionary ~~ nil
            then: (methodDictionary atOrNil: selector)
            else: nil).
        if: method ~~ nil
        then: method
        else: {
            let: #supertype with: self supertype.
            if: supertype ~~ nil
                then: (supertype lookupSelector: selector)
                else: (nil)
        }
    }.

Void
    withSelector: #coerceValue: addMethod: {:self :value :: self | void };
    withSelector: #printString addMethod: {:self :: String | "void" }.

UndefinedObject
    withSelector: #printString addMethod: {:self :: String | "nil" }.

False
    withSelector: #printString addMethod: {:self :: String | "false" }.

True
    withSelector: #printString addMethod: {:self :: String | "true" }.

Class
    withSelector: #withSelector:addClassMethod: addMethod: {:self :selector :method :: Void |
        self class withSelector: selector addMethod: method
    }.

Function
    withSelector: #hasFlag: addMethod: {:self :(Size)flag :: Boolean |
        (self flags & flag) ~= 0sz
    };

    withSelector: #isMacro addMethod: {:self :: Boolean |
        self hasFlag: (1sz << 0sz)
    };
    
    withSelector: #isVariadic addMethod: {:self :: Boolean |
        self hasFlag: (1sz << 1sz)
    };
    withSelector: #isCorePrimitive addMethod: {:self :: Boolean |
        self hasFlag: (1sz << 2sz)
    };

    withSelector: #isPure addMethod: {:self :: Boolean |
        self hasFlag: (1sz << 3sz)
    };
    withSelector: #makePure addMethod: {:self :: self __type__ |
        self addFlag: (1sz << 0sz).
        self
    };

    withSelector: #isFinal addMethod: {:self :: Boolean |
        self hasFlag: (1sz << 4sz)
    };
    withSelector: #makeFinal addMethod: {:self :: self __type__ |
        self addFlag: (1sz << 0sz).
        self
    };
    withSelector: #hasPragmaNamed: addMethod: {:self :selector :: Boolean |
        let: #body with: self body.
        (body ~~ nil) && (body hasPragmaNamed: selector)
    }.

ValueBox
    withSelector: #with: addClassMethod: {:self :value |
        self basicNew
            value: value;
            yourself
    };
    withSelector: #_ addMethod: {:self | self value };
    withSelector: #_: addMethod: {:self :newValue | self value: newValue. newValue };
    withSelector: #":=" addMethod: {:self :newValue | self value: newValue. newValue }.

Collection
    withSelector: #isEmpty addMethod: {:self :: Boolean |
        self size = 0sz
    };
    withSelector: #isNotEmpty addMethod: {:self :: Boolean |
        self size ~= 0sz
    }.

SequenceableCollection
    withSelector: #with: addClassMethod: {:self :value :: self |
        (self new: 1sz)
            at: 0sz put: value;
            yourself
    };
    withSelector: #anySatisfy: addMethod: {:self :aBlock :: Boolean |
        let: #index with: (ValueBox with: 0sz).
        let: #size with: self size.
        let: #hasFoundIt with: (ValueBox with: false).

        while: (if: hasFoundIt _ then: false else: index _ < self size) do: (
            hasFoundIt := aBlock(self at: index _)
        ) continueWith: (index := index _ + 1).
        hasFoundIt _
    };
    withSelector: #allSatisfy: addMethod: {:self :aBlock :: Boolean |
        let: #index with: (ValueBox with: 0sz).
        let: #size with: self size.
        let: #everythingIsFine with: (ValueBox with: true).

        while: (if: everythingIsFine _ then: index _ < self size else: false) do: (
            everythingIsFine := aBlock(self at: index _)
        ) continueWith: (index := index _ + 1).
        everythingIsFine _
    };
    withSelector: #collect: addMethod: {:self :aBlock :: self species |
        let: #index with: (ValueBox with: 0sz).
        let: #size with: self size.
        let: #result with: (self species new: size).

        while: index _ < self size do: {
            let: #i with: index _.
            result at: i put: aBlock(self at: i)
        } continueWith: (index := index _ + 1).

        result
    };
    withSelector: #do: addMethod: {:self :aBlock :: Void |
        let: #index with: (ValueBox with: 0sz).
        let: #size with: self size.

        while: index _ < self size do: (
            aBlock(self at: index _)
        ) continueWith: (index := index _ + 1)
    };
    withSelector: #doWithIndex: addMethod: {:self :aBlock :: Void |
        let: #index with: (ValueBox with: 0sz).
        let: #size with: self size.

        while: index _ < self size do: {
            let: #i with: index _.
            aBlock(self at: i, i)
        } continueWith: (index := index _ + 1)
    };
    withSelector: #-- addMethod: {:self :other :: self species |
        let: #size with: self size.
        let: #otherSize with: other size.
        let: #result with: (self species new: size + otherSize ).
        
        self doWithIndex: {:element :(Size)index :: Void |
            result at: index put: element
        }.

        other doWithIndex: {:element :(Size)index :: Void |
            result at: size + index put: element
        }.

        result
    };
    withSelector: #first addMethod: {:self | self at: 0sz };
    withSelector: #second addMethod: {:self | self at: 1sz };
    withSelector: #third addMethod: {:self | self at: 2sz };
    withSelector: #fourth addMethod: {:self | self at: 3sz };

    withSelector: #printString addMethod: {:self :: String |
        let: #builder with: StringBuilder new.
        builder addAll: self class printString; addAll: "(".
        self doWithIndex: {:element :index :: Void |
            if: index > 0 then: (builder addAll: ", ").
            builder addAll: element printString.
            void
        }.

        builder addAll: ")"; asString
    }.

ArrayList
    withSelector: #new: addClassMethod: {:self :(Size)initialSize :: self |
        self basicNew initializeWithSize: initialSize; yourself
    };
    withSelector: #initialize addMethod: {:self :: Void |
        self size: 0sz
    };
    withSelector: #initializeWithSize: addMethod: {:self :(Size)initialSize :: Void |
        self size: initialSize sz.
        self storage: (Array new: initialSize).
    };
    withSelector: #at: addMethod: {:self :(Size)index |
        if: index < self size then: {
            self storage at: index
        } else: {
            error("Index out of bounds.")
        }
    };
    withSelector: #at:put: addMethod: {:self :(Size)index :value :: Void |
        if: index < self size then: {
            self storage at: index + self offset put: value
        } else: {
            error("Index out of bounds.")
        }
    }.

StringBuilder
    withSelector: #initialize addMethod: {:self :: Void |
        self size: 0
    }.

Array
    withSelector: #new: addClassMethod: {:self :(Size)initialSize :: self |
        self basicNew: initialSize
    };
    withSelector: #at: addMethod: {:self :(Size)index |
        self __slotAt__: index
    };
    withSelector: #at:put: addMethod: {:self :(Size)index :value :: Void |
        self __slotAt__: index put: value
    };
    withSelector: #size addMethod: {:self :: Size |
        self __size__
    };
    withSelector: #asArraySlice addMethod: {:self :: ArraySlice |
        ArraySlice basicNew
            elements: self;
            offset: 0sz;
            size: self size;
            yourself
    }.

ByteArray
    withSelector: #at: addMethod: {:self :(Size)index |
        self __slotAt__: index
    };
    withSelector: #at:put: addMethod: {:self :(Size)index :value :: Void |
        self __slotAt__: index put: value
    };
    withSelector: #size addMethod: {:self :: Size |
        self __byteSize__
    };
    withSelector: #printString addMethod: {:self :: String |
        let: #builder with: StringBuilder new.
        builder addAll: "#[".
        self doWithIndex: {:element :index :: Void |
            if: index > 0sz then: (builder addAll: ". ").
            builder addAll: element printString.
            void
        }.

        builder addAll: "]"; asString
    }.

ArraySlice
    withSelector: #new: addClassMethod: {:self :(Size)size :: self |
        self basicNew
            elements: (Array basicNew: size);
            offset: 0sz;
            size: size;
            yourself
    };
    withSelector: #at: addMethod: {:self :(Size)index |
        if: index < self size then: {
            self elements at: index + self offset
        } else: {
            error("Index out of bounds.")
        }
    };
    withSelector: #at:put: addMethod: {:self :(Size)index :value :: Void |
        if: index < self size then: {
            self elements at: index + self offset put: value
        } else: {
            error("Index out of bounds.")
        }
    }.

TypeSlot
    withSelector: #named:type:flags: addClassMethod: {:self :name :(Type)type :(Size)flags :: self |
        self new
            name: name;
            type: type;
            flags: flags;
            yourself
    };
    withSelector: #named:type: addClassMethod: {:self :name :(Type)type :: self |
        self named: name type: type flags: 0sz
    };
    withSelector: #named: addClassMethod: {:self :name :(Type)type :: self |
        self publicNamed: name type: nil
    };
    withSelector: #publicNamed:type: addClassMethod: {:self :name :(Type)type :: self |
        self named: name type: type flags: 1sz
    };
    withSelector: #publicNamed: addClassMethod: {:self :name :(Type)type :: self |
        self publicNamed: name type: nil
    };

    withSelector: #isPublic addMethod: {:self :: Boolean |
        (self flags & 1sz) ~= 0sz
    };
    withSelector: #generateAccessorsOn:withIndex: addMethod: {:self :(Type)type :(Size)slotIndex :: Void |
        if: self isPublic then: {
            let: #slotType with: self type.
            let: #getterName with: self name.
            let: #setterName with: (self name asString -- ":") asSymbol.

            ## Getter.
            type withSelector: getterName addMethod: {:(type)self :: slotType | (RawTuple::slotAt:)(self, slotIndex) }.

            ## Setter
            type withSelector: setterName addMethod: {:(type)self :(slotType)value :: Void | RawTuple::slotAt:put:(self, slotIndex, value) }.
        }
    }.

Type
    withSelector: #supertypeSlotCount addMethod: {:self :: Size |
        if: self supertype == nil
            then: 0sz
            else: self supertype totalSlotCount.
    };
    withSelector: #generatePublicAccessors addMethod: {:self :: Void |
        let: #baseSlotIndex with: self supertypeSlotCount.
        self slots doWithIndex: {:slot :index :: Void |
            let: #slotIndex with: baseSlotIndex + index.
            slot generateAccessorsOn: self withIndex: slotIndex
        }.
    }.

Class
    withSelector: #subclassWithClassSlots:slots: addMethod: {:self :(Array)classSlots :(Array)instanceSlots :: Class |
        let: #metaclass with: Metaclass basicNew.
        let: #metaclassSuper with: self class.
        metaclass
            flags: 1sz;
            supertype: metaclassSuper;
            slots: classSlots;
            totalSlotCount: metaclassSuper totalSlotCount + classSlots size;
            generatePublicAccessors.
        
        let: #class with: metaclass basicNew.
        class
            flags: 1sz;
            supertype: self;
            slots: instanceSlots;
            totalSlotCount: self totalSlotCount + instanceSlots size;
            generatePublicAccessors.
        metaclass thisClass: class.
        class
    };
    withSelector: #subclass:classSlots:slots: addMethod: {:self :(Symbol)name :(Array)classSlots :(Array)instanceSlots :: Class |
        let: #class with: (self subclassWithClassSlots: classSlots slots: instanceSlots).
        class name: name.
        class
    };
    withSelector: #subclass:slots: addMethod: {:self :(Symbol)name :(Array)instanceSlots :: Class |
        self subclass: name classSlots: () slots: instanceSlots
    }.

Environment
    withSelector: #setSymbol:value: addMethod: {:self :selector :value :: Void | self setSymbol: selector binding: value };
    withSelector: #setPublicSymbol:value: addMethod: {:self :selector :value :: Void | self setSymbol: selector binding: value };
    withSelector: #withSelector:addMethod: addMethod: {:self :selector :method :: Void | self setSymbol: selector binding: binding }.

## ============================================================================
## Bootstrap AST methods
## ============================================================================

ASTNode
    withSelector: #astAnalyzeWithEnvironment: addMethod: {:self :environment | self subclassResponsibility };
    withSelector: #astAnalyzeAndEvaluateWithEnvironment: addMethod: {:self :environment | self subclassResponsibility };
    withSelector: #astEvaluateWithEnvironment: addMethod: {:self :environment | self subclassResponsibility };

    withSelector: #childrenDo: addMethod: {:self :aBlock :: Void | self subclassResponsibility };

    withSelector: #transformWith: addMethod: {:self :aBlock :: Void | self subclassResponsibility };
    withSelector: #transformedWith: addMethod: {:self :aBlock :: self class | self copy transformWith: aBlock; yourself };
    
    withSelector: #hasPragmaNamed: addMethod: {:self :selector :: Boolean | false };
    withSelector: #hasLiteralValueEqualTo: addMethod: {:self :expectedValue :: Boolean | false };

    withSelector: #isLiteralNode addMethod: {:self :: Boolean | false }.

ASTArgumentNode
    withSelector: #childrenDo: addMethod: {:self :aBlock :: Void |
        if: (self name isNotNil) then: aBlock(self name).
        if: (self type isNotNil) then: aBlock(self type).
    };
    withSelector: #transformWith: addMethod: {:self :aBlock :: Void |
        if: (self name isNotNil) then: (self name: aBlock(self name)).
        if: (self type isNotNil) then: (self type: aBlock(self type)).
    }.

ASTBinaryExpressionSequenceNode
    withSelector: #childrenDo: addMethod: {:self :aBlock :: Void |
        self operands do: aBlock.
        self operators do: aBlock.
    };
    withSelector: #transformWith: addMethod: {:self :aBlock :: Void |
        self operands: (self operands collect: aBlock).
        self operators: (self operators collect: aBlock).
    }.

ASTDoWhileContinueWithNode
    withSelector: #childrenDo: addMethod: {:self :aBlock :: Void |
        if: (self bodyExpression isNotNil) then: aBlock(self bodyExpression).
        if: (self conditionExpression isNotNil) then: aBlock(self conditionExpression).
        if: (self continueExpression isNotNil) then: aBlock(self continueExpression).
    };
    withSelector: #transformWith: addMethod: {:self :aBlock :: Void |
        if: (self bodyExpression isNotNil) then: (self bodyExpression: aBlock(self bodyExpression)).
        if: (self conditionExpression isNotNil) then: (self conditionExpression: aBlock(self conditionExpression)).
        if: (self continueExpression isNotNil) then: (self continueExpression: aBlock(self continueExpression)).
    }.

ASTErrorNode
    withSelector: #transformWith: addMethod: {:self :aBlock :: Void |
    }.

ASTFunctionApplicationNode
    withSelector: #childrenDo: addMethod: {:self :aBlock :: Void |
        if: (self functionExpression isNotNil) then: aBlock(self functionExpression).
        self arguments do: aBlock.
    };
    withSelector: #transformWith: addMethod: {:self :aBlock :: Void |
        if: (self functionExpression isNotNil) then: (self functionExpression: aBlock(self functionExpression)).
        self arguments: (self arguments collect: aBlock).
    }.

ASTLambdaNode
    withSelector: #childrenDo: addMethod: {:self :aBlock :: Void |
        self arguments do: aBlock.
        if: (self resultType isNotNil) then: aBlock(self resultType).
        if: (self body isNotNil) then: aBlock(self body).
    };
    withSelector: #transformWith: addMethod: {:self :aBlock :: Void |
        self arguments: (self arguments collect: aBlock).
        if: (self resultType isNotNil) then: (self resultType: aBlock(self resultType)).
        if: (self body isNotNil) then: (self body: aBlock(self body)).
    }.

ASTLexicalBlockNode
    withSelector: #hasPragmaNamed: addMethod: {:self :selector :: Boolean |
        self body hasPragmaNamed: selector
    };
    withSelector: #childrenDo: addMethod: {:self :aBlock :: Void |
        if: (self body isNotNil) then: aBlock(self body).
    };
    withSelector: #transformWith: addMethod: {:self :aBlock :: Void |
        if: (self body isNotNil) then: (self body: aBlock(self body)).
    }.

ASTLiteralNode
    withSelector: #astAnalyzeWithEnvironment: addMethod: {:self :environment | self };
    withSelector: #astAnalyzeAndEvaluateWithEnvironment: addMethod: {:self :environment | self value };
    withSelector: #astEvaluateWithEnvironment: addMethod: {:self :environment | self value };
    withSelector: #isLiteralNode addMethod: {:self :: Boolean | true };
    withSelector: #hasLiteralValueEqualTo: addMethod: {:self :expectedValue :: Boolean | self value = expectedValue };

    withSelector: #childrenDo: addMethod: {:self :aBlock :: Void | };
    withSelector: #transformWith: addMethod: {:self :aBlock :: Void | }.

ASTLocalDefinitionNode
    withSelector: #childrenDo: addMethod: {:self :aBlock :: Void |
        if: (self nameExpression isNotNil) then: aBlock(self nameExpression).
        if: (self valueExpression isNotNil) then: aBlock(self valueExpression).
    };
    withSelector: #transformWith: addMethod: {:self :aBlock :: Void |
        if: (self nameExpression isNotNil) then: (self nameExpression: aBlock(self nameExpression)).
        if: (self valueExpression isNotNil) then: (self valueExpression: aBlock(self valueExpression)).
    }.

ASTIdentifierReferenceNode
    withSelector: #childrenDo: addMethod: {:self :aBlock :: Void | };
    withSelector: #transformWith: addMethod: {:self :aBlock :: Void | }.

ASTIfNode
    withSelector: #childrenDo: addMethod: {:self :aBlock :: Void |
        if: (self conditionExpression isNotNil) then: aBlock(self conditionExpression).
        if: (self trueExpression isNotNil) then: aBlock(self trueExpression).
        if: (self falseExpression isNotNil) then: aBlock(self falseExpression).
    };
    withSelector: #transformWith: addMethod: {:self :aBlock :: Void |
        if: (self conditionExpression isNotNil) then: (self conditionExpression: aBlock(self conditionExpression)).
        if: (self trueExpression isNotNil) then: (self trueExpression: aBlock(self trueExpression)).
        if: (self falseExpression isNotNil) then: (self falseExpression: aBlock(self falseExpression)).
    }.

ASTMakeAssociationNode
    withSelector: #childrenDo: addMethod: {:self :aBlock :: Void |
        if: (self key isNotNil) then: aBlock(self key).
        if: (self value isNotNil) then: aBlock(self value).
    };
    withSelector: #transformWith: addMethod: {:self :aBlock :: Void |
        if: (self key isNotNil) then: (self key: aBlock(self key)).
        if: (self value isNotNil) then: (self value: aBlock(self value)).
    }.

ASTMakeByteArrayNode
    withSelector: #childrenDo: addMethod: {:self :aBlock :: Void |
        self elements do: aBlock
    };
    withSelector: #transformWith: addMethod: {:self :aBlock :: Void |
        self elements: (self elements collect: aBlock)
    }.

ASTMakeDictionaryNode
    withSelector: #childrenDo: addMethod: {:self :aBlock :: Void |
        self elements do: aBlock
    };
    withSelector: #transformWith: addMethod: {:self :aBlock :: Void |
        self elements: (self elements collect: aBlock)
    }.

ASTMakeTupleNode
    withSelector: #childrenDo: addMethod: {:self :aBlock :: Void |
        self elements do: aBlock
    };
    withSelector: #transformWith: addMethod: {:self :aBlock :: Void |
        self elements: (self elements collect: aBlock)
    }.

ASTMessageSendNode
    withSelector: #childrenDo: addMethod: {:self :aBlock :: Void |
        if: (self receiver isNotNil) then: aBlock(self receiver).
        if: (self selector isNotNil) then: aBlock(self selector).
        self arguments do: aBlock
    };
    withSelector: #transformWith: addMethod: {:self :aBlock :: Void |
        if: (self receiver isNotNil) then: (self receiver: aBlock(self receiver)).
        if: (self selector isNotNil) then: (self selector: aBlock(self selector)).
        self arguments: (self arguments collect: aBlock)
    }.

ASTMessageChainNode
    withSelector: #childrenDo: addMethod: {:self :aBlock :: Void |
        if: (self receiver isNotNil) then: aBlock(self receiver).
        self messages do: aBlock
    };
    withSelector: #transformWith: addMethod: {:self :aBlock :: Void |
        if: (self receiver isNotNil) then: (self receiver: aBlock(self receiver)).
        self messages: (self messages collect: aBlock)
    }.

ASTMessageChainMessageNode
    withSelector: #childrenDo: addMethod: {:self :aBlock :: Void |
        if: (self selector isNotNil) then: aBlock(self selector).
        self arguments do: aBlock
    };
    withSelector: #transformWith: addMethod: {:self :aBlock :: Void |
        if: (self selector isNotNil) then: (self selector: aBlock(self selector)).
        self arguments: (self arguments collect: aBlock)
    }.

ASTPragmaNode
    withSelector: #hasPragmaNamed: addMethod: {:self :expectedSelector :: Boolean |
        let: #selector with: self selector.
        if: selector isNotNil
            then: (selector hasLiteralValueEqualTo: expectedSelector)
            else: false
    };
    withSelector: #childrenDo: addMethod: {:self :aBlock :: Void |
        if: (self selector isNotNil) then: aBlock(self selector).
        self arguments do: aBlock
    };
    withSelector: #transformWith: addMethod: {:self :aBlock :: Void |
        if: (self selector isNotNil) then: (self bodyselector: aBlock(self body)).
        self arguments: (self arguments collect: aBlock)
    }.

ASTSequenceNode
    withSelector: #hasPragmaNamed: addMethod: {:self :selector :: Boolean |
        self pragmas anySatisfy: {:pragma :: Boolean | pragma hasPragmaNamed: selector}
    };
    withSelector: #childrenDo: addMethod: {:self :aBlock :: Void |
        self pragmas do: aBlock.
        self expressions do: aBlock.
    };
    withSelector: #transformWith: addMethod: {:self :aBlock :: Void |
        self pragmas: (self pragmas collect: aBlock).
        self expressions: (self expressions collect: aBlock)
    }.

ASTUnexpandedApplicationNode
    withSelector: #childrenDo: addMethod: {:self :aBlock :: Void |
        if: (self functionOrMacroExpression isNotNil) then: aBlock(self functionOrMacroExpression).
        self arguments do: aBlock
    };
    withSelector: #transformWith: addMethod: {:self :aBlock :: Void |
        if: (self functionOrMacroExpression isNotNil) then: (self functionOrMacroExpression: aBlock(self functionOrMacroExpression)).
        self arguments: (self arguments collect: aBlock)
    }.

ASTUnexpandedSExpressionNode
    withSelector: #childrenDo: addMethod: {:self :aBlock :: Void |
        self elements do: aBlock
    };
    withSelector: #transformWith: addMethod: {:self :aBlock :: Void |
        self elements: (self elements collect: aBlock)
    }.

ASTNode
    withSelector: #analyzeQuasiQuoteWithEnvironment: addMethod: {:self :environment |
        self transformedWith: {:child | child analyzeQuasiQuoteWithEnvironment: environment}
    };
    withSelector: #analyzeAndEvaluateQuasiQuoteWithEnvironment: addMethod: {:self :environment |
        self transformedWith: {:child | child analyzeAndEvaluateQuasiQuoteWithEnvironment: environment}
    };
    withSelector: #evaluateQuasiQuoteWithEnvironment: addMethod: {:self :environment |
        self transformedWith: {:child | child evaluateQuasiQuoteWithEnvironment: environment}
    }.

ASTQuasiQuoteNode
    withSelector: #astAnalyzeWithEnvironment: addMethod: {:self :environment |
        self copy
            node: (self node analyzeQuasiQuoteWithEnvironment: environment);
            yourself
    };
    withSelector: #astAnalyzeAndEvaluateWithEnvironment: addMethod: {:self :environment |
        self node analyzeAndEvaluateQuasiQuoteWithEnvironment: environment
    };
    withSelector: #astEvaluateWithEnvironment: addMethod: {:self :environment |
        self node evaluateQuasiQuoteWithEnvironment: environment
    };
    withSelector: #childrenDo: addMethod: {:self :aBlock :: Void |
        if: (self node isNotNil) then: aBlock(self node)
    };
    withSelector: #transformWith: addMethod: {:self :aBlock :: Void |
        if: (self node isNotNil) then: (self node: aBlock(self node))
    }.

ASTQuasiUnquoteNode
    withSelector: #analyzeQuasiQuoteWithEnvironment: addMethod: {:self :environment |
        self copy
            expression: (self expression astAnalyzeWithEnvironment: environment);
            yourself
    };
    withSelector: #analyzeAndEvaluateQuasiQuoteWithEnvironment: addMethod: {:self :environment |
        self expression astAnalyzeAndEvaluateWithEnvironment: environment
    };
    withSelector: #evaluateQuasiQuoteWithEnvironment: addMethod: {:self :environment |
        self expression astEvaluateWithEnvironment: environment
    };
    withSelector: #childrenDo: addMethod: {:self :aBlock :: Void |
        if: (self expression) then: aBlock(self node)
    };
    withSelector: #transformWith: addMethod: {:self :aBlock :: Void |
        if: (self expression) then: (self node: aBlock(self node))
    }.

ASTQuoteNode
    withSelector: #astAnalyzeWithEnvironment: addMethod: {:self :environment | self};
    withSelector: #astAnalyzeAndEvaluateWithEnvironment: addMethod: {:self :environment | self node};
    withSelector: #astEvaluateWithEnvironment: addMethod: {:self :environment | self node};
    withSelector: #childrenDo: addMethod: {:self :aBlock :: Void |
        if: (self node) then: aBlock(self node)
    };
    withSelector: #transformWith: addMethod: {:self :aBlock :: Void |
        if: (self node) then: (self node: aBlock(self node))
    }.

ASTSpliceNode
    withSelector: #astAnalyzeWithEnvironment: addMethod: {:self :environment | self invalidLocationError };
    withSelector: #astAnalyzeAndEvaluateWithEnvironment: addMethod: {:self :environment | self invalidLocationError };
    withSelector: #astEvaluateWithEnvironment: addMethod: {:self :environment | self invalidLocationError };
    withSelector: #childrenDo: addMethod: {:self :aBlock :: Void |
        if: (self expression) then: aBlock(self node)
    };
    withSelector: #transformWith: addMethod: {:self :aBlock :: Void |
        if: (self expression) then: (self node: aBlock(self node))
    };

    withSelector: #analyzeQuasiQuoteWithEnvironment: addMethod: {:self :environment | self invalidLocationError };
    withSelector: #analyzeAndEvaluateQuasiQuoteWithEnvironment: addMethod: {:self :environment | self invalidLocationError };
    withSelector: #evaluateQuasiQuoteWithEnvironment: addMethod: {:self :environment | self invalidLocationError };

    withSelector: #invalidLocationError addMethod: {:self :environment |
        self error: "Invalid location for a splice expression."
    }.

ASTWhileContinueWithNode
    withSelector: #childrenDo: addMethod: {:self :aBlock :: Void |
        if: (self conditionExpression isNotNil) then: aBlock(self conditionExpression).
        if: (self bodyExpression isNotNil) then: aBlock(self bodyExpression).
        if: (self continueExpression isNotNil) then: aBlock(self bodyExpression).
    };
    withSelector: #transformWith: addMethod: {:self :aBlock :: Void |
        if: (self conditionExpression isNotNil) then: (self conditionExpression: aBlock(self conditionExpression)).
        if: (self bodyExpression isNotNil) then: (self bodyExpression: aBlock(self bodyExpression)).
        if: (self continueExpression isNotNil) then: (self continueExpression: aBlock(self continueExpression)).
    }.

## ============================================================================
## Bootstrap Meta builder
## ============================================================================
BootstrapEnv::IntrinsicsBuiltInEnvironment
    setSymbol: #__OwnerProgramEntity__ value: BootstrapEnv::IntrinsicsBuiltInEnvironment;
    setSymbol: #public:with: value: {:macroContext :(ASTNode)symbol :(ASTNode)value :: ASTNode |
        ``(__OwnerProgramEntity__ setPublicSymbol: `,symbol value: `,value)
    } makeMacro.

Class
    withSelector: #publicSubclass:classSlots:slots: addMacroMethod: {:macroContext :(ASTNode)self :(ASTNode)name :(ASTNode)classSlots :(ASTNode)instanceSlots :: ASTNode |
        ``(public: `,name with: (`,self subclass: `,name classSlots: `,classSlots slots: `,instanceSlots))
    } makeMacro;
    withSelector: #publicSubclass:slots: addMacroMethod: {:macroContext :(ASTNode)self :(ASTNode)name :(ASTNode)instanceSlots :: ASTNode |
        ``(public: `,name with: (`,self subclass: `,name slots: `,instanceSlots))
    } makeMacro.

Object publicSubclass: #MetaBuilder slots: ().

MetaBuilder
    withSelector: #analyzeAndEvaluateMessageSendNode:forReceiver:withEnvironment: addClassMethod: {:self :messageSendNode :receiver :environment |
        let: #selfReceiver with: (ASTLiteralNode new
            sourcePosition: messageSendNode receiver sourcePosition;
            value: receiver;
            yourself). 
        let: #messageWithSelfReceiver with: (messageSendNode copy
            receiver: selfReceiver;
            yourself).

        receiver analyzeAndEvaluateMessageSendNode: messageWithSelfReceiver withEnvironment: environment
    };
    withSelector: #analyzeMessageSendNode:withEnvironment: addClassMethod: {:self :messageSendNode :environment |
        messageSendNode receiver value analyzeMessageSendNode: messageSendNode withEnvironment: environment
    };
    withSelector: #analyzeAndEvaluateMessageSendNode:withEnvironment: addMethod: {:self :messageSendNode :environment |
        self subclassResponsibility
    };
    withSelector: #analyzeMessageSendNode:withEnvironment: addMethod: {:self :messageSendNode :environment |
        self subclassResponsibility
    }.

MetaBuilder publicSubclass: #MetaBuilderFactory slots: (
    TypeSlot publicNamed: #metaBuilderClass type: Class,
).

MetaBuilderFactory
    withSelector: #for: addClassMethod: {:self :metaBuilderClass :: self |
        self new
            metaBuilderClass: metaBuilderClass;
            yourself
    };
    withSelector: #analyzeAndEvaluateMessageSendNode:withEnvironment: addMethod: {:self :messageSendNode :environment |
        let: #metaBuilderInstance with: self metaBuilderClass new.
        let: #metaBuilderInstanceNode with: (ASTLiteralNode new
            sourcePosition: messageSendNode receiver sourcePosition;
            value: metaBuilderInstance;
            yourself).
        let: #messageWithMetaBuilderInstance with: (messageSendNode copy
            receiver: metaBuilderInstanceNode;
            yourself).
        metaBuilderInstance analyzeAndEvaluateMessageSendNode: messageWithMetaBuilderInstance withEnvironment: environment
    };
    withSelector: #analyzeMessageSendNode:withEnvironment: addMethod: {:self :messageSendNode :environment |
        let: #metaBuilderInstance with: self metaBuilderClass new.
        let: #metaBuilderInstanceNode with: (ASTLiteralNode new
            sourcePosition: messageSendNode receiver sourcePosition;
            value: metaBuilderInstance;
            yourself).
        let: #messageWithMetaBuilderInstance with: (messageSendNode copy
            receiver: metaBuilderInstanceNode;
            yourself).
        metaBuilderInstance analyzeMessageSendNode: messageWithMetaBuilderInstance withEnvironment: environment
    }.

MetaBuilder publicSubclass: #MacroMetaBuilder slots: (
    TypeSlot publicNamed: #environment type: Environment ,
    TypeSlot publicNamed: #sourcePosition type: SourcePosition ,
    TypeSlot publicNamed: #continueExpansion type: ASTNode
).

MacroMetaBuilder
    withSelector: #analyzeAndEvaluateMessageSendNode:withEnvironment: addMethod: {:self :messageSendNode :environment |
        (self expandMessageSendNode: messageSendNode withEnvironment: environment) astAnalyzeAndEvaluateWithEnvironment: environment
    };
    withSelector: #analyzeMessageSendNode:withEnvironment: addMethod: {:self :messageSendNode :environment |
        (self expandMessageSendNode: messageSendNode withEnvironment: environment) astAnalyzeWithEnvironment: environment
    };
    withSelector: #expandMessageSendNode:withEnvironment: addMethod: {:self :messageSendNode :environment :: ASTNode |
        self
            environment: environment;
            sourcePosition: messageSendNode sourcePosition;
            continueExpansion: messageSendNode receiver;
            expandMessageSendNode: messageSendNode
    };
    withSelector: #expandMessageSendNode: addMethod: {:self :messageSendNode :: ASTNode |
        self expandMessageSendNodeWithMetaBuilderMethod: messageSendNode
    };
    withSelector: #expandMessageSendNodeWithMetaBuilderMethod: addMethod: {:self :messageSendNode :: ASTNode |
        let: #metaBuilderMethod with: (
            if: messageSendNode selector isLiteralNode
                then: (self class lookupSelector: messageSendNode selector value)
                else: (nil)
        ).

        if: metaBuilderMethod isNotNil && (metaBuilderMethod hasPragmaNamed: #metaBuilder)
            then: apply(metaBuilderMethod, self, messageSendNode arguments)
            else: self finishExpansion
    };
    withSelector: #finishExpansionWithMessageSendNode:environment: addMethod: {:self :messageSendNode :environment :: ASTNode |
        messageSendNode copy
            receiver: (self finishExpansionWithEnvironment: environment);
            yourself
    };
    withSelector: #finishExpansionWithMessageSendNode: addMethod: {:self :messageSendNode :: ASTNode |
        self finishExpansionWithMessageSendNode: messageSendNode environment: self environment
    };
    withSelector: #finishExpansionWithEnvironment: addMethod: {:self :environment :: ASTNode |
        self subclassResponsibility
    };
    withSelector: #finishExpansion addMethod: {:self :: ASTNode |
        self finishExpansionWithEnvironment: self environment
    }.

MacroMetaBuilder publicSubclass: #NamedMetaBuilder slots: (
    TypeSlot publicNamed: #name type: ASTNode ,
).

NamedMetaBuilder
    withSelector: #expandMessageSendNode: addMethod: {:self :messageSendNode :: ASTNode |
        if: (self name == nil) && messageSendNode arguments isEmpty then: {
            self name: messageSendNode selector.
            self continueExpansion
        } else: {
            self expandMessageSendNodeWithMetaBuilderMethod: messageSendNode
        }.
    }.

NamedMetaBuilder
    withSelector: #expandMessageSendNode: addMethod: {:self :messageSendNode :: ASTNode |
        if: (self name == nil) && messageSendNode arguments isEmpty then: {
            self name: messageSendNode selector.
            self continueExpansion
        } else: {
            self expandMessageSendNodeWithMetaBuilderMethod: messageSendNode
        }.
    }.

NamedMetaBuilder publicSubclass: #VariableMetaBuilder slots: (
    TypeSlot publicNamed: #typeExpression type: ASTNode ,
    TypeSlot publicNamed: #initialValue type: ASTNode ,
).

VariableMetaBuilder
    withSelector: #type: addMethod: {:self :(ASTNode)typeExpression :: ASTNode |
        <metaBuilder>
        self typeExpression: typeExpression.
        self continueExpansion
    };
    withSelector: #=> addMethod: {:self :(ASTNode)typeExpression :: ASTNode |
        <metaBuilder>
        self typeExpression: typeExpression.
        self continueExpansion
    };
    withSelector: #":=" addMethod: {:self :(ASTNode)initialValue :: ASTNode |
        <metaBuilder>
        self initialValue: initialValue.
        self finishExpansion
    }.

VariableMetaBuilder publicSubclass: #LetMetaBuilder slots: (
    TypeSlot publicNamed: #typeExpression type: ASTNode ,
    TypeSlot publicNamed: #initialValue type: ASTNode ,
).

LetMetaBuilder
    withSelector: #finishExpansionWithEnvironment: addMethod: {:self :environment :: ASTNode |
        ASTLocalDefinitionNode new
            sourcePosition: self sourcePosition;
            nameExpression: self name;
            typeExpression: self typeExpression;
            valueExpression: self initialValue;
            yourself
    }.

public: #let with: (MetaBuilderFactory for: LetMetaBuilder).

MacroMetaBuilder publicSubclass: #MethodMetaBuilder slots: (
    TypeSlot publicNamed: #selector type: ASTNode ,
    TypeSlot publicNamed: #resultType type: ASTNode ,
    TypeSlot publicNamed: #body type: ASTNode ,
    TypeSlot publicNamed: #arguments type: ArraySlice
).

ASTNode
    withSelector: #parseAsArgumentNode addMethod: {:self :: ASTArgumentNode |
        self error: self asString -- " is not a valid argument expression."
    }.

ASTArgumentNode
    withSelector: #parseAsArgumentNode addMethod: {:self :: ASTArgumentNode | self }.

ASTIdentifierReferenceNode
    withSelector: #parseAsArgumentNode addMethod: {:self :: ASTArgumentNode |
        ASTArgumentNode new
            sourcePosition: self sourcePosition;
            isForAll: false;
            name: (ASTLiteralNode new
                sourcePosition: self sourcePosition;
                value: self value;
                yourself);
            yourself
    }.

MethodMetaBuilder
    withSelector: #expandMessageSendNode: addMethod: {:self :messageSendNode :: ASTNode |
        if: self selector == nil then: {
            self selector: messageSendNode selector.
            self arguments: (messageSendNode arguments collect: {:each | each parseAsArgumentNode}).
            self continueExpansion
        } else: {
            self expandMessageSendNodeWithMetaBuilderMethod: messageSendNode
        }.
    };
    withSelector: #":=" addMethod: {:self :(ASTNode)bodyNode :: ASTNode |
        <metaBuilder>
        self body: bodyNode.
        self finishExpansion
    };
    withSelector: #=> addMethod: {:self :(ASTNode)resultType :: ASTNode |
        <metaBuilder>
        self resultType: resultType.
        self continueExpansion
    };
    withSelector: #finishExpansionWithEnvironment: addMethod: {:self :environment :: ASTNode |
        let: #selfArgument with: (ASTArgumentNode new
            sourcePosition: self sourcePosition;
            isForAll: false;
            name: `'#self;
            type: `'SelfType;
            yourself).
        let: #arguments with: ((Array with: selfArgument) -- self arguments) asArraySlice.
        let: #methodNode with: (ASTLambdaNode new
            sourcePosition: self sourcePosition;
            arguments: arguments;
            body: self body;
            resultType: self resultType;
            yourself
        ).
        
        ``(__OwnerProgramEntity__ withSelector: `,(self selector) addMethod: `,methodNode)
    }.

public: #method with: (MetaBuilderFactory for: MethodMetaBuilder).

{
    let: #typeExtendMacro with: {:macroContext :self :extensionBlock :: ASTNode |
            ``{
                let: #SelfType with: `,self.
                let: #__Meta__ with: SelfType __type__.
                let: #__OwnerProgramEntity__ with: SelfType.
                `,extensionBlock
            }
        } makeMacro.
    Type
        withSelector: #extend: addMacroMethod: typeExtendMacro;
        withSelector: #definition: addMacroMethod: typeExtendMacro.
}.
