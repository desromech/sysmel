## ============================================================================
## Bootstrap core runtime
## ============================================================================

AnyValue
    withSelector: #initialize addMethod: {:self :: Void | };
    withSelector: #yourself addMethod: {:self :: self __type__ | self };

    withSelector: #postCopy addMethod: {:self :: Void | };
    withSelector: #shallowCopy addMethod: {:self :: self __type__ | RawTuple::shallowCopy(self) };
    withSelector: #copy addMethod: {:self :: self __type__ | self shallowCopy postCopy; yourself };

    withSelector: #isNil addMethod: {:self :: Boolean | self == nil };
    withSelector: #isNotNil addMethod: {:self :: Boolean | self ~~ nil }.

Object
    withSelector: #class addMethod: {:self :: self __type__ __type__ | self __type__ };
    withSelector: #species addMethod: {:self :: Class | self class };
    withSelector: #error: addMethod: {:self :(String)errorMessage :: Void | error(errorMessage) };
    withSelector: #subclassResponsibility addMethod: {:self :: Void | self error: "Subclass responsibility." }.

Type
    withSelector: #basicNew addMethod: {:self :: self |
        let: #result with: RawTuple::new(self totalSlotCount).
        (RawTuple::type:)(result, self).
        result
    };
    withSelector: #basicNew: addMethod: {:self :(Integer)variableSlotCount :: self |
        let: #result with: RawTuple::new(self totalSlotCount + variableSlotCount).
        (RawTuple::type:)(result, self).
        result
    };
    withSelector: #new addMethod: {:self :: self |
        self basicNew initialize; yourself
    }.

Void
    withSelector: #coerceValue: addMethod: {:self :value :: self | void }.

Class
    withSelector: #withSelector:addClassMethod: addMethod: {:self :selector :method :: Void |
        self class withSelector: selector addMethod: method
    }.

ValueBox
    withSelector: #with: addClassMethod: {:self :value |
        self basicNew
            _: value;
            yourself
    };
    withSelector: #_ addMethod: {:self | self value };
    withSelector: #_: addMethod: {:self :newValue | self value: newValue. newValue };
    withSelector: #":=" addMethod: {:self :newValue | self value: newValue. newValue }.

SequenceableCollection
    withSelector: #collect: addMethod: {:self :aBlock :: Void |
        let: #index with: (ValueBox with: 0).
        let: #size with: self size.
        let: #result with: (self species new: size).

        while: index _ < self size do: {
            let: #i with: index _.
            result at: i put: aBlock(self at: i)
        } continueWith: (index := index _ + 1)
    };
    withSelector: #do: addMethod: {:self :aBlock :: Void |
        let: #index with: (ValueBox with: 0).
        let: #size with: self size.

        while: index _ < self size do: (
            aBlock(self at: index _)
        ) continueWith: (index := index _ + 1)
    };
    withSelector: #doWithIndex: addMethod: {:self :aBlock :: Void |
        let: #index with: (ValueBox with: 0).
        let: #size with: self size.

        while: index _ < self size do: {
            let: #i with: index _.
            aBlock(self at: i, i)
        } continueWith: (index := index _ + 1)
    };
    withSelector: #first addMethod: {:self | self at: 0 };
    withSelector: #second addMethod: {:self | self at: 1 };
    withSelector: #third addMethod: {:self | self at: 2 };
    withSelector: #fourth addMethod: {:self | self at: 3 };

    withSelector: #printString addMethod: {:self :: String |
        let: #builder with: StringBuilder new.
        builder addAll: self class printString; addAll: "(".
        self doWithIndex: {:element :index :: Void |
            if: index > 0 then: (builder addAll: ", ").
            builder addAll: element printString.
            void
        }.

        builder addAll: ")"; asString
    }.

ArrayList
    withSelector: #new: addClassMethod: {:self :(Integer)initialSize :: Void |
        self basicNew initializeWithSize: initialSize; yourself
    };
    withSelector: #initialize addMethod: {:self :: Void |
        self size: 0sz
    };
    withSelector: #initializeWithSize: addMethod: {:self :(Integer)initialSize :: Void |
        self size: initialSize sz.
        self storage: (Array new: initialSize).
    };
    withSelector: #at: addMethod: {:self :(Integer)index |
        if: index < self size then: {
            self storage at: index + self offset
        } else: {
            error("Index out of bounds.")
        }
    };
    withSelector: #at:put: addMethod: {:self :(Integer)index :value :: Void |
        if: index < self size then: {
            self storage at: index + self offset put: value
        } else: {
            error("Index out of bounds.")
        }
    }.

StringBuilder
    withSelector: #initialize addMethod: {:self :: Void |
        self size: 0
    }.

Array
    withSelector: #at: addMethod: {:self :(Integer)index |
        self __slotAt__: index
    };
    withSelector: #at:put: addMethod: {:self :(Integer)index :value :: Void |
        self __slotAt__: index put: value
    };
    withSelector: #size addMethod: {:self :: Integer |
        self __size__
    }.

ByteArray
    withSelector: #at: addMethod: {:self :(Integer)index |
        self __slotAt__: index
    };
    withSelector: #at:put: addMethod: {:self :(Integer)index :value :: Void |
        self __slotAt__: index put: value
    };
    withSelector: #size addMethod: {:self :: Integer |
        self __byteSize__
    };
    withSelector: #printString addMethod: {:self :: String |
        let: #builder with: StringBuilder new.
        builder addAll: "#[".
        self doWithIndex: {:element :index :: Void |
            if: index > 0 then: (builder addAll: ". ").
            builder addAll: element printString.
            void
        }.

        builder addAll: "]"; asString
    }.

ArraySlice
    withSelector: #new: addClassMethod: {:self :(Integer)size |
        self basicNew
            elements: (Array basicNew: size);
            offset: 0 sz;
            size: size sz;
            yourself
    };
    withSelector: #at: addMethod: {:self :(Integer)index |
        if: index < self size then: {
            self elements at: index + self offset
        } else: {
            error("Index out of bounds.")
        }
    };
    withSelector: #at:put: addMethod: {:self :(Integer)index :value :: Void |
        if: index < self size then: {
            self elements at: index + self offset put: value
        } else: {
            error("Index out of bounds.")
        }
    }.

## ============================================================================
## Bootstrap AST methods
## ============================================================================

ASTNode
    withSelector: #astAnalyzeWithEnvironment: addMethod: {:self :environment | self subclassResponsibility };
    withSelector: #astAnalyzeAndEvaluateWithEnvironment: addMethod: {:self :environment | self subclassResponsibility };
    withSelector: #astEvaluateWithEnvironment: addMethod: {:self :environment | self subclassResponsibility };
    withSelector: #childrenDo: addMethod: {:self :aBlock :: Void | self subclassResponsibility };
    withSelector: #transformWith: addMethod: {:self :aBlock :: Void | self subclassResponsibility };
    withSelector: #transformedWith: addMethod: {:self :aBlock :: self class | self copy transformWith: aBlock; yourself }.

ASTArgumentNode
    withSelector: #childrenDo: addMethod: {:self :aBlock :: Void |
        if: (self name isNotNil) then: aBlock(self name).
        if: (self type isNotNil) then: aBlock(self type).
    };
    withSelector: #transformWith: addMethod: {:self :aBlock :: Void |
        if: (self name isNotNil) then: (self name: aBlock(self name)).
        if: (self type isNotNil) then: (self type: aBlock(self type)).
    }.

ASTBinaryExpressionSequenceNode
    withSelector: #childrenDo: addMethod: {:self :aBlock :: Void |
        self operands do: aBlock.
        self operators do: aBlock.
    };
    withSelector: #transformWith: addMethod: {:self :aBlock :: Void |
        self operands: (self operands collect: aBlock).
        self operators: (self operators collect: aBlock).
    }.

ASTDoWhileContinueWithNode
    withSelector: #childrenDo: addMethod: {:self :aBlock :: Void |
        if: (self bodyExpression isNotNil) then: aBlock(self bodyExpression).
        if: (self conditionExpression isNotNil) then: aBlock(self conditionExpression).
        if: (self continueExpression isNotNil) then: aBlock(self continueExpression).
    };
    withSelector: #transformWith: addMethod: {:self :aBlock :: Void |
        if: (self bodyExpression isNotNil) then: (self bodyExpression: aBlock(self bodyExpression)).
        if: (self conditionExpression isNotNil) then: (self conditionExpression: aBlock(self conditionExpression)).
        if: (self continueExpression isNotNil) then: (self continueExpression: aBlock(self continueExpression)).
    }.

ASTErrorNode
    withSelector: #transformWith: addMethod: {:self :aBlock :: Void |
    }.

ASTFunctionApplicationNode
    withSelector: #childrenDo: addMethod: {:self :aBlock :: Void |
        if: (self functionExpression isNotNil) then: aBlock(self functionExpression).
        self arguments do: aBlock.
    };
    withSelector: #transformWith: addMethod: {:self :aBlock :: Void |
        if: (self functionExpression isNotNil) then: (self functionExpression: aBlock(self functionExpression)).
        self arguments: (self arguments collect: aBlock).
    }.

ASTLambdaNode
    withSelector: #childrenDo: addMethod: {:self :aBlock :: Void |
        self arguments do: aBlock.
        if: (self resultType isNotNil) then: aBlock(self resultType).
        if: (self body isNotNil) then: aBlock(self body).
    };
    withSelector: #transformWith: addMethod: {:self :aBlock :: Void |
        self arguments: (self arguments collect: aBlock).
        if: (self resultType isNotNil) then: (self resultType: aBlock(self resultType)).
        if: (self body isNotNil) then: (self body: aBlock(self body)).
    }.

ASTLexicalBlockNode
    withSelector: #childrenDo: addMethod: {:self :aBlock :: Void |
        if: (self body isNotNil) then: aBlock(self body).
    };
    withSelector: #transformWith: addMethod: {:self :aBlock :: Void |
        if: (self body isNotNil) then: (self body: aBlock(self body)).
    }.

ASTLiteralNode
    withSelector: #astAnalyzeWithEnvironment: addMethod: {:self :environment | self };
    withSelector: #astAnalyzeAndEvaluateWithEnvironment: addMethod: {:self :environment | self value };
    withSelector: #astEvaluateWithEnvironment: addMethod: {:self :environment | self value };
    withSelector: #childrenDo: addMethod: {:self :aBlock :: Void | };
    withSelector: #transformWith: addMethod: {:self :aBlock :: Void | }.

ASTLocalDefinitionNode
    withSelector: #childrenDo: addMethod: {:self :aBlock :: Void |
        if: (self nameExpression isNotNil) then: aBlock(self nameExpression).
        if: (self valueExpression isNotNil) then: aBlock(self valueExpression).
    };
    withSelector: #transformWith: addMethod: {:self :aBlock :: Void |
        if: (self nameExpression isNotNil) then: (self nameExpression: aBlock(self nameExpression)).
        if: (self valueExpression isNotNil) then: (self valueExpression: aBlock(self valueExpression)).
    }.

ASTIdentifierReferenceNode
    withSelector: #childrenDo: addMethod: {:self :aBlock :: Void | };
    withSelector: #transformWith: addMethod: {:self :aBlock :: Void | }.

ASTIfNode
    withSelector: #childrenDo: addMethod: {:self :aBlock :: Void |
        if: (self conditionExpression isNotNil) then: aBlock(self conditionExpression).
        if: (self trueExpression isNotNil) then: aBlock(self trueExpression).
        if: (self falseExpression isNotNil) then: aBlock(self falseExpression).
    };
    withSelector: #transformWith: addMethod: {:self :aBlock :: Void |
        if: (self conditionExpression isNotNil) then: (self conditionExpression: aBlock(self conditionExpression)).
        if: (self trueExpression isNotNil) then: (self trueExpression: aBlock(self trueExpression)).
        if: (self falseExpression isNotNil) then: (self falseExpression: aBlock(self falseExpression)).
    }.

ASTMakeAssociationNode
    withSelector: #childrenDo: addMethod: {:self :aBlock :: Void |
        if: (self key isNotNil) then: aBlock(self key).
        if: (self value isNotNil) then: aBlock(self value).
    };
    withSelector: #transformWith: addMethod: {:self :aBlock :: Void |
        if: (self key isNotNil) then: (self key: aBlock(self key)).
        if: (self value isNotNil) then: (self value: aBlock(self value)).
    }.

ASTMakeByteArrayNode
    withSelector: #childrenDo: addMethod: {:self :aBlock :: Void |
        self elements do: aBlock
    };
    withSelector: #transformWith: addMethod: {:self :aBlock :: Void |
        self elements: (self elements collect: aBlock)
    }.

ASTMakeDictionaryNode
    withSelector: #childrenDo: addMethod: {:self :aBlock :: Void |
        self elements do: aBlock
    };
    withSelector: #transformWith: addMethod: {:self :aBlock :: Void |
        self elements: (self elements collect: aBlock)
    }.

ASTMakeTupleNode
    withSelector: #childrenDo: addMethod: {:self :aBlock :: Void |
        self elements do: aBlock
    };
    withSelector: #transformWith: addMethod: {:self :aBlock :: Void |
        self elements: (self elements collect: aBlock)
    }.

ASTMessageSendNode
    withSelector: #childrenDo: addMethod: {:self :aBlock :: Void |
        if: (self receiver isNotNil) then: aBlock(self receiver).
        if: (self selector isNotNil) then: aBlock(self selector).
        self arguments do: aBlock
    };
    withSelector: #transformWith: addMethod: {:self :aBlock :: Void |
        if: (self receiver isNotNil) then: (self receiver: aBlock(self receiver)).
        if: (self selector isNotNil) then: (self selector: aBlock(self selector)).
        self arguments: (self arguments collect: aBlock)
    }.

ASTMessageChainNode
    withSelector: #childrenDo: addMethod: {:self :aBlock :: Void |
        if: (self receiver isNotNil) then: aBlock(self receiver).
        self messages do: aBlock
    };
    withSelector: #transformWith: addMethod: {:self :aBlock :: Void |
        if: (self receiver isNotNil) then: (self receiver: aBlock(self receiver)).
        self messages: (self messages collect: aBlock)
    }.

ASTMessageChainMessageNode
    withSelector: #childrenDo: addMethod: {:self :aBlock :: Void |
        if: (self selector isNotNil) then: aBlock(self selector).
        self arguments do: aBlock
    };
    withSelector: #transformWith: addMethod: {:self :aBlock :: Void |
        if: (self selector isNotNil) then: (self selector: aBlock(self selector)).
        self arguments: (self arguments collect: aBlock)
    }.

ASTSequenceNode
    withSelector: #childrenDo: addMethod: {:self :aBlock :: Void |
        self pragmas do: aBlock.
        self expressions do: aBlock.
    };
    withSelector: #transformWith: addMethod: {:self :aBlock :: Void |
        self pragmas: (self pragmas collect: aBlock).
        self expressions: (self expressions collect: aBlock)
    }.

ASTUnexpandedApplicationNode
    withSelector: #childrenDo: addMethod: {:self :aBlock :: Void |
        if: (self functionOrMacroExpression isNotNil) then: aBlock(self functionOrMacroExpression).
        self arguments do: aBlock
    };
    withSelector: #transformWith: addMethod: {:self :aBlock :: Void |
        if: (self functionOrMacroExpression isNotNil) then: (self functionOrMacroExpression: aBlock(self functionOrMacroExpression)).
        self arguments: (self arguments collect: aBlock)
    }.

ASTUnexpandedSExpressionNode
    withSelector: #childrenDo: addMethod: {:self :aBlock :: Void |
        self elements do: aBlock
    };
    withSelector: #transformWith: addMethod: {:self :aBlock :: Void |
        self elements: (self elements collect: aBlock)
    }.

ASTNode
    withSelector: #analyzeQuasiQuoteWithEnvironment: addMethod: {:self :environment |
        self transformedWith: {:child | child analyzeQuasiQuoteWithEnvironment: environment}
    };
    withSelector: #analyzeAndEvaluateQuasiQuoteWithEnvironment: addMethod: {:self :environment |
        self transformedWith: {:child | child analyzeAndEvaluateQuasiQuoteWithEnvironment: environment}
    };
    withSelector: #evaluateQuasiQuoteWithEnvironment: addMethod: {:self :environment |
        self transformedWith: {:child | child evaluateQuasiQuoteWithEnvironment: environment}
    }.

ASTQuasiQuoteNode
    withSelector: #astAnalyzeWithEnvironment: addMethod: {:self :environment |
        self copy
            node: (self node analyzeQuasiQuoteWithEnvironment: environment);
            yourself
    };
    withSelector: #astAnalyzeAndEvaluateWithEnvironment: addMethod: {:self :environment |
        self node analyzeAndEvaluateQuasiQuoteWithEnvironment: environment
    };
    withSelector: #astEvaluateWithEnvironment: addMethod: {:self :environment |
        self node evaluateQuasiQuoteWithEnvironment: environment
    };
    withSelector: #childrenDo: addMethod: {:self :aBlock :: Void |
        if: (self node isNotNil) then: aBlock(self node)
    };
    withSelector: #transformWith: addMethod: {:self :aBlock :: Void |
        if: (self node isNotNil) then: (self node: aBlock(self node))
    }.

ASTQuasiUnquoteNode
    withSelector: #analyzeQuasiQuoteWithEnvironment: addMethod: {:self :environment |
        self copy
            expression: (self expression astAnalyzeWithEnvironment: environment);
            yourself
    };
    withSelector: #analyzeAndEvaluateQuasiQuoteWithEnvironment: addMethod: {:self :environment |
        self expression astAnalyzeAndEvaluateWithEnvironment: environment
    };
    withSelector: #evaluateQuasiQuoteWithEnvironment: addMethod: {:self :environment |
        self expression astEvaluateWithEnvironment: environment
    };
    withSelector: #childrenDo: addMethod: {:self :aBlock :: Void |
        if: (self expression) then: aBlock(self node)
    };
    withSelector: #transformWith: addMethod: {:self :aBlock :: Void |
        if: (self expression) then: (self node: aBlock(self node))
    }.

ASTQuoteNode
    withSelector: #astAnalyzeWithEnvironment: addMethod: {:self :environment | self};
    withSelector: #astAnalyzeAndEvaluateWithEnvironment: addMethod: {:self :environment | self node};
    withSelector: #astEvaluateWithEnvironment: addMethod: {:self :environment | self node};
    withSelector: #childrenDo: addMethod: {:self :aBlock :: Void |
        if: (self node) then: aBlock(self node)
    };
    withSelector: #transformWith: addMethod: {:self :aBlock :: Void |
        if: (self node) then: (self node: aBlock(self node))
    }.

ASTSpliceNode
    withSelector: #astAnalyzeWithEnvironment: addMethod: {:self :environment | self invalidLocationError };
    withSelector: #astAnalyzeAndEvaluateWithEnvironment: addMethod: {:self :environment | self invalidLocationError };
    withSelector: #astEvaluateWithEnvironment: addMethod: {:self :environment | self invalidLocationError };
    withSelector: #childrenDo: addMethod: {:self :aBlock :: Void |
        if: (self expression) then: aBlock(self node)
    };
    withSelector: #transformWith: addMethod: {:self :aBlock :: Void |
        if: (self expression) then: (self node: aBlock(self node))
    };

    withSelector: #analyzeQuasiQuoteWithEnvironment: addMethod: {:self :environment | self invalidLocationError };
    withSelector: #analyzeAndEvaluateQuasiQuoteWithEnvironment: addMethod: {:self :environment | self invalidLocationError };
    withSelector: #evaluateQuasiQuoteWithEnvironment: addMethod: {:self :environment | self invalidLocationError };

    withSelector: #invalidLocationError addMethod: {:self :environment |
        self error: "Invalid location for a splice expression."
    }.

ASTWhileContinueWithNode
    withSelector: #childrenDo: addMethod: {:self :aBlock :: Void |
        if: (self conditionExpression isNotNil) then: aBlock(self conditionExpression).
        if: (self bodyExpression isNotNil) then: aBlock(self bodyExpression).
        if: (self continueExpression isNotNil) then: aBlock(self bodyExpression).
    };
    withSelector: #transformWith: addMethod: {:self :aBlock :: Void |
        if: (self conditionExpression isNotNil) then: (self conditionExpression: aBlock(self conditionExpression)).
        if: (self bodyExpression isNotNil) then: (self bodyExpression: aBlock(self bodyExpression)).
        if: (self continueExpression isNotNil) then: (self continueExpression: aBlock(self continueExpression)).
    }.
