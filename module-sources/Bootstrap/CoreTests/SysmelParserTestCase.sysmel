public class SysmelParserTestCase superclass: TestCase; definition: {
    public method parseString: (string: String) ::=> ASTNode
        := SysmelLanguage parseSourceCode: (SourceCode text: string directory: nil name: "test" language: #sysmel).

    public method testEmptyString => Void := {
        let ast := self parseString: "".
        self assert: ast isNotNil.
        self assert: ast isSequenceNode.

        let sequenceNode := ast downCastTo: ASTSequenceNode.
        self assert: sequenceNode pragmas size equals: 0sz.
        self assert: sequenceNode expressions size equals: 0sz.
    }.

    public method testSingleLineComment => Void := {
        let ast := self parseString: "## Single line comment".
        self assert: ast isNotNil.
        self assert: ast isSequenceNode.

        let sequenceNode := ast downCastTo: ASTSequenceNode.
        self assert: sequenceNode pragmas size equals: 0sz.
        self assert: sequenceNode expressions size equals: 0sz.
    }.

    public method testMultiLineComment => Void := {
        let ast := self parseString: "
        #**
         * Multi line comment
         *#
        ".
        self assert: ast isNotNil.
        self assert: ast isSequenceNode.

        let sequenceNode := ast downCastTo: ASTSequenceNode.
        self assert: sequenceNode pragmas size equals: 0sz.
        self assert: sequenceNode expressions size equals: 0sz.
    }.

    public method testIdentifierReference => Void := {
        let ast := self parseString: "identifier".
        self assert: ast isNotNil.
        self assert: ast isSequenceNode.

        let sequenceNode := ast downCastTo: ASTSequenceNode.
        self assert: sequenceNode pragmas size equals: 0sz.
        self assert: sequenceNode expressions size equals: 1sz.

        self assert: sequenceNode expressions first isIdentifierReferenceNode.
        let identifierNode => ASTIdentifierReferenceNode := sequenceNode expressions first.
        self assert: identifierNode value equals: #identifier.
    }.

    public method testLiteralInteger => Void := {
        let ast := self parseString: "1234".
        self assert: ast isNotNil.
        self assert: ast isSequenceNode.

        let sequenceNode := ast downCastTo: ASTSequenceNode.
        self assert: sequenceNode pragmas size equals: 0sz.
        self assert: sequenceNode expressions size equals: 1sz.

        self assert: sequenceNode expressions first isLiteralNode.
        let literalNode => ASTLiteralNode := sequenceNode expressions first.
        self assert: literalNode value equals: 1234.
    }.

    public method testLiteralSymbol => Void := {
        let ast := self parseString: "#test".
        self assert: ast isNotNil.
        self assert: ast isSequenceNode.

        let sequenceNode := ast downCastTo: ASTSequenceNode.
        self assert: sequenceNode pragmas size equals: 0sz.
        self assert: sequenceNode expressions size equals: 1sz.

        self assert: sequenceNode expressions first isLiteralNode.
        let literalNode => ASTLiteralNode := sequenceNode expressions first.
        self assert: literalNode value equals: #test.
    }.

    public method testParentheses => Void := {
        let ast := self parseString: "(1234)".
        self assert: ast isNotNil.
        self assert: ast isSequenceNode.

        let sequenceNode := ast downCastTo: ASTSequenceNode.
        self assert: sequenceNode pragmas size equals: 0sz.
        self assert: sequenceNode expressions size equals: 1sz.

        self assert: sequenceNode expressions first isLiteralNode.
        let literalNode => ASTLiteralNode := sequenceNode expressions first.
        self assert: literalNode value equals: 1234.
    }.

    public method testParenthesesSequence => Void := {
        let ast := self parseString: "(1234 . hello)".
        self assert: ast isNotNil.
        self assert: ast isSequenceNode.

        let sequenceNode := ast downCastTo: ASTSequenceNode.
        self assert: sequenceNode pragmas size equals: 0sz.
        self assert: sequenceNode expressions size equals: 1sz.

        self assert: sequenceNode expressions first isSequenceNode.
        let subsequenceNode => ASTSequenceNode := sequenceNode expressions first.
        self assert: subsequenceNode pragmas size equals: 0sz.
        self assert: subsequenceNode expressions size equals: 2sz.

        self assert: subsequenceNode expressions first isLiteralNode.
        let literalNode => ASTLiteralNode := subsequenceNode expressions first.
        self assert: literalNode value equals: 1234.

        self assert: subsequenceNode expressions second isIdentifierReferenceNode.
        let identifierNode => ASTIdentifierReferenceNode := subsequenceNode expressions second.
        self assert: identifierNode value equals: #hello.
    }.

    public method testUnaryMessage => Void := {
        let ast := self parseString: "42 negated".
        self assert: ast isNotNil.
        self assert: ast isSequenceNode.

        let sequenceNode := ast downCastTo: ASTSequenceNode.
        self assert: sequenceNode pragmas size equals: 0sz.
        self assert: sequenceNode expressions size equals: 1sz.

        self assert: sequenceNode expressions first isMessageSendNode.
        let sendNode => ASTMessageSendNode := sequenceNode expressions first.
        self assert: sendNode receiver isLiteralNode.
        self assert: (sendNode receiver downCastTo: ASTLiteralNode) value equals: 42.

        self assert: sendNode selector isLiteralNode.
        self assert: (sendNode selector downCastTo: ASTLiteralNode) value equals: #negated.

        self assert: sendNode arguments isEmpty
    }.

    public method testQuasiUnquoteMessage => Void := {
        let ast := self parseString: "let `,gensym".
        self assert: ast isNotNil.
        self assert: ast isSequenceNode.

        let sequenceNode := ast downCastTo: ASTSequenceNode.
        self assert: sequenceNode pragmas size equals: 0sz.
        self assert: sequenceNode expressions size equals: 1sz.

        self assert: sequenceNode expressions first isMessageSendNode.
        let sendNode => ASTMessageSendNode := sequenceNode expressions first.
        self assert: sendNode arguments isEmpty.
        self assert: sendNode receiver isIdentifierReferenceNode.
        self assert: (sendNode receiver downCastTo: ASTIdentifierReferenceNode) value equals: #let.

        self assert: sendNode selector isQuasiUnquoteNode.
        let quasiUnquoteNode := sendNode selector downCastTo: ASTQuasiUnquoteNode..

        self assert: quasiUnquoteNode expression isIdentifierReferenceNode.
        self assert: (quasiUnquoteNode expression downCastTo: ASTIdentifierReferenceNode) value equals: #gensym.
    }.

    public method testApplyBlock => Void := {
        let ast := self parseString: "42 {}".
        self assert: ast isNotNil.
        self assert: ast isSequenceNode.

        let sequenceNode := ast downCastTo: ASTSequenceNode.
        self assert: sequenceNode pragmas size equals: 0sz.
        self assert: sequenceNode expressions size equals: 1sz.

        self assert: sequenceNode expressions first isMessageSendNode.
        let sendNode => ASTMessageSendNode := sequenceNode expressions first.
        self assert: sendNode receiver isLiteralNode.
        self assert: (sendNode receiver downCastTo: ASTLiteralNode) value equals: 42.

        self assert: sendNode selector isLiteralNode.
        self assert: (sendNode selector downCastTo: ASTLiteralNode) value equals: #"{}:".

        self assert: sendNode arguments size equals: 1sz.
        self assert: sendNode arguments first isLexicalBlockNode.
    }.

    public method testApplyByteArray => Void := {
        let ast := self parseString: "42 #[]".
        self assert: ast isNotNil.
        self assert: ast isSequenceNode.

        let sequenceNode := ast downCastTo: ASTSequenceNode.
        self assert: sequenceNode pragmas size equals: 0sz.
        self assert: sequenceNode expressions size equals: 1sz.

        self assert: sequenceNode expressions first isMessageSendNode.
        let sendNode => ASTMessageSendNode := sequenceNode expressions first.
        self assert: sendNode receiver isLiteralNode.
        self assert: (sendNode receiver downCastTo: ASTLiteralNode) value equals: 42.

        self assert: sendNode selector isLiteralNode.
        self assert: (sendNode selector downCastTo: ASTLiteralNode) value equals: #"#[]:".

        self assert: sendNode arguments size equals: 1sz.
        self assert: sendNode arguments first isMakeByteArrayNode.
    }.

    public method testApplyDictionary => Void := {
        let ast := self parseString: "42 #{}".
        self assert: ast isNotNil.
        self assert: ast isSequenceNode.

        let sequenceNode := ast downCastTo: ASTSequenceNode.
        self assert: sequenceNode pragmas size equals: 0sz.
        self assert: sequenceNode expressions size equals: 1sz.

        self assert: sequenceNode expressions first isMessageSendNode.
        let sendNode => ASTMessageSendNode := sequenceNode expressions first.
        self assert: sendNode receiver isLiteralNode.
        self assert: (sendNode receiver downCastTo: ASTLiteralNode) value equals: 42.

        self assert: sendNode selector isLiteralNode.
        self assert: (sendNode selector downCastTo: ASTLiteralNode) value equals: #"#{}:".

        self assert: sendNode arguments size equals: 1sz.
        self assert: sendNode arguments first isMakeDictionaryNode.
    }.

    public method testApplyLiteralArray => Void := {
        let ast := self parseString: "42 #()".
        self assert: ast isNotNil.
        self assert: ast isSequenceNode.

        let sequenceNode := ast downCastTo: ASTSequenceNode.
        self assert: sequenceNode pragmas size equals: 0sz.
        self assert: sequenceNode expressions size equals: 1sz.

        self assert: sequenceNode expressions first isMessageSendNode.
        let sendNode => ASTMessageSendNode := sequenceNode expressions first.
        self assert: sendNode receiver isLiteralNode.
        self assert: (sendNode receiver downCastTo: ASTLiteralNode) value equals: 42.

        self assert: sendNode selector isLiteralNode.
        self assert: (sendNode selector downCastTo: ASTLiteralNode) value equals: #"#():".

        self assert: sendNode arguments size equals: 1sz.
        self assert: sendNode arguments first isMakeArrayNode.
    }.

    public method testSubscript => Void := {
        let ast := self parseString: "42 [1]".
        self assert: ast isNotNil.
        self assert: ast isSequenceNode.

        let sequenceNode := ast downCastTo: ASTSequenceNode.
        self assert: sequenceNode pragmas size equals: 0sz.
        self assert: sequenceNode expressions size equals: 1sz.

        self assert: sequenceNode expressions first isMessageSendNode.
        let sendNode => ASTMessageSendNode := sequenceNode expressions first.
        self assert: sendNode receiver isLiteralNode.
        self assert: (sendNode receiver downCastTo: ASTLiteralNode) value equals: 42.

        self assert: sendNode selector isLiteralNode.
        self assert: (sendNode selector downCastTo: ASTLiteralNode) value equals: #"[]:".

        self assert: sendNode arguments size equals: 1sz.

        self assert: sendNode arguments first isLiteralNode.
        self assert: (sendNode arguments first downCastTo: ASTLiteralNode) value equals: 1.
    }.

    public method testSubscript2 => Void := {
        let ast := self parseString: "42 []".
        self assert: ast isNotNil.
        self assert: ast isSequenceNode.

        let sequenceNode := ast downCastTo: ASTSequenceNode.
        self assert: sequenceNode pragmas size equals: 0sz.
        self assert: sequenceNode expressions size equals: 1sz.

        self assert: sequenceNode expressions first isMessageSendNode.
        let sendNode => ASTMessageSendNode := sequenceNode expressions first.
        self assert: sendNode receiver isLiteralNode.
        self assert: (sendNode receiver downCastTo: ASTLiteralNode) value equals: 42.

        self assert: sendNode selector isLiteralNode.
        self assert: (sendNode selector downCastTo: ASTLiteralNode) value equals: #"[]".

        self assert: sendNode arguments isEmpty
    }.

    public method testBinaryExpression => Void := {
        let ast := self parseString: "1 + 2".
        self assert: ast isNotNil.
        self assert: ast isSequenceNode.

        let sequenceNode := ast downCastTo: ASTSequenceNode.
        self assert: sequenceNode pragmas size equals: 0sz.
        self assert: sequenceNode expressions size equals: 1sz.

        self assert: sequenceNode expressions first isMessageSendNode.
        let sendNode => ASTMessageSendNode := sequenceNode expressions first.
        self assert: sendNode receiver isLiteralNode.
        self assert: (sendNode receiver downCastTo: ASTLiteralNode) value equals: 1.

        self assert: sendNode selector isLiteralNode.
        self assert: (sendNode selector downCastTo: ASTLiteralNode) value equals: #+.

        self assert: sendNode arguments size equals: 1sz.
        self assert: sendNode arguments first isLiteralNode.
        self assert: (sendNode arguments first downCastTo: ASTLiteralNode) value equals: 2.
    }.

    public method testMessageWithoutReceiver => Void := {
        let ast := self parseString: "if: true then: 1".
        self assert: ast isNotNil.
        self assert: ast isSequenceNode.

        let sequenceNode := ast downCastTo: ASTSequenceNode.
        self assert: sequenceNode pragmas size equals: 0sz.
        self assert: sequenceNode expressions size equals: 1sz.

        self assert: sequenceNode expressions first isMessageSendNode.
        let sendNode => ASTMessageSendNode := sequenceNode expressions first.
        self assert: sendNode selector isLiteralNode.
        self assert: (sendNode selector downCastTo: ASTLiteralNode) value equals: #if:then:.

        self assert: sendNode arguments size equals: 2sz.
        self assert: sendNode arguments first isIdentifierReferenceNode.
        self assert: (sendNode arguments first downCastTo: ASTIdentifierReferenceNode) value equals: #true.

        self assert: sendNode arguments second isLiteralNode.
        self assert: (sendNode arguments second downCastTo: ASTLiteralNode) value equals: 1.
    }.

    public method testKeywordMessage => Void := {
        let ast := self parseString: "Array with: 1".
        self assert: ast isNotNil.
        self assert: ast isSequenceNode.

        let sequenceNode := ast downCastTo: ASTSequenceNode.
        self assert: sequenceNode pragmas size equals: 0sz.
        self assert: sequenceNode expressions size equals: 1sz.

        self assert: sequenceNode expressions first isMessageSendNode.
        let sendNode => ASTMessageSendNode := sequenceNode expressions first.
        self assert: sendNode receiver isIdentifierReferenceNode.
        self assert: (sendNode receiver downCastTo: ASTIdentifierReferenceNode) value equals: #Array.

        self assert: sendNode selector isLiteralNode.
        self assert: (sendNode selector downCastTo: ASTLiteralNode) value equals: #with:.

        self assert: sendNode arguments size equals: 1sz.
        self assert: sendNode arguments first isLiteralNode.
        self assert: (sendNode arguments first downCastTo: ASTLiteralNode) value equals: 1.
    }.

    public method testBinaryExpression2 => Void := {
        let ast := self parseString: "1 + 2 - 3".
        self assert: ast isNotNil.
        self assert: ast isSequenceNode.

        let sequenceNode := ast downCastTo: ASTSequenceNode.
        self assert: sequenceNode pragmas size equals: 0sz.
        self assert: sequenceNode expressions size equals: 1sz.

        self assert: sequenceNode expressions first isBinaryExpressionSequenceNode.
        let binaryExpressionSequence => ASTBinaryExpressionSequenceNode := sequenceNode expressions first.
        self assert: binaryExpressionSequence operands size equals: 3sz.
        self assert: binaryExpressionSequence operators size equals: 2sz.

        self assert: binaryExpressionSequence operands first isLiteralNode.
        self assert: (binaryExpressionSequence operands first downCastTo: ASTLiteralNode) value equals: 1.

        self assert: binaryExpressionSequence operands second isLiteralNode.
        self assert: (binaryExpressionSequence operands second downCastTo: ASTLiteralNode) value equals: 2.

        self assert: binaryExpressionSequence operands third isLiteralNode.
        self assert: (binaryExpressionSequence operands third downCastTo: ASTLiteralNode) value equals: 3.

        self assert: binaryExpressionSequence operators first isLiteralNode.
        self assert: (binaryExpressionSequence operators first downCastTo: ASTLiteralNode) value equals: #+.

        self assert: binaryExpressionSequence operators second isLiteralNode.
        self assert: (binaryExpressionSequence operators second downCastTo: ASTLiteralNode) value equals: #-.
    }.

    public method testLowPrecedenceBinaryExpression => Void := {
        let ast := self parseString: "1 ::+ 2".
        self assert: ast isNotNil.
        self assert: ast isSequenceNode.

        let sequenceNode := ast downCastTo: ASTSequenceNode.
        self assert: sequenceNode pragmas size equals: 0sz.
        self assert: sequenceNode expressions size equals: 1sz.

        self assert: sequenceNode expressions first isMessageSendNode.
        let sendNode => ASTMessageSendNode := sequenceNode expressions first.
        self assert: sendNode receiver isLiteralNode.
        self assert: (sendNode receiver downCastTo: ASTLiteralNode) value equals: 1.

        self assert: sendNode selector isLiteralNode.
        self assert: (sendNode selector downCastTo: ASTLiteralNode) value equals: #+.

        self assert: sendNode arguments size equals: 1sz.
        self assert: sendNode arguments first isLiteralNode.
        self assert: (sendNode arguments first downCastTo: ASTLiteralNode) value equals: 2.
    }.
    
    public method testMakeArray0 => Void := {
        let ast := self parseString: "()".
        self assert: ast isNotNil.
        self assert: ast isSequenceNode.

        let sequenceNode := ast downCastTo: ASTSequenceNode.
        self assert: sequenceNode pragmas size equals: 0sz.
        self assert: sequenceNode expressions size equals: 1sz.

        self assert: sequenceNode expressions first isMakeArrayNode.
        let makeArrayNode => ASTMakeArrayNode := sequenceNode expressions first.
        self assert: makeArrayNode elements isEmpty.
    }.

    public method testMakeArray1 => Void := {
        let ast := self parseString: "1,".
        self assert: ast isNotNil.
        self assert: ast isSequenceNode.

        let sequenceNode := ast downCastTo: ASTSequenceNode.
        self assert: sequenceNode pragmas size equals: 0sz.
        self assert: sequenceNode expressions size equals: 1sz.

        self assert: sequenceNode expressions first isMakeArrayNode.
        let makeArrayNode => ASTMakeArrayNode := sequenceNode expressions first.
        self assert: makeArrayNode elements size equals: 1sz.

        {
            self assert: makeArrayNode elements first isLiteralNode.
            let literalNode => ASTLiteralNode := makeArrayNode elements first.
            self assert: literalNode value equals: 1.
        }.
    }.

    public method testMakeArray2 => Void := {
        let ast := self parseString: "1, 2".
        self assert: ast isNotNil.
        self assert: ast isSequenceNode.

        let sequenceNode := ast downCastTo: ASTSequenceNode.
        self assert: sequenceNode pragmas size equals: 0sz.
        self assert: sequenceNode expressions size equals: 1sz.

        self assert: sequenceNode expressions first isMakeArrayNode.
        let makeArrayNode => ASTMakeArrayNode := sequenceNode expressions first.
        self assert: makeArrayNode elements size equals: 2sz.

        {
            self assert: makeArrayNode elements first isLiteralNode.
            let literalNode => ASTLiteralNode := makeArrayNode elements first.
            self assert: literalNode value equals: 1.
        }.

        {
            self assert: makeArrayNode elements second isLiteralNode.
            let literalNode => ASTLiteralNode := makeArrayNode elements second.
            self assert: literalNode value equals: 2.
        }.
    }.

    public method testMakeLiteralArray0 => Void := {
        let ast := self parseString: "#()".
        self assert: ast isNotNil.
        self assert: ast isSequenceNode.

        let sequenceNode := ast downCastTo: ASTSequenceNode.
        self assert: sequenceNode pragmas size equals: 0sz.
        self assert: sequenceNode expressions size equals: 1sz.

        self assert: sequenceNode expressions first isMakeArrayNode.
        let makeArrayNode => ASTMakeArrayNode := sequenceNode expressions first.
        self assert: makeArrayNode elements isEmpty.
    }.

    public method testMakeLiteralArray1 => Void := {
        let ast := self parseString: "#(1)".
        self assert: ast isNotNil.
        self assert: ast isSequenceNode.

        let sequenceNode := ast downCastTo: ASTSequenceNode.
        self assert: sequenceNode pragmas size equals: 0sz.
        self assert: sequenceNode expressions size equals: 1sz.

        self assert: sequenceNode expressions first isMakeArrayNode.
        let makeArrayNode => ASTMakeArrayNode := sequenceNode expressions first.
        self assert: makeArrayNode elements size equals: 1sz.

        {
            self assert: makeArrayNode elements first isLiteralNode.
            let literalNode => ASTLiteralNode := makeArrayNode elements first.
            self assert: literalNode value equals: 1.
        }.
    }.

    public method testMakeLiteralArray2 => Void := {
        let ast := self parseString: "#(1 2)".
        self assert: ast isNotNil.
        self assert: ast isSequenceNode.

        let sequenceNode := ast downCastTo: ASTSequenceNode.
        self assert: sequenceNode pragmas size equals: 0sz.
        self assert: sequenceNode expressions size equals: 1sz.

        self assert: sequenceNode expressions first isMakeArrayNode.
        let makeArrayNode => ASTMakeArrayNode := sequenceNode expressions first.
        self assert: makeArrayNode elements size equals: 2sz.

        {
            self assert: makeArrayNode elements first isLiteralNode.
            let literalNode => ASTLiteralNode := makeArrayNode elements first.
            self assert: literalNode value equals: 1.
        }.

        {
            self assert: makeArrayNode elements second isLiteralNode.
            let literalNode => ASTLiteralNode := makeArrayNode elements second.
            self assert: literalNode value equals: 2.
        }.
    }.

    public method testMakeLiteralArray3 => Void := {
        let ast := self parseString: "#(1 #() 2)".
        self assert: ast isNotNil.
        self assert: ast isSequenceNode.

        let sequenceNode := ast downCastTo: ASTSequenceNode.
        self assert: sequenceNode pragmas size equals: 0sz.
        self assert: sequenceNode expressions size equals: 1sz.

        self assert: sequenceNode expressions first isMakeArrayNode.
        let makeArrayNode => ASTMakeArrayNode := sequenceNode expressions first.
        self assert: makeArrayNode elements size equals: 3sz.

        {
            self assert: makeArrayNode elements first isLiteralNode.
            let literalNode => ASTLiteralNode := makeArrayNode elements first.
            self assert: literalNode value equals: 1.
        }.

        {
            self assert: makeArrayNode elements second isMakeArrayNode.
            let innerMakeArrayNode => ASTMakeArrayNode := makeArrayNode elements second.
            self assert: innerMakeArrayNode elements isEmpty.
        }.

        {
            self assert: makeArrayNode elements third isLiteralNode.
            let literalNode => ASTLiteralNode := makeArrayNode elements third.
            self assert: literalNode value equals: 2.
        }.
    }.

    public method testMakeByteArray0 => Void := {
        let ast := self parseString: "#[]".
        self assert: ast isNotNil.
        self assert: ast isSequenceNode.

        let sequenceNode := ast downCastTo: ASTSequenceNode.
        self assert: sequenceNode pragmas size equals: 0sz.
        self assert: sequenceNode expressions size equals: 1sz.

        self assert: sequenceNode expressions first isMakeByteArrayNode.
        let makeArrayNode => ASTMakeByteArrayNode := sequenceNode expressions first.
        self assert: makeArrayNode elements isEmpty.
    }.

    public method testMakeByteArray1 => Void := {
        let ast := self parseString: "#[1]".
        self assert: ast isNotNil.
        self assert: ast isSequenceNode.

        let sequenceNode := ast downCastTo: ASTSequenceNode.
        self assert: sequenceNode pragmas size equals: 0sz.
        self assert: sequenceNode expressions size equals: 1sz.

        self assert: sequenceNode expressions first isMakeByteArrayNode.
        let makeArrayNode => ASTMakeByteArrayNode := sequenceNode expressions first.
        self assert: makeArrayNode elements size equals: 1sz.

        {
            self assert: makeArrayNode elements first isLiteralNode.
            let literalNode => ASTLiteralNode := makeArrayNode elements first.
            self assert: literalNode value equals: 1.
        }.
    }.

    public method testMakeByteArray2 => Void := {
        let ast := self parseString: "#[1 . 2]".
        self assert: ast isNotNil.
        self assert: ast isSequenceNode.

        let sequenceNode := ast downCastTo: ASTSequenceNode.
        self assert: sequenceNode pragmas size equals: 0sz.
        self assert: sequenceNode expressions size equals: 1sz.

        self assert: sequenceNode expressions first isMakeByteArrayNode.
        let makeArrayNode => ASTMakeByteArrayNode := sequenceNode expressions first.
        self assert: makeArrayNode elements size equals: 2sz.

        {
            self assert: makeArrayNode elements first isLiteralNode.
            let literalNode => ASTLiteralNode := makeArrayNode elements first.
            self assert: literalNode value equals: 1.
        }.

        {
            self assert: makeArrayNode elements second isLiteralNode.
            let literalNode => ASTLiteralNode := makeArrayNode elements second.
            self assert: literalNode value equals: 2.
        }.
    }.

    public method testMakeDictionary0 => Void := {
        let ast := self parseString: "#{}".
        self assert: ast isNotNil.
        self assert: ast isSequenceNode.

        let sequenceNode := ast downCastTo: ASTSequenceNode.
        self assert: sequenceNode pragmas size equals: 0sz.
        self assert: sequenceNode expressions size equals: 1sz.

        self assert: sequenceNode expressions first isMakeDictionaryNode.
        let makeDictionaryNode => ASTMakeDictionaryNode := sequenceNode expressions first.
        self assert: makeDictionaryNode elements isEmpty.
    }.

    public method testMakeDictionary1 => Void := {
        let ast := self parseString: "#{first: 1}".
        self assert: ast isNotNil.
        self assert: ast isSequenceNode.

        let sequenceNode := ast downCastTo: ASTSequenceNode.
        self assert: sequenceNode pragmas size equals: 0sz.
        self assert: sequenceNode expressions size equals: 1sz.

        self assert: sequenceNode expressions first isMakeDictionaryNode.
        let makeDictionaryNode => ASTMakeDictionaryNode := sequenceNode expressions first.
        self assert: makeDictionaryNode elements size equals: 1sz.

        {
            self assert: makeDictionaryNode elements first isMakeAssociationNode.
            let associationNode => ASTMakeAssociationNode := makeDictionaryNode elements first.
            self assert: associationNode key isLiteralNode.
            self assert: (associationNode key downCastTo: ASTLiteralNode) value equals: #first.
            self assert: associationNode value isLiteralNode.
            self assert: (associationNode value downCastTo: ASTLiteralNode) value equals: 1.
        }.
    }.

    public method testMakeDictionary2 => Void := {
        let ast := self parseString: "#{first: 1 . second:}".
        self assert: ast isNotNil.
        self assert: ast isSequenceNode.

        let sequenceNode := ast downCastTo: ASTSequenceNode.
        self assert: sequenceNode pragmas size equals: 0sz.
        self assert: sequenceNode expressions size equals: 1sz.

        self assert: sequenceNode expressions first isMakeDictionaryNode.
        let makeDictionaryNode => ASTMakeDictionaryNode := sequenceNode expressions first.
        self assert: makeDictionaryNode elements size equals: 2sz.

        {
            self assert: makeDictionaryNode elements first isMakeAssociationNode.
            let associationNode => ASTMakeAssociationNode := makeDictionaryNode elements first.
            self assert: associationNode key isLiteralNode.
            self assert: (associationNode key downCastTo: ASTLiteralNode) value equals: #first.
            self assert: associationNode value isLiteralNode.
            self assert: (associationNode value downCastTo: ASTLiteralNode) value equals: 1.
        }.

        {
            self assert: makeDictionaryNode elements second isMakeAssociationNode.
            let associationNode => ASTMakeAssociationNode := makeDictionaryNode elements second.
            self assert: associationNode key isLiteralNode.
            self assert: (associationNode key downCastTo: ASTLiteralNode) value equals: #second.
            self assert: associationNode value isNil
        }.
    }.

    public method testMakeDictionary3 => Void := {
        let ast := self parseString: "#{first: 1 . second:. third : 3}".
        self assert: ast isNotNil.
        self assert: ast isSequenceNode.

        let sequenceNode := ast downCastTo: ASTSequenceNode.
        self assert: sequenceNode pragmas size equals: 0sz.
        self assert: sequenceNode expressions size equals: 1sz.

        self assert: sequenceNode expressions first isMakeDictionaryNode.
        let makeDictionaryNode => ASTMakeDictionaryNode := sequenceNode expressions first.
        self assert: makeDictionaryNode elements size equals: 3sz.

        {
            self assert: makeDictionaryNode elements first isMakeAssociationNode.
            let associationNode => ASTMakeAssociationNode := makeDictionaryNode elements first.
            self assert: associationNode key isLiteralNode.
            self assert: (associationNode key downCastTo: ASTLiteralNode) value equals: #first.
            self assert: associationNode value isLiteralNode.
            self assert: (associationNode value downCastTo: ASTLiteralNode) value equals: 1.
        }.

        {
            self assert: makeDictionaryNode elements second isMakeAssociationNode.
            let associationNode => ASTMakeAssociationNode := makeDictionaryNode elements second.
            self assert: associationNode key isLiteralNode.
            self assert: (associationNode key downCastTo: ASTLiteralNode) value equals: #second.
            self assert: associationNode value isNil
        }.

        {
            self assert: makeDictionaryNode elements third isMakeAssociationNode.
            let associationNode => ASTMakeAssociationNode := makeDictionaryNode elements third.
            self assert: associationNode key isIdentifierReferenceNode.
            self assert: (associationNode key downCastTo: ASTIdentifierReferenceNode) value equals: #third.

            self assert: associationNode value isLiteralNode.
            self assert: (associationNode value downCastTo: ASTLiteralNode) value equals: 3.
        }.
    }.

    public method testEmptyBlock => Void := {
        let ast := self parseString: "{}".
        self assert: ast isNotNil.
        self assert: ast isSequenceNode.

        let sequenceNode := ast downCastTo: ASTSequenceNode.
        self assert: sequenceNode pragmas size equals: 0sz.
        self assert: sequenceNode expressions size equals: 1sz.

        self assert: sequenceNode expressions first isLexicalBlockNode.
        let lexicalBlockNode => ASTLexicalBlockNode := sequenceNode expressions first.
        
        self assert: lexicalBlockNode body isSequenceNode.
        let blockSequenceNode => ASTSequenceNode := lexicalBlockNode body downCastTo: ASTSequenceNode.
        self assert: blockSequenceNode pragmas isEmpty.
        self assert: blockSequenceNode expressions isEmpty.
    }.

    public method testLambda => Void := {
        let ast := self parseString: "{|}".
        self assert: ast isNotNil.
        self assert: ast isSequenceNode.

        let sequenceNode := ast downCastTo: ASTSequenceNode.
        self assert: sequenceNode pragmas size equals: 0sz.
        self assert: sequenceNode expressions size equals: 1sz.

        self assert: sequenceNode expressions first isLambdaNode.
        let lambdaNode => ASTLambdaNode := sequenceNode expressions first.
        self assert: lambdaNode arguments isEmpty.
        self assert: lambdaNode resultType isNil.
        
        self assert: lambdaNode body isSequenceNode.
        let blockSequenceNode => ASTSequenceNode := lambdaNode body downCastTo: ASTSequenceNode.
        self assert: blockSequenceNode pragmas isEmpty.
        self assert: blockSequenceNode expressions isEmpty.
    }.

    public method testLambda2 => Void := {
        let ast := self parseString: "{:arg |}".
        self assert: ast isNotNil.
        self assert: ast isSequenceNode.

        let sequenceNode := ast downCastTo: ASTSequenceNode.
        self assert: sequenceNode pragmas size equals: 0sz.
        self assert: sequenceNode expressions size equals: 1sz.

        self assert: sequenceNode expressions first isLambdaNode.
        let lambdaNode => ASTLambdaNode := sequenceNode expressions first.
        self assert: lambdaNode arguments size equals: 1sz.
        self assert: lambdaNode resultType isNil.

        {
            self assert: lambdaNode arguments first isArgumentNode.
            let argumentNode => ASTArgumentNode := lambdaNode arguments first.
            self deny: argumentNode isForAll.
            self assert: argumentNode name isLiteralNode.
            self assert: (argumentNode name downCastTo: ASTLiteralNode) value equals: #arg.
            self assert: argumentNode type isNil.
        }.
        
        self assert: lambdaNode body isSequenceNode.
        let blockSequenceNode => ASTSequenceNode := lambdaNode body downCastTo: ASTSequenceNode.
        self assert: blockSequenceNode pragmas isEmpty.
        self assert: blockSequenceNode expressions isEmpty.
    }.
    
    public method testLambda3 => Void := {
        let ast := self parseString: "{:(Int32)arg :secondArg |}".
        self assert: ast isNotNil.
        self assert: ast isSequenceNode.

        let sequenceNode := ast downCastTo: ASTSequenceNode.
        self assert: sequenceNode pragmas size equals: 0sz.
        self assert: sequenceNode expressions size equals: 1sz.

        self assert: sequenceNode expressions first isLambdaNode.
        let lambdaNode => ASTLambdaNode := sequenceNode expressions first.
        self assert: lambdaNode arguments size equals: 2sz.
        self assert: lambdaNode resultType isNil.

        {
            self assert: lambdaNode arguments first isArgumentNode.
            let argumentNode => ASTArgumentNode := lambdaNode arguments first.
            self deny: argumentNode isForAll.
            self assert: argumentNode name isLiteralNode.
            self assert: (argumentNode name downCastTo: ASTLiteralNode) value equals: #arg.
            self assert: argumentNode type isIdentifierReferenceNode.
            self assert: (argumentNode type downCastTo: ASTIdentifierReferenceNode) value equals: #Int32.
        }.
        
        {
            self assert: lambdaNode arguments second isArgumentNode.
            let argumentNode => ASTArgumentNode := lambdaNode arguments second.
            self deny: argumentNode isForAll.
            self assert: argumentNode name isLiteralNode.
            self assert: (argumentNode name downCastTo: ASTLiteralNode) value equals: #secondArg.
            self assert: argumentNode type isNil.
        }.

        self assert: lambdaNode body isSequenceNode.
        let blockSequenceNode => ASTSequenceNode := lambdaNode body downCastTo: ASTSequenceNode.
        self assert: blockSequenceNode pragmas isEmpty.
        self assert: blockSequenceNode expressions isEmpty.
    }.

    public method testLambda4 => Void := {
        let ast := self parseString: "{:(Int32)arg :secondArg :: Void |}".
        self assert: ast isNotNil.
        self assert: ast isSequenceNode.

        let sequenceNode := ast downCastTo: ASTSequenceNode.
        self assert: sequenceNode pragmas size equals: 0sz.
        self assert: sequenceNode expressions size equals: 1sz.

        self assert: sequenceNode expressions first isLambdaNode.
        let lambdaNode => ASTLambdaNode := sequenceNode expressions first.
        self assert: lambdaNode arguments size equals: 2sz.
        self assert: lambdaNode resultType isIdentifierReferenceNode.
        self assert: (lambdaNode resultType downCastTo: ASTIdentifierReferenceNode) value equals: #Void.

        {
            self assert: lambdaNode arguments first isArgumentNode.
            let argumentNode => ASTArgumentNode := lambdaNode arguments first.
            self deny: argumentNode isForAll.
            self assert: argumentNode name isLiteralNode.
            self assert: (argumentNode name downCastTo: ASTLiteralNode) value equals: #arg.
            self assert: argumentNode type isIdentifierReferenceNode.
            self assert: (argumentNode type downCastTo: ASTIdentifierReferenceNode) value equals: #Int32.
        }.
        
        {
            self assert: lambdaNode arguments second isArgumentNode.
            let argumentNode => ASTArgumentNode := lambdaNode arguments second.
            self deny: argumentNode isForAll.
            self assert: argumentNode name isLiteralNode.
            self assert: (argumentNode name downCastTo: ASTLiteralNode) value equals: #secondArg.
            self assert: argumentNode type isNil.
        }.

        self assert: lambdaNode body isSequenceNode.
        let blockSequenceNode => ASTSequenceNode := lambdaNode body downCastTo: ASTSequenceNode.
        self assert: blockSequenceNode pragmas isEmpty.
        self assert: blockSequenceNode expressions isEmpty.
    }.


    public method testLambda5 => Void := {
        let ast := self parseString: "{ :: Void |}".
        self assert: ast isNotNil.
        self assert: ast isSequenceNode.

        let sequenceNode := ast downCastTo: ASTSequenceNode.
        self assert: sequenceNode pragmas size equals: 0sz.
        self assert: sequenceNode expressions size equals: 1sz.

        self assert: sequenceNode expressions first isLambdaNode.
        let lambdaNode => ASTLambdaNode := sequenceNode expressions first.
        self assert: lambdaNode arguments isEmpty.
        self assert: lambdaNode resultType isIdentifierReferenceNode.
        self assert: (lambdaNode resultType downCastTo: ASTIdentifierReferenceNode) value equals: #Void.

        self assert: lambdaNode body isSequenceNode.
        let blockSequenceNode => ASTSequenceNode := lambdaNode body downCastTo: ASTSequenceNode.
        self assert: blockSequenceNode pragmas isEmpty.
        self assert: blockSequenceNode expressions isEmpty.
    }.

    public method testBlockSingleExpression => Void := {
        let ast := self parseString: "{1234}".
        self assert: ast isNotNil.
        self assert: ast isSequenceNode.

        let sequenceNode := ast downCastTo: ASTSequenceNode.
        self assert: sequenceNode pragmas size equals: 0sz.
        self assert: sequenceNode expressions size equals: 1sz.

        self assert: sequenceNode expressions first isLexicalBlockNode.
        let lexicalBlockNode => ASTLexicalBlockNode := sequenceNode expressions first.
        
        self assert: lexicalBlockNode body isSequenceNode.
        let blockSequenceNode => ASTSequenceNode := lexicalBlockNode body downCastTo: ASTSequenceNode.
        self assert: blockSequenceNode pragmas isEmpty.
        self assert: blockSequenceNode expressions size equals: 1sz.

        self assert: blockSequenceNode expressions first isLiteralNode.
        let literalNode => ASTLiteralNode := blockSequenceNode expressions first.
        self assert: literalNode value equals: 1234.
    }.

    public method testBlockUnaryPragma => Void := {
        let ast := self parseString: "{<unaryPragma> 1234}".
        self assert: ast isNotNil.
        self assert: ast isSequenceNode.

        let sequenceNode := ast downCastTo: ASTSequenceNode.
        self assert: sequenceNode pragmas size equals: 0sz.
        self assert: sequenceNode expressions size equals: 1sz.

        self assert: sequenceNode expressions first isLexicalBlockNode.
        let lexicalBlockNode => ASTLexicalBlockNode := sequenceNode expressions first.
        
        self assert: lexicalBlockNode body isSequenceNode.
        let blockSequenceNode => ASTSequenceNode := lexicalBlockNode body downCastTo: ASTSequenceNode.
        self assert: blockSequenceNode pragmas size equals: 1sz.
        self assert: blockSequenceNode expressions size equals: 1sz.

        self assert: blockSequenceNode pragmas first isPragmaNode.
        let pragmaNode => ASTPragmaNode := blockSequenceNode pragmas first.
        self assert: pragmaNode selector isLiteralNode.
        self assert: pragmaNode arguments isEmpty.

        let pragmaSelectorNode := pragmaNode selector downCastTo: ASTLiteralNode.
        self assert: pragmaSelectorNode value equals: #unaryPragma.

        self assert: blockSequenceNode expressions first isLiteralNode.
        let literalNode => ASTLiteralNode := blockSequenceNode expressions first.
        self assert: literalNode value equals: 1234.
    }.

    public method testBlockKeywordPragma => Void := {
        let ast := self parseString: "{<testPragma: 1>}".
        self assert: ast isNotNil.
        self assert: ast isSequenceNode.

        let sequenceNode := ast downCastTo: ASTSequenceNode.
        self assert: sequenceNode pragmas size equals: 0sz.
        self assert: sequenceNode expressions size equals: 1sz.

        self assert: sequenceNode expressions first isLexicalBlockNode.
        let lexicalBlockNode => ASTLexicalBlockNode := sequenceNode expressions first.
        
        self assert: lexicalBlockNode body isSequenceNode.
        let blockSequenceNode => ASTSequenceNode := lexicalBlockNode body downCastTo: ASTSequenceNode.
        self assert: blockSequenceNode pragmas size equals: 1sz.
        self assert: blockSequenceNode expressions isEmpty.

        self assert: blockSequenceNode pragmas first isPragmaNode.
        let pragmaNode => ASTPragmaNode := blockSequenceNode pragmas first.
        self assert: pragmaNode selector isLiteralNode.
        self assert: pragmaNode arguments size equals: 1sz.

        let pragmaSelectorNode := pragmaNode selector downCastTo: ASTLiteralNode.
        self assert: pragmaSelectorNode value equals: #testPragma:.

        {
            self assert: pragmaNode arguments first isLiteralNode.
            let argumentNode => ASTLiteralNode :=  pragmaNode arguments first.
            self assert: argumentNode value equals: 1.
        }
    }.

    public method testQuote => Void := {
        let ast := self parseString: "`'test".
        self assert: ast isNotNil.
        self assert: ast isSequenceNode.

        let sequenceNode := ast downCastTo: ASTSequenceNode.
        self assert: sequenceNode pragmas size equals: 0sz.
        self assert: sequenceNode expressions size equals: 1sz.

        self assert: sequenceNode expressions first isQuoteNode.
        let quoteNode => ASTQuoteNode := sequenceNode expressions first.
        self assert: quoteNode node isIdentifierReferenceNode.
        self assert: (quoteNode node downCastTo: ASTIdentifierReferenceNode) value equals: #test.
    }.

    public method testQuasiQuote => Void := {
        let ast := self parseString: "``test".
        self assert: ast isNotNil.
        self assert: ast isSequenceNode.

        let sequenceNode := ast downCastTo: ASTSequenceNode.
        self assert: sequenceNode pragmas size equals: 0sz.
        self assert: sequenceNode expressions size equals: 1sz.

        self assert: sequenceNode expressions first isQuasiQuoteNode.
        let quasiQuoteNode => ASTQuasiQuoteNode := sequenceNode expressions first.
        self assert: quasiQuoteNode node isIdentifierReferenceNode.
        self assert: (quasiQuoteNode node downCastTo: ASTIdentifierReferenceNode) value equals: #test.
    }.

    public method testQuasiUnquote => Void := {
        let ast := self parseString: "`,test".
        self assert: ast isNotNil.
        self assert: ast isSequenceNode.

        let sequenceNode := ast downCastTo: ASTSequenceNode.
        self assert: sequenceNode pragmas size equals: 0sz.
        self assert: sequenceNode expressions size equals: 1sz.

        self assert: sequenceNode expressions first isQuasiUnquoteNode.
        let quasiUnquoteNode => ASTQuasiUnquoteNode := sequenceNode expressions first.
        self assert: quasiUnquoteNode expression isIdentifierReferenceNode.
        self assert: (quasiUnquoteNode expression downCastTo: ASTIdentifierReferenceNode) value equals: #test.
    }.

    public method testSpliceNode => Void := {
        let ast := self parseString: "`@test".
        self assert: ast isNotNil.
        self assert: ast isSequenceNode.

        let sequenceNode := ast downCastTo: ASTSequenceNode.
        self assert: sequenceNode pragmas size equals: 0sz.
        self assert: sequenceNode expressions size equals: 1sz.

        self assert: sequenceNode expressions first isSpliceNode.
        let quasiUnquoteNode => ASTSpliceNode := sequenceNode expressions first.
        self assert: quasiUnquoteNode expression isIdentifierReferenceNode.
        self assert: (quasiUnquoteNode expression downCastTo: ASTIdentifierReferenceNode) value equals: #test.
    }.
}.
