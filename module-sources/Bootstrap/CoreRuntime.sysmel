Function
    withSelector: #addFlags: addMethod: {:(Function)self :(Size)flag :: Void |
        self flags: self flags | flag
    };
    withSelector: #makeMacro addMethod: {:(Function)self :: Function |
        self addFlags: (1sz << 0sz).
        self
    };
    withSelector: #makePure addMethod: {:(Function)self :: Function |
        self addFlags: (1sz << 3sz).
        self
    };
    withSelector: #makeFinal addMethod: {:(Function)self :: Function |
        self addFlags: (1sz << 4sz).
        self
    };
    withSelector: #makeVirtual addMethod: {:(Function)self :: Function |
        self addFlags: (1sz << 5sz).
        self
    };
    withSelector: #makeAbstract addMethod: {:(Function)self :: Function |
        self addFlags: (1sz << 6sz).
        self
    };
    withSelector: #makeOverride addMethod: {:(Function)self :: Function |
        self addFlags: (1sz << 7sz).
        self
    };
    withSelector: #makeStatic addMethod: {:(Function)self :: Function |
        self addFlags: (1sz << 8sz).
        self
    }.

AnyValue
    withSelector: #initialize addMethod: {:(AnyValue)self :: Void | };
    withSelector: #yourself addMethod: {:(AnyValue)self :: self __type__ | self } makePure makeFinal;

    withSelector: #postCopy addMethod: {:(AnyValue)self :: Void | };
    withSelector: #shallowCopy addMethod: {:(AnyValue)self :: self __type__ | RawTuple::shallowCopy(self) } makeFinal;
    withSelector: #copy addMethod: {:(AnyValue)self :: self __type__ | self shallowCopy postCopy; yourself };

    withSelector: #doesNotUnderstand: addMethod: {:(AnyValue)self :(Message)message :: Void |
        error("doesNotUnderstand: " -- message selector printString)
    };

    withSelector: #isNil addMethod: {:(AnyValue)self :: Boolean | self == nil } makePure makeFinal;
    withSelector: #isNotNil addMethod: {:(AnyValue)self :: Boolean | self ~~ nil } makePure makeFinal;

    withSelector: #= addMethod: {:(AnyValue)self :other :: Boolean | self == other } makePure;
    withSelector: #~= addMethod: {:(AnyValue)self :other :: Boolean | self ~~ other } makePure;

    withSelector: #&& addMacroMethod: {:(MacroContext)macroContext :(ASTNode)self :(ASTNode)other :: ASTIfNode |
        ASTIfNode new
            sourcePosition: macroContext sourcePosition;
            conditionExpression: self;
            trueExpression: other;
            falseExpression: (ASTLiteralNode new
                sourcePosition: macroContext sourcePosition;
                value: false;
                yourself);
            yourself
    } makeMacro;
    withSelector: #|| addMacroMethod: {:(MacroContext)macroContext :(ASTNode)self :(ASTNode)other :: ASTIfNode |
        ASTIfNode new
            sourcePosition: macroContext sourcePosition;
            conditionExpression: self;
            trueExpression: (ASTLiteralNode new
                sourcePosition: macroContext sourcePosition;
                value: true;
                yourself);
            falseExpression: other;
            yourself
    } makeMacro;

    withSelector: #ifTrue: addMacroMethod: {:(MacroContext)macroContext :(ASTNode)self :(ASTNode)trueExpression :: ASTIfNode |
        ASTIfNode new
            sourcePosition: macroContext sourcePosition;
            conditionExpression: self;
            trueExpression: trueExpression;
            yourself
    } makeMacro;
    withSelector: #ifFalse: addMacroMethod: {:(MacroContext)macroContext :(ASTNode)self :(ASTNode)falseExpression :: ASTIfNode |
        ASTIfNode new
            sourcePosition: macroContext sourcePosition;
            conditionExpression: self;
            falseExpression: falseExpression;
            yourself
    } makeMacro;
    withSelector: #ifTrue:ifFalse: addMacroMethod: {:(MacroContext)macroContext :(ASTNode)self :(ASTNode)trueExpression :(ASTNode)falseExpression :: ASTIfNode |
        ASTIfNode new
            sourcePosition: macroContext sourcePosition;
            conditionExpression: self;
            trueExpression: trueExpression;
            falseExpression: falseExpression;
            yourself
    } makeMacro;
    withSelector: #ifFalse:ifTrue: addMacroMethod: {:(MacroContext)macroContext :(ASTNode)self :(ASTNode)falseExpression :(ASTNode)trueExpression :: ASTIfNode |
        ASTIfNode new
            sourcePosition: macroContext sourcePosition;
            conditionExpression: self;
            trueExpression: trueExpression;
            falseExpression: falseExpression;
            yourself
    } makeMacro.

Object
    withSelector: #class addMethod: {:(Object)self :: self __type__ __type__ | self __type__ } makePure makeFinal;
    withSelector: #species addMethod: {:(Object)self :: Class | self class };

    withSelector: #error: addMethod: {:(Object)self :(String)errorMessage :: Void | error(errorMessage) };
    withSelector: #assert: addMethod: {:(Object)self :(Boolean)condition :: Void |
        if: condition then: void else: error("Assertion failure.")
    };
    withSelector: #subclassResponsibility addMethod: {:(Object)self :: Void | self error: self __type__ printString -- " Subclass responsibility." };
    withSelector: #doesNotUnderstand: addMethod: {:(AnyValue)self :(Message)message :: Void |
        error((self printString -- " doesNotUnderstand: ") -- message selector printString)
    }.

Type
    withSelector: #addFlags: addMethod: {:(Type)self :(Size)flag :: Void |
        self flags: self flags | flag
    };
    withSelector: #makeNullable addMethod: {:(Type)self :: Type |
        self addFlags: (1sz << 0sz).
        self
    };
    withSelector: #makeBytes addMethod: {:(Type)self :: Type |
        self addFlags: (1sz << 1sz).
        self
    };
    withSelector: #makeImmediate addMethod: {:(Type)self :: Type |
        self addFlags: (1sz << 2sz).
        self
    };
    withSelector: #makeFinal addMethod: {:(Type)self :: Type |
        self addFlags: (1sz << 3sz).
        self
    };
    withSelector: #makeAbstract addMethod: {:(Type)self :: Type |
        self addFlags: (1sz << 4sz).
        self
    };
    withSelector: #hasBytesContent addMethod: {:(Type)self :: Boolean |
        (self flags & 2sz) ~= 0sz
    };
    withSelector: #addTypeSlot: addMethod: {:(Type)self :(TypeSlot)extraSlot :: Void |
        if: self totalSlotCount ~~ nil then: (self error: "Cannot add type slot when the total slot count has already been computed").
        if: self pendingSlots == nil then: (self pendingSlots: ArrayList new).
        self pendingSlots add: extraSlot
    };
    withSelector: #validSlots addMethod: {:(Type)self |
        let: #pendingSlots with: self pendingSlots.
        if: pendingSlots ~~ nil then: {

            let: #pendingSlotsArray with: pendingSlots asArray.
            let: #baseIndex with: self validSupertypeTotalSlotCount + self slots size.

            pendingSlotsArray doWithIndex: {:pendingSlot :pendingSlotIndex :: Void |
                let: #slotIndex with: baseIndex + pendingSlotIndex.
                pendingSlot generateAccessorsOn: self withIndex: slotIndex
            }.

            self slots: self slots -- pendingSlotsArray.
            self pendingSlots: nil
        }.
        
        self slots
    };
    withSelector: #validSupertypeTotalSlotCount addMethod: {:(Type)self :: Size |
        let: #supertype with: self supertype.
        if: supertype == nil then: 0sz else: supertype validTotalSlotCount.
    };
    withSelector: #validTotalSlotCount addMethod: {:(Type)self :: Size |
        let: #totalSlotCount with: self totalSlotCount.
        if: totalSlotCount == nil then: {
            self totalSlotCount: self validSupertypeTotalSlotCount + self validSlots size.
            self totalSlotCount
        } else: totalSlotCount
    };
    withSelector: #basicAllocate addMethod: {:(Type)self :: self |
        let: #result with: (if: self hasBytesContent
            then: RawTuple::byteNew(0sz)
            else: RawTuple::new(self validTotalSlotCount)).
        (RawTuple::type:)(result, self).
        result
    };
    withSelector: #basicAllocate: addMethod: {:(Type)self :(Size)variableSize :: self |
        let: #result with: (if: self hasBytesContent
            then: RawTuple::byteNew(variableSize)
            else: RawTuple::new(self validTotalSlotCount + variableSize)).
        (RawTuple::type:)(result, self).
        result
    };
    withSelector: #basicNew addMethod: {:(Type)self :: self |
        self basicAllocate
    };
    withSelector: #basicNew: addMethod: {:(Type)self :(Size)variableSlotCount :: self |
        self basicAllocate: variableSlotCount
    };
    withSelector: #new addMethod: {:(Type)self :: self |
        self basicNew initialize; yourself
    };
    withSelector: #>> addMethod: {:(Type)self :selector |
        let: #methodDictionary with: self methodDictionary.
        if: methodDictionary ~~ nil
            then: (methodDictionary atOrNil: selector)
            else: nil
    };
    withSelector: #lookupSelector: addMethod: {:(Type)self :selector |
        let: #method with: self >> selector.
        if: method ~~ nil
        then: method
        else: {
            let: #supertype with: self supertype.
            if: supertype ~~ nil
                then: (supertype lookupSelector: selector)
                else: (nil)
        }
    }.

Stream
    withSelector: #print: addMethod: {:(Stream)self :value :: Void | 
        value printOn: self
    };
    withSelector: #fullPrint: addMethod: {:(Stream)self :value :: Void | 
        value fullPrintOn: self
    };
    withSelector: #cr addMethod: {:(Stream)self :: Void | 
        self nextPut: '\r'
    };
    withSelector: #lf addMethod: {:(Stream)self :: Void | 
        self nextPut: '\n'
    };
    withSelector: #nl addMethod: {:(Stream)self :: Void | 
        self nextPut: '\n'
    };
    withSelector: #tab addMethod: {:(Stream)self :: Void | 
        self nextPut: '\t'
    };
    withSelector: #space addMethod: {:(Stream)self :: Void | 
        self nextPut: ' '
    }.

AnyValue
    withSelector: #printString addMethod: {:(AnyValue)self :: String | 
        let: #stream with: StringStream new.
        self printOn: stream.
        stream asString.
    };
    withSelector: #printOn: addMethod: {:(AnyValue)self :(Stream)stream :: Void |
        stream nextPutAll: "a " ; print: self __type__
    };
    withSelector: #fullPrintString addMethod: {:(AnyValue)self :: String | 
        let: #stream with: StringStream new.
        self fullPrintOn: stream.
        stream asString.
    };
    withSelector: #fullPrintOn: addMethod: {:(AnyValue)self :(Stream)stream :: Void |
        self printOn: stream
    }.

Type
    withSelector: #printOn: addMethod: {:(Type)self :(Stream)stream :: Void |
        let: #name with: self name.
        if: name ~~ nil
            then: (stream nextPutAll: name)
            else: (stream nextPutAll: "a Type")
    }.

Void class
    withSelector: #coerceValue: addMethod: {:(Void class)self :value :: Void | void }.
Void
    withSelector: #printString addMethod: {:(Void)self :: String | "void" };
    withSelector: #printOn: addMethod: {:(Void)self :(Stream)stream :: Void | stream nextPutAll: "void" }.

UndefinedObject
    withSelector: #printString addMethod: {:(UndefinedObject)self :: String | "nil" };
    withSelector: #printOn: addMethod: {:(UndefinedObject)self :(Stream)stream :: Void | stream nextPutAll: "nil" }.

False
    withSelector: #printString addMethod: {:(False)self :: String | "false" };
    withSelector: #printOn: addMethod: {:(False)self :(Stream)stream :: Void | stream nextPutAll: "false" }.

True
    withSelector: #printString addMethod: {:(True)self :: String | "true" };
    withSelector: #printOn: addMethod: {:(True)self :(Stream)stream :: Void | stream nextPutAll: "true" }.

String
    withSelector: #printOn: addMethod: {:(String)self :(Stream)stream :: Void |
        ## TODO: Implement this part properly.
        stream nextPut: '"'.
        stream nextPutAll: self.
        stream nextPut: '"'.
    }.

StringSymbol
    withSelector: #printOn: addMethod: {:(StringSymbol)self :(Stream)stream :: Void |
        ## TODO: Implement this part properly.
        stream nextPut: '#'; nextPutAll: self
    }.

Class
    withSelector: #withSelector:addClassMethod: addMethod: {:(Class)self :selector :method :: Void |
        self class withSelector: selector addMethod: method
    }.

FunctionDefinition
    withSelector: #hasPragmaNamed: addMethod: {:(FunctionDefinition)self :selector :: Boolean |
        let: #definitionBodyNode with: self definitionBodyNode.
        (definitionBodyNode ~~ nil) && (definitionBodyNode hasPragmaNamed: selector)
    }.

Function
    withSelector: #hasFlag: addMethod: {:(Function)self :(Size)flag :: Boolean |
        (self flags & flag) ~= 0sz
    };

    withSelector: #isMacro addMethod: {:(Function)self :: Boolean |
        self hasFlag: (1sz << 0sz)
    };
    
    withSelector: #isVariadic addMethod: {:(Function)self :: Boolean |
        self hasFlag: (1sz << 1sz)
    };
    withSelector: #isCorePrimitive addMethod: {:(Function)self :: Boolean |
        self hasFlag: (1sz << 2sz)
    };

    withSelector: #isPure addMethod: {:(Function)self :: Boolean |
        self hasFlag: (1sz << 3sz)
    };
    withSelector: #isFinal addMethod: {:(Function)self :: Boolean |
        self hasFlag: (1sz << 4sz)
    };
    withSelector: #isVirtual addMethod: {:(Function)self :: Boolean |
        self hasFlag: (1sz << 5sz)
    };
    withSelector: #isAbstract addMethod: {:(Function)self :: Boolean |
        self hasFlag: (1sz << 6sz)
    };
    withSelector: #isOverride addMethod: {:(Function)self :: Boolean |
        self hasFlag: (1sz << 7sz)
    };
    withSelector: #isStatic addMethod: {:(Function)self :: Boolean |
        self hasFlag: (1sz << 8sz)
    };

    withSelector: #hasPragmaNamed: addMethod: {:(Function)self :selector :: Boolean |
        let: #definition with: self definition.
        if: definition == nil then: false else: (definition hasPragmaNamed: selector)
    };
    
    withSelector: #printOn: addMethod: {:(Function)self :(Stream)stream :: Void |
        let: #name with: self name.
        let: #definition with: self definition.
        let: #sourcePosition with: (if: definition ~~ nil then: definition sourcePosition else: nil).

        stream nextPutAll: "Function(".

        if: name ~~ nil then: {
            let: #owner with: self owner.
            if: owner ~~ nil then: (stream print: owner; nextPutAll: " >> ").
            
            stream print: name.
            if: sourcePosition ~~ nil then: (stream space).

        }.
        if: sourcePosition ~~ nil then: {
            stream nextPutAll: "at "; print: sourcePosition
        }.

        stream nextPut: ')'
    }.

ValueBox
    withSelector: #with: addClassMethod: {:(ValueBox class)self :value :: self |
        self basicNew
            value: value;
            yourself
    };
    withSelector: #_ addMethod: {:(ValueBox)self | self value };
    withSelector: #_: addMethod: {:(ValueBox)self :newValue | self value: newValue. newValue };
    withSelector: #":=" addMethod: {:(ValueBox)self :newValue | self value: newValue. newValue }.

Collection
    withSelector: #isEmpty addMethod: {:(Collection)self :: Boolean |
        self size = 0sz
    };
    withSelector: #isNotEmpty addMethod: {:(Collection)self :: Boolean |
        self size ~= 0sz
    };
    withSelector: #size addMethod: {:(Collection)self :: Size |
        self subclassResponsibility
    } makeAbstract.

SequenceableCollection
    withSelector: #with: addClassMethod: {:(SequenceableCollection class)self :value :: self |
        (self new: 1sz)
            at: 0sz put: value;
            yourself
    };
    withSelector: #anySatisfy: addMethod: {:(SequenceableCollection)self :aBlock :: Boolean |
        let: #index with: (ValueBox with: 0sz).
        let: #size with: self size.
        let: #hasFoundIt with: (ValueBox with: false).

        while: (if: hasFoundIt _ then: false else: index _ < self size) do: (
            hasFoundIt := aBlock(self at: index _)
        ) continueWith: (index := index _ + 1sz).
        hasFoundIt _
    } makeFinal;
    withSelector: #allSatisfy: addMethod: {:(SequenceableCollection)self :aBlock :: Boolean |
        let: #index with: (ValueBox with: 0sz).
        let: #size with: self size.
        let: #everythingIsFine with: (ValueBox with: true).

        while: (if: everythingIsFine _ then: index _ < self size else: false) do: (
            everythingIsFine := aBlock(self at: index _)
        ) continueWith: (index := index _ + 1sz).
        everythingIsFine _
    } makeFinal;
    withSelector: #collect: addMethod: {:(SequenceableCollection)self :aBlock :: self species |
        let: #index with: (ValueBox with: 0sz).
        let: #size with: self size.
        let: #result with: (self species new: size).

        while: index _ < self size do: {
            let: #i with: index _.
            result at: i put: aBlock(self at: i)
        } continueWith: (index := index _ + 1sz).

        result
    } makeFinal;
    withSelector: #do: addMethod: {:(SequenceableCollection)self :aBlock :: Void |
        let: #index with: (ValueBox with: 0sz).
        let: #size with: self size.

        while: index _ < self size do: (
            aBlock(self at: index _)
        ) continueWith: (index := index _ + 1sz)
    };
    withSelector: #doWithIndex: addMethod: {:(SequenceableCollection)self :aBlock :: Void |
        let: #index with: (ValueBox with: 0sz).
        let: #size with: self size.

        while: index _ < self size do: {
            let: #i with: index _.
            aBlock(self at: i, i)
        } continueWith: (index := index _ + 1sz)
    };
    withSelector: #-- addMethod: {:(SequenceableCollection)self :(SequenceableCollection)other :: self species |
        let: #size with: self size.
        let: #otherSize with: other size.
        let: #result with: (self species new: size + otherSize ).
        
        self doWithIndex: {:element :(Size)index :: Void |
            result at: index put: element
        }.

        other doWithIndex: {:element :(Size)index :: Void |
            result at: size + index put: element
        }.

        result
    };
    withSelector: #first addMethod: {:(SequenceableCollection)self | self at: 0sz } makeFinal;
    withSelector: #second addMethod: {:(SequenceableCollection)self | self at: 1sz } makeFinal;
    withSelector: #third addMethod: {:(SequenceableCollection)self | self at: 2sz } makeFinal;
    withSelector: #fourth addMethod: {:(SequenceableCollection)self | self at: 3sz } makeFinal;

    withSelector: #printOn: addMethod: {:(SequenceableCollection)self :(Stream)stream :: Void |
        stream print: self class; nextPutAll: "(".
        self doWithIndex: {:element :index :: Void |
            if: index > 0 then: (stream nextPutAll: ", ").
            stream print: element.
            void
        }.

        stream nextPutAll: ")"
    };
    withSelector: #asArray addMethod: {:(SequenceableCollection)self :: Array |
        let: #array with: (Array new: self size).
        self doWithIndex: {:element :(Size)index :: Void |
            array at: index put: element
        }.

        array
    }.

ArrayList
    withSelector: #new: addClassMethod: {:(ArrayList class)self :(Size)initialSize :: self |
        self basicNew initializeWithSize: initialSize; yourself
    } makeFinal;
    withSelector: #initialize addMethod: {:(ArrayList)self :: Void |
        self size: 0sz
    };
    withSelector: #initializeWithSize: addMethod: {:(ArrayList)self :(Size)initialSize :: Void |
        self size: initialSize sz.
        self storage: (Array new: initialSize).
    };
    withSelector: #at: addMethod: {:(ArrayList)self :(Size)index |
        if: index < self size then: {
            self storage at: index
        } else: {
            error("Index out of bounds.")
        }
    };
    withSelector: #at:put: addMethod: {:(ArrayList)self :(Size)index :value :: Void |
        if: index < self size then: {
            self storage at: index + self offset put: value
        } else: {
            error("Index out of bounds.")
        }
    }.

StringStream
    withSelector: #initialize addMethod: {:(StringStream)self :: Void |
        self size: 0
    }.

Array
    withSelector: #new: addClassMethod: {:(Array class)self :(Size)initialSize :: self |
        self basicNew: initialSize
    } makeFinal;
    withSelector: #at: addMethod: {:(Array)self :(Size)index |
        self __slotAt__: index
    };
    withSelector: #at:put: addMethod: {:(Array)self :(Size)index :value :: Void |
        self __slotAt__: index put: value
    };
    withSelector: #size addMethod: {:(Array)self :: Size |
        self __size__
    };
    withSelector: #asArray addMethod: {:(Array)self :: Array | self };
    withSelector: #asArraySlice addMethod: {:(Array)self :: ArraySlice |
        ArraySlice basicNew
            elements: self;
            offset: 0sz;
            size: self size;
            yourself
    }.

ByteArray
    withSelector: #at: addMethod: {:(ByteArray)self :(Size)index |
        self __slotAt__: index
    };
    withSelector: #at:put: addMethod: {:(ByteArray)self :(Size)index :value :: Void |
        self __slotAt__: index put: value
    };
    withSelector: #size addMethod: {:(ByteArray)self :: Size |
        self __byteSize__
    };
    withSelector: #printOn: addMethod: {:(ByteArray)self :(Stream)stream :: Void |
        stream nextPutAll: "#[".
        self doWithIndex: {:element :index :: Void |
            if: index > 0sz then: (stream nextPutAll: ". ").
            stream print: element.
            void
        }.

        stream nextPutAll: "]"
    }.

ArraySlice
    withSelector: #new: addClassMethod: {:(ArraySlice class)self :(Size)size :: self |
        self basicNew
            elements: (Array basicNew: size);
            offset: 0sz;
            size: size;
            yourself
    };
    withSelector: #at: addMethod: {:(ArraySlice)self :(Size)index |
        if: index < self size then: {
            self elements at: index + self offset
        } else: {
            error("Index out of bounds.")
        }
    };
    withSelector: #at:put: addMethod: {:(ArraySlice)self :(Size)index :value :: Void |
        if: index < self size then: {
            self elements at: index + self offset put: value
        } else: {
            error("Index out of bounds.")
        }
    }.

TypeSlot
    withSelector: #named:type:flags: addClassMethod: {:(TypeSlot class)self :name :(Type)type :(Size)flags :: self |
        self new
            name: name;
            type: type;
            flags: flags;
            yourself
    };
    withSelector: #named:type: addClassMethod: {:(TypeSlot class)self :name :(Type)type :: self |
        self named: name type: type flags: 0sz
    };
    withSelector: #named:flags: addClassMethod: {:(TypeSlot class)self :name :(Size)flags :: self |
        self named: name type: nil flags: flags
    };
    withSelector: #named: addClassMethod: {:(TypeSlot class)self :name :(Type)type :: self |
        self publicNamed: name type: nil
    };
    withSelector: #publicNamed:type: addClassMethod: {:(TypeSlot class)self :name :(Type)type :: self |
        self named: name type: type flags: 1sz
    };
    withSelector: #publicNamed: addClassMethod: {:(TypeSlot class)self :name :(Type)type :: self |
        self publicNamed: name type: nil
    };

    withSelector: #isPublic addMethod: {:(TypeSlot)self :: Boolean |
        (self flags & 1sz) ~= 0sz
    };
    withSelector: #isReadonly addMethod: {:(TypeSlot)self :: Boolean |
        (self flags & 2sz) ~= 0sz
    };
    withSelector: #generateAccessorsOn:withIndex: addMethod: {:(TypeSlot)self :(Type)type :(Size)slotIndex :: Void |
        if: self isPublic then: {
            let: #slotType with: self type.
            let: #getterName with: self name.
            let: #setterName with: (self name asString -- ":") asSymbol.

            ## Getter.
            type withSelector: getterName addMethod: ({:(type)self :: slotType | (RawTuple::slotAt:)(self, slotIndex) }
                makePure;
                makeFinal; 
                recompileAndOptimize).

            ## Setter
            if: self isReadonly not then: {
                type withSelector: setterName addMethod: ({:(type)self :(slotType)value :: Void | RawTuple::slotAt:put:(self, slotIndex, value) }
                    makeFinal; 
                    recompileAndOptimize).
            }
        }
    }.

Type
    withSelector: #generatePublicAccessors addMethod: {:(Type)self :: Void |
        let: #baseSlotIndex with: self validSupertypeTotalSlotCount.
        self slots doWithIndex: {:slot :index :: Void |
            let: #slotIndex with: baseSlotIndex + index.
            slot generateAccessorsOn: self withIndex: slotIndex
        }.
    }.

Metatype
    withSelector: #printOn: addMethod: {:(Metaclass)self :(Stream)stream :: Void |
        let: #thisType with: self thisType.
        if: thisType ~~ nil
        then: (stream print: thisType; nextPutAll: " __type__")
        else: (stream nextPutAll: "a "; print: self __type__)
    }.

Metaclass
    withSelector: #thisClass addMethod: {:(Metaclass)self :: Type | self thisType };
    withSelector: #thisClass: addMethod: {:(Metaclass)self :(Type)thisClass :: Void | self thisType: thisClass };
    withSelector: #printOn: addMethod: {:(Metaclass)self :(Stream)stream :: Void |
        let: #thisClass with: self thisClass.
        if: thisClass ~~ nil
        then: (stream print: thisClass; nextPutAll: " class")
        else: (stream nextPutAll: "a "; print: self __type__)
    }.

DependentFunctionType
    withSelector: #printOn: addMethod: {:(Type)self :(Stream)stream :: Void |
        stream nextPutAll: "DependentFunctionType at "; print: self sourcePosition
    }.

SimpleFunctionType
    withSelector: #printOn: addMethod: {:(Type)self :(Stream)stream :: Void |
        stream nextPut: '('.
        self argumentTypes doWithIndex: {:(Type)argumentType :(Size)index :: Void |
            index > 0 ifTrue: (stream nextPutAll: ", ").
            stream print: argumentType
        }.
        self isVariadic ifTrue: {
            self argumentTypes isNotEmpty
                ifTrue: (stream nextPutAll: ", ...")
                ifFalse: (stream nextPutAll: "...")
        }.
        stream nextPutAll: ") ==> "; print: self resultType.
    }.

## Primitive values print string.
(
    UInt8,Int8,Char8,
    UInt16,Int16,Char16,
    UInt32,Int32,Char32,
    UInt64,Int64,
    Float32,Float64,
    Integer
) do: {:SelfType :: Void |
    SelfType
        withSelector: #printOn: addMethod: {:(SelfType)self :(Stream)stream :: Void |
            stream nextPutAll: self printString
        } recompileAndOptimize;
            makeFinal.
}.

SourcePosition
    withSelector: #printOn: addMethod: {:(SourcePosition)self :(Stream)stream :: Void |
        let: #sourceCode with: self sourceCode.

        stream
            nextPutAll: (sourceCode directory FileSystem::joinPath: sourceCode name);
            nextPut: ':';
            print: self startLine;
            nextPut: '.';
            print: self startColumn;
            nextPut: '-';
            print: self endLine;
            nextPut: '.';
            print: self endColumn
    }.

Class
    withSelector: #subclassWithClassSlots: addMethod: {:(Class)self :(Array)classSlots  :: Class |
        let: #metaclass with: Metaclass basicNew.
        let: #metaclassSuper with: self class.
        metaclass
            flags: 1sz;
            supertype: metaclassSuper;
            slots: classSlots;
            totalSlotCount: metaclassSuper validTotalSlotCount + classSlots size;
            generatePublicAccessors.
        
        let: #class with: metaclass basicNew.
        class
            flags: 1sz;
            supertype: self;
            slots: ();
            totalSlotCount: nil.
        metaclass thisClass: class.
        class
    };
    withSelector: #subclassWithClassSlots:slots: addMethod: {:(Class)self :(Array)classSlots :(Array)instanceSlots :: Class |
        (self subclassWithClassSlots: classSlots)
            slots: instanceSlots;
            totalSlotCount: self validTotalSlotCount + instanceSlots size;
            generatePublicAccessors;
            yourself
    };
    withSelector: #subclass:classSlots:slots: addMethod: {:(Class)self :(StringSymbol)name :(Array)classSlots :(Array)instanceSlots :: Class |
        let: #class with: (self subclassWithClassSlots: classSlots slots: instanceSlots).
        class name: name.
        class
    };
    withSelector: #subclass:slots: addMethod: {:(Class)self :(StringSymbol)name :(Array)instanceSlots :: Class |
        self subclass: name classSlots: () slots: instanceSlots
    }.

Environment
    withSelector: #setSymbol:value: addMethod: {:(Environment)self :(Symbol)selector :value :: value __type__ | self setSymbol: selector bindingWithValue: value. value };
    withSelector: #setPublicSymbol:value: addMethod: {:(Environment)self :(Symbol)selector :value :: value __type__ | self setSymbol: selector bindingWithValue: value. value };
    withSelector: #withSelector:addMethod: addMethod: {:(Environment)self :(Symbol)selector :method :: Void | self setSymbol: selector bindingWithValue: method }.
