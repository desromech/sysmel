## We use these for the different implementations of Size
error __type__: (SimpleFunctionTypeTemplate((String,), false, Unwinds)).
    
{
    let: #binaryFunctionType with: SimpleFunctionTypeTemplate((UInt32, UInt32), false, UInt32).
    let: #equalityComparisonFunctionType with: SimpleFunctionTypeTemplate((UInt32, nil), false, Boolean).
    let: #comparisonFunctionType with: SimpleFunctionTypeTemplate((UInt32, UInt32), false, Boolean).

    UInt32::+ __type__: binaryFunctionType.
    UInt32::- __type__: binaryFunctionType.
    UInt32::* __type__: binaryFunctionType.
    UInt32::/ __type__: binaryFunctionType.
    UInt32::% __type__: binaryFunctionType.

    UInt32::& __type__: binaryFunctionType.
    UInt32::| __type__: binaryFunctionType.
    UInt32::<< __type__: binaryFunctionType.
    UInt32::>> __type__: binaryFunctionType.

    UInt32::= __type__: equalityComparisonFunctionType.
    UInt32::~= __type__: equalityComparisonFunctionType.
    UInt32::< __type__: comparisonFunctionType.
    UInt32::<= __type__: comparisonFunctionType.
    UInt32::>= __type__: comparisonFunctionType.
    UInt32::> __type__: comparisonFunctionType.
}.

{
    let: #binaryFunctionType with: SimpleFunctionTypeTemplate((UInt64, UInt64), false, UInt64).
    let: #equalityComparisonFunctionType with: SimpleFunctionTypeTemplate((UInt64, nil), false, Boolean).
    let: #comparisonFunctionType with: SimpleFunctionTypeTemplate((UInt64, UInt64), false, Boolean).

    UInt64::+ __type__: binaryFunctionType.
    UInt64::- __type__: binaryFunctionType.
    UInt64::* __type__: binaryFunctionType.
    UInt64::/ __type__: binaryFunctionType.
    UInt64::% __type__: binaryFunctionType.

    UInt64::& __type__: binaryFunctionType.
    UInt64::| __type__: binaryFunctionType.
    UInt64::<< __type__: binaryFunctionType.
    UInt64::>> __type__: binaryFunctionType.

    UInt64::= __type__: equalityComparisonFunctionType.
    UInt64::~= __type__: equalityComparisonFunctionType.
    UInt64::< __type__: comparisonFunctionType.
    UInt64::<= __type__: comparisonFunctionType.
    UInt64::>= __type__: comparisonFunctionType.
    UInt64::> __type__: comparisonFunctionType.
}.

Function
    withSelector: #addFlags: addMethod: {:(Function)self :(Bitflags)flag :: Void |
        self flags: self flags | flag
    };
    withSelector: #makeMacro addMethod: {:(Function)self :: Function |
        self addFlags: FunctionFlags::Macro.
        self
    };
    withSelector: #makePure addMethod: {:(Function)self :: Function |
        self addFlags: FunctionFlags::Pure.
        self
    };
    withSelector: #makeFinal addMethod: {:(Function)self :: Function |
        self addFlags: FunctionFlags::Final.
        self
    };
    withSelector: #makeVirtual addMethod: {:(Function)self :: Function |
        self addFlags: FunctionFlags::Virtual.
        self
    };
    withSelector: #makeAbstract addMethod: {:(Function)self :: Function |
        self addFlags: FunctionFlags::Abstract.
        self
    };
    withSelector: #makeOverride addMethod: {:(Function)self :: Function |
        self addFlags: FunctionFlags::Override.
        self
    };
    withSelector: #makeStatic addMethod: {:(Function)self :: Function |
        self addFlags: FunctionFlags::Static.
        self
    };

    withSelector: #makeMemoized addMethod: {:(Function)self :: Function |
        self addFlags: FunctionFlags::Memoized.
        self
    };
    withSelector: #makeTemplate addMethod: {:(Function)self :: Function |
        self addFlags: FunctionFlags::Template.
        self
    }.

ValueBox
    withSelector: #loadAtOffset:withType: addMethod: {:(ValueBox)self :(IntPointer)offset :(Type)valueType :: valueType |
        (RawTuple::slotAt:)(self, 0sz)
    } makeFinal;
    withSelector: #store:atOffset:withType: addMethod: {:(ValueBox)self :value :(IntPointer)offset :(Type)valueType :: Void |
        RawTuple::slotAt:put:(self, 0sz, value).
        void
    } makeFinal.

AnyValue
    withSelector: #initialize addMethod: {:(AnyValue)self :: Void | };
    withSelector: #yourself addMethod: {:(AnyValue)self :: self __type__ |
        <primitive: #yourself>
        self
    } makePure makeFinal;

    withSelector: #postCopy addMethod: {:(AnyValue)self :: Void | };
    withSelector: #shallowCopy addMethod: {:(AnyValue)self :: self __type__ | RawTuple::shallowCopy(self) } makeFinal;
    withSelector: #copy addMethod: {:(AnyValue)self :: self __type__ | self shallowCopy postCopy; yourself };

    withSelector: #doesNotUnderstand: addMethod: {:(AnyValue)self :(Message)message |
        error("doesNotUnderstand: " -- message selector printString)
    };

    withSelector: #isNil addMethod: {:(AnyValue)self :: Boolean | self == nil } makePure makeFinal;
    withSelector: #isNotNil addMethod: {:(AnyValue)self :: Boolean | self ~~ nil } makePure makeFinal;

    withSelector: #= addMethod: {:(AnyValue)self :other :: Boolean | self == other } makePure;
    withSelector: #~= addMethod: {:(AnyValue)self :other :: Boolean | self ~~ other } makePure.

Object
    withSelector: #class addMethod: {:(Object)self :: self __type__ __type__ | self __type__ } makePure makeFinal;
    withSelector: #species addMethod: {:(Object)self :: Class | self class };

    withSelector: #error: addMethod: {:(Object)self :(String)errorMessage :: Unwinds | error(errorMessage) };
    withSelector: #assert: addMethod: {:(Object)self :(Boolean)condition :: Void |
        if: condition then: void else: error("Assertion failure.")
    };
    withSelector: #subclassResponsibility addMethod: {:(Object)self :: Unwinds | self error: self __type__ printString -- " Subclass responsibility." };
    withSelector: #doesNotUnderstand: addMethod: {:(AnyValue)self :(Message)message |
        error((self printString -- " doesNotUnderstand: ") -- message selector printString)
    }.

Type
    withSelector: #isSubtypeOf: addMethod: {:(Type)self :(Type)expectedParent :: Boolean |
        if: self == expectedParent
        then: true
        else: {
            let: #supertype with: self supertype.
            if: supertype ~~ nil
                then: (supertype isSubtypeOf: expectedParent )
                else: false
        }
    } makePure;
    withSelector: #coerceASTNode:into:withEnvironment: addMethod: {:(Type)self :(ASTNode)astNode :(Type)targetType :(AnalysisAndEvaluationEnvironment)environment :: ASTNode |
        if: (self isSubtypeOf: targetType)
        then: astNode
        else: error((("Cannot coerce node from type " -- self printString) -- " into type ") -- targetType printString)
    };
    withSelector: #coerceASTNode:withEnvironment: addMethod: {:(Type)self :(ASTNode)astNode :(AnalysisAndEvaluationEnvironment)environment :: ASTNode |
        let: #sourceType with: astNode analyzedType.
        if: (if: sourceType ~~ nil then: sourceType ~= self else: false)
        then: (sourceType coerceASTNode: astNode into: self withEnvironment: environment)
        else: astNode
    };
    withSelector: #isReferenceType addMethod: {:(Type)self :: Boolean | false } makePure;

    withSelector: #addFlags: addMethod: {:(Type)self :(Bitflags)flag :: Void |
        self flags: self flags | flag
    };
    withSelector: #hasFlag: addMethod: {:(Type)self :(Bitflags)flag :: Boolean |
        (self flags & flag) ~= 0bflgs
    };

    withSelector: #makeNullable addMethod: {:(Type)self :: Type |
        self addFlags: TypeFlags::Nullable.
        self
    };
    withSelector: #isNullable addMethod: {:(Type)self :: Boolean |
        self hasFlag: TypeFlags::Nullable.
    };

    withSelector: #makeBytes addMethod: {:(Type)self :: Type |
        self addFlags: TypeFlags::Bytes.
        self
    };
    withSelector: #isBytes addMethod: {:(Type)self :: Boolean |
        self hasFlag: TypeFlags::Bytes.
    };

    withSelector: #makeWeak addMethod: {:(Type)self :: Type |
        self addFlags: TypeFlags::Weak.
        self
    };
    withSelector: #isWeak addMethod: {:(Type)self :: Boolean |
        self hasFlag: TypeFlags::Weak.
    };

    withSelector: #makeImmediate addMethod: {:(Type)self :: Type |
        self addFlags: TypeFlags::Immediate.
        self
    };
    withSelector: #isImmediate addMethod: {:(Type)self :: Boolean |
        self hasFlag: TypeFlags::Immediate.
    };

    withSelector: #makeFinal addMethod: {:(Type)self :: Type |
        self addFlags: TypeFlags::Final.
        self
    };
    withSelector: #isFinal addMethod: {:(Type)self :: Boolean |
        self hasFlag: TypeFlags::Final.
    };

    withSelector: #makeAbstract addMethod: {:(Type)self :: Type |
        self addFlags: TypeFlags::Abstract.
        self
    };
    withSelector: #isAbstract addMethod: {:(Type)self :: Boolean |
        self hasFlag: TypeFlags::Abstract.
    };

    withSelector: #addTypeSlot: addMethod: {:(Type)self :(TypeSlot)extraSlot :: Void |
        if: self totalSlotCount ~~ nil then: (self error: "Cannot add type slot when the total slot count has already been computed").
        if: self pendingSlots == nil then: (self pendingSlots: ArrayList new).
        self pendingSlots add: extraSlot
    };
    withSelector: #validSlots addMethod: {:(Type)self |
        let: #pendingSlots with: self pendingSlots.
        if: pendingSlots ~~ nil then: {

            let: #pendingSlotsArray with: pendingSlots asArray.
            let: #baseIndex with: self validSupertypeTotalSlotCount + self slots size.

            pendingSlotsArray doWithIndex: {:pendingSlot :pendingSlotIndex :: Void |
                let: #slotIndex with: baseIndex + pendingSlotIndex.
                pendingSlot generateAccessorsOn: self withIndex: slotIndex
            }.

            self slots: self slots -- pendingSlotsArray.
            self pendingSlots: nil
        }.
        
        self slots
    };
    withSelector: #validSupertypeTotalSlotCount addMethod: {:(Type)self :: Size |
        let: #supertype with: self supertype.
        if: supertype == nil then: 0sz else: supertype validTotalSlotCount.
    };
    withSelector: #validTotalSlotCount addMethod: {:(Type)self :: Size |
        let: #totalSlotCount with: self totalSlotCount.
        if: totalSlotCount == nil then: {
            self totalSlotCount: self validSupertypeTotalSlotCount + self validSlots size.
            self totalSlotCount
        } else: totalSlotCount
    };
    withSelector: #basicAllocate addMethod: {:(Type)self :: self |
        let: #result with: (if: self isBytes
            then: RawTuple::byteNew(0sz)
            else: RawTuple::new(self validTotalSlotCount)).
        (RawTuple::type:)(result, self).
        if: self isWeak then: RawTuple::markWeak(result).
        result
    };
    withSelector: #basicAllocate: addMethod: {:(Type)self :(Size)variableSize :: self |
        let: #result with: (if: self isBytes
            then: RawTuple::byteNew(variableSize)
            else: RawTuple::new(self validTotalSlotCount + variableSize)).
        (RawTuple::type:)(result, self).
        result
    };
    withSelector: #basicNew addMethod: {:(Type)self :: self |
        self basicAllocate
    };
    withSelector: #basicNew: addMethod: {:(Type)self :(Size)variableSlotCount :: self |
        self basicAllocate: variableSlotCount
    };
    withSelector: #new addMethod: {:(Type)self :: self |
        self basicNew initialize; yourself
    };
    withSelector: #>> addMethod: {:(Type)self :selector |
        let: #methodDictionary with: self methodDictionary.
        if: methodDictionary ~~ nil
            then: (methodDictionary atOrNil: selector)
            else: nil
    };
    withSelector: #lookupSelector: addMethod: {:(Type)self :selector |
        let: #method with: self >> selector.
        if: method ~~ nil
        then: method
        else: {
            let: #supertype with: self supertype.
            if: supertype ~~ nil
                then: (supertype lookupSelector: selector)
                else: (nil)
        }
    }.

ControlFlowEscapeType class
    withSelector: #coerceASTNode:into:withEnvironment: addMethod: {:(Type)self :(ASTNode)astNode :(Type)targetType :(AnalysisAndEvaluationEnvironment)environment :: ASTNode |
        astNode
    }.

UndefinedObject class
    withSelector: #coerceASTNode:into:withEnvironment: addMethod: {:(Type)self :(ASTNode)astNode :(Type)targetType :(AnalysisAndEvaluationEnvironment)environment :: ASTNode |
        if: targetType isNullable
        then: astNode
        else: error("Cannot coerce nil into non-nullable type " -- targetType printString)
    }.

ReferenceType
    withSelector: #isReferenceType addMethod: {:(Type)self :: Boolean | true } makePure;
    withSelector: #coerceASTNode:into:withEnvironment: addMethod: {:(Type)self :(ASTNode)astNode :(Type)targetType :(AnalysisAndEvaluationEnvironment)environment :: ASTNode |

        if: targetType isReferenceType then: {
            error("TODO: Implement coercion between two reference types.")
        } else: {
            let: #sourcePosition with: astNode sourcePosition.
            let: #analyzerToken with: environment analyzerToken.
            let: #loadValueFunction with: self loadValueFunction.
            let: #baseType with: self baseType.

            targetType
                coerceASTNode: (ASTFunctionApplicationNode new
                    sourcePosition: astNode sourcePosition;
                    functionExpression: (ASTLiteralNode new
                        value: loadValueFunction;
                        analyzedType: loadValueFunction __type__;
                        analyzerToken: analyzerToken;
                        yourself);
                    arguments: (astNode,);
                    analyzedType: self baseType;
                    analyzerToken: analyzerToken;
                    yourself)
                withEnvironment: environment
        }.
    }.

AnyValue
    withSelector: #&& addMacroMethod: {:(MacroContext)macroContext :(ASTNode)self :(ASTNode)other :: ASTIfNode |
        ASTIfNode new
            sourcePosition: macroContext sourcePosition;
            conditionExpression: self;
            trueExpression: other;
            falseExpression: (ASTLiteralNode new
                sourcePosition: macroContext sourcePosition;
                value: false;
                yourself);
            yourself
    } makeMacro;
    withSelector: #|| addMacroMethod: {:(MacroContext)macroContext :(ASTNode)self :(ASTNode)other :: ASTIfNode |
        ASTIfNode new
            sourcePosition: macroContext sourcePosition;
            conditionExpression: self;
            trueExpression: (ASTLiteralNode new
                sourcePosition: macroContext sourcePosition;
                value: true;
                yourself);
            falseExpression: other;
            yourself
    } makeMacro;

    withSelector: #ifTrue: addMacroMethod: {:(MacroContext)macroContext :(ASTNode)self :(ASTNode)trueExpression :: ASTIfNode |
        ASTIfNode new
            sourcePosition: macroContext sourcePosition;
            conditionExpression: self;
            trueExpression: trueExpression;
            yourself
    } makeMacro;
    withSelector: #ifFalse: addMacroMethod: {:(MacroContext)macroContext :(ASTNode)self :(ASTNode)falseExpression :: ASTIfNode |
        ASTIfNode new
            sourcePosition: macroContext sourcePosition;
            conditionExpression: self;
            falseExpression: falseExpression;
            yourself
    } makeMacro;
    withSelector: #ifTrue:ifFalse: addMacroMethod: {:(MacroContext)macroContext :(ASTNode)self :(ASTNode)trueExpression :(ASTNode)falseExpression :: ASTIfNode |
        ASTIfNode new
            sourcePosition: macroContext sourcePosition;
            conditionExpression: self;
            trueExpression: trueExpression;
            falseExpression: falseExpression;
            yourself
    } makeMacro;
    withSelector: #ifFalse:ifTrue: addMacroMethod: {:(MacroContext)macroContext :(ASTNode)self :(ASTNode)falseExpression :(ASTNode)trueExpression :: ASTIfNode |
        ASTIfNode new
            sourcePosition: macroContext sourcePosition;
            conditionExpression: self;
            trueExpression: trueExpression;
            falseExpression: falseExpression;
            yourself
    } makeMacro.

AnyReference
    withSelector: #doesNotUnderstand: addMacroMethod: {:(MacroContext)macroContext :(ASTNode)self :(ASTMessageSendNode)messageSend :: ASTNode |
        messageSend copy
            receiver: (ASTFunctionApplicationNode new
                sourcePosition: self sourcePosition;
                functionExpression: (ASTLiteralNode new
                    sourcePosition: self sourcePosition;
                    value: self analyzedType loadValueFunction;
                    yourself);
                arguments: (self,);
                yourself);
            yourself
    } makeMacro.

Stream
    withSelector: #print: addMethod: {:(Stream)self :value :: Void | 
        value printOn: self
    };
    withSelector: #fullPrint: addMethod: {:(Stream)self :value :: Void | 
        value fullPrintOn: self
    };
    withSelector: #cr addMethod: {:(Stream)self :: Void | 
        self nextPut: '\r'
    };
    withSelector: #lf addMethod: {:(Stream)self :: Void | 
        self nextPut: '\n'
    };
    withSelector: #nl addMethod: {:(Stream)self :: Void | 
        self nextPut: '\n'
    };
    withSelector: #tab addMethod: {:(Stream)self :: Void | 
        self nextPut: '\t'
    };
    withSelector: #space addMethod: {:(Stream)self :: Void | 
        self nextPut: ' '
    }.

AnyValue
    withSelector: #printString addMethod: {:(AnyValue)self :: String | 
        let: #stream with: StringStream new.
        self printOn: stream.
        stream asString.
    };
    withSelector: #printOn: addMethod: {:(AnyValue)self :(Stream)stream :: Void |
        stream nextPutAll: "a " ; print: self __type__
    };
    withSelector: #fullPrintString addMethod: {:(AnyValue)self :: String | 
        let: #stream with: StringStream new.
        self fullPrintOn: stream.
        stream asString.
    };
    withSelector: #fullPrintOn: addMethod: {:(AnyValue)self :(Stream)stream :: Void |
        self printOn: stream
    }.

Type
    withSelector: #printOn: addMethod: {:(Type)self :(Stream)stream :: Void |
        let: #name with: self name.
        if: name ~~ nil
            then: (stream nextPutAll: name)
            else: (stream nextPutAll: "a Type")
    }.

Void class
    withSelector: #coerceValue: addMethod: {:(Void class)self :value :: Void | void }.
Void
    withSelector: #printString addMethod: {:(Void)self :: String | "void" };
    withSelector: #printOn: addMethod: {:(Void)self :(Stream)stream :: Void | stream nextPutAll: "void" }.

UndefinedObject
    withSelector: #printString addMethod: {:(UndefinedObject)self :: String | "nil" };
    withSelector: #printOn: addMethod: {:(UndefinedObject)self :(Stream)stream :: Void | stream nextPutAll: "nil" }.

False
    withSelector: #printString addMethod: {:(False)self :: String | "false" };
    withSelector: #printOn: addMethod: {:(False)self :(Stream)stream :: Void | stream nextPutAll: "false" }.

True
    withSelector: #printString addMethod: {:(True)self :: String | "true" };
    withSelector: #printOn: addMethod: {:(True)self :(Stream)stream :: Void | stream nextPutAll: "true" }.

String
    withSelector: #printOn: addMethod: {:(String)self :(Stream)stream :: Void |
        ## TODO: Implement this part properly.
        stream nextPut: '"'.
        stream nextPutAll: self.
        stream nextPut: '"'.
    }.

StringSymbol
    withSelector: #printOn: addMethod: {:(StringSymbol)self :(Stream)stream :: Void |
        ## TODO: Implement this part properly.
        stream nextPut: '#'; nextPutAll: self
    }.

Class
    withSelector: #withSelector:addClassMethod: addMethod: {:(Class)self :selector :method :: Void |
        self class withSelector: selector addMethod: method
    }.

FunctionDefinition
    withSelector: #hasPragmaNamed: addMethod: {:(FunctionDefinition)self :selector :: Boolean |
        let: #analyzedPragmas with: self analyzedPragmas.
        let: #definitionBodyNode with: self definitionBodyNode.
        if: analyzedPragmas ~~ nil
        then: (analyzedPragmas anySatisfy: {:(Pragma)pragma :: Boolean | selector == pragma selector })
        else: (
            if: definitionBodyNode ~~ nil
            then: (definitionBodyNode hasPragmaNamed: selector)
            else: false
        )
    }.

Function
    withSelector: #hasFlag: addMethod: {:(Function)self :(Bitflags)flag :: Boolean |
        (self flags & flag) ~= 0bflgs
    };
    withSelector: #isMacro addMethod: {:(Function)self :: Boolean |
        self hasFlag: FunctionFlags::Macro
    };
    
    withSelector: #isVariadic addMethod: {:(Function)self :: Boolean |
        self hasFlag: FunctionFlags::Variadic
    };
    withSelector: #isCorePrimitive addMethod: {:(Function)self :: Boolean |
        self hasFlag: FunctionFlags::CorePrimitive
    };

    withSelector: #isPure addMethod: {:(Function)self :: Boolean |
        self hasFlag: FunctionFlags::Pure
    };
    withSelector: #isFinal addMethod: {:(Function)self :: Boolean |
        self hasFlag: FunctionFlags::Final
    };
    withSelector: #isVirtual addMethod: {:(Function)self :: Boolean |
        self hasFlag: FunctionFlags::Virtual
    };
    withSelector: #isAbstract addMethod: {:(Function)self :: Boolean |
        self hasFlag: FunctionFlags::Abstract
    };
    withSelector: #isOverride addMethod: {:(Function)self :: Boolean |
        self hasFlag: FunctionFlags::Override
    };
    withSelector: #isStatic addMethod: {:(Function)self :: Boolean |
        self hasFlag: FunctionFlags::Static
    };

    withSelector: #hasPragmaNamed: addMethod: {:(Function)self :selector :: Boolean |
        let: #definition with: self definition.
        if: definition == nil then: false else: (definition hasPragmaNamed: selector)
    };
    
    withSelector: #printOn: addMethod: {:(Function)self :(Stream)stream :: Void |
        let: #name with: self name.
        let: #definition with: self definition.
        let: #sourcePosition with: (if: definition ~~ nil then: definition sourcePosition else: nil).

        stream nextPutAll: "Function(".

        if: name ~~ nil then: {
            let: #owner with: self owner.
            if: owner ~~ nil then: (stream print: owner; nextPutAll: " >> ").
            
            stream print: name.
            if: sourcePosition ~~ nil then: (stream space).

        }.
        if: sourcePosition ~~ nil then: {
            stream nextPutAll: "at "; print: sourcePosition
        }.

        stream nextPut: ')'
    }.

ValueBox
    withSelector: #with: addClassMethod: {:(ValueBox class)self :value :: self |
        self basicNew
            value: value;
            yourself
    };
    withSelector: #_ addMethod: {:(ValueBox)self | self value };
    withSelector: #_: addMethod: {:(ValueBox)self :newValue | self value: newValue. newValue };
    withSelector: #":=" addMethod: {:(ValueBox)self :newValue | self value: newValue. newValue }.

Collection
    withSelector: #isEmpty addMethod: {:(Collection)self :: Boolean |
        self size = 0sz
    };
    withSelector: #isNotEmpty addMethod: {:(Collection)self :: Boolean |
        self size ~= 0sz
    };
    withSelector: #size addMethod: {:(Collection)self :: Size |
        self subclassResponsibility
    } makeAbstract;

    withSelector: #do: addMethod: {:(Collection)self :aBlock :: Void |
        self subclassResponsibility
    } makeAbstract;

    withSelector: #doWithIndex: addMethod: {:(Collection)self :aBlock :: Void |
        let: #i mutableWith: 0sz.
        self do: {:element :: Void |
            aBlock(element, i).
            i := 1sz + i
        }
    };

    withSelector: #printOn: addMethod: {:(Collection)self :(Stream)stream :: Void |
        stream print: self class; nextPutAll: "(".
        self doWithIndex: {:element :(Size)index :: Void |
            if: index > 0sz then: (stream nextPutAll: ", ").
            stream print: element.
            void
        }.

        stream nextPutAll: ")"
    };
    withSelector: #asArray addMethod: {:(SequenceableCollection)self :: Array |
        let: #array with: (Array new: self size).
        self doWithIndex: {:element :(Size)index :: Void |
            array at: index put: element
        }.

        array
    }.

Association
    withSelector: #printOn: addMethod: {:(Association)self :(Stream)stream :: Void |
        stream print: self key; nextPutAll: " -> "; print: self value
    }.

WeakValueAssociation
    withSelector: #value addMethod: {:(WeakValueAssociation)self |
        (RawTuple::slotAt:)(self, 1sz)
    } makePure; makeFinal;
    withSelector: #value: addMethod: {:(WeakValueAssociation)self :newValue :: Void |
        RawTuple::slotAt:put:(self, 1sz, newValue)
    } makePure; makeFinal;
    withSelector: #printOn: addMethod: {:(WeakValueAssociation)self :(Stream)stream :: Void |
        stream print: self key; nextPutAll: " -> "; print: self value
    }.

Dictionary
    withSelector: #do: addMethod: {:(Dictionary)self :aBlock :: Void |
        let: #storage with: self storage.
        if: storage ~~ nil then: {
            storage do: {:element :: Void |
                if: element ~~ nil then: aBlock(element).
            }
        }
    }.

Set
    withSelector: #do: addMethod: {:(Set)self :aBlock :: Void |
        let: #storage with: self storage.
        if: storage ~~ nil then: {
            storage do: {:element :: Void |
                if: __hashtableEmptyElement__ ~~ element then: aBlock(element).
            }
        }
    }.

WeakSet
    withSelector: #do: addMethod: {:(WeakSet)self :aBlock :: Void |
        let: #storage with: self storage.
        if: storage ~~ nil then: {
            storage do: {:element :: Void |
                if: (__hashtableEmptyElement__ ~~ element) && (__tombstone__ ~~ element) then: aBlock(element).
            }
        }
    }.

SequenceableCollection
    withSelector: #with: addClassMethod: {:(SequenceableCollection class)self :value :: self |
        (self new: 1sz)
            at: 0sz put: value;
            yourself
    };
    withSelector: #at: addMethod: {:(Collection)self :(Size)index  |
        self subclassResponsibility
    } makeAbstract;
    withSelector: #at:put: addMethod: {:(Collection)self :(Size)index :value  |
        self subclassResponsibility
    } makeAbstract;
    withSelector: #anySatisfy: addMethod: {:(SequenceableCollection)self :aBlock :: Boolean |
        let: #i mutableWith: 0sz.
        let: #size with: self size.
        let: #hasFoundIt type: Boolean mutableWith: false.

        while: (if: hasFoundIt then: false else: i < self size) do: (
            hasFoundIt := aBlock(self at: i)
        ) continueWith: (i := i + 1sz).
        hasFoundIt
    } makeFinal;
    withSelector: #allSatisfy: addMethod: {:(SequenceableCollection)self :aBlock :: Boolean |
        let: #i mutableWith: 0sz.
        let: #size with: self size.
        let: #everythingIsFine type: Boolean mutableWith: true.

        while: (if: everythingIsFine then: i < self size else: false) do: (
            everythingIsFine := aBlock(self at: i)
        ) continueWith: (i := i + 1sz).
        everythingIsFine
    } makeFinal;
    withSelector: #includes: addMethod: {:(SequenceableCollection)self :element :: Boolean |
        let: #i mutableWith: 0sz.
        let: #size with: self size.
        let: #hasFoundIt type: Boolean mutableWith: false.

        while: (if: hasFoundIt then: false else: i < self size) do: (
            hasFoundIt := (self at: i) = element
        ) continueWith: (i := i + 1sz).
        hasFoundIt
    } makeFinal;
    withSelector: #collect: addMethod: {:(SequenceableCollection)self :aBlock :: self species |
        let: #i mutableWith: 0sz.
        let: #size with: self size.
        let: #result with: (self species new: size).

        while: i < self size do: {
            result at: i put: aBlock(self at: i)
        } continueWith: (i := i + 1sz).

        result
    } makeFinal;
    withSelector: #do: addMethod: {:(SequenceableCollection)self :aBlock :: Void |
        let: #i mutableWith: 0sz.
        let: #size with: self size.

        while: i < self size do: (
            aBlock(self at: i)
        ) continueWith: (i := i + 1sz)
    };
    withSelector: #doWithIndex: addMethod: {:(SequenceableCollection)self :aBlock :: Void |
        let: #i mutableWith: 0sz.
        let: #size with: self size.

        while: i < self size do: {
            aBlock(self at: i, i)
        } continueWith: (i := i + 1sz)
    };
    withSelector: #-- addMethod: {:(SequenceableCollection)self :(SequenceableCollection)other :: self species |
        let: #size with: self size.
        let: #otherSize with: other size.
        let: #result with: (self species new: size + otherSize ).
        
        self doWithIndex: {:element :(Size)index :: Void |
            result at: index put: element
        }.

        other doWithIndex: {:element :(Size)index :: Void |
            result at: size + index put: element
        }.

        result
    };
    withSelector: #replaceAll:with: addMethod: {:(SequenceableCollection)self :oldObject :newObject :: Void |
        let: #i mutableWith: 0sz.
        let: #size with: self size.

        while: i < self size do: {
            if: (self at: i) = oldObject then: (self at: i put: newObject)
        } continueWith: (i := i + 1sz)
    };
    withSelector: #replaceAllWithDictionary: addMethod: {:(SequenceableCollection)self :(Dictionary)replacementDictionary :: Void |
        let: #i mutableWith: 0sz.
        let: #size with: self size.

        while: i < self size do: {
            replacementDictionary at: (self at: i) ifPresent: {:replacement :: Void |
                (self at: i put: replacement)
            }
        } continueWith: (i := i + 1sz)
    };
    withSelector: #first addMethod: {:(SequenceableCollection)self | self at: 0sz } makeFinal;
    withSelector: #second addMethod: {:(SequenceableCollection)self | self at: 1sz } makeFinal;
    withSelector: #third addMethod: {:(SequenceableCollection)self | self at: 2sz } makeFinal;
    withSelector: #fourth addMethod: {:(SequenceableCollection)self | self at: 3sz } makeFinal;
    withSelector: #fifth addMethod: {:(SequenceableCollection)self | self at: 4sz } makeFinal;
    withSelector: #sixth addMethod: {:(SequenceableCollection)self | self at: 5sz } makeFinal;
    withSelector: #seventh addMethod: {:(SequenceableCollection)self | self at: 6sz } makeFinal;
    withSelector: #eighth addMethod: {:(SequenceableCollection)self | self at: 7sz } makeFinal;
    withSelector: #ninth addMethod: {:(SequenceableCollection)self | self at: 8sz } makeFinal;
    withSelector: #tenth addMethod: {:(SequenceableCollection)self | self at: 9sz } makeFinal;
    
    withSelector: #=> addMethod: {:(SequenceableCollection)self :(Type)resultType :: SimpleFunctionType |
        SimpleFunctionTypeTemplate(self asArray, false, resultType)
    } makePure makeFinal.

Type
    withSelector: #=> addMethod: {:(Type)self :(Type)resultType :: SimpleFunctionType |
        SimpleFunctionTypeTemplate((self,), false, resultType)
    } makePure makeFinal.

ArrayList
    withSelector: #arrayType addClassMethod: {:(ArrayList class)self :: Array class |
        Array
    };
    withSelector: #new: addClassMethod: {:(ArrayList class)self :(Size)initialSize :: self |
        self basicNew initializeWithSize: initialSize; yourself
    } makeFinal;
    withSelector: #initialize addMethod: {:(ArrayList)self :: Void |
        self size: 0sz
    };
    withSelector: #initializeWithSize: addMethod: {:(ArrayList)self :(Size)initialSize :: Void |
        self size: initialSize sz.
        self storage: (self class arrayType new: initialSize).
    };
    withSelector: #at: addMethod: {:(ArrayList)self :(Size)index |
        if: index < self size then: {
            self storage at: index
        } else: {
            error("Index out of bounds.")
        }
    };
    withSelector: #at:put: addMethod: {:(ArrayList)self :(Size)index :value :: Void |
        if: index < self size then: {
            self storage at: index + self offset put: value
        } else: {
            error("Index out of bounds.")
        }
    }.

WeakArrayList
    withSelector: #arrayType addClassMethod: {:(ArrayList class)self :: Array class |
        WeakArray
    }.
    
StringStream
    withSelector: #initialize addMethod: {:(StringStream)self :: Void |
        self size: 0
    }.

Array
    withSelector: #new: addClassMethod: {:(Array class)self :(Size)initialSize :: self |
        self basicNew: initialSize
    } makeFinal;
    withSelector: #at: addMethod: {:(Array)self :(Size)index |
        self __slotAt__: index
    };
    withSelector: #at:put: addMethod: {:(Array)self :(Size)index :value :: Void |
        self __slotAt__: index put: value
    };
    withSelector: #size addMethod: {:(Array)self :: Size |
        self __size__
    };
    withSelector: #asArray addMethod: {:(Array)self :: Array | self };
    withSelector: #asArraySlice addMethod: {:(Array)self :: ArraySlice |
        ArraySlice basicNew
            elements: self;
            offset: 0sz;
            size: self size;
            yourself
    }.

ByteArray
    withSelector: #at: addMethod: {:(ByteArray)self :(Size)index |
        self __slotAt__: index
    };
    withSelector: #at:put: addMethod: {:(ByteArray)self :(Size)index :value :: Void |
        self __slotAt__: index put: value
    };
    withSelector: #size addMethod: {:(ByteArray)self :: Size |
        self __byteSize__
    };
    withSelector: #printOn: addMethod: {:(ByteArray)self :(Stream)stream :: Void |
        stream nextPutAll: "#[".
        self doWithIndex: {:element :index :: Void |
            if: index > 0sz then: (stream nextPutAll: ". ").
            stream print: element.
            void
        }.

        stream nextPutAll: "]"
    }.

ArraySlice
    withSelector: #new: addClassMethod: {:(ArraySlice class)self :(Size)size :: self |
        self basicNew
            elements: (Array basicNew: size);
            offset: 0sz;
            size: size;
            yourself
    };
    withSelector: #at: addMethod: {:(ArraySlice)self :(Size)index |
        if: index < self size then: {
            self elements at: index + self offset
        } else: {
            error("Index out of bounds.")
        }
    };
    withSelector: #at:put: addMethod: {:(ArraySlice)self :(Size)index :value :: Void |
        if: index < self size then: {
            self elements at: index + self offset put: value
        } else: {
            error("Index out of bounds.")
        }
    }.

TypeSlot
    withSelector: #named:type:flags: addClassMethod: {:(TypeSlot class)self :name :(Type)type :(Size)flags :: self |
        self new
            name: name;
            type: type;
            flags: flags;
            yourself
    };
    withSelector: #named:type: addClassMethod: {:(TypeSlot class)self :name :(Type)type :: self |
        self named: name type: type flags: TypeSlotFlags::None
    };
    withSelector: #named:flags: addClassMethod: {:(TypeSlot class)self :name :(Size)flags :: self |
        self named: name type: nil flags: flags
    };
    withSelector: #named: addClassMethod: {:(TypeSlot class)self :name :(Type)type :: self |
        self publicNamed: name type: nil
    };
    withSelector: #publicNamed:type: addClassMethod: {:(TypeSlot class)self :name :(Type)type :: self |
        self named: name type: type flags: TypeSlotFlags::Public
    };
    withSelector: #publicNamed: addClassMethod: {:(TypeSlot class)self :name :(Type)type :: self |
        self publicNamed: name type: nil
    };

    withSelector: #hasFlag: addMethod: {:(TypeSlot)self :(Size)flag :: Boolean |
        (self flags & flag) ~= 0bflgs
    };
    withSelector: #isPublic addMethod: {:(TypeSlot)self :: Boolean |
        self hasFlag: TypeSlotFlags::Public
    };
    withSelector: #isReadonly addMethod: {:(TypeSlot)self :: Boolean |
        self hasFlag: TypeSlotFlags::ReadOnly
    };
    withSelector: #generateAccessorsOn:withIndex: addMethod: {:(TypeSlot)self :(Type)type :(Size)slotIndex :: Void |
        if: self isPublic then: {
            let: #slotType with: self type.
            let: #getterName with: self name.
            let: #setterName with: (self name asString -- ":") asSymbol.

            ## Getter.
            type withSelector: getterName addMethod: {:(type)self :: slotType |
                (RawTuple::slotAt:)(self, slotIndex)
            } makePure makeFinal recompileAndOptimize.

            ## Setter
            if: self isReadonly not then: {
                type withSelector: setterName addMethod: {:(type)self :(slotType)value :: Void |
                    RawTuple::slotAt:put:(self, slotIndex, value)
                } makeFinal recompileAndOptimize.
            }
        }
    }.

Type
    withSelector: #generatePublicAccessors addMethod: {:(Type)self :: Void |
        let: #baseSlotIndex with: self validSupertypeTotalSlotCount.
        self slots doWithIndex: {:slot :index :: Void |
            let: #slotIndex with: baseSlotIndex + index.
            slot generateAccessorsOn: self withIndex: slotIndex
        }.
    }.

Metatype
    withSelector: #printOn: addMethod: {:(Metatype)self :(Stream)stream :: Void |
        let: #thisType with: self thisType.
        if: thisType ~~ nil
        then: (stream print: thisType; nextPutAll: " __type__")
        else: (stream nextPutAll: "a "; print: self __type__)
    }.

Metaclass
    withSelector: #thisClass addMethod: {:(Metaclass)self :: Type | self thisType };
    withSelector: #thisClass: addMethod: {:(Metaclass)self :(Type)thisClass :: Void | self thisType: thisClass };
    withSelector: #printOn: addMethod: {:(Metaclass)self :(Stream)stream :: Void |
        let: #thisClass with: self thisClass.
        if: thisClass ~~ nil
        then: (stream print: thisClass; nextPutAll: " class")
        else: (stream nextPutAll: "a "; print: self __type__)
    }.

Type
    withSelector: #refFor: addMethod: {:(Type)self :addressSpace :: ReferenceType |
        ReferenceTypeTemplate(self, addressSpace)
    } makePure;
    withSelector: #ref addMethod: {:(Type)self :: ReferenceType |
        self refFor: nil
    } makePure;
    withSelector: #pointerFor: addMethod: {:(Type)self :addressSpace :: ReferenceType |
        PointerTypeTemplate(self, addressSpace)
    } makePure;
    withSelector: #pointer addMethod: {:(Type)self :addressSpace :: ReferenceType |
        self pointerFor: nil
    } makePure.

ReferenceType
    withSelector: #printOn: addMethod: {:(Type)self :(Stream)stream :: Void |
        stream print: self baseType.
        if: self addressSpace == nil then: {
            stream nextPutAll: " ref"
        } else: {
            stream nextPutAll: " refFor: "; print: self addressSpace
        }.
    }.

PointerType
    withSelector: #printOn: addMethod: {:(Type)self :(Stream)stream :: Void |
        stream print: self baseType.
        if: self addressSpace == nil then: {
            stream nextPutAll: " pointer"
        } else: {
            stream nextPutAll: " pointerFor: "; print: self addressSpace
        }.
    }.

DependentFunctionType
    withSelector: #printOn: addMethod: {:(Type)self :(Stream)stream :: Void |
        stream nextPutAll: "DependentFunctionType at "; print: self sourcePosition
    }.

SimpleFunctionType
    withSelector: #printOn: addMethod: {:(Type)self :(Stream)stream :: Void |
        stream nextPut: '('.
        self argumentTypes doWithIndex: {:(Type)argumentType :(Size)index :: Void |
            index > 0sz ifTrue: (stream nextPutAll: ", ").
            stream print: argumentType
        }.
        self isVariadic ifTrue: {
            self argumentTypes isNotEmpty
                ifTrue: (stream nextPutAll: ", ...")
                ifFalse: (stream nextPutAll: "...")
        }.
        stream nextPutAll: ") => "; print: self resultType.
    }.

## Primitive values printString and primitive function types
(
    UInt8,Int8,Char8,
    UInt16,Int16,Char16,
    UInt32,Int32,Char32,
    UInt64,Int64,
    Float32,Float64,
    Integer
) do: {:SelfType :: Void |
    let: #unaryFunctionType with: SelfType => SelfType.
    let: #binaryFunctionType with: (SelfType, SelfType) => SelfType.
    let: #equalityFunctionType with: (SelfType, nil) => Boolean.
    let: #binaryComparisonFunctionType with: (SelfType, SelfType) => Boolean.

    ## Unary selectors
    #(
        negated bitInvert
    ) do: {:selector :: Void |
        let: #method with: (SelfType >> selector).
        if: method ~~ nil then: (method __type__: unaryFunctionType)
    }.

    ## Binary selectors.
    #(
        + - * / %
        | & ^ << >>
    ) do: {:selector :: Void |
        let: #method with: (SelfType >> selector).
        if: method ~~ nil then: (method __type__: binaryFunctionType)
    }.

    ## Equality
    #(
        = ~=
    ) do: {:selector :: Void |
        (SelfType >> selector) __type__: equalityFunctionType
    }.

    ## Comparisons
    #(
        < <= >= >
    ) do: {:selector :: Void |
        (SelfType >> selector) __type__: binaryComparisonFunctionType
    }.

    SelfType
        withSelector: #printOn: addMethod: {:(SelfType)self :(Stream)stream :: Void |
            stream nextPutAll: self printString
        } makeFinal recompileAndOptimize
}.

(Integer >> #i8) __type__: (Integer => Int8).
(Integer >> #u8) __type__: (Integer => UInt8).
(Integer >> #c8) __type__: (Integer => Char8).
(Integer >> #i16) __type__: (Integer => Int16).
(Integer >> #u16) __type__: (Integer => UInt16).
(Integer >> #c16) __type__: (Integer => Char16).
(Integer >> #i32) __type__: (Integer => Int32).
(Integer >> #u32) __type__: (Integer => UInt32).
(Integer >> #c32) __type__: (Integer => Char32).
(Integer >> #i64) __type__: (Integer => Int64).
(Integer >> #u64) __type__: (Integer => UInt64).
##(Integer >> #f32) __type__: (Integer => Float32).
##(Integer >> #f64) __type__: (Integer => Float64).

(Float32 >> #sqrt) __type__: (Float32 => Float32).
(Float64 >> #sqrt) __type__: (Float32 => Float32).

SourcePosition
    withSelector: #printOn: addMethod: {:(SourcePosition)self :(Stream)stream :: Void |
        let: #sourceCode with: self sourceCode.

        stream
            nextPutAll: (sourceCode directory FileSystem::joinPath: sourceCode name);
            nextPut: ':';
            print: self startLine;
            nextPut: '.';
            print: self startColumn;
            nextPut: '-';
            print: self endLine;
            nextPut: '.';
            print: self endColumn
    }.

GeneratedSymbol
    withSelector: #printOn: addMethod: {:(GeneratedSymbol)self :(Stream)stream :: Void |
        stream print: self class; nextPut: '('; print: self value; nextPut: ')'
    }.

Metaclass class
    withSelector: #getOrCreateDependentApplicationValueForNode: addMethod: {:(Metaclass class)self :(ASTNode)astNode |
        Class
    }.

Class
    withSelector: #subclassWithClassSlots: addMethod: {:(Class)self :(Array)classSlots :: Class |
        let: #metaclass with: Metaclass basicNew.
        let: #metaclassSuper with: self class.
        metaclass
            flags: TypeFlags::MetatypeRequiredFlags;
            supertype: metaclassSuper;
            slots: classSlots;
            totalSlotCount: metaclassSuper validTotalSlotCount + classSlots size;
            generatePublicAccessors.
        
        let: #class with: metaclass basicNew.
        class
            flags: TypeFlags::ClassDefaultFlags;
            supertype: self;
            slots: ();
            totalSlotCount: nil.
        metaclass thisClass: class.
        class
    };
    withSelector: #subclassWithClassSlots:slots: addMethod: {:(Class)self :(Array)classSlots :(Array)instanceSlots :: Class |
        (self subclassWithClassSlots: classSlots)
            slots: instanceSlots;
            totalSlotCount: self validTotalSlotCount + instanceSlots size;
            generatePublicAccessors;
            yourself
    };
    withSelector: #subclass:classSlots:slots: addMethod: {:(Class)self :(StringSymbol)name :(Array)classSlots :(Array)instanceSlots :: Class |
        let: #class with: (self subclassWithClassSlots: classSlots slots: instanceSlots).
        class name: name.
        class
    };
    withSelector: #subclass:slots: addMethod: {:(Class)self :(StringSymbol)name :(Array)instanceSlots :: Class |
        self subclass: name classSlots: () slots: instanceSlots
    }.

Environment
    withSelector: #setSymbol:value: addMethod: {:(Environment)self :(Symbol)selector :value :: value __type__ | self setSymbol: selector bindingWithValue: value. value };
    withSelector: #setPublicSymbol:value: addMethod: {:(Environment)self :(Symbol)selector :value :: value __type__ | self setSymbol: selector bindingWithValue: value. value };
    withSelector: #withSelector:addMethod: addMethod: {:(Environment)self :(Symbol)selector :method :: Void | self setSymbol: selector bindingWithValue: method }.
