SymbolBinding definition: {
    public abstract method analyzeAndEvaluateWithEnvironment: (environment: Environment) at: (sourcePosition: SourcePosition) ::=> Untyped
        := self subclassResponsibility.

    public abstract eager method analyzeIdentifierReference: (node: ASTIdentifierReferenceNode) withEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode
        := self subclassResponsibility.
    
    public abstract method evaluateWithActivationEnvironment: (environment: FunctionActivationEnvironment) ::=> Untyped
        := self subclassResponsibility.
}.

SymbolValueBinding definition: {
    public override method analyzeAndEvaluateWithEnvironment: (environment: Environment) at: (sourcePosition: SourcePosition) ::=> Untyped
        := self __slotNamedAt__: #value.

    public override eager method analyzeIdentifierReference: (node: ASTIdentifierReferenceNode) withEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode
        := environment newLiteral: (self __slotNamedAt__: #value) at: node sourcePosition.

    public override method evaluateWithActivationEnvironment: (environment: FunctionActivationEnvironment) ::=> Untyped
        := self __slotNamedAt__: #value.
}.

SymbolMacroValueBinding definition: {
    public override eager method analyzeIdentifierReference: (node: ASTIdentifierReferenceNode) withEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode
        := self expansion analyzeWithEnvironment: environment.
}.

SymbolAnalysisBinding definition: {
    public override eager method analyzeIdentifierReference: (node: ASTIdentifierReferenceNode) withEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode
        := node copy
            analyzerToken: environment validAnalyzerToken;
            analyzedType: self type;
            binding: self;
            yourself.
}.

SymbolArgumentBinding definition: {
    public override method evaluateWithActivationEnvironment: (environment: FunctionActivationEnvironment) ::=> Untyped
        := environment valueVector at: vectorIndex.
}.

SymbolCaptureBinding definition: {
    public override method evaluateWithActivationEnvironment: (environment: FunctionActivationEnvironment) ::=> Untyped
        := environment captureVector at: vectorIndex.
}.

SymbolLocalBinding definition: {
    public override method evaluateWithActivationEnvironment: (environment: FunctionActivationEnvironment) ::=> Untyped
        := environment valueVector at: environment argumentVectorSize + vectorIndex.
}.

function concretizeMetaValueWithEnvironment(value: Untyped, environment: Environment) => Untyped := {
    let type := RawTuple::type(value).
    type
        ifNil: value
        ifNotNil: (type analyzeAndEvaluateConcreteMetaValue: value withEnvironment: environment)
}.

Type definition: {
    public virtual eager method getOrCreateDependentApplicationValueForNode: (node: ASTNode) ::=> Untyped := {
        let result := RawTuple::new(0sz).
        (RawTuple::type:)(result, self).
        RawTuple::markDummyValue(result).
        result
    }.
}.

ASTNode definition: {
    public virtual eager method analyzeConcreteMetaValueWithEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode
        := self.

    public virtual eager method semanticError: (errorMessage: String) at: (errorSourcePosition: SourcePosition)::=> Unwinds := {
        self error: errorSourcePosition printString -- ": " -- errorMessage
    }.

    public virtual eager method semanticError: (errorMessage: String) ::=> Unwinds := {
        self semanticError: errorMessage at: self sourcePosition
    }.

    public virtual eager method getOrCreateDependentApplicationValue => Untyped
        := analyzedType getOrCreateDependentApplicationValueForNode: self.
}.

ASTLiteralNode definition: {
    public override eager method getOrCreateDependentApplicationValue => Untyped
        := self __slotNamedAt__: #value.
}.

ASTArgumentNode definition: {
    public eager override method analyzeWithEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode := {
        let result := self copy
            analyzerToken: environment validAnalyzerToken;
            yourself.

        result name ifNotNil: { result name: (environment analyze: result name withExpectedType: Symbol) }.
        result type ifNotNil: {
            result type: (environment analyze: result type withExpectedType: Type)
        } ifNil: {
            result type: (environment newLiteral: AnyValue at: result sourcePosition)
        }.

        let evaluatedName => Symbol := (result name isNotNil && result name isLiteralNode)
            ifTrue: (result name downCastTo: ASTLiteralNode) value
            ifFalse: nil.
        let evaluatedType => Type := (result type isNotNil && result type isLiteralNode)
            ifTrue: (result type downCastTo: ASTLiteralNode) value
            ifFalse: AnyValue.
        result
            analyzedType: evaluatedType;
            binding: (environment setNewSymbol: evaluatedName argumentBindingOfType: evaluatedType at: result sourcePosition);
            yourself
    }.

    public eager method evaluateDependentArgumentTypeInEnvironment: (environment: FunctionActivationEnvironment) ::=> Type
        := self type ifNil: (Untyped) ifNotNil: (self type evaluateWithEnvironment: environment).
}.

ASTCoerceValueNode definition: {
    public override method analyzeAndEvaluateWithEnvironment: (environment: Environment) ::=> Untyped := {
        let type => Type := self typeExpression analyzeAndEvaluateWithEnvironment: environment.
        let value := self valueExpression analyzeAndEvaluateWithEnvironment: environment.
        type coerceValue: value.
    }.

    public eager override method analyzeWithEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode := {
        (environment analyze: self valueExpression withExpectedTypeExpression: self typeExpression at: self sourcePosition)
            node
    }.

    public override eager method evaluateWithEnvironment: (environment: FunctionActivationEnvironment) ::=> Untyped := {
        let type => Type := self typeExpression evaluateWithEnvironment: environment.
        let value := self valueExpression evaluateWithEnvironment: environment.
        type coerceValue: value.
    }.
}.

ASTDownCastNode definition: {
    public override method analyzeAndEvaluateWithEnvironment: (environment: Environment) ::=> Untyped := {
        let type => Type := self typeExpression analyzeAndEvaluateWithEnvironment: environment.
        let value := self valueExpression analyzeAndEvaluateWithEnvironment: environment.
        (RawTuple::type(value) isSubtypeOf: type) ifFalse: {
            self semanticError: "Expected a value whose type is " -- type printString
        }.
        value
    }.

    public eager override method analyzeWithEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode := {
        let result := self copy
            analyzerToken: environment validAnalyzerToken;
            typeExpression: (environment analyze: self typeExpression withExpectedType: Type);
            yourself.

        let hasLiteralType := result typeExpression isLiteralNode.
        result analyzedType: (hasLiteralType
            ifTrue: (result typeExpression downCastTo: ASTLiteralNode) value
            ifFalse: (result typeExpression analyzedType asCanonicalPendingInstanceType)
        ).
        result valueExpression: (environment analyzeWithDecayedType: result valueExpression).

        hasLiteralType && (result valueExpression analyzedType isDirectSubtypeOf: result analyzedType)
            ifTrue: result valueExpression
            ifFalse: result
    }.

    public override eager method evaluateWithEnvironment: (environment: FunctionActivationEnvironment) ::=> Untyped := {
        let type => Type := self typeExpression evaluateWithEnvironment: environment.
        let value := self valueExpression evaluateWithEnvironment: environment.
        (RawTuple::type(value) isSubtypeOf: type) ifFalse: {
            self semanticError: "Expected a value whose type is " -- type printString.
        }.
        value
    }.
}.

ASTErrorNode definition: {
    public override method analyzeAndEvaluateWithEnvironment: (environment: Environment) ::=> Untyped
        := self semanticError: self errorMessage.

    public override eager method analyzeWithEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode
        := self semanticError: self errorMessage.

    public override eager method evaluateWithEnvironment: (environment: FunctionActivationEnvironment) ::=> Untyped
        := self semanticError: self errorMessage.
}.

ASTIdentifierReferenceNode definition: {
    public override method analyzeAndEvaluateWithEnvironment: (environment: Environment) ::=> Untyped := {
        let binding := environment lookSymbolRecursively: self value.
        binding ifNil: {
            self semanticError: "Failed to find binding for symbol " -- self value printString
        }.

        binding analyzeAndEvaluateWithEnvironment: environment at: self sourcePosition
    }.

    public override eager method analyzeWithEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode := {
        let binding := environment lookSymbolRecursively: self value.
        binding ifNil: {
            self semanticError: "Failed to find binding for symbol " -- self value printString
        }.

        binding analyzeIdentifierReference: self withEnvironment: environment
    }.

    public override eager method evaluateWithEnvironment: (environment: FunctionActivationEnvironment) ::=> Untyped
        := binding evaluateWithActivationEnvironment: environment.
}.

ASTLiteralNode definition: {
    public override method analyzeAndEvaluateWithEnvironment: (environment: Environment) ::=> Untyped
        := self __slotNamedAt__: #value.

    public override eager method analyzeWithEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode
        := self copy
            analyzerToken: environment validAnalyzerToken;
            analyzedType: RawTuple::type(self __slotNamedAt__: #value);
            yourself.

    public override eager method evaluateWithEnvironment: (environment: FunctionActivationEnvironment) ::=> Untyped
        := self __slotNamedAt__: #value.

    public override eager method analyzeConcreteMetaValueWithEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode := {
        analyzedType
            ifNil: (self)
            ifNotNil: (analyzedType analyzeConcreteMetaValue: self withEnvironment: environment)
    }.
}.

ASTLambdaNode definition: {
    public eager method argumentCount => Size := {
        let result mutable := 0sz.
        self arguments do: {:(ASTArgumentNode)eachArgument :: Void |
            eachArgument isForAll ifFalse: {
                result := result + 1sz.
            }
        }.

        result
    }.

    public eager method makeFunctionDefinitionWithName: (name: Symbol) environment: (environment: Environment) ::=> FunctionDefinition
        := FunctionDefinition new
            sourcePosition: self sourcePosition;
            flags: self flags;
            argumentCount: self argumentCount;
            definitionEnvironment: environment;
            definitionArgumentNodes: self arguments;
            definitionResultTypeNode: self resultType;
            definitionBodyNode: self body;
            yourself.

    public override method analyzeAndEvaluateWithEnvironment: (environment: Environment) ::=> Untyped := {
        let name => Symbol := self name ifNotNil: (self name analyzeAndEvaluateWithEnvironment: environment).

        let functionDefinition := self makeFunctionDefinitionWithName: name environment: environment.

        let result := self hasLazyAnalysis == false ifTrue: {
            functionDefinition ensureAnalysis.
            let captureVector => AnySequenceTuple := functionDefinition analyzedCaptureVectorType new.
            
            functionDefinition analyzedCaptures doWithIndex: {:(SymbolBinding)eachCapture :(Size)index :: Void |
                captureVector at: index put: (environment evaluateSymbolBinding: eachCapture)
            }.

            let closure => Function := functionDefinition analyzedType new.
            closure setupWithFunctionDefinition: functionDefinition captureVector: captureVector.
            closure.
        } ifFalse: {
            functionDefinition ensureTypeAnalysis.
            let closure => Function := functionDefinition analyzedType new.
            closure setupWithFunctionDefinition: functionDefinition captureEnvironment: environment.
            environment enqueuePendingAnalysis: closure.
            closure
        }.

        name ifNotNil: {
            environment setNewSymbol: name valueBinding: result at: self sourcePosition
        }.

        result
    }.

    public override eager method analyzeWithEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode := {
        let result := self copy
            analyzerToken: environment validAnalyzerToken;
            yourself.
        
        ## Construct the lambda definition.
        let name => Symbol := result name ifNotNil: {
            result name: (environment analyze: result name withExpectedType: Symbol).
            result name isLiteralNode ifFalse: {
                result name semanticError: "Lambda analyzed name must be a literal."
            }.

            (result name downCastTo: ASTLiteralNode) value
        }.

        ## TODO: Use the expected type for assisting the type inference of argument types and return values.

        ## Construct the lambda function definition.
        let functionDefinition := result makeFunctionDefinitionWithName: name environment: environment.
        environment addInnerFunction: functionDefinition.
        result functionDefinition: functionDefinition.

        ## Analyze the function definition.
        functionDefinition ensureAnalysis.
        result analyzedType: functionDefinition analyzedType.

        ## Optimize the captureless lambdas.
        functionDefinition analyzedCaptures isEmpty ifTrue: {
            let capturelessClosure => Function := functionDefinition analyzedType new.
            capturelessClosure setupWithFunctionDefinition: functionDefinition captureVector: functionDefinition analyzedCaptureVectorType new.
            name ifNotNil: {
                environment setNewSymbol: name valueBinding: capturelessClosure at: self sourcePosition
            }.

            return: (environment newLiteral: capturelessClosure at: self sourcePosition)
        }.

        name ifNotNil: {
            result binding: (environment setNewSymbol: name localBindingOfType: result analyzedType at: result sourcePosition)
        }.

        result
    }.

    public override eager method evaluateWithEnvironment: (environment: FunctionActivationEnvironment) ::=> Untyped := {
        let functionDefinition := self functionDefinition.
        let captureVector => AnySequenceTuple := functionDefinition analyzedCaptureVectorType new.
        functionDefinition analyzedCaptures doWithIndex: {:(SymbolBinding)eachCapture :(Size)index :: Untyped |
            captureVector at: index put: (eachCapture evaluateWithActivationEnvironment: environment)
        }.

        let closure => Function := functionDefinition analyzedType new.
        closure setupWithFunctionDefinition: functionDefinition captureVector: captureVector.
        self binding ifNotNil: {
            environment setBinding: self binding activationValue: closure
        }.
        closure.
    }.
}.

ASTLexicalBlockNode definition: {
    public override method analyzeAndEvaluateWithEnvironment: (environment: Environment) ::=> Untyped := {
        let childEnvironment := AnalysisAndEvaluationEnvironment parent: environment.
        body analyzeAndEvaluateWithEnvironment: childEnvironment
    }.

    public override eager method analyzeWithEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode := {
        let childEnvironment := LocalAnalysisEnvironment parent: environment.
        (childEnvironment analyzeWithCurrentExpectedType: body)
    }.

    public override eager method evaluateWithEnvironment: (environment: FunctionActivationEnvironment) ::=> Untyped := {
        body evaluateWithEnvironment: environment
    }.
}.

ASTLocalDefinitionNode definition: {
    public override method analyzeAndEvaluateWithEnvironment: (environment: Environment) ::=> Untyped := {
        let name := self nameExpression ifNotNil: (self nameExpression analyzeAndEvaluateWithEnvironment: environment).
        self isMacroSymbol ifTrue: {
            environment setNewMacro: name valueBinding: self valueExpression at: self sourcePosition.
            return: void
        }.

        let type => Type := self typeExpression ifNotNil: (self typeExpression analyzeAndEvaluateWithEnvironment: environment).
        let value := self valueExpression ifNotNil: (self valueExpression analyzeAndEvaluateWithEnvironment: environment).
        let coercedValue := type ifNil: value ifNotNil: (type coerceValue: value).

        let mutableValue := self isMutable
            ifTrue: ((type ifNil: value __type__) refForFunction untypedWithBoxForValue: value)
            ifFalse: value.

        environment setNewSymbol: name valueBinding: mutableValue at: self sourcePosition.
        mutableValue
    }.

    public eager override method analyzeWithEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode := {
        let result := self copy
            analyzerToken: environment validAnalyzerToken;
            yourself.

        result nameExpression ifNotNil: {
            result nameExpression: (environment analyze: result nameExpression withExpectedType: Symbol)
        }.
        let evaluatedName => Symbol := (result nameExpression isNotNil && result nameExpression isLiteralNode)
            ifTrue: (result nameExpression downCastTo: ASTLiteralNode) value
            ifFalse: nil.

        result isMacroSymbol ifTrue: {
            environment setNewMacro: evaluatedName valueBinding: result valueExpression at: result sourcePosition.
            return: (environment newLiteral: void at: result sourcePosition)
        }.

        result typeExpression ifNotNil: {
            result typeExpression: (environment analyze: result typeExpression withExpectedType: Type)
        }.

        let nodeWithCanonicalType := environment analyze: result valueExpression withExpectedTypeExpression: result typeExpression at: result sourcePosition.
        result valueExpression: nodeWithCanonicalType node.

        let evaluatedValueType := nodeWithCanonicalType canonicalType.
        let evaluatedType := result isMutable
            ifTrue: (evaluatedValueType refForFunction)
            ifFalse: (evaluatedValueType).

        result nameExpression ifNil: {
            return: result valueExpression
        }.

        result isMutable not && result valueExpression isLiteralNode ifTrue: {
            let value := (result valueExpression downCastTo: ASTLiteralNode) value.
            environment setNewSymbol: evaluatedName valueBinding: value at: result sourcePosition.
            result valueExpression
        } ifFalse: {
            let binding := environment setNewSymbol: evaluatedName localBindingOfType: evaluatedType at: result sourcePosition.
            result
                analyzedType: evaluatedType;
                binding: binding;
                yourself
        }.
    }.

    public override eager method evaluateWithEnvironment: (environment: FunctionActivationEnvironment) ::=> Untyped := {
        let value := self valueExpression ifNotNil: (self valueExpression evaluateWithEnvironment: environment).
        let mutableValue => Untyped := self isMutable
            ifTrue: ((self analyzedType downCastTo: ReferenceType) untypedWithBoxForValue: value)
            ifFalse: value.
        environment setBinding: self binding activationValue: mutableValue.
        mutableValue
    }.
}.

ASTMakeAssociationNode definition: {
    public override eager method analyzeAndEvaluateWithEnvironment: (environment: Environment) ::=> Untyped
        := Association
            key: (self key analyzeAndEvaluateWithEnvironment: environment)
            value: (self value ifNotNil: (self value analyzeAndEvaluateWithEnvironment: environment)).

    public override eager method analyzeWithEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode
        := self copy
            analyzerToken: environment validAnalyzerToken;
            analyzedType: Association;
            key: (environment analyzeWithDecayedType: self key);
            value: (self value ifNotNil: (environment analyzeWithDecayedType: self value));
            yourself.

    public override eager method evaluateWithEnvironment: (environment: FunctionActivationEnvironment) ::=> Untyped
        := Association
            key: (self key evaluateWithEnvironment: environment)
            value: (self value ifNotNil: (self value evaluateWithEnvironment: environment)).
}.

ASTMakeArrayNode definition: {
    public override eager method analyzeAndEvaluateWithEnvironment: (environment: Environment) ::=> Untyped
        := self elements collect: {:(ASTNode)each | each analyzeAndEvaluateWithEnvironment: environment }.

    public override eager method analyzeWithEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode
        := self copy
            analyzerToken: environment validAnalyzerToken;
            analyzedType: Array;
            elements: (self elements collect: {:(ASTNode)each :: ASTNode | environment analyzeWithDecayedType: each});
            yourself.

    public override eager method evaluateWithEnvironment: (environment: FunctionActivationEnvironment) ::=> Untyped
        := self elements collect: {:(ASTNode)each | each evaluateWithEnvironment: environment }.
}.

ASTMakeByteArrayNode definition: {
    public override eager method analyzeAndEvaluateWithEnvironment: (environment: Environment) ::=> Untyped := {
        let result := ByteArray new: elements size.
        self elements doWithIndex: {:(ASTNode)each :(Size)index :: Void |
            result at: index put: (each analyzeAndEvaluateWithEnvironment: environment) u8 ## FIXME: Use the asUInt8 message on integer.
        }.
        result
    }.

    public override eager method analyzeWithEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode
        := self copy
            analyzerToken: environment validAnalyzerToken;
            analyzedType: ByteArray;
            elements: (self elements collect: {:(ASTNode)each :: ASTNode | environment analyzeWithDecayedType: each});
            yourself.

    public override eager method evaluateWithEnvironment: (environment: FunctionActivationEnvironment) ::=> Untyped := {
        let result := ByteArray new: elements size.
        self elements doWithIndex: {:(ASTNode)each :(Size)index :: Void |
            result at: index put: (each evaluateWithEnvironment: environment)
        }.
        result
    }.
}.

ASTMakeDictionaryNode definition: {
    public override eager method analyzeAndEvaluateWithEnvironment: (environment: Environment) ::=> Untyped := {
        let result := Dictionary new: elements size.
        self elements doWithIndex: {:(ASTNode)each :(Size)index :: Void |
            result add: (each analyzeAndEvaluateWithEnvironment: environment)
        }.
        result
    }.

    public override eager method analyzeWithEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode
        := self copy
            analyzerToken: environment validAnalyzerToken;
            analyzedType: Dictionary;
            elements: (self elements collect: {:(ASTNode)each :: ASTNode | environment analyzeWithDecayedType: each});
            yourself.

    public override eager method evaluateWithEnvironment: (environment: FunctionActivationEnvironment) ::=> Untyped := {
        let result := Dictionary new: elements size.
        self elements doWithIndex: {:(ASTNode)each :(Size)index :: Void |
            result add: (each evaluateWithEnvironment: environment)
        }.
        result
    }.
}.

ASTPragmaNode definition: {
    public eager override method analyzeWithEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode := {
        let result := self copy
            analyzerToken: environment validAnalyzerToken;
            analyzedType: Pragma;
            selector: (environment analyze: self selector withExpectedType: Symbol);
            arguments: (self arguments collect: {:(ASTNode)eachArgument :: ASTNode | environment analyzeWithDecayedType: eachArgument});
            yourself.

        result selector isLiteralNode && (result arguments allSatisfy: {:(ASTNode)eachArgument :: Boolean | eachArgument isLiteralNode}) ifTrue: {
            let pragma := Pragma new
                selector: (result selector downCastTo: ASTLiteralNode) value;
                arguments: (result arguments collect: {:(ASTLiteralNode)eachArgument | eachArgument value});
                yourself.
            environment addPragma: pragma.
            environment newLiteral: pragma at: result sourcePosition
        } ifFalse: {
            result
        }.
    }.
}.

ASTSequenceNode definition: {
    public override method analyzeAndEvaluateWithEnvironment: (environment: Environment) ::=> Untyped := {
        let resultBox := ValueBox with: void.
        self expressions do: {:(ASTNode)eachExpression :: Void |
            let expressionValue := eachExpression analyzeAndEvaluateWithEnvironment: environment.
            resultBox value: concretizeMetaValueWithEnvironment(expressionValue, environment)
        }.

        resultBox value
    }.

    public override eager method analyzeWithEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode := {
        let expressionCount := self expressions size.
        let result := self copy
            analyzerToken: environment validAnalyzerToken;
            pragmas: (self pragmas collect: {:(ASTNode)eachPragma :: ASTNode |
                environment analyze: eachPragma withExpectedType: Pragma
            });
            expressions: (self expressions collectWithIndex: {:(ASTNode)eachExpression :(Size)index :: ASTNode |
                (index + 1sz = expressionCount
                    ifFalse: (environment analyze: eachExpression withExpectedType: Void)
                    ifTrue: (environment analyzeWithCurrentExpectedType: eachExpression))
                    analyzeConcreteMetaValueWithEnvironment: environment
            });
            yourself.
        result analyzedType: (expressionCount = 0sz ifTrue: Void ifFalse: result expressions last analyzedType).
        result
    }.

    public override eager method evaluateWithEnvironment: (environment: FunctionActivationEnvironment) ::=> Untyped := {
        let resultBox := ValueBox with: void.
        self expressions do: {:(ASTNode)eachExpression :: Void |
            resultBox value: (eachExpression evaluateWithEnvironment: environment)
        }.

        resultBox value
    }.
}.

ASTUnexpandedSExpressionNode definition: {
    public method asUnexpandedApplicationNode => ASTUnexpandedApplicationNode
        := ASTUnexpandedApplicationNode new
            sourcePosition: self sourcePosition;
            functionOrMacroExpression: self elements first;
            arguments: self elements allButFirst;
            yourself.

    public override method analyzeAndEvaluateWithEnvironment: (environment: Environment) ::=> Untyped := {
        self elements isEmpty ifTrue: {
            #()
        } ifFalse: {
            self asUnexpandedApplicationNode analyzeAndEvaluateWithEnvironment: environment
        }
    }.

    public override eager method analyzeWithEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode := {
        self elements isEmpty ifTrue: {
            environment newLiteral: #() at: self sourcePosition
        } ifFalse: {
            self asUnexpandedApplicationNode analyzeWithEnvironment: environment
        }
    }.
}.

ASTUnexpandedApplicationNode definition: {
    public eager method asFunctionApplicationNode => ASTFunctionApplicationNode
        := ASTFunctionApplicationNode new
            sourcePosition: self sourcePosition;
            functionExpression: self functionOrMacroExpression;
            arguments: self arguments;
            yourself.

    public eager method expandWithMacro: macroFunction environment: (environment: Environment) ::=> ASTNode := {
        let macroContext := MacroContext new
            sourceNode: self;
            sourcePosition: self sourcePosition;
            environment: environment;
            yourself.
        macroFunction applyWithArguments: (Array with: macroContext) -- self arguments
    }.
}.

## Temporal definition to avoid cyclic issues.
Function class definition: {
    public virtual eager method analyzeAndEvaluateUnexpandedApplicationNode: (node: ASTUnexpandedApplicationNode) of: (functional: Untyped) withEnvironment: (environment: Environment) ::=> Untyped := {
        functional isMacro ifTrue: {
            (node expandWithMacro: functional environment: environment) analyzeAndEvaluateWithEnvironment: environment
        } ifFalse: {
            node asFunctionApplicationNode
                functionExpression: (ASTLiteralNode new
                    sourcePosition: node functionOrMacroExpression sourcePosition;
                    value: functional;
                    yourself);
                analyzeAndEvaluateWithEnvironment: environment
        }.
    }.

    public virtual eager method analyzeUnexpandedApplicationNode: (node: ASTUnexpandedApplicationNode) withEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> Untyped := {
        node functionOrMacroExpression isLiteralNode && (node functionOrMacroExpression downCastTo: ASTLiteralNode) value isMacro ifTrue: {
            environment analyzeWithCurrentExpectedType: (node expandWithMacro: (node functionOrMacroExpression downCastTo: ASTLiteralNode) value environment: environment)
        } ifFalse: {
            node asFunctionApplicationNode analyzeWithEnvironment: environment
        }.
    }.
}.

FunctionType definition: {
    public virtual eager method analyzeAndEvaluateUnexpandedApplicationNode: (node: ASTUnexpandedApplicationNode) of: (functional: Untyped) withEnvironment: (environment: Environment) ::=> Untyped := {
        functional isMacro ifTrue: {
            (node expandWithMacro: functional environment: environment) analyzeAndEvaluateWithEnvironment: environment
        } ifFalse: {
            node asFunctionApplicationNode
                functionExpression: (ASTLiteralNode new
                    sourcePosition: node functionOrMacroExpression sourcePosition;
                    value: functional;
                    yourself);
                analyzeAndEvaluateWithEnvironment: environment
        }.
    }.

    public virtual eager method analyzeUnexpandedApplicationNode: (node: ASTUnexpandedApplicationNode) withEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> Untyped := {
        node functionOrMacroExpression isLiteralNode && (node functionOrMacroExpression downCastTo: ASTLiteralNode) value isMacro ifTrue: {
            environment analyzeWithCurrentExpectedType: (node expandWithMacro: (node functionOrMacroExpression downCastTo: ASTLiteralNode) value environment: environment)
        } ifFalse: {
            node asFunctionApplicationNode analyzeWithEnvironment: environment
        }.
    }.
}.

Type definition: {
    public virtual eager method analyzeAndEvaluateUnexpandedApplicationNode: (node: ASTUnexpandedApplicationNode) of: (functional: Untyped) withEnvironment: (environment: Environment) ::=> Untyped := {
        node asFunctionApplicationNode
            functionExpression: (ASTLiteralNode new
                sourcePosition: node functionOrMacroExpression sourcePosition;
                value: functional;
                yourself);
            analyzeAndEvaluateWithEnvironment: environment
    }.

    public virtual eager method analyzeUnexpandedApplicationNode: (node: ASTUnexpandedApplicationNode) withEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> Untyped := {
        node asFunctionApplicationNode analyzeWithEnvironment: environment
    }.
}.

Function class definition: {
    public virtual eager method analyzeAndEvaluateUnexpandedApplicationNode: (node: ASTUnexpandedApplicationNode) of: (functional: Untyped) withEnvironment: (environment: Environment) ::=> Untyped := {
        functional isMacro ifTrue: {
            (node expandWithMacro: functional environment: environment) analyzeAndEvaluateWithEnvironment: environment
        } ifFalse: {
            super analyzeAndEvaluateUnexpandedApplicationNode: node of: functional withEnvironment: environment
        }.
    }.

    public virtual eager method analyzeUnexpandedApplicationNode: (node: ASTUnexpandedApplicationNode) withEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> Untyped := {
        node functionOrMacroExpression isLiteralNode && (node functionOrMacroExpression downCastTo: ASTLiteralNode) value isMacro ifTrue: {
            (node expandWithMacro: (node functionOrMacroExpression downCastTo: ASTLiteralNode) value environment: environment) analyzeWithEnvironment: environment
        } ifFalse: {
            super analyzeUnexpandedApplicationNode: node withEnvironment: environment
        }.
    }.
}.

FunctionType definition: {
    public virtual eager method analyzeAndEvaluateUnexpandedApplicationNode: (node: ASTUnexpandedApplicationNode) of: (functional: Untyped) withEnvironment: (environment: Environment) ::=> Untyped := {
        functional isMacro ifTrue: {
            (node expandWithMacro: functional environment: environment) analyzeAndEvaluateWithEnvironment: environment
        } ifFalse: {
            super analyzeAndEvaluateUnexpandedApplicationNode: node of: functional withEnvironment: environment
        }.
    }.

    public virtual eager method analyzeUnexpandedApplicationNode: (node: ASTUnexpandedApplicationNode) withEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> Untyped := {
        node functionOrMacroExpression isLiteralNode && (node functionOrMacroExpression downCastTo: ASTLiteralNode) value isMacro ifTrue: {
            (node expandWithMacro: (node functionOrMacroExpression downCastTo: ASTLiteralNode) value environment: environment) analyzeWithEnvironment: environment
        } ifFalse: {
            super analyzeUnexpandedApplicationNode: node withEnvironment: environment
        }.
    }.
}.

MetaBuilder class definition: {
    public virtual eager method analyzeUnexpandedApplicationNode: (node: ASTUnexpandedApplicationNode) withEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> Untyped := {
        node functionOrMacroExpression isLiteralNode ifTrue: {
            (node functionOrMacroExpression downCastTo: ASTLiteralNode) value analyzeUnexpandedApplicationNode: node withEnvironment: environment
        } ifFalse: {
            super analyzeUnexpandedApplicationNode: node withEnvironment: environment
        }.
    }.
}.

ASTUnexpandedApplicationNode definition: {
    public override method analyzeAndEvaluateWithEnvironment: (environment: Environment) ::=> Untyped := {
        let functionOrMacro := self functionOrMacroExpression analyzeAndEvaluateWithEnvironment: environment.
        RawTuple::type(functionOrMacro) analyzeAndEvaluateUnexpandedApplicationNode: self of: functionOrMacro withEnvironment: environment
    }.

    public override eager method analyzeWithEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode := {
        let result := self copy
            analyzerToken: environment validAnalyzerToken;
            functionOrMacroExpression: (environment analyzeWithDecayedType: self functionOrMacroExpression);
            yourself.
        result functionOrMacroExpression analyzedType analyzeUnexpandedApplicationNode: result withEnvironment: environment
    }.
}.

ASTFunctionApplicationNode definition: {
    public eager method optimizePureApplicationWithEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode := {
        let canOptimize := self functionExpression isLiteralPureFunctionNode
            && (self arguments allSatisfy: {:(ASTNode)each :: Boolean | each isLiteralNode }).
        canOptimize
            ifTrue: (environment newLiteral: (self analyzeAndEvaluateWithEnvironment: environment) at: self sourcePosition)
            ifFalse: (self)
    }.
}.

public final class MessageSendNodeStaticLookupResult superclass: Object; definition: {
    public field foundMethod => AnyValue.
    public field owner => Type.
    public field selector => Symbol.
    public field isDoesNotUnderstand => Boolean.

    public eager method isMacro => Boolean
        := (foundMethod answersTo: #isMacro) && foundMethod isMacro.
    public eager method isFinal => Boolean
        := (foundMethod answersTo: #isFinal) && foundMethod isFinal.
    public eager method hasVirtualDispatch => Boolean
        := (foundMethod answersTo: #hasVirtualDispatch) && foundMethod hasVirtualDispatch.

    public eager method shouldOptimizeLookup => Boolean
        := isDoesNotUnderstand not && (owner isFinal || self isMacro || self isFinal || self hasVirtualDispatch not).
}.

ASTMessageSendNode definition: {
    public eager method expandWithDoesNotUnderstandMacro: macroFunction environment: (environment: Environment) ::=> ASTNode := {
        let macroContext := MacroContext new
            sourceNode: self;
            sourcePosition: self sourcePosition;
            environment: environment;
            yourself.
        macroFunction(macroContext, self receiver, self)
    }.

    public eager method expandWithMacro: macroFunction environment: (environment: Environment) ::=> ASTNode := {
        let macroContext := MacroContext new
            sourceNode: self;
            sourcePosition: self sourcePosition;
            environment: environment;
            yourself.
        macroFunction applyWithArguments: (Array with: macroContext with: self receiver) -- self arguments
    }.
}.

ASTMessageChainMessageNode definition: {
    public eager method analyzeAndEvaluateWithReceiver: (receiver: Untyped) environment: (environment: Environment) ::=> Untyped
        := (self asMessageSendNodeWithReceiver: (ASTLiteralNode new
            sourcePosition: self sourcePosition;
            value: receiver;
            yourself)) analyzeAndEvaluateWithEnvironment: environment.
}.

ASTMessageChainNode definition: {
    public eager method expandAsSequence => ASTNode := {
        let messageCount := self messages size.
        messageCount = 0sz ifTrue: {
            return: self receiver
        }.
        messageCount = 1sz ifTrue: {
            let message => ASTMessageChainMessageNode := self messages first.
            return: (message asMessageSendNodeWithReceiver: self receiver receiverLookupType: self receiverLookupType)
        }.

        self receiver isLiteralNode ifTrue: {
            return: (ASTSequenceNode new
                sourcePosition: self sourcePosition;
                pragmas: #();
                expressions: (self messages collect: {:(ASTMessageChainMessageNode)eachMessage :: ASTNode |
                    eachMessage asMessageSendNodeWithReceiver: self receiver receiverLookupType: self receiverLookupType
                });
                yourself)
        }.

        let expansionSymbol := GeneratedSymbol new
            sourcePosition: self sourcePosition;
            value: #"<messageChainReceiver>";
            yourself.

        let expansionReceiverExpression := ASTLocalDefinitionNode new
            sourcePosition: self sourcePosition;
            nameExpression: (ASTLiteralNode new
                sourcePosition: self sourcePosition;
                value: expansionSymbol;
                yourself);
            valueExpression: self receiver;
            typeExpression: (ASTLiteralNode new
                sourcePosition: self sourcePosition;
                value: DirectTypeInferenceType;
                yourself);
            yourself.

        let expansionReceiverIdentifier := ASTIdentifierReferenceNode new
            sourcePosition: self sourcePosition;
            value: expansionSymbol;
            yourself.

        let expansionReceiverLookupType := self receiverLookupType.

        ASTSequenceNode new
            sourcePosition: self sourcePosition;
            pragmas: #();
            expressions: (Array with: expansionReceiverExpression) -- (self messages collect: {:(ASTMessageChainMessageNode)eachMessage :: ASTNode |
                eachMessage asMessageSendNodeWithReceiver: expansionReceiverIdentifier receiverLookupType: expansionReceiverLookupType
            });
            yourself
    }
}.

Type definition: {
    public virtual eager method analyzeAndTypeCheckFunctionApplicationNode: (node: ASTFunctionApplicationNode) withEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode := {
        node
            analyzedType: AnyValue;
            arguments: (node arguments collect: {:(ASTNode)each :: ASTNode | environment analyzeWithDecayedType: each});
            optimizePureApplicationWithEnvironment: environment
    }.

    public virtual eager method analyzeAndTypeCheckSolvedMessageSendNode: (node: ASTMessageSendNode) withEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode
        := node
            analyzedType: AnyValue;
            receiver: (node receiver ifNotNil: (environment analyzeWithReceiverType: node receiver));
            arguments: (node arguments collect: {:(ASTNode)each :: ASTNode | environment analyzeWithDecayedType: each});
            yourself.

    public virtual eager method messageSendNodeStaticLookupDirectSelector: (selector: Symbol) ::=> MessageSendNodeStaticLookupResult := {
        let foundMethod mutable => AnyValue := nil.
        foundMethod := self lookupMacroSelector: selector.
        foundMethod ifNil: {
            foundMethod := self lookupSelector: selector.
            foundMethod ifNil: {
                foundMethod := self lookupFallbackSelector: selector.
            }.
        }.

        foundMethod ifNotNil: (MessageSendNodeStaticLookupResult new
            foundMethod: foundMethod;
            owner: self;
            selector: selector;
            yourself)
    }.

    public virtual eager method messageSendNodeStaticLookupDoesNotUnderstandSelector ::=> MessageSendNodeStaticLookupResult := {
        let foundMethod mutable => AnyValue := nil.
        let selector := #doesNotUnderstand:.
        foundMethod := self lookupMacroSelector: selector.
        foundMethod ifNil: {
            foundMethod := self lookupSelector: selector.
            foundMethod ifNil: {
                foundMethod := self lookupFallbackSelector: selector.
            }.
        }.

        foundMethod ifNotNil: (MessageSendNodeStaticLookupResult new
            foundMethod: foundMethod;
            owner: self;
            selector: selector;
            isDoesNotUnderstand: true;
            yourself)
    }.

    public virtual eager method messageSendNodeStaticLookupSelector: (selector: Symbol) ::=> MessageSendNodeStaticLookupResult
        := (self messageSendNodeStaticLookupDirectSelector: selector) ifNil: (self messageSendNodeStaticLookupDoesNotUnderstandSelector).

    public virtual eager method analyzeAndEvaluateUnboundMessageSendNode: (node: ASTMessageSendNode) forReceiver: (receiver: Untyped) selector: (selector: Symbol) withEnvironment: (environment: Environment) ::=> Untyped
        := node semanticError: "Message " -- selector printString -- " not understood by " -- self printString -- ".".

    public virtual eager method analyzeAndEvaluateOrdinaryMessageSendNode: (node: ASTMessageSendNode) forReceiver: (receiver: Untyped) withEnvironment: (environment: Environment) ::=> Untyped := {
        let selector => Symbol := node selector analyzeAndEvaluateWithEnvironment: environment.
        let staticMethod := self messageSendNodeStaticLookupSelector: selector.

        staticMethod ifNotNil: {
            ## Is this a macro that we should expand?
            staticMethod isMacro ifTrue: {
                let newMessageNode := node copy
                    receiver: (ASTLiteralNode new
                        analyzedType: RawTuple::type(receiver);
                        sourcePosition: node receiver sourcePosition;
                        value: receiver;
                        yourself);
                    selector: (ASTLiteralNode new
                        analyzedType: selector __type__;
                        sourcePosition: node selector sourcePosition;
                        value: selector;
                        yourself);
                    yourself.
                let expandedNode := staticMethod isDoesNotUnderstand
                    ifTrue: (newMessageNode expandWithDoesNotUnderstandMacro: staticMethod foundMethod environment: environment)
                    ifFalse: (newMessageNode expandWithMacro: staticMethod foundMethod environment: environment).
                return: (expandedNode analyzeAndEvaluateWithEnvironment: environment)
            }.

            let arguments := node arguments collect: {:(ASTNode)eachArgumentNode :: Untyped |
                eachArgumentNode analyzeAndEvaluateWithEnvironment: environment
            }.

            staticMethod isDoesNotUnderstand ifTrue: {
                staticMethod foundMethod(receiver, Message new
                    selector: selector;
                    arguments: arguments;
                    yourself)
            } ifFalse: {
                staticMethod foundMethod applyWithArguments: (Array with: receiver) -- arguments
            }
        } ifNil: {
            ## Analyze and evaluate an unbound message.
            self analyzeAndEvaluateUnboundMessageSendNode: node forReceiver: receiver selector: selector withEnvironment: environment
        }.
    }.

    public virtual eager method analyzeAndEvaluateMessageSendNode: (node: ASTMessageSendNode) forReceiver: (receiver: Untyped) withEnvironment: (environment: Environment) ::=> Untyped
        := self analyzeAndEvaluateOrdinaryMessageSendNode: node forReceiver: receiver withEnvironment: environment.

    public virtual eager method analyzeAndEvaluateOrdinaryMessageChainNode: (node: ASTMessageChainNode) forReceiver: (receiver: Untyped) withEnvironment: (environment: Environment) ::=> Untyped := {
        let result := ValueBox with: receiver.
        node messages do: {:(ASTMessageChainMessageNode)chainedMessage :: Void |
            result := chainedMessage analyzeAndEvaluateWithReceiver: receiver environment: environment.
        }.

        result value
    }.

    public virtual eager method analyzeAndEvaluateMessageChainNode: (node: ASTMessageChainNode) forReceiver: (receiver: Untyped) withEnvironment: (environment: Environment) ::=> Untyped
        := self analyzeAndEvaluateOrdinaryMessageChainNode: node forReceiver: receiver withEnvironment: environment.

    public virtual eager method analyzeUnboundMessageNode: (node: ASTMessageSendNode) withEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode
        := node
            analyzedType: AnyValue;
            receiver: (node receiver ifNotNil: (environment analyzeWithDecayedType: node receiver));
            arguments: (node arguments collect: {:(ASTNode)each :: ASTNode | environment analyzeWithDecayedType: each});
            yourself.

    public virtual eager method analyzeOrdinaryMessageNode: (node: ASTMessageSendNode) withEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode := {
        node selector: (environment analyze: node selector withExpectedType: Symbol).

        let staticMethod := node selector isLiteralNode
            ifTrue: (self messageSendNodeStaticLookupSelector: (node selector downCastTo: ASTLiteralNode) value)
            ifFalse: (nil).

        staticMethod ifNotNil: {
            staticMethod isMacro && staticMethod isDoesNotUnderstand ifTrue: {
                return: (environment analyzeWithCurrentExpectedType: (node expandWithDoesNotUnderstandMacro: staticMethod foundMethod environment: environment))
            }.

            staticMethod isDoesNotUnderstand ifFalse: {
                let hasLiteralReceiver := node receiver isLiteralNode.
                let hasExplicitSolvedLookupType := node receiverLookupType isNotNil && node receiverLookupType isLiteralNode.
                hasExplicitSolvedLookupType || hasLiteralReceiver || staticMethod shouldOptimizeLookup ifTrue: {
                    return: (ASTUnexpandedApplicationNode new
                        sourcePosition: node sourcePosition;
                        functionOrMacroExpression: (environment newLiteral: staticMethod foundMethod at: node sourcePosition);
                        arguments: (Array with: node receiver) -- node arguments;
                        analyzeWithEnvironment: environment
                    )
                }.

                node boundMethod: staticMethod foundMethod.
                return: (staticMethod foundMethod __type__ analyzeAndTypeCheckSolvedMessageSendNode: node withEnvironment: environment)
            }.
        }.

        staticMethod isNil || staticMethod isDoesNotUnderstand ifTrue: {
            node isDynamic || node receiver analyzedType asDecayedType isDynamic ifFalse: {
                node selector isLiteralNode ifTrue: {
                    let selector := (node selector downCastTo: ASTLiteralNode) value.
                    node semanticError: "Cannot send undeclared message with selector " -- selector printString -- " to receiver without dynamic type " -- node receiver analyzedType printString
                } ifFalse: {
                    node semanticError: "Cannot send undeclared message to receiver without dynamic type " -- node receiver analyzedType printString
                }
            }.
        }.

        self analyzeUnboundMessageNode: node withEnvironment: environment
    }.

    public virtual eager method analyzeOrdinaryMessageChainNode: (node: ASTMessageChainNode) withEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode
        := node expandAsSequence analyzeWithEnvironment: environment.

    MetaBuilder class definition: {
        public virtual eager method analyzeMessageSendNode: (node: ASTMessageSendNode) withEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode := {
            node receiver isLiteralNode ifTrue: {
                (node receiver downCastTo: ASTLiteralNode) value analyzeMessageSendNode: node withEnvironment: environment
            } ifFalse: {
                self analyzeOrdinaryMessageNode: node withEnvironment: environment
            }
        }.

        public virtual eager method analyzeMessageChainNode: (node: ASTMessageChainNode) withEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode := {
            node receiver isLiteralNode ifTrue: {
                (node receiver downCastTo: ASTLiteralNode) value analyzeOrdinaryMessageChainNode: node withEnvironment: environment
            } ifFalse: {
                self analyzeOrdinaryMessageChainNode: node withEnvironment: environment
            }
        }.
    }.

    public virtual eager method analyzeMessageSendNode: (node: ASTMessageSendNode) withEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode
        := self analyzeOrdinaryMessageNode: node withEnvironment: environment.

    public virtual eager method analyzeMessageChainNode: (node: ASTMessageChainNode) withEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode
        := self analyzeOrdinaryMessageChainNode: node withEnvironment: environment.
}.

PointerType definition: {
    public override eager method analyzeAndTypeCheckFunctionApplicationNode: (node: ASTFunctionApplicationNode) withEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode
        := baseType analyzeAndTypeCheckFunctionApplicationNode: node withEnvironment: environment.
}.

ReferenceType definition: {
    public override eager method messageSendNodeStaticLookupDirectSelector: (selector: Symbol) ::=> MessageSendNodeStaticLookupResult
        := (super messageSendNodeStaticLookupDirectSelector: selector) ifNil: (baseType messageSendNodeStaticLookupDirectSelector: selector).

    public override eager method messageSendNodeStaticLookupDoesNotUnderstandSelector ::=> MessageSendNodeStaticLookupResult
        := super messageSendNodeStaticLookupDoesNotUnderstandSelector ifNil: (baseType messageSendNodeStaticLookupDoesNotUnderstandSelector).
}.

SimpleFunctionType definition: {
    public virtual eager method analyzeAndTypeCheckFunctionApplicationNode: (node: ASTFunctionApplicationNode) withEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode := {
        let isVariadic := self isVariadic.
        let isMemoizedTemplate := self isMemoizedTemplate.

        let typeArgumentCount := argumentTypes size.
        let expectedArgumentCount mutable := typeArgumentCount.
        let applicationArgumentCount := node arguments size.
        let startingArgumentIndex := isMemoizedTemplate ifTrue: 1sz ifFalse: 0sz.
        isVariadic && (typeArgumentCount = 0sz) ifTrue: {
            node semanticError: "Variadic applications require at least a single argument."
        }.

        let directApplicationArgumentCount mutable := isVariadic ifTrue: (typeArgumentCount - 1sz) ifFalse: (typeArgumentCount).
        isMemoizedTemplate ifTrue: {
            expectedArgumentCount = 0sz ifTrue: {
                node semanticError: "Memoized template requires at least a single argument."
            }.

            expectedArgumentCount := expectedArgumentCount - 1sz.
            directApplicationArgumentCount := directApplicationArgumentCount - 1sz.
        }.

        isVariadic && (applicationArgumentCount < directApplicationArgumentCount) ifTrue: {
            node semanticError: "Missing required arguments."
        }.
        isVariadic not && (applicationArgumentCount ~= expectedArgumentCount) ifTrue: {
            node semanticError: "Expected number of arguments is mismatching."
        }.

        ## Create the direct analyzed argument list.
        let analyzedArguments := Array new: expectedArgumentCount.
        let argumentIndex mutable := 0sz.
        while: (argumentIndex < directApplicationArgumentCount) do: {
            let expectedType := argumentTypes at: startingArgumentIndex + argumentIndex.
            analyzedArguments
                at: argumentIndex
                put: (environment analyze: (node arguments at: argumentIndex) withExpectedType: expectedType)
        } continueWith: (argumentIndex := argumentIndex + 1sz).

        ## Analyze the variadic arguments.
        isVariadic ifTrue: {
            let expectedVariadicVectorType := argumentTypes at: directApplicationArgumentCount.
            let variadicArguments := ASTMakeArrayNode new
                sourcePosition: node sourcePosition;
                elements: (node arguments allButFirst: directApplicationArgumentCount);
                yourself.
            
            analyzedArguments at: directApplicationArgumentCount put: (environment analyze: variadicArguments withExpectedType: expectedVariadicVectorType)
        } ifFalse: {
            self assert: argumentIndex = analyzedArguments size.
        }.



        node
            arguments: analyzedArguments;
            analyzedType: resultType;
            applicationFlags: node applicationFlags | (isMemoizedTemplate ifTrue: 0bflgs ifFalse: FunctionApplicationFlags::NoTypecheck) | FunctionApplicationFlags::VariadicExpanded;
            optimizePureApplicationWithEnvironment: environment
    }.

    public override eager method analyzeAndTypeCheckSolvedMessageSendNode: (node: ASTMessageSendNode) withEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode := {
        let firstArgumentIndex := node receiver ifNil: 0sz ifNotNil: 1sz.
        node
            analyzedType: self canonicalResultType;
            receiver: (node receiver ifNotNil: (environment analyze: node receiver withExpectedType: argumentTypes first));
            arguments: (node arguments collectWithIndex: {:(ASTNode)eachArgument :(Size)eachArgumentIndex :: ASTNode |
                environment analyze: eachArgument withExpectedType: (argumentTypes at: firstArgumentIndex + eachArgumentIndex)
            });
            yourself
    }.
}.

DependentFunctionType definition: {
    public method initializeWithFunctionAnalysisEnvironment: (functionAnalysisEnvironment: FunctionAnalysisEnvironment)
        argumentNodes: (theArgumentNode: Array) resultTypeNode: (theResultTypeNode: ASTNode) functionFlags: (theFunctionFlags: Bitflags) ::=> Void := {

        supertype := Function.
        flags := supertype flags | TypeFlags::Function.
        totalSlotCount := supertype totalSlotCount.
        instanceSize := supertype validInstanceSize.
        instanceAlignment := supertype instanceAlignment.

        functionFlags := theFunctionFlags.
        argumentNodes := theArgumentNode.
        resultTypeNode := theResultTypeNode.

        environment := functionAnalysisEnvironment.
        captureBindings := functionAnalysisEnvironment captureBindingList asArray.
        argumentBindings := functionAnalysisEnvironment argumentBindingList asArray.
        localBindings := functionAnalysisEnvironment localBindingList asArray.
    }.

    public method canonicalize => FunctionType := {
        let hasLiteralResultType := resultTypeNode isNil || resultTypeNode isLiteralNode.
        let hasLiteralArguments := argumentNodes allSatisfy: {:(ASTArgumentNode)each :: Boolean |
            each type isNil || each type isLiteralNode
        }.

        hasLiteralResultType && hasLiteralArguments ifTrue: {
            let resultType => Type := resultTypeNode
                ifNil: (AnyValue)
                ifNotNil: (resultTypeNode downCastTo: ASTLiteralNode) value.
            let argumentTypes := argumentNodes collect: {:(ASTArgumentNode)eachArgumentNode :: Type |
                eachArgumentNode type
                    ifNil: (AnyValue)
                    ifNotNil: (eachArgumentNode type downCastTo: ASTLiteralNode) value.
            }.

            SimpleFunctionTypeTemplate(argumentTypes, functionFlags, resultType)
        } ifFalse: {
            self
        }
    }.

    public override eager method canonicalResultType => Type
        := resultTypeNode isNotNil && resultTypeNode isLiteralNode
            ifTrue: (resultTypeNode downCastTo: ASTLiteralNode) value
            ifFalse: AnyValue.

    public override eager method canonicalTypeForApplicationArgumentWithIndex: (argumentIndex: Size) ::=> Type := {
        argumentIndex < self argumentBindings size
            ifTrue: (argumentBindings at: argumentIndex) type
            ifFalse: AnyValue
    }.

    public eager method createActivationEnvironment => FunctionActivationEnvironment := {
        (FunctionActivationEnvironment parent: nil)
            dependentFunctionType: self;
            captureVector: SequenceTupleTypeTemplate(#()) new;
            argumentVectorSize: argumentBindings size;
            valueVector: (Array new: argumentBindings size + localBindings size);
            yourself
    }.

    public eager method canonicalizeDependentResultType: (type: Type) ::=> Type
        := if: (nil == type) || RawTuple::isDummyValue(type)
            then: AnyValue
            else: type.

    public virtual eager method analyzeAndTypeCheckFunctionApplicationNode: (applicationNode: ASTFunctionApplicationNode) withEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode := {
        let argumentNodeCount := argumentNodes size.
        let directEvaluationArgumentNodeCount mutable := argumentNodeCount.
        let applicationArgumentCount := applicationNode arguments size.

        let isVariadic := self isVariadic.
        isVariadic ifTrue: {
            directEvaluationArgumentNodeCount = 0sz ifTrue: {
                applicationNode semanticError: "Variadic functions require at least a single argument."
            }.

            directEvaluationArgumentNodeCount := directEvaluationArgumentNodeCount - 1sz.
        }.

        let isMemoizedTemplate := self isMemoizedTemplate.
        isMemoizedTemplate ifTrue: {
            error("TODO: Implement this case.").
        }.

        let sourceArgumentIndex mutable := 0sz.

        let applicationEnvironment := self createActivationEnvironment.
        let analyzedArguments := Array new: applicationArgumentCount.
        argumentNodes doWithIndex: {:(ASTArgumentNode)typeArgumentNode :(Size)typeArgumentNodeIndex :: Void |
            typeArgumentNode isForAll ifTrue: {
                error("TODO: Implement support for forall arguments.").
            } ifFalse: {
                sourceArgumentIndex < applicationNode arguments size ifFalse: {
                    applicationNode semanticError: "Function application is missing required arguments."
                }.

                let applicationArgument := applicationNode arguments at: sourceArgumentIndex.
                let expectedType := typeArgumentNode evaluateDependentArgumentTypeInEnvironment: applicationEnvironment.
                let analyzedArgument := environment analyze: applicationArgument withExpectedType: expectedType.
                analyzedArguments at: sourceArgumentIndex put: analyzedArgument.
                sourceArgumentIndex := sourceArgumentIndex + 1sz.

                let applicationValue := analyzedArgument getOrCreateDependentApplicationValue.
                applicationEnvironment bindArgumentNodeAt: typeArgumentNodeIndex value: applicationValue
            }
        }.

        isVariadic not && (sourceArgumentIndex = applicationArgumentCount) ifFalse: {
            applicationNode semanticError: "Message send is not receiving the expected number of arguments."
        }.

        ## Remaining variadic arguments.
        while: (sourceArgumentIndex < applicationArgumentCount) do: {
            let variadicArgument := environment analyzeWithDecayedType: (applicationNode arguments at: sourceArgumentIndex).
            analyzedArguments at: sourceArgumentIndex put: variadicArgument
        } continueWith: (sourceArgumentIndex := sourceArgumentIndex + 1sz).
        applicationNode arguments: analyzedArguments.

        let resultType => Type := resultTypeNode
            ifNil: AnyValue
            ifNotNil: (resultTypeNode evaluateWithEnvironment: applicationEnvironment).
        applicationNode
            analyzedType: (self canonicalizeDependentResultType: resultType);
            applicationFlags: applicationNode applicationFlags | (isMemoizedTemplate ifTrue: 0bflgs ifFalse: FunctionApplicationFlags::NoTypecheck);
            optimizePureApplicationWithEnvironment: environment
    }.

    public override eager method analyzeAndTypeCheckSolvedMessageSendNode: (sendNode: ASTMessageSendNode) withEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode := {
        let applicationEnvironment := self createActivationEnvironment.

        let argumentNodeCount := argumentNodes size.
        let directEvaluationArgumentNodeCount := argumentNodeCount.
        let applicationArgumentCount := sendNode arguments size.

        let sourceArgumentIndex mutable := 0sz.
        let hasAnalyzedReceiver mutable := false.

        let analyzedArguments := Array new: applicationArgumentCount.
        argumentNodes doWithIndex: {:(ASTArgumentNode)typeArgumentNode :(Size)typeArgumentNodeIndex :: Void |
            typeArgumentNode isForAll ifTrue: {
                error("TODO: Implement support for forall arguments.").
            } ifFalse: {
                let isReceiver := hasAnalyzedReceiver not && sendNode receiver isNotNil.
                let applicationArgument := isReceiver ifTrue: {
                    sendNode receiver
                } ifFalse: {
                    sourceArgumentIndex < sendNode arguments size ifFalse: {
                        sendNode semanticError: "Message send is missing required arguments."
                    }.
                    sendNode arguments at: sourceArgumentIndex
                }.

                let expectedType := typeArgumentNode evaluateDependentArgumentTypeInEnvironment: applicationEnvironment.
                let analyzedArgument := environment analyze: applicationArgument withExpectedType: expectedType.
                isReceiver ifTrue: {
                    sendNode receiver: analyzedArgument.
                    hasAnalyzedReceiver := true.
                } ifFalse: {
                    analyzedArguments at: sourceArgumentIndex put: analyzedArgument.
                    sourceArgumentIndex := sourceArgumentIndex + 1sz
                }.

                let applicationValue := analyzedArgument getOrCreateDependentApplicationValue.
                applicationEnvironment bindArgumentNodeAt: typeArgumentNodeIndex value: applicationValue
            }
        }.

        sourceArgumentIndex = applicationArgumentCount ifFalse: {
            sendNode semanticError: "Message send is not receiving the expected number of arguments."
        }.
        sendNode arguments: analyzedArguments.

        let resultType => Type := resultTypeNode
            ifNil: AnyValue
            ifNotNil: (resultTypeNode evaluateWithEnvironment: applicationEnvironment).
        sendNode
            analyzedType: (self canonicalizeDependentResultType: resultType);
            yourself
    }.
}.

FunctionDefinition definition: {
    public eager method ensureTypeAnalysis => Void := {
        definitionArgumentNodes ifNil: {return: void}.
        analyzedType ifNotNil: {return: void}.

        analysisEnvironment := FunctionAnalysisEnvironment parent: definitionEnvironment.
        analysisEnvironment functionDefinition: self.

        analyzedArgumentNodes := definitionArgumentNodes collect: {:(ASTNode)each :: ASTNode |
            analysisEnvironment analyzeIfNeeded: each
        }.

        definitionResultTypeNode ifNotNil: {
            analyzedResultTypeNode := analysisEnvironment analyze: definitionResultTypeNode withExpectedType: Type
        }.

        analyzedType := DependentFunctionType new 
            initializeWithFunctionAnalysisEnvironment: analysisEnvironment
                argumentNodes: analyzedArgumentNodes resultTypeNode: analyzedResultTypeNode functionFlags: flags & FunctionFlags::TypeFlags;
            canonicalize.
        analysisEnvironment returnTypeExpression: analyzedResultTypeNode.
    }.

    public eager override method ensureAnalysis => Void := {
        analyzedCaptures ifNotNil: {return: void}.
        definitionBodyNode ifNil: {return: void}.
        self ensureTypeAnalysis.

        analyzedBodyNode := (analysisEnvironment analyze: definitionBodyNode withExpectedTypeExpression: analyzedResultTypeNode at: sourcePosition) node.

        analyzedCaptures := analysisEnvironment captureBindingList asArray.
        analyzedArguments := analysisEnvironment argumentBindingList asArray.
        analyzedLocals := analysisEnvironment localBindingList asArray.
        analyzedPragmas := analysisEnvironment pragmaList asArray.
        analyzedInnerFunctions := analysisEnvironment innerFunctionList asArray.
        analyzedPrimitiveName := analysisEnvironment primitiveName.

        let captureTypes := analyzedCaptures collect: {:(SymbolBinding)eachCaptureBinding :: Type | eachCaptureBinding type ifNil: Untyped}.
        analyzedCaptureVectorType := SequenceTupleTypeTemplate(captureTypes).
    }.
}.

ASTFunctionApplicationNode definition: {
    public override method analyzeAndEvaluateWithEnvironment: (environment: Environment) ::=> Untyped := {
        let function := self functionExpression analyzeAndEvaluateWithEnvironment: environment.
        let arguments := self arguments collect: {:(ASTNode)each :: Untyped | each analyzeAndEvaluateWithEnvironment: environment}.
        function applyWithArguments: arguments
    }.

    public override eager method analyzeWithEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode := {
        let result := self copy
            analyzerToken: environment validAnalyzerToken;
            functionExpression: (environment analyzeWithDecayedType: self functionExpression);
            yourself.
        result functionExpression analyzedType analyzeAndTypeCheckFunctionApplicationNode: self withEnvironment: environment
    }.

    public override eager method evaluateWithEnvironment: (environment: FunctionActivationEnvironment) ::=> Untyped := {
        let function := self functionExpression evaluateWithEnvironment: environment.
        let arguments := self arguments collect: {:(ASTNode)each :: Untyped | each evaluateWithEnvironment: environment}.
        function applyWithArguments: arguments
    }.
}.

ASTMessageSendNode definition: {
    public override method analyzeAndEvaluateWithEnvironment: (environment: Environment) ::=> Untyped := {
        self receiver ifNotNil: {
            let receiver := self receiver analyzeAndEvaluateWithEnvironment: environment.
            let receiverLookupType => Type := self receiverLookupType
                ifNil: (RawTuple::type(receiver))
                ifNotNil: (self receiverLookupType analyzeAndEvaluateWithEnvironment: environment).

            receiverLookupType analyzeAndEvaluateMessageSendNode: self forReceiver: receiver withEnvironment: environment
        } ifNil: {
            let selector => Symbol := self selector analyzeAndEvaluateWithEnvironment: environment.
            let binding := environment lookSymbolRecursively: selector.
            binding ifNil: {
                self semanticError: "Failed to find binding for symbol " -- selector printString
            }.
            
            let methodObject => AnyValue := binding analyzeAndEvaluateWithEnvironment: environment at: self sourcePosition.

            (methodObject answersTo: #isMacro) && methodObject isMacro ifTrue: {
                let macroContext := MacroContext new
                    sourceNode: self;
                    sourcePosition: self sourcePosition;
                    environment: environment;
                    yourself.
                let expandedMacro => ASTNode := methodObject applyWithArguments: (Array with: macroContext) -- self arguments.
                expandedMacro analyzeAndEvaluateWithEnvironment: environment
            } ifFalse: {
                let arguments := self arguments collect: {:(ASTNode)each :: Untyped | each analyzeAndEvaluateWithEnvironment: environment }.
                methodObject applyWithArguments: arguments
            }
        }.
    }.

    public override eager method analyzeWithEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode := {
        let result := self copy
            analyzerToken: environment validAnalyzerToken;
            yourself.

        result receiver ifNotNil: {
            result receiver: (environment analyzeWithDirectType: result receiver).

            result receiver isTupleWithLookupStartingFromNode ifTrue: {
                let receiverWithTypeNode := result receiver downCastTo: ASTTupleWithLookupStartingFromNode.
                result
                    receiver: receiverWithTypeNode tupleExpression;
                    receiverLookupType: receiverWithTypeNode typeExpression
            }.

            let receiverType := result receiverLookupType ifNotNil: {
                result receiverLookupType: (environment analyze: result receiverLookupType withExpectedType: Type).
                result receiverLookupType isLiteralNode ifFalse: {
                    result receiverLookupType semanticError: "Receiver explicit lookup type expression must be solved into a literal."
                }.

                (result receiverLookupType downCastTo: ASTLiteralNode) value
            } ifNil: {
                result receiver analyzedType
            }.

            receiverType analyzeMessageSendNode: result withEnvironment: environment
        } ifNil: {
            result selector: (environment analyze: result selector withExpectedType: Symbol).
            result selector isLiteralNode ifFalse: {
                result selector semanticError: "Message sends without receiver must have a literal selector."
            }.

            let selectorValue := (result selector downCastTo: ASTLiteralNode) value.
            let identifierNode := ASTIdentifierReferenceNode new
                sourcePosition: result selector sourcePosition;
                value: selectorValue;
                yourself.
            ASTUnexpandedApplicationNode new
                sourcePosition: result sourcePosition;
                functionOrMacroExpression: identifierNode;
                arguments: result arguments;
                analyzeWithEnvironment: environment
        }
    }.

    public override eager method evaluateWithEnvironment: (environment: FunctionActivationEnvironment) ::=> Untyped := {
        let receiver := self receiver evaluateWithEnvironment: environment.
        let selector := self selector evaluateWithEnvironment: environment.
        let arguments := self arguments collect: {:(ASTNode)eachArgument :: Untyped | eachArgument evaluateWithEnvironment: environment}.

        let receiverLookupType => Type := self receiverLookupType
            ifNil: RawTuple::type(receiver)
            ifNotNil: (self receiverLookupType evaluateWithEnvironment: environment).
        let foundMethod := receiverLookupType lookupSelector: selector.
        foundMethod ifNotNil: {
            foundMethod applyWithArguments: (Array with: receiver) -- arguments
        } ifNil: {
            let doesNotUnderstand := receiverLookupType lookupSelector: #doesNotUnderstand:.
            doesNotUnderstand ifNil: (self error: "Message " -- selector printString -- " not understood by " -- receiverLookupType printString -- ".").
            doesNotUnderstand(receiver, Message new
                selector: selector;
                arguments: arguments;
                yourself
            )
        }
    }.
}.

ASTMessageChainNode definition: {
    public override method analyzeAndEvaluateWithEnvironment: (environment: Environment) ::=> Untyped := {
        self receiver ifNotNil: {
            let receiver := self receiver analyzeAndEvaluateWithEnvironment: environment.
            RawTuple::type(receiver) analyzeAndEvaluateMessageChainNode: self forReceiver: receiver withEnvironment: environment
        } ifNil: {
            let result := ValueBox with: nil.
            self messages do: {:(ASTMessageChainMessageNode)eachMessage :: Void |
                result := (eachMessage asMessageSendNodeWithReceiver: nil) analyzeAndEvaluateWithEnvironment: environment
            }.

            result value
        }.
    }.

    public override eager method analyzeWithEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode := {
        let result := self copy
            analyzerToken: environment validAnalyzerToken;
            yourself.

        result receiver ifNotNil: {
            result receiver: (environment analyzeWithDirectType: result receiver).

            result receiver isTupleWithLookupStartingFromNode ifTrue: {
                let receiverWithTypeNode := result receiver downCastTo: ASTTupleWithLookupStartingFromNode.
                result
                    receiver: receiverWithTypeNode tupleExpression;
                    receiverLookupType: receiverWithTypeNode typeExpression
            }.

            let receiverType := result receiverLookupType ifNotNil: {
                result receiverLookupType: (environment analyze: result receiverLookupType withExpectedType: Type).
                result receiverLookupType isLiteralNode ifFalse: {
                    result receiverLookupType semanticError: "Receiver explicit lookup type expression must be solved into a literal."
                }.

                (result receiverLookupType downCastTo: ASTLiteralNode) value
            } ifNil: {
                result receiver analyzedType
            }.

            receiverType analyzeMessageChainNode: result withEnvironment: environment
        } ifNil: {
            error("TODO").
        }
    }.

    public override eager method evaluateWithEnvironment: (environment: FunctionActivationEnvironment) ::=> Untyped
        := self error: "Message chain node should be expanded."
}.

ASTTupleWithLookupStartingFromNode definition: {
    public override method analyzeAndEvaluateWithEnvironment: (environment: Environment) ::=> Untyped
        := self tupleExpression analyzeAndEvaluateWithEnvironment: environment.

    public override eager method analyzeWithEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode := {
        let analyzedTupleExpression := environment analyzeWithCurrentExpectedType: self tupleExpression.
        
        self copy
            analyzedType: analyzedTupleExpression analyzedType;
            analyzerToken: environment validAnalyzerToken;
            tupleExpression: analyzedTupleExpression;
            typeExpression: (environment analyze: self typeExpression withExpectedType: Type);
            yourself
    }.

    public override eager method evaluateWithEnvironment: (environment: FunctionActivationEnvironment) ::=> Untyped
        := self tupleExpression evaluateWithEnvironment: environment.
}.

ASTTupleSlotNamedAtNode definition: {
    public override method analyzeAndEvaluateWithEnvironment: (environment: Environment) ::=> Untyped := {
        let tuple := self tupleExpression analyzeAndEvaluateWithEnvironment: environment.
        let slot => TypeSlot := self boundSlot ifNotNil: {
            self boundSlot
        } ifNil: {
            let slotName := self nameExpression analyzeAndEvaluateWithEnvironment: environment.
            (RawTuple::type(tuple) asDecayedType lookupSlot: slotName) ifNil: {
                self semanticError: "Failed to find slot named " -- slotName printString -- ".".

            }
        }.

        (RawTuple::typeSlotAt:)(tuple, slot)
    }.

    public override eager method analyzeWithEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode := {
        let result := self copy
            analyzerToken: environment validAnalyzerToken;
            tupleExpression: (environment analyzeWithReceiverType: self tupleExpression);
            yourself.

        result nameExpression ifNotNil: {
            result nameExpression: (environment analyze: result nameExpression withExpectedType: Symbol).
            result nameExpression isLiteralNode ifFalse: {
                result nameExpression semanticError: "Literal slot name is required."
            }.

            let slotName => Symbol := (self nameExpression downCastTo: ASTLiteralNode) value.
            let slot := tupleExpression analyzedType asDecayedType lookupSlot: slotName.
            slot ifNil: {
                self semanticError: "Failed to find slot named " -- slotName printString -- ".".
            }.
            
            result boundSlot: slot
        } ifNil: {
            result boundSlot ifNil: {
                self semanticError: "ASTTupleSlotNamedAtNode without a name expression requires a explicit type slot."
            }
        }.

        result
            analyzedType: result boundSlot type;
            yourself
    }.

    public override eager method evaluateWithEnvironment: (environment: FunctionActivationEnvironment) ::=> Untyped := {
        let tuple := self tupleExpression evaluateWithEnvironment: environment.
        (RawTuple::typeSlotAt:)(tuple, self boundSlot)
    }.
}.

ASTTupleSlotNamedReferenceAtNode definition: {
    public override method analyzeAndEvaluateWithEnvironment: (environment: Environment) ::=> Untyped := {
        let tuple := self tupleExpression analyzeAndEvaluateWithEnvironment: environment.
        let slot => TypeSlot := self boundSlot ifNotNil: {
            self boundSlot
        } ifNil: {
            let slotName := self nameExpression analyzeAndEvaluateWithEnvironment: environment.
            (RawTuple::type(tuple) asDecayedType lookupSlot: slotName) ifNil: {
                self semanticError: "Failed to find slot named " -- slotName printString -- ".".

            }
        }.

        error("TODO: ASTTupleSlotNamedReferenceAtNode >> analyzeAndEvaluateWithEnvironment:").
    }.

    public override eager method analyzeWithEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode := {
        let result := self copy
            analyzerToken: environment validAnalyzerToken;
            tupleExpression: (environment analyzeWithReceiverType: self tupleExpression);
            yourself.

        result nameExpression ifNotNil: {
            result nameExpression: (environment analyze: result nameExpression withExpectedType: Symbol).
            result nameExpression isLiteralNode ifFalse: {
                result nameExpression semanticError: "Literal slot name is required."
            }.

            let slotName => Symbol := (self nameExpression downCastTo: ASTLiteralNode) value.
            let slot := tupleExpression analyzedType asDecayedType lookupSlot: slotName.
            slot ifNil: {
                self semanticError: "Failed to find slot named " -- slotName printString -- ".".
            }.
            
            result boundSlot: slot
        } ifNil: {
            result boundSlot ifNil: {
                self semanticError: "ASTTupleSlotNamedAtNode without a name expression requires a explicit type slot."
            }
        }.

        result
            analyzedType: result boundSlot validReferenceType;
            yourself
    }.

    public override eager method evaluateWithEnvironment: (environment: FunctionActivationEnvironment) ::=> Untyped := {
        let tuple := self tupleExpression evaluateWithEnvironment: environment.
        error("TODO: ASTTupleSlotNamedReferenceAtNode >> evaluateWithEnvironment:").
    }.
}.

ASTTupleSlotNamedAtPutNode definition: {
    public override method analyzeAndEvaluateWithEnvironment: (environment: Environment) ::=> Untyped := {
        let tuple := self tupleExpression analyzeAndEvaluateWithEnvironment: environment.
        let value := self valueExpression analyzeAndEvaluateWithEnvironment: environment.
        let slot => TypeSlot := self boundSlot ifNotNil: {
            self boundSlot
        } ifNil: {
            let slotName := self nameExpression analyzeAndEvaluateWithEnvironment: environment.
            (RawTuple::type(tuple) asDecayedType lookupSlot: slotName) ifNil: {
                self semanticError: "Failed to find slot named " -- slotName printString -- ".".
            }
        }.

        let coercedValue := slot type coerceValue: value.
        (RawTuple::typeSlotAt:put:)(tuple, slot, coercedValue).
        coercedValue
    }.

    public override eager method analyzeWithEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode := {
        let result := self copy
            analyzerToken: environment validAnalyzerToken;
            tupleExpression: (environment analyzeWithReceiverType: self tupleExpression);
            yourself.

        result nameExpression ifNotNil: {
            result nameExpression: (environment analyze: result nameExpression withExpectedType: Symbol).
            result nameExpression isLiteralNode ifFalse: {
                result nameExpression semanticError: "Literal slot name is required."
            }.

            let slotName => Symbol := (self nameExpression downCastTo: ASTLiteralNode) value.
            let slot := tupleExpression analyzedType asDecayedType lookupSlot: slotName.
            slot ifNil: {
                self semanticError: "Failed to find slot named " -- slotName printString -- ".".
            }.
            
            result boundSlot: slot
        } ifNil: {
            result boundSlot ifNil: {
                self semanticError: "ASTTupleSlotNamedAtNode without a name expression requires a explicit type slot."
            }
        }.

        result
            analyzedType: result boundSlot type;
            valueExpression: (environment analyze: result valueExpression withExpectedType: result boundSlot type);
            yourself
    }.

    public override eager method evaluateWithEnvironment: (environment: FunctionActivationEnvironment) ::=> Untyped := {
        let tuple := self tupleExpression evaluateWithEnvironment: environment.
        let value := self valueExpression evaluateWithEnvironment: environment.
        (RawTuple::typeSlotAt:put:)(tuple, self boundSlot, value).
        value
    }.
}.

ASTUseNamedSlotsOfNode definition: {
    public override method analyzeAndEvaluateWithEnvironment: (environment: Environment) ::=> Untyped := {
        let usedTuple := self tupleExpression analyzeAndEvaluateWithEnvironment: environment.
        let localBinding := environment setNewSymbol: nil valueBinding: usedTuple at: self sourcePosition.
        environment addUseTupleWithNamedSlotsBinding: localBinding.
        void
    }.

    public override eager method analyzeWithEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode := {
        let result := self copy
            analyzedType: Void;
            analyzerToken: environment validAnalyzerToken;
            tupleExpression: (environment analyzeWithReceiverType: tupleExpression);
            yourself.

        result tupleExpression isLiteralNode ifTrue: {
            let usedTuple := (result tupleExpression downCastTo: ASTLiteralNode) value.
            let localBinding := environment setNewSymbol: nil valueBinding: usedTuple at: self sourcePosition.
            environment addUseTupleWithNamedSlotsBinding: localBinding.
            environment newLiteral: void at: self sourcePosition
        } ifFalse: {
            let localBinding := environment setNewSymbol: nil localBindingOfType: result tupleExpression analyzedType at: result sourcePosition.
            environment addUseTupleWithNamedSlotsBinding: localBinding.
            result
                binding: localBinding;
                yourself
        }
    }.

    public override eager method evaluateWithEnvironment: (environment: FunctionActivationEnvironment) ::=> Untyped := {
        let usedTuple := self tupleExpression analyzeAndEvaluateWithEnvironment: environment.
        environment setBinding: self binding activationValue: usedTuple.
        void
    }.
}.

ASTBreakNode definition: {
    public override method analyzeAndEvaluateWithEnvironment: (environment: Environment) ::=> Untyped := {
        self semanticError: "TODO: ASTBreakNode analyzeAndEvaluateWithEnvironment"
    }.

    public override eager method analyzeWithEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode := {
        environment hasValidBreakTarget ifFalse: {
            self semanticError: "Cannot a break statement in this location."
        }.

        self copy
            analyzedType: ControlFlowBreakType;
            analyzerToken: environment validAnalyzerToken;
            yourself
    }.

    public override eager method evaluateWithEnvironment: (environment: FunctionActivationEnvironment) ::=> Untyped := {
        self semanticError: "TODO: ASTBreakNode analyzeWithEnvironment"
    }.
}.

ASTContinueNode definition: {
    public override method analyzeAndEvaluateWithEnvironment: (environment: Environment) ::=> Untyped := {
        self semanticError: "TODO: ASTContinueNode analyzeAndEvaluateWithEnvironment"
    }.

    public override eager method analyzeWithEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode := {
        environment hasValidContinueTarget ifFalse: {
            self semanticError: "Cannot a continue statement in this location."
        }.
        
        self copy
            analyzedType: ControlFlowContinueType;
            analyzerToken: environment validAnalyzerToken;
            yourself
    }.

    public override eager method evaluateWithEnvironment: (environment: FunctionActivationEnvironment) ::=> Untyped := {
        self semanticError: "TODO: ASTContinueNode analyzeWithEnvironment"
    }.
}.

Type definition: {
    public method computeTypeHierarchyDepth => Int32
        := supertype ifNil: 0i32 ifNotNil: supertype computeTypeHierarchyDepth + 1i32.
    Type ensureAnalysisOfMethodWithSelector: #computeTypeHierarchyDepth.

    public eager method computeTypeHierarchyLowestCommonAncestorWith: (otherType: Type) ::=> Type := {
        let leftType mutable := self.
        let leftTypeDepth mutable := leftType computeTypeHierarchyDepth.

        let rightType mutable := self.
        let rightTypeDepth mutable := rightType computeTypeHierarchyDepth.

        while: leftTypeDepth > rightTypeDepth do: {
            leftType := leftType supertype.
            leftTypeDepth := leftTypeDepth - 1i32.
        }.

        while: rightTypeDepth > rightTypeDepth do: {
            rightType := rightType supertype.
            rightTypeDepth := rightTypeDepth - 1i32.
        }.

        while: leftType isNotNil && rightType isNotNil && (leftType ~~ rightType) do: {
            leftType := leftType supertype.
            rightType := rightType supertype.
        }.

        leftType isNil || rightType isNil
            ifTrue: nil
            ifFalse: leftType
    }.

    public virtual eager method computeConditionCoercionTypeWithOrdinaryType: (otherType: Type) ::=> Type := {
        (self computeTypeHierarchyLowestCommonAncestorWith: otherType) ifNil: AnyValue
    }.

    public virtual eager method computeConditionCoercionTypeWithControlFlowEscapeType: (otherType: Type) ::=> Type
        := self.

    public virtual eager method computeConditionCoercionTypeWithUndefinedType: (otherType: Type) ::=> Type
        := self.

    public virtual eager method computeConditionCoercionTypeWith: (otherType: Type) ::=> Type
        := otherType computeConditionCoercionTypeWithOrdinaryType: self.
}.

UndefinedObject __type__ definition: {
    public override eager method computeConditionCoercionTypeWithOrdinaryType: (otherType: Type) ::=> Type
        := otherType.

    public override eager method computeConditionCoercionTypeWith: (otherType: Type) ::=> Type
        := otherType computeConditionCoercionTypeWithUndefinedType: self.
}.

ControlFlowEscapeType __type__ definition: {
    public override eager method computeConditionCoercionTypeWithOrdinaryType: (otherType: Type) ::=> Type
        := otherType.

    public override eager method computeConditionCoercionTypeWith: (otherType: Type) ::=> Type
        := otherType computeConditionCoercionTypeWithControlFlowEscapeType: self.
}.

ASTIfNode definition: {
    public override method analyzeAndEvaluateWithEnvironment: (environment: Environment) ::=> Untyped := {
        let condition => Boolean := self conditionExpression analyzeAndEvaluateWithEnvironment: environment.
        condition ifTrue: {
            self trueExpression
                ifNil: {void}
                ifNotNil: {self trueExpression analyzeAndEvaluateWithEnvironment: environment}
        } ifFalse: {
            self falseExpression
                ifNil: {void}
                ifNotNil: {self falseExpression analyzeAndEvaluateWithEnvironment: environment}
        }
    }.

    public override eager method analyzeWithEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode := {
        let result := self copy
            analyzedType: AnyValue;
            analyzerToken: environment validAnalyzerToken;
            conditionExpression: (environment analyze: self conditionExpression withExpectedType: Boolean);
            yourself.
        result trueExpression ifNotNil: {
            result trueExpression: (environment analyzeWithCurrentExpectedType: result trueExpression)
        }.
        result falseExpression ifNotNil: {
            result falseExpression: (environment analyzeWithCurrentExpectedType: result falseExpression)
        }.

        ## Optimize the case where the condition is a constant.
        result conditionExpression isLiteralNode ifTrue: {
            let literalCondition => Boolean := (result conditionExpression downCastTo: ASTLiteralNode) value.
            let literalResultNode := literalCondition
                ifTrue: result trueExpression
                ifFalse: result falseExpression.
            return: (literalResultNode ifNil: (environment newLiteral: void at: self sourcePosition))
        }.

        result trueExpression isNotNil && result falseExpression isNotNil ifTrue: {
            result analyzedType: (result trueExpression analyzedType computeConditionCoercionTypeWith: result falseExpression analyzedType)
        } ifFalse: {
            (result trueExpression isNil || result falseExpression isNil) ifTrue: {
                result analyzedType: Void
            }
        }.

        result
    }.

    public override eager method evaluateWithEnvironment: (environment: FunctionActivationEnvironment) ::=> Untyped := {
        let condition => Boolean := self conditionExpression evaluateWithEnvironment: environment.
        condition ifTrue: {
            self trueExpression
                ifNil: {void}
                ifNotNil: {self trueExpression evaluateWithEnvironment: environment}
        } ifFalse: {
            self falseExpression
                ifNil: {void}
                ifNotNil: {self falseExpression evaluateWithEnvironment: environment}
        }
    }.
}.

ASTReturnNode definition: {
    public override method analyzeAndEvaluateWithEnvironment: (environment: Environment) ::=> Untyped := {
        self semanticError: "TODO: ASTReturnNode analyzeAndEvaluateWithEnvironment"
    }.

    public override eager method analyzeWithEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode
        := self copy
            analyzedType: ControlFlowReturnType;
            analyzerToken: environment validAnalyzerToken;
            expression: (environment analyze: self expression withExpectedTypeExpression: environment lookReturnTypeExpression at: self sourcePosition)
                node;
            yourself.

    public override eager method evaluateWithEnvironment: (environment: FunctionActivationEnvironment) ::=> Untyped := {
        self semanticError: "TODO: ASTReturnNode evaluateWithEnvironment"
    }.
}.

ASTDoWhileContinueWithNode definition: {
    public override method analyzeAndEvaluateWithEnvironment: (environment: Environment) ::=> Untyped := {
        do: {
            self bodyExpression ifNotNil: {
                self bodyExpression analyzeAndEvaluateWithEnvironment: environment
            }.
        } while: (self conditionExpression ifNil: true ifNotNil: (self conditionExpression analyzeAndEvaluateWithEnvironment: environment))
          continueWith: (self continueExpression ifNotNil: (self continueExpression analyzeAndEvaluateWithEnvironment: environment)).
        void
    }.

    public override eager method analyzeWithEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode := {
        let result := self copy
            analyzerToken: environment validAnalyzerToken;
            analyzedType: Void;
            yourself.

        result bodyExpression ifNotNil: {
            let bodyEnvironment := LocalAnalysisEnvironment parent: environment.
            bodyEnvironment hasBreakTarget: true; hasContinueTarget: true.
            result bodyExpression: (bodyEnvironment analyze: result bodyExpression withExpectedType: Void)
        }.

        result conditionExpression ifNotNil: {
            result conditionExpression: (environment analyze: result conditionExpression withExpectedType: Boolean)
        }.

        result continueExpression ifNotNil: {
            result continueExpression: (environment analyze: result continueExpression withExpectedType: Void)
        }.

        (result conditionExpression isNotNil && result conditionExpression isLiteralNode) ifTrue: {
            let literalCondition => Boolean := (result conditionExpression downCastTo: ASTLiteralNode) value.
            literalCondition ifTrue: {
                result conditionExpression: nil
            } ifFalse: {
                return: (result bodyExpression
                    ifNotNil: result bodyExpression
                    ifNil: (environment newLiteral: void at: result sourcePosition))
            }
        }.

        result.
    }.

    public override eager method evaluateWithEnvironment: (environment: FunctionActivationEnvironment) ::=> Untyped := {
        do: {
            self bodyExpression ifNotNil: {
                self bodyExpression evaluateWithEnvironment: environment
            }.
        } while: (self conditionExpression ifNil: true ifNotNil: (self conditionExpression evaluateWithEnvironment: environment))
          continueWith: (self continueExpression ifNotNil: (self continueExpression evaluateWithEnvironment: environment)).
        void

    }.
}.

ASTWhileContinueWithNode definition: {
    public override method analyzeAndEvaluateWithEnvironment: (environment: Environment) ::=> Untyped := {
        while: (self conditionExpression ifNil: true ifNotNil: (self conditionExpression analyzeAndEvaluateWithEnvironment: environment)) do: {
            self bodyExpression ifNotNil: {
                self bodyExpression analyzeAndEvaluateWithEnvironment: environment
            }.

        } continueWith: (self continueExpression ifNotNil: (self continueExpression analyzeAndEvaluateWithEnvironment: environment)).
        void
    }.

    public override eager method analyzeWithEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode := {
        let result := self copy
            analyzerToken: environment validAnalyzerToken;
            analyzedType: Void;
            yourself.
        result conditionExpression ifNotNil: {
            result conditionExpression: (environment analyze: result conditionExpression withExpectedType: Boolean)
        }.

        result bodyExpression ifNotNil: {
            let bodyEnvironment := LocalAnalysisEnvironment parent: environment.
            bodyEnvironment hasBreakTarget: true; hasContinueTarget: true.
            result bodyExpression: (bodyEnvironment analyze: result bodyExpression withExpectedType: Void)
        }.

        result continueExpression ifNotNil: {
            result continueExpression: (environment analyze: result continueExpression withExpectedType: Void)
        }.

        (result conditionExpression isNotNil && result conditionExpression isLiteralNode) ifTrue: {
            let literalCondition => Boolean := (result conditionExpression downCastTo: ASTLiteralNode) value.
            literalCondition ifTrue: {
                result conditionExpression: nil
            } ifFalse: {
                return: (environment newLiteral: void at: result sourcePosition)
            }
        }.

        result.
    }.

    public override eager method evaluateWithEnvironment: (environment: FunctionActivationEnvironment) ::=> Untyped := {
        while: (self conditionExpression ifNil: true ifNotNil: (self conditionExpression evaluateWithEnvironment: environment)) do: {
            self bodyExpression ifNotNil: {
                self bodyExpression evaluateWithEnvironment: environment
            }.

        } continueWith: (self continueExpression ifNotNil: (self continueExpression evaluateWithEnvironment: environment)).
        void
    }.
}.
