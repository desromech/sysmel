Function definition: {
    public eager method setupWithFunctionDefinition: (newDefinition: FunctionDefinition) captureEnvironment: (newCaptureEnvironment: Environment) ::=> Void := {
        flags := newDefinition flags.
        argumentCount := newDefinition argumentCount.
        captureEnvironment := newCaptureEnvironment.
        definition := newDefinition.
    }.

    public eager method setupWithFunctionDefinition: (newDefinition: FunctionDefinition) captureVector: (newCaptureVector: Array) ::=> Void := {
        flags := newDefinition flags.
        argumentCount := newDefinition argumentCount.
        captureVector := newCaptureVector.
        definition := newDefinition.
    }.

    public method isTargetDefinedPrimitive => Boolean
        := (self hasAnyFlag: FunctionFlags::TargetDefinedPrimitive) || (self hasPragmaNamed: #targetDefinedPrimitive).
}.

FunctionDefinition definition: {
    public method isTargetDefinedPrimitive => Boolean
        := (self hasAnyFlag: FunctionFlags::TargetDefinedPrimitive) || (self hasPragmaNamed: #targetDefinedPrimitive).

    public method allAnalyzedNodesDo: (aBlock: (ASTNode) => Void) ::=> Void := {
        self ensureAnalysis.
        analyzedArgumentNodes do: {:(ASTNode)each :: Void |
            each withAllChildrenDo: aBlock
        }.
        analyzedBodyNode ifNotNil: (analyzedBodyNode withAllChildrenDo: aBlock).
        analyzedResultTypeNode ifNotNil: (analyzedResultTypeNode withAllChildrenDo: aBlock).
    }.

    public method allLiteralDependenciesDo: (aBlock: (Untyped, Boolean) => Void) ::=> Void := {
        self allAnalyzedNodesDo: {:(ASTNode)each :: Void |
            each literalDependenciesDo: aBlock
        }
    }.
}.

(apply) adoptDefinitionOf: {:function :(Array)arguments... :: Untyped |
    let actualArguments := arguments isEmpty
        ifTrue: #()
        ifFalse: arguments allButLast -- arguments last.
    function applyWithArguments: actualArguments
} withEagerAnalysis.
