Function definition: {
    public eager method setupWithFunctionDefinition: (newDefinition: FunctionDefinition) captureEnvironment: (newCaptureEnvironment: Environment) ::=> Void := {
        flags := newDefinition flags.
        argumentCount := newDefinition argumentCount.
        captureEnvironment := newCaptureEnvironment.
        definition := newDefinition.
    }.

    public eager method setupWithFunctionDefinition: (newDefinition: FunctionDefinition) captureVector: (newCaptureVector: Array) ::=> Void := {
        flags := newDefinition flags.
        argumentCount := newDefinition argumentCount.
        captureVector := newCaptureVector.
        definition := newDefinition.
    }.

    public method isTargetDefinedPrimitive => Boolean
        := (self hasAnyFlag: FunctionFlags::TargetDefinedPrimitive) || (self hasPragmaNamed: #targetDefinedPrimitive).

    public eager method applyWithArguments: (arguments: Array) ::=> Untyped := {
        let argCount := arguments size.
        argCount = 0sz ifTrue: {return: self()}.
        argCount = 1sz ifTrue: {return: self(
            arguments at: 0sz
        )}.
        argCount = 2sz ifTrue: {return: self(
            arguments at: 0sz, arguments at: 1sz 
        )}.
        argCount = 3sz ifTrue: {return: self(
            arguments at: 0sz, arguments at: 1sz, arguments at: 2sz
        )}.
        argCount = 4sz ifTrue: {return: self(
            arguments at: 0sz, arguments at: 1sz, arguments at: 2sz, arguments at: 3sz
        )}.
        argCount = 5sz ifTrue: {return: self(
            arguments at: 0sz, arguments at: 1sz, arguments at: 2sz, arguments at: 3sz,
            arguments at: 4sz
        )}.

        error("Unsupported apply argument count " -- argCount printString -- ".")
    }.
}.

FunctionDefinition definition: {
    public method isTargetDefinedPrimitive => Boolean
        := (self hasAnyFlag: FunctionFlags::TargetDefinedPrimitive) || (self hasPragmaNamed: #targetDefinedPrimitive).

    public method allAnalyzedNodesDo: (aBlock: (ASTNode) => Void) ::=> Void := {
        self ensureAnalysis.
        analyzedArgumentNodes do: {:(ASTNode)each :: Void |
            each withAllChildrenDo: aBlock
        }.
        analyzedBodyNode ifNotNil: (analyzedBodyNode withAllChildrenDo: aBlock).
        analyzedResultTypeNode ifNotNil: (analyzedResultTypeNode withAllChildrenDo: aBlock).
    }.

    public method allLiteralDependenciesDo: (aBlock: (Untyped, Boolean) => Void) ::=> Void := {
        self allAnalyzedNodesDo: {:(ASTNode)each :: Void |
            each literalDependenciesDo: aBlock
        }
    }.
}.

(apply) adoptDefinitionOf: {:function :(Array)arguments... :: Untyped |
    let actualArguments := arguments isEmpty
        ifTrue: #()
        ifFalse: arguments allButLast -- arguments last.
    function applyWithArguments: actualArguments
} withEagerAnalysis.
