Function definition: {
    public eager method setupWithFunctionDefinition: (newDefinition: FunctionDefinition) captureEnvironment: (newCaptureEnvironment: Environment) ::=> Void := {
        flags := newDefinition flags.
        argumentCount := newDefinition argumentCount.
        captureEnvironment := newCaptureEnvironment.
        definition := newDefinition.
    }.

    public eager method setupWithFunctionDefinition: (newDefinition: FunctionDefinition) captureVector: (newCaptureVector: Array) ::=> Void := {
        flags := newDefinition flags.
        argumentCount := newDefinition argumentCount.
        captureVector := newCaptureVector.
        definition := newDefinition.
    }.

    public method isTargetDefinedPrimitive => Boolean
        := (self hasAnyFlag: FunctionFlags::TargetDefinedPrimitive) || (self hasPragmaNamed: #targetDefinedPrimitive).

    public override eager method recordBindingWithOwner: (newOwner: ProgramEntity) andName: (newName: Symbol) ::=> Void := {
        super recordBindingWithOwner: newOwner andName: newName.
        definition ifNotNil: {
            definition recordBindingWithOwner: newOwner andName: newName
        }
    }.

    public eager method adoptDefinitionOf: (definitionFunction: Function) ::=> Void := {
        definition := definitionFunction definition.
        captureVector := definitionFunction captureVector.
        captureEnvironment := definitionFunction captureEnvironment.
        definitionFunction isBootstrapPrimitive ifTrue: {
            flags := (flags & FunctionFlags::BootstrapPrimitiveKeptFlags) | definitionFunction flags.

            definitionFunction primitiveName ifNotNil: {
                primitiveName := definitionFunction primitiveName
            }.

        } ifFalse: {
            flags := definitionFunction flags.
            primitiveName := definitionFunction primitiveName.
            primitiveTableIndex := definitionFunction primitiveTableIndex.
            annotations := definitionFunction annotations.
        }.

        (RawTuple::type:)(self, definitionFunction __type__)
    }.

    public override eager method ensureAnalysis => Void := {
        super ensureAnalysis.
        captureEnvironment isNil || definition isNil ifTrue: {return: void}.

        let captureEnvironment := self captureEnvironment.
        self captureEnvironment == __pendingMemoizationValue__ ifTrue: {
            error("Cyclic analysis of function " -- self printString).
        }.

        self captureEnvironment: __pendingMemoizationValue__.
        definition ensureAnalysis.

        captureVector := definition analyzedCaptures collect: {:(SymbolBinding)captureBinding :: Untyped |
            captureEnvironment evaluateSymbolBinding: captureBinding
        }.
        self captureEnvironment: nil.
        self primitiveName ifNil: {
            self primitiveName: definition analyzedPrimitiveName
        }.
        (RawTuple::type:)(self, definition analyzedType).
    }.

    public eager method recompileAndOptimize => Function := {
        self ensureAnalysis.
        (definition isNil || captureVector isNotNil) ifTrue: (return: self).

        error("TODO: recompileAndOptimize")
    }.

    public eager method applyWithArguments: (arguments: Array) ::=> Untyped := {
        let argCount := arguments size.
        argCount = 0sz ifTrue: {return: self()}.
        argCount = 1sz ifTrue: {return: self(
            arguments at: 0sz
        )}.
        argCount = 2sz ifTrue: {return: self(
            arguments at: 0sz, arguments at: 1sz 
        )}.
        argCount = 3sz ifTrue: {return: self(
            arguments at: 0sz, arguments at: 1sz, arguments at: 2sz
        )}.
        argCount = 4sz ifTrue: {return: self(
            arguments at: 0sz, arguments at: 1sz, arguments at: 2sz, arguments at: 3sz
        )}.
        argCount = 5sz ifTrue: {return: self(
            arguments at: 0sz, arguments at: 1sz, arguments at: 2sz, arguments at: 3sz,
            arguments at: 4sz
        )}.

        error("Unsupported apply argument count " -- argCount printString -- ".")
    }.
}.

FunctionDefinition definition: {
    public eager method ensureTypeAnalysis => Void := {
        error("TODO: FunctionDefinition >> ensureTypeAnalysis").
    }.

    public eager override method ensureAnalysis => Void := {
        definitionArgumentNodes ifNil: {return: void}.
        definitionBodyNode ifNil: {return: void}.
        analyzedType ifNotNil: {return: void}.

        error("TODO: FunctionDefinition >> ensureAnalysis").
    }.

    public method isTargetDefinedPrimitive => Boolean
        := (self hasAnyFlag: FunctionFlags::TargetDefinedPrimitive) || (self hasPragmaNamed: #targetDefinedPrimitive).

    public method allAnalyzedNodesDo: (aBlock: (ASTNode) => Void) ::=> Void := {
        self ensureAnalysis.
        analyzedArgumentNodes do: {:(ASTNode)each :: Void |
            each withAllChildrenDo: aBlock
        }.
        analyzedBodyNode ifNotNil: (analyzedBodyNode withAllChildrenDo: aBlock).
        analyzedResultTypeNode ifNotNil: (analyzedResultTypeNode withAllChildrenDo: aBlock).
    }.

    public method allLiteralDependenciesDo: (aBlock: (Untyped, Boolean) => Void) ::=> Void := {
        self allAnalyzedNodesDo: {:(ASTNode)each :: Void |
            each literalDependenciesDo: aBlock
        }
    }.
}.

(apply) adoptDefinitionOf: {:function :(Array)arguments... :: Untyped |
    let actualArguments := arguments isEmpty
        ifTrue: #()
        ifFalse: arguments allButLast -- arguments last.
    function applyWithArguments: actualArguments
} withEagerAnalysis.
