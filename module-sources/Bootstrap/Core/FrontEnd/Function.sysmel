Function definition: {
    public eager method setupWithFunctionDefinition: (newDefinition: FunctionDefinition) captureEnvironment: (newCaptureEnvironment: Environment) ::=> Void := {
        flags := newDefinition flags.
        argumentCount := newDefinition argumentCount.
        captureEnvironment := newCaptureEnvironment.
        definition := newDefinition.
    }.

    public eager method setupWithFunctionDefinition: (newDefinition: FunctionDefinition) captureVector: (newCaptureVector: AnySequenceTuple) ::=> Void := {
        flags := newDefinition flags.
        argumentCount := newDefinition argumentCount.
        captureVector := newCaptureVector.
        definition := newDefinition.
    }.

    public method isTargetDefinedPrimitive => Boolean
        := (self hasAnyFlag: FunctionFlags::TargetDefinedPrimitive) || (self hasPragmaNamed: #targetDefinedPrimitive).

    public override eager method recordBindingWithOwner: (newOwner: ProgramEntity) andName: (newName: Symbol) ::=> Void := {
        super recordBindingWithOwner: newOwner andName: newName.
        definition ifNotNil: {
            definition recordBindingWithOwner: newOwner andName: newName
        }
    }.

    public eager method adoptDefinitionOf: (definitionFunction: Function) ::=> Void := {
        definition := definitionFunction definition.
        captureVector := definitionFunction captureVector.
        captureEnvironment := definitionFunction captureEnvironment.
        definitionFunction isBootstrapPrimitive ifTrue: {
            flags := (flags & FunctionFlags::BootstrapPrimitiveKeptFlags) | definitionFunction flags.

            definitionFunction primitiveName ifNotNil: {
                primitiveName := definitionFunction primitiveName
            }.

        } ifFalse: {
            flags := definitionFunction flags.
            primitiveName := definitionFunction primitiveName.
            primitiveTableIndex := definitionFunction primitiveTableIndex.
            annotations := definitionFunction annotations.
        }.

        (RawTuple::type:)(self, definitionFunction __type__)
    }.

    public override eager method ensureAnalysis => Void := {
        super ensureAnalysis.
        captureEnvironment isNil || definition isNil ifTrue: {return: void}.

        let captureEnvironment := self captureEnvironment.
        self captureEnvironment == __pendingMemoizationValue__ ifTrue: {
            error("Cyclic analysis of function " -- self printString).
        }.

        self captureEnvironment: __pendingMemoizationValue__.
        definition ensureAnalysis.

        let newCaptureVector => AnySequenceTuple := definition analyzedCaptureVectorType new.
        definition analyzedCaptures doWithIndex: {:(SymbolBinding)captureBinding :(Size)index |
            newCaptureVector at: index put: (captureEnvironment evaluateSymbolBinding: captureBinding)
        }.

        captureVector := newCaptureVector.
        self captureEnvironment: nil.
        self primitiveName ifNil: {
            self primitiveName: definition analyzedPrimitiveName
        }.
        (RawTuple::type:)(self, definition analyzedType).
    }.

    public eager method recompileAndOptimize => Function := {
        self ensureAnalysis.
        (definition isNil || captureVector isNotNil) ifTrue: (return: self).

        error("TODO: recompileAndOptimize")
    }.

    public eager method applyWithExpandedArguments: (arguments: Array) ::=> Untyped := {
        error("TODO: applyWithDirectArguments.")
    }.

    public eager method applyWithMemoizedArguments: (arguments: Array) ::=> Untyped := {
        error("TODO: applyWithMemoizedArguments.")
    }.

    public eager method applyWithArguments: (arguments: Array) ::=> Untyped := {
        let expandedArguments := self isVariadic ifTrue: {
            self assert: argumentCount > 0sz.
            let expandedArguments := Array new: argumentCount.
        } ifFalse: (arguments).

        self isMemoized ifTrue: {
            return: (self applyWithMemoizedArguments: expandedArguments)

        }.
        
        return: (self applyWithExpandedArguments: expandedArguments).
    }.
}.

FunctionDefinition definition: {
    public eager method ensureTypeAnalysis => Void := {
        error("TODO: FunctionDefinition >> ensureTypeAnalysis").
    }.

    public eager override method ensureAnalysis => Void := {
        definitionArgumentNodes ifNil: {return: void}.
        definitionBodyNode ifNil: {return: void}.
        analyzedType ifNotNil: {return: void}.

        error("TODO: FunctionDefinition >> ensureAnalysis").
    }.

    public method isTargetDefinedPrimitive => Boolean
        := (self hasAnyFlag: FunctionFlags::TargetDefinedPrimitive) || (self hasPragmaNamed: #targetDefinedPrimitive).

    public method allAnalyzedNodesDo: (aBlock: (ASTNode) => Void) ::=> Void := {
        self ensureAnalysis.
        analyzedArgumentNodes do: {:(ASTNode)each :: Void |
            each withAllChildrenDo: aBlock
        }.
        analyzedBodyNode ifNotNil: (analyzedBodyNode withAllChildrenDo: aBlock).
        analyzedResultTypeNode ifNotNil: (analyzedResultTypeNode withAllChildrenDo: aBlock).
    }.

    public method allLiteralDependenciesDo: (aBlock: (Untyped, Boolean) => Void) ::=> Void := {
        self allAnalyzedNodesDo: {:(ASTNode)each :: Void |
            each literalDependenciesDo: aBlock
        }
    }.
}.

(apply) adoptDefinitionOf: {:function :(Array)arguments... :: Untyped |
    let actualArguments := arguments isEmpty
        ifTrue: #()
        ifFalse: arguments allButLast -- arguments last.
    function applyWithArguments: actualArguments
} withEagerAnalysis.
