SourceCode definition: {
    __Meta__ definition: {
        public method text: (text: String) directory: (directory: String) name: (name: String) language: (language: StringSymbol) ::=> self
            := self new
                text: text;
                directory: directory;
                name: name;
                language: language;
                yourself.

        public method text: (text: String) filename: (filename: String) language: (language: StringSymbol) ::=> self
            := self text: text directory: FileSystem::dirname(filename) name: FileSystem::basename(filename) language: language.
    }.

    public method ensureLineStartIndexTableIsBuilt => Void := {
        lineStartIndexTable ifNotNil: {return: void}.

        let table := OrderedCollection new.
        table add: 0u32.

        let textSize := text size asUInt32.
        let i mutable := 0u32.
        while: (i < textSize) do: {
            let c := text at: i asSize.
            c = '\n'c8 ifTrue: {
                table add: i + 1u32
            }
        } continueWith: (i := i + 1u32).

        lineStartIndexTable := table asArray.
    }.

    public method findLineIndexForSourceIndex: (sourceCodeIndex: UInt32) ::=> UInt32 := {
        self ensureLineStartIndexTableIsBuilt.

        let left mutable := 0u32.
        let right mutable := lineStartIndexTable size asUInt32.

        let bestSoFar mutable := 0u32.
        while: (left < right) do: {
            let middle := left + ((right - left) / 2u32).
            let middleIndex := lineStartIndexTable at: middle asSize.
            middleIndex <= sourceCodeIndex ifTrue: {
                bestSoFar := middle.
                left := middle + 1u32
            } ifFalse: {
                right := middle
            }
        }.

        bestSoFar
    }.

    public method computeLineInfoForSourcePosition: (sourcePosition: SourcePosition) ::=> Void := {
        ## Start.
        {
            let lineIndex := self findLineIndexForSourceIndex: sourcePosition startIndex.
            let lineSourceIndex => UInt32 := lineStartIndexTable at: lineIndex asSize.

            sourcePosition
                startLine: lineIndex + 1u32;
                startColumn: sourcePosition startIndex - lineSourceIndex + 1u32
        }.

        ## End
        {
            let lineIndex := self findLineIndexForSourceIndex: sourcePosition endIndex.
            let lineSourceIndex => UInt32 := lineStartIndexTable at: lineIndex asSize.

            sourcePosition
                endLine: lineIndex + 1u32;
                endColumn: sourcePosition endIndex - lineSourceIndex + 1u32
        }.
    }.
}.

SourcePosition definition: {
    __Meta__ definition: {
        public method for: (sourceCode: SourceCode) startIndex: (startIndex: UInt32) endIndex: (endIndex: UInt32) ::=> self
            := self new
                sourceCode: sourceCode;
                startIndex: startIndex;
                endIndex: endIndex;
                computeLineAndColumnInfo;
                yourself.
    }.

    public override eager method hash => Size
        := (sourceCode identityHash hashConcatenate: startIndex hash) hashConcatenate: endIndex hash.

    public override eager method = other => Boolean := {
        self == other ifTrue: {return: true}.
        self class == other class ifFalse: {return: false}.
        let otherSourcePosition => SourcePosition := other.
        (self sourceCode == otherSourcePosition sourceCode) && (self startIndex = otherSourcePosition startIndex) && (self endIndex = otherSourcePosition endIndex)
    }.

    public method computeLineAndColumnInfo => Void := {
        sourceCode ifNotNil: {
            sourceCode computeLineInfoForSourcePosition: self.
        }
    }.

    public method makeUnionWith: (next: SourcePosition) ::=> SourcePosition := {
        sourceCode == next sourceCode ifTrue: {
            SourcePosition for: sourceCode startIndex: (startIndex min: next startIndex) endIndex: (endIndex max: next endIndex)
        } ifFalse: {
            self
        }
    }.
}.
