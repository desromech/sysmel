## ----------------------------------------------------------------------------
## Sysmel and sysmel lisp scanner definition.
## ----------------------------------------------------------------------------

#(
    Character Float Identifier Integer Keyword MultiKeyword Operator String Symbol
    LeftParent RightParent LeftBracket RightBracket LeftCurlyBracket RightCurlyBracket
    LessThan GreaterThan Star
    Colon ColonColon Bar
    Assignment Semicolon Comma Dot Ellipsis
    Quote QuasiQuote QuasiUnquote Splice
    ByteArrayStart DictionaryStart LiteralArrayStart
    Error
) doWithIndex: {:(Symbol)tokenName :(Size)index :: Void |
    __OwnerProgramEntity__ setPublicSymbol: ("SysmelTokenKind::" -- tokenName asString) asSymbol value: index asUInt8
}.

SysmelToken definition: {
    __Meta__ definition: {
        public method kind: (kind: UInt8) value: (value: AnyValue) sourcePosition: (sourcePosition: SourcePosition) ::=> self
            := self new
                kind: kind;
                value: value;
                sourcePosition: sourcePosition;
                yourself.
    }.

    public override method printOn: (stream: Stream) ::=> Void := {
        stream nextPutAll: "SystemToken kind: "; print: kind; nextPutAll: " value: "; print: value
    }.
}.

let Scanner::Whitespace := MonadicParser white plus withoutValue.
let Scanner::NotNewline := MonadicParser predicate: {:(Char8)character :: Boolean | ('\n'c8 ~= character) && ('\r'c8 ~= character)} errorMessage: "Newline found".
let Scanner::SingleLineComment := ("##" asMonadicParser -- Scanner::NotNewline star withoutValue) withoutValue.
let Scanner::MultiLineComment := ("#*" asMonadicParser -- "*#" asMonadicParser negate star withoutValue -- "*#" asMonadicParser) withoutValue.

let Scanner::White := (Scanner::Whitespace | Scanner::SingleLineComment | Scanner::MultiLineComment) plus withoutValue.

let Scanner::ColonPattern := ':'c8 asMonadicElementParser -- ':'c8 asMonadicElementParser not.
let Scanner::ColonColonPattern := "::" asMonadicParser.
let Scanner::HashChar := '#'c8 asMonadicElementParser.

let Scanner::LeftParentPattern := '('c8 asMonadicElementParser.
let Scanner::RightParentPattern := ')'c8 asMonadicElementParser.
let Scanner::LeftBracketPattern := '['c8 asMonadicElementParser.
let Scanner::RightBracketPattern := ']'c8 asMonadicElementParser.
let Scanner::LeftCurlyBracketPattern := '{'c8 asMonadicElementParser.
let Scanner::RightCurlyBracketPattern := '}'c8 asMonadicElementParser.
let Scanner::EllipsisPattern := "..." asMonadicParser.
let Scanner::DotPattern := '.'c8 asMonadicElementParser.
let Scanner::CommaPattern := ','c8 asMonadicElementParser.
let Scanner::AssignmentPattern := ":=" asMonadicParser.
let Scanner::SemicolonPattern := ';'c8 asMonadicElementParser.

let Scanner::QuotePattern := "`'" asMonadicParser.
let Scanner::QuasiQuotePattern := "``" asMonadicParser.
let Scanner::QuasiUnquotePattern := "`," asMonadicParser.
let Scanner::SplicePattern := "`@" asMonadicParser.

let Scanner::ByteArrayStartPattern := "#[" asMonadicParser.
let Scanner::LiteralArrayStartPattern := "#(" asMonadicParser.
let Scanner::DictionaryStartPattern := "#{" asMonadicParser.

let Scanner::IdentifierPattern := (MonadicParser identifierStart -- MonadicParser identifierMiddle star withoutValue) withoutValue.
let Scanner::IdentifierScopePrefixPattern := (Scanner::IdentifierPattern -- Scanner::ColonColonPattern) star withoutValue.
let Scanner::ScopedIdentifierPattern := (Scanner::IdentifierScopePrefixPattern -- Scanner::IdentifierPattern) withoutValue.

let Scanner::OperatorCharacter := "+-/\\*~<>=@%|&?!^" asMonadicSetParser.
let Scanner::OperatorPattern := Scanner::OperatorCharacter plus withoutValue.
let Scanner::ScopedOperatorPattern := (Scanner::IdentifierScopePrefixPattern -- Scanner::OperatorPattern) withoutValue.

let Scanner::Sign := "+-" asMonadicSetParser.
let Scanner::Digit := MonadicParser digit.
let Scanner::DigitUnderscore := Scanner::Digit | '_'c8 asMonadicElementParser.
let Scanner::Alphanum := MonadicParser alphaNum.
let Scanner::AlphanumUnderscore := MonadicParser identifierMiddle.

let Scanner::DecimalIntegerPattern := (Scanner::Sign optional -- Scanner::Digit -- Scanner::DigitUnderscore star withoutValue) withoutValue.
let Scanner::RadixIntegerPattern := (Scanner::DecimalIntegerPattern -- 'r'c8 asMonadicElementParser -- Scanner::Alphanum -- Scanner::AlphanumUnderscore star withoutValue) withoutValue.
let Scanner::IntegerPattern := Scanner::RadixIntegerPattern | Scanner::DecimalIntegerPattern.

let Scanner::ExponentPattern := ("eE" asMonadicSetParser -- Scanner::DecimalIntegerPattern) withoutValue.
let Scanner::FloatDecimalPattern := (Scanner::IntegerPattern -- '.'c8 asMonadicElementParser -- Scanner::Digit -- Scanner::DigitUnderscore star withoutValue) withoutValue.
let Scanner::FloatExponentPattern := (Scanner::IntegerPattern -- Scanner::ExponentPattern) withoutValue.
let Scanner::FloatPattern := Scanner::FloatDecimalPattern | Scanner::FloatExponentPattern.

let Scanner::CharacterPattern := ('\''c8 asMonadicElementParser
    -- (('\\'c8 asMonadicElementParser -- MonadicParser any) withoutValue | '\''c8 asMonadicElementParser negate)
    -- '\''c8 asMonadicElementParser) withoutValue.
let Scanner::StringPattern := ('"'c8 asMonadicElementParser
    -- (('\\'c8 asMonadicElementParser -- MonadicParser any) withoutValue | '"'c8 asMonadicElementParser negate) star
    -- '"'c8 asMonadicElementParser) withoutValue.
let Scanner::SymbolStringPattern := ('#'c8 asMonadicElementParser -- Scanner::StringPattern) withoutValue.

let Scanner::ScopedKeywordPattern := (Scanner::ScopedIdentifierPattern -- Scanner::ColonPattern) withoutValue.
let Scanner::ScopedMultiKeywordPattern := (Scanner::IdentifierScopePrefixPattern -- ((Scanner::IdentifierPattern -- Scanner::ColonPattern) withoutValue plusN: 2sz) withoutValue) withoutValue.

let Scanner::SymbolMultiKeywordPattern := (Scanner::HashChar -- Scanner::ScopedMultiKeywordPattern) withoutValue.
let Scanner::SymbolKeywordPattern := (Scanner::HashChar -- Scanner::ScopedKeywordPattern) withoutValue.
let Scanner::SymbolIdentifierPattern := (Scanner::HashChar -- Scanner::ScopedIdentifierPattern) withoutValue.
let Scanner::SymbolOperatorPattern := (Scanner::HashChar -- Scanner::ScopedOperatorPattern) withoutValue.

let Scanner::LeftParent := Scanner::LeftParentPattern ::==> {:(MonadicParserResult)parserResult :: AnyValue |
    SysmelToken kind: SysmelTokenKind::LeftParent value: #"(" sourcePosition: parserResult sourcePosition
}.
let Scanner::RightParent := Scanner::RightParentPattern ::==> {:(MonadicParserResult)parserResult :: AnyValue |
    SysmelToken kind: SysmelTokenKind::RightParent value: #")" sourcePosition: parserResult sourcePosition
}.
let Scanner::LeftBracket := Scanner::LeftBracketPattern ::==> {:(MonadicParserResult)parserResult :: AnyValue |
    SysmelToken kind: SysmelTokenKind::LeftBracket value: #"[" sourcePosition: parserResult sourcePosition
}.
let Scanner::RightBracket := Scanner::RightBracketPattern ::==> {:(MonadicParserResult)parserResult :: AnyValue |
    SysmelToken kind: SysmelTokenKind::RightBracket value: #"]" sourcePosition: parserResult sourcePosition
}.
let Scanner::LeftCurlyBracket := Scanner::LeftCurlyBracketPattern ::==> {:(MonadicParserResult)parserResult :: AnyValue |
    SysmelToken kind: SysmelTokenKind::LeftCurlyBracket value: #"{" sourcePosition: parserResult sourcePosition
}.
let Scanner::RightCurlyBracket := Scanner::RightCurlyBracketPattern ::==> {:(MonadicParserResult)parserResult :: AnyValue |
    SysmelToken kind: SysmelTokenKind::RightCurlyBracket value: #"}" sourcePosition: parserResult sourcePosition
}.
let Scanner::Ellipsis := Scanner::EllipsisPattern ::==> {:(MonadicParserResult)parserResult :: AnyValue |
    SysmelToken kind: SysmelTokenKind::Ellipsis value: #"..." sourcePosition: parserResult sourcePosition
}.
let Scanner::Dot := Scanner::DotPattern ::==> {:(MonadicParserResult)parserResult :: AnyValue |
    SysmelToken kind: SysmelTokenKind::Dot value: #"." sourcePosition: parserResult sourcePosition
}.
let Scanner::Comma := Scanner::CommaPattern ::==> {:(MonadicParserResult)parserResult :: AnyValue |
    SysmelToken kind: SysmelTokenKind::Comma value: #"," sourcePosition: parserResult sourcePosition
}.
let Scanner::Colon := Scanner::ColonPattern ::==> {:(MonadicParserResult)parserResult :: AnyValue |
    SysmelToken kind: SysmelTokenKind::Colon value: #":" sourcePosition: parserResult sourcePosition
}.
let Scanner::ColonColon := Scanner::ColonColonPattern ::==> {:(MonadicParserResult)parserResult :: AnyValue |
    SysmelToken kind: SysmelTokenKind::ColonColon value: #"::" sourcePosition: parserResult sourcePosition
}.
let Scanner::Assignment := Scanner::AssignmentPattern ::==> {:(MonadicParserResult)parserResult :: AnyValue |
    SysmelToken kind: SysmelTokenKind::Assignment value: #":=" sourcePosition: parserResult sourcePosition
}.
let Scanner::Semicolon := Scanner::SemicolonPattern ::==> {:(MonadicParserResult)parserResult :: AnyValue |
    SysmelToken kind: SysmelTokenKind::Semicolon value: #";" sourcePosition: parserResult sourcePosition
}.

let Scanner::Quote := Scanner::QuotePattern ::==> {:(MonadicParserResult)parserResult :: AnyValue |
    SysmelToken kind: SysmelTokenKind::Quote value: #"`'" sourcePosition: parserResult sourcePosition
}.
let Scanner::QuasiQuote := Scanner::QuasiQuotePattern ::==> {:(MonadicParserResult)parserResult :: AnyValue |
    SysmelToken kind: SysmelTokenKind::QuasiQuote value: #"``" sourcePosition: parserResult sourcePosition
}.
let Scanner::QuasiUnquote := Scanner::QuasiUnquotePattern ::==> {:(MonadicParserResult)parserResult :: AnyValue |
    SysmelToken kind: SysmelTokenKind::QuasiUnquote value: #"`," sourcePosition: parserResult sourcePosition
}.
let Scanner::Splice := Scanner::SplicePattern ::==> {:(MonadicParserResult)parserResult :: AnyValue |
    SysmelToken kind: SysmelTokenKind::Splice value: #"`@" sourcePosition: parserResult sourcePosition
}.

let Scanner::ByteArrayStart := Scanner::ByteArrayStartPattern ::==> {:(MonadicParserResult)parserResult :: AnyValue |
    SysmelToken kind: SysmelTokenKind::ByteArrayStart value: #"#[" sourcePosition: parserResult sourcePosition
}.
let Scanner::LiteralArrayStart := Scanner::LiteralArrayStartPattern ::==> {:(MonadicParserResult)parserResult :: AnyValue |
    SysmelToken kind: SysmelTokenKind::LiteralArrayStart value: #"#(" sourcePosition: parserResult sourcePosition
}.
let Scanner::DictionaryStart := Scanner::DictionaryStartPattern ::==> {:(MonadicParserResult)parserResult :: AnyValue |
    SysmelToken kind: SysmelTokenKind::DictionaryStart value: #"#{" sourcePosition: parserResult sourcePosition
}.

let Scanner::Identifier := Scanner::ScopedIdentifierPattern ::==> {:(MonadicParserResult)parserResult :: AnyValue |
    SysmelToken kind: SysmelTokenKind::Identifier value: parserResult sourceStringValue asSymbol sourcePosition: parserResult sourcePosition
}.

let Scanner::Integer := Scanner::IntegerPattern ::==> {:(MonadicParserResult)parserResult :: AnyValue |
    SysmelToken kind: SysmelTokenKind::Integer value: (Integer parseString: parserResult sourceStringValue) sourcePosition: parserResult sourcePosition
}.

let Scanner::Float := Scanner::FloatPattern ::==> {:(MonadicParserResult)parserResult :: AnyValue |
    SysmelToken kind: SysmelTokenKind::Float value: (Float64 parseString: parserResult sourceStringValue) sourcePosition: parserResult sourcePosition
}.

let Scanner::DelimiterOperatorMap := #{
    #"*" : SysmelTokenKind::Star.
    #| : SysmelTokenKind::Bar.
    #< : SysmelTokenKind::LessThan.
    #> : SysmelTokenKind::GreaterThan.
}.

let Scanner::Operator := Scanner::ScopedOperatorPattern ::==> {:(MonadicParserResult)parserResult :: AnyValue |
    let value := parserResult sourceStringValue asSymbol.
    SysmelToken kind: (Scanner::DelimiterOperatorMap at: value ifAbsent: {| SysmelTokenKind::Operator}) value: value sourcePosition: parserResult sourcePosition
}.

let Scanner::Keyword := Scanner::ScopedKeywordPattern ::==> {:(MonadicParserResult)parserResult :: AnyValue |
    SysmelToken kind: SysmelTokenKind::Keyword value: parserResult sourceStringValue asSymbol sourcePosition: parserResult sourcePosition
}.

let Scanner::MultiKeyword := Scanner::ScopedMultiKeywordPattern ::==> {:(MonadicParserResult)parserResult :: AnyValue |
    SysmelToken kind: SysmelTokenKind::MultiKeyword value: parserResult sourceStringValue asSymbol sourcePosition: parserResult sourcePosition
}.

let Scanner::Character := Scanner::CharacterPattern ::==> {:(MonadicParserResult)parserResult :: AnyValue |
    SysmelToken kind: SysmelTokenKind::Character value: (parserResult sourceStringValueWithoutFirst: 1sz last: 1sz) parseCEscapeSequences first asChar32 sourcePosition: parserResult sourcePosition
}.

let Scanner::String := Scanner::StringPattern ::==> {:(MonadicParserResult)parserResult :: AnyValue |
    SysmelToken kind: SysmelTokenKind::String value: (parserResult sourceStringValueWithoutFirst: 1sz last: 1sz) parseCEscapeSequences sourcePosition: parserResult sourcePosition
}.

let Scanner::SymbolMultiKeyword := Scanner::SymbolMultiKeywordPattern ::==> {:(MonadicParserResult)parserResult :: AnyValue |
    SysmelToken kind: SysmelTokenKind::Symbol value: (parserResult sourceStringValueWithoutFirst: 1sz) asSymbol sourcePosition: parserResult sourcePosition
}.

let Scanner::SymbolKeyword := Scanner::SymbolKeywordPattern ::==> {:(MonadicParserResult)parserResult :: AnyValue |
    SysmelToken kind: SysmelTokenKind::Symbol value: (parserResult sourceStringValueWithoutFirst: 1sz) asSymbol sourcePosition: parserResult sourcePosition
}.

let Scanner::SymbolIdentifier := Scanner::SymbolIdentifierPattern ::==> {:(MonadicParserResult)parserResult :: AnyValue |
    SysmelToken kind: SysmelTokenKind::Symbol value: (parserResult sourceStringValueWithoutFirst: 1sz) asSymbol sourcePosition: parserResult sourcePosition
}.

let Scanner::SymbolOperator := Scanner::SymbolOperatorPattern ::==> {:(MonadicParserResult)parserResult :: AnyValue |
    SysmelToken kind: SysmelTokenKind::Symbol value: (parserResult sourceStringValueWithoutFirst: 1sz) asSymbol sourcePosition: parserResult sourcePosition
}.

let Scanner::SymbolString := Scanner::SymbolStringPattern ::==> {:(MonadicParserResult)parserResult :: AnyValue |
    SysmelToken kind: SysmelTokenKind::Symbol value: (parserResult sourceStringValueWithoutFirst: 2sz last: 1sz) parseCEscapeSequences asSymbol sourcePosition: parserResult sourcePosition
}.

let Scanner::Token
    := Scanner::LeftParent
    | Scanner::RightParent
    | Scanner::LeftBracket
    | Scanner::RightBracket
    | Scanner::LeftCurlyBracket
    | Scanner::RightCurlyBracket

    | Scanner::ByteArrayStart
    | Scanner::LiteralArrayStart
    | Scanner::DictionaryStart

    | Scanner::Ellipsis
    | Scanner::Dot
    | Scanner::Comma
    | Scanner::Assignment
    | Scanner::ColonColon
    | Scanner::Colon
    | Scanner::Semicolon

    | Scanner::Quote
    | Scanner::QuasiQuote
    | Scanner::QuasiUnquote
    | Scanner::Splice

    | Scanner::Character
    | Scanner::String
    | Scanner::Float
    | Scanner::Integer

    | Scanner::SymbolMultiKeyword
    | Scanner::SymbolKeyword
    | Scanner::SymbolIdentifier
    | Scanner::SymbolString
    | Scanner::SymbolOperator

    | Scanner::MultiKeyword
    | Scanner::Keyword
    | Scanner::Identifier
    | Scanner::Operator.

let Scanner::TrimmedToken := Scanner::Token trim: Scanner::White.
let Scanner::Grammar := Scanner::White optional -- Scanner::TrimmedToken star -- Scanner::White optional .


public class SysmelTokenMonadicParser superclass: MonadicParser; definition: {
    public field expectedToken => UInt8.
    public field tokenName => String.

    __Meta__ definition: {
        public method for: (expectedToken: UInt8) name: (tokenName: String) ::=> self
            := self new
                expectedToken: expectedToken;
                tokenName: tokenName;
                yourself.
    }.
    
    public override method parseWithState: (state: MonadicParserState) ::=> MonadicParserResult := {
        let startPosition := state memento.
        state atEnd not ifTrue: {
            let token => SysmelToken := state peek.
            expectedToken = token kind ifTrue: {
                state advance.
                self makeResult: token from: startPosition withState: state
            } ifFalse: {
                self makeError: "Expected {0} instead of the end." formatWith: (Array with: tokenName) withState: state
            }
        } ifFalse: {
            self makeError: "Expected {0}." formatWith: (Array with: tokenName) withState: state
        }.
    }
}.

public class SysmelTokenMonadicParserState superclass: MonadicParserState; definition: {
    public method sourceIndexForTokenStart: (tokenIndex: Size) ::=> Size := {
        tokenIndex < sourceCollection size ifTrue: {
            let token => SysmelToken := sourceCollection at: tokenIndex.
            token sourcePosition startIndex
        } ifFalse: {
            sourceCollection size
        }
    }.

    public method sourceIndexForTokenEnd: (tokenIndex: Size) ::=> Size := {
        tokenIndex < sourceCollection size ifTrue: {
            let token => SysmelToken := sourceCollection at: tokenIndex.
            token sourcePosition endIndex
        } ifFalse: {
            sourceCollection size
        }
    }.

    public override method sourcePositionFrom: (startIndex: Size) until: (endIndex: Size) ::=> SourcePosition
        := SourcePosition for: sourceCode startIndex: (self sourceIndexForTokenStart: startIndex) endIndex: (self sourceIndexForTokenEnd: endIndex).

    public override method sourcePositionUntilEnd => SourcePosition
        := SourcePosition for: sourceCode startIndex: (self sourceIndexForTokenStart: position) endIndex: sourceCollection size.

    public override method sourcePositionAtEnd => SourcePosition := {
        let endIndex := sourceCode text size.
        SourcePosition for: sourceCode startIndex: endIndex endIndex: endIndex
    }.
}.

MonadicParserResult extend: {
    public method valueAsSysmelToken => SysmelToken
        := value downCastTo: SysmelToken.
}.

let Grammar::Token::Integer := SysmelTokenMonadicParser for: SysmelTokenKind::Integer name: "integer".
let Grammar::Token::Float := SysmelTokenMonadicParser for: SysmelTokenKind::Float name: "integer".
let Grammar::Token::Character := SysmelTokenMonadicParser for: SysmelTokenKind::Character name: "character".
let Grammar::Token::String := SysmelTokenMonadicParser for: SysmelTokenKind::String name: "string".
let Grammar::Token::Symbol := SysmelTokenMonadicParser for: SysmelTokenKind::Symbol name: "symbol".

let Grammar::Token::Identifier := SysmelTokenMonadicParser for: SysmelTokenKind::Identifier name: "identifier".
let Grammar::Token::Keyword := SysmelTokenMonadicParser for: SysmelTokenKind::Keyword name: "keyword".
let Grammar::Token::MultiKeyword := SysmelTokenMonadicParser for: SysmelTokenKind::MultiKeyword name: "multi keyword".
let Grammar::Token::Operator := SysmelTokenMonadicParser for: SysmelTokenKind::Operator name: "operator".

let Grammar::Token::LeftParent := SysmelTokenMonadicParser for: SysmelTokenKind::LeftParent name: "left parenthesis".
let Grammar::Token::RightParent := SysmelTokenMonadicParser for: SysmelTokenKind::RightParent name: "right parenthesis".
let Grammar::Token::LeftBracket := SysmelTokenMonadicParser for: SysmelTokenKind::LeftBracket name: "left bracket".
let Grammar::Token::RightBracket := SysmelTokenMonadicParser for: SysmelTokenKind::RightBracket name: "right bracket".
let Grammar::Token::LeftCurlyBracket := SysmelTokenMonadicParser for: SysmelTokenKind::LeftCurlyBracket name: "left curly bracket".
let Grammar::Token::RightCurlyBracket := SysmelTokenMonadicParser for: SysmelTokenKind::RightCurlyBracket name: "right curly bracket".

let Grammar::Token::ByteArrayStart := SysmelTokenMonadicParser for: SysmelTokenKind::ByteArrayStart name: "byte array start (#[)".
let Grammar::Token::DictionaryStart := SysmelTokenMonadicParser for: SysmelTokenKind::DictionaryStart name: "dictionary start (#{)".
let Grammar::Token::LiteralArrayStart := SysmelTokenMonadicParser for: SysmelTokenKind::LiteralArrayStart name: "dictionary start (#()".

let Grammar::Token::Dot := SysmelTokenMonadicParser for: SysmelTokenKind::Dot name: "dot (.)".
let Grammar::Token::Comma := SysmelTokenMonadicParser for: SysmelTokenKind::Comma name: "comma (,)".
let Grammar::Token::Ellipsis := SysmelTokenMonadicParser for: SysmelTokenKind::Ellipsis name: "elipsis (...)".
let Grammar::Token::ColonColon := SysmelTokenMonadicParser for: SysmelTokenKind::ColonColon name: "double colon (::)".
let Grammar::Token::Colon := SysmelTokenMonadicParser for: SysmelTokenKind::Colon name: "colon (:)".
let Grammar::Token::Semicolon := SysmelTokenMonadicParser for: SysmelTokenKind::Semicolon name: "colon (:)".
let Grammar::Token::Assignment := SysmelTokenMonadicParser for: SysmelTokenKind::Assignment name: "assignment (:=)".

let Grammar::Token::Bar := SysmelTokenMonadicParser for: SysmelTokenKind::Bar name: "bar (|)".
let Grammar::Token::Star := SysmelTokenMonadicParser for: SysmelTokenKind::Star name: "star (*)".
let Grammar::Token::LessThan := SysmelTokenMonadicParser for: SysmelTokenKind::LessThan name: "less than (<)".
let Grammar::Token::GreaterThan := SysmelTokenMonadicParser for: SysmelTokenKind::GreaterThan name: "greater than (>)".

let Grammar::Token::Quote := SysmelTokenMonadicParser for: SysmelTokenKind::Quote name: "quote (`')".
let Grammar::Token::QuasiQuote := SysmelTokenMonadicParser for: SysmelTokenKind::QuasiQuote name: "quasi quote (``)".
let Grammar::Token::QuasiUnquote := SysmelTokenMonadicParser for: SysmelTokenKind::QuasiUnquote name: "quasi unquote (`,)".
let Grammar::Token::Splice := SysmelTokenMonadicParser for: SysmelTokenKind::Splice name: "splice (`@)".

let Grammar::Token::Error := SysmelTokenMonadicParser for: SysmelTokenKind::Splice name: "error".

## ----------------------------------------------------------------------------
## Sysmel lisp grammar
## ----------------------------------------------------------------------------
let LispGrammar::Expression := MonadicMemoizedDelegateParser new.
let LispGrammar::Atom := MonadicMemoizedDelegateParser new.
let LispGrammar::ExpressionList := MonadicMemoizedDelegateParser new.

let LispGrammar::ErrorToken := Grammar::Token::Error ::==> {:(MonadicParserResult)parserResult :: AnyValue |
        let token := parserResult valueAsSysmelToken.
        ASTErrorNode new
            sourcePosition: token sourcePosition;
            errorMessage: token value;
            yourself
    }.

let LispGrammar::Identifier
    := Grammar::Token::MultiKeyword
    | Grammar::Token::Keyword
    | Grammar::Token::Identifier
    | Grammar::Token::Operator
    | Grammar::Token::Star
    | Grammar::Token::LessThan
    | Grammar::Token::GreaterThan
    | Grammar::Token::Bar
    | Grammar::Token::Colon
    | Grammar::Token::ColonColon
    | Grammar::Token::Ellipsis
    | Grammar::Token::Comma
    | Grammar::Token::Semicolon
    | Grammar::Token::Assignment
    ::==> {:(MonadicParserResult)parserResult :: AnyValue |
        let token := parserResult valueAsSysmelToken.
        ASTIdentifierReferenceNode new
            sourcePosition: token sourcePosition;
            value: token value;
            yourself
    }.

let LispGrammar::LiteralAtom
    := Grammar::Token::Integer
    | Grammar::Token::Float
    | Grammar::Token::Character
    | Grammar::Token::String
    | Grammar::Token::Symbol 
    
    ::==> {:(MonadicParserResult)parserResult :: AnyValue |
        let token := parserResult valueAsSysmelToken.
        ASTLiteralNode new
            sourcePosition: token sourcePosition;
            value: token value;
            yourself
    }.
LispGrammar::Atom := LispGrammar::LiteralAtom | LispGrammar::Identifier | LispGrammar::ErrorToken.
LispGrammar::ExpressionList := LispGrammar::Expression star.

let LispGrammar::SExpression
    := (Grammar::Token::LeftParent -- LispGrammar::ExpressionList -- Grammar::Token::RightParent)
    | (Grammar::Token::LeftBracket -- LispGrammar::ExpressionList -- Grammar::Token::RightBracket)
    | (Grammar::Token::LeftCurlyBracket -- LispGrammar::ExpressionList -- Grammar::Token::RightCurlyBracket)
    ::==> {:(MonadicParserResult)parserResult :: AnyValue |
        let nodes => Array := parserResult value.
        ASTUnexpandedSExpressionNode new
            sourcePosition: parserResult sourcePosition;
            elements: nodes second asArray;
            yourself
    }.

LispGrammar::Expression := LispGrammar::Atom | LispGrammar::SExpression.

let LispGrammar::ExpressionSequence := LispGrammar::Expression star ::==> {:(MonadicParserResult)parserResult :: AnyValue |
    ASTSequenceNode new
        sourcePosition: parserResult sourcePosition;
        pragmas: #();
        expressions: parserResult value asArray;
        yourself
}.

## ----------------------------------------------------------------------------
## Sysmel grammar
## ----------------------------------------------------------------------------
let SysmelGrammar::Literal := MonadicMemoizedDelegateParser new.
let SysmelGrammar::LiteralIdentifier := MonadicMemoizedDelegateParser new.
let SysmelGrammar::LiteralBinaryOperator := MonadicMemoizedDelegateParser new.
let SysmelGrammar::LiteralLowPrecedenceBinaryOperator := MonadicMemoizedDelegateParser new.
let SysmelGrammar::Identifier := MonadicMemoizedDelegateParser new.

let SysmelGrammar::ParenthesisExpression := MonadicMemoizedDelegateParser new.
let SysmelGrammar::LambdaArgument := MonadicMemoizedDelegateParser new.
let SysmelGrammar::LambdaHeader := MonadicMemoizedDelegateParser new.
let SysmelGrammar::BlockExpression := MonadicMemoizedDelegateParser new.

let SysmelGrammar::Quote := MonadicMemoizedDelegateParser new.
let SysmelGrammar::QuasiQuote := MonadicMemoizedDelegateParser new.
let SysmelGrammar::QuasiUnquote := MonadicMemoizedDelegateParser new.
let SysmelGrammar::Splice := MonadicMemoizedDelegateParser new.

let SysmelGrammar::DictionaryElement := MonadicMemoizedDelegateParser new.
let SysmelGrammar::DictionaryElementList := MonadicMemoizedDelegateParser new.
let SysmelGrammar::MakeByteArray := MonadicMemoizedDelegateParser new.
let SysmelGrammar::MakeDictionary := MonadicMemoizedDelegateParser new.
let SysmelGrammar::LiteralArrayIdentifier := MonadicMemoizedDelegateParser new.
let SysmelGrammar::LiteralArrayElement := MonadicMemoizedDelegateParser new.
let SysmelGrammar::LiteralArray := MonadicMemoizedDelegateParser new.

let SysmelGrammar::PrimaryTerm := MonadicMemoizedDelegateParser new.
let SysmelGrammar::Primary := MonadicMemoizedDelegateParser new.
let SysmelGrammar::UnarySuffixExpression := MonadicMemoizedDelegateParser new.
let SysmelGrammar::UnaryExpression := MonadicMemoizedDelegateParser new.
let SysmelGrammar::BinaryExpression := MonadicMemoizedDelegateParser new.
let SysmelGrammar::ChainExpression := MonadicMemoizedDelegateParser new.
let SysmelGrammar::LowPrecedenceBinaryExpression := MonadicMemoizedDelegateParser new.
let SysmelGrammar::AssignmentExpression := MonadicMemoizedDelegateParser new.
let SysmelGrammar::CommaExpressionElement := MonadicMemoizedDelegateParser new.
let SysmelGrammar::CommaExpression := MonadicMemoizedDelegateParser new.
let SysmelGrammar::Expression := MonadicMemoizedDelegateParser new.
let SysmelGrammar::ExpressionList := MonadicMemoizedDelegateParser new.

let SysmelGrammar::KeywordPragma := MonadicMemoizedDelegateParser new.
let SysmelGrammar::UnaryPragma := MonadicMemoizedDelegateParser new.
let SysmelGrammar::Pragma := MonadicMemoizedDelegateParser new.
let SysmelGrammar::PragmaList := MonadicMemoizedDelegateParser new.

let SysmelGrammar::ErrorToken := Grammar::Token::Error ::==> {:(MonadicParserResult)parserResult :: AnyValue |
        let token := parserResult valueAsSysmelToken.
        ASTErrorNode new
            sourcePosition: token sourcePosition;
            errorMessage: token value;
            yourself
    }.

SysmelGrammar::Literal
    := Grammar::Token::Integer
    | Grammar::Token::Float
    | Grammar::Token::Character
    | Grammar::Token::String
    | Grammar::Token::Symbol
    ::==> {:(MonadicParserResult)parserResult :: AnyValue |
        let token := parserResult valueAsSysmelToken.
        ASTLiteralNode new
            sourcePosition: token sourcePosition;
            value: token value;
            yourself
    }.
SysmelGrammar::LiteralIdentifier
    := Grammar::Token::Identifier
    ::==> {:(MonadicParserResult)parserResult :: AnyValue |
        let token := parserResult valueAsSysmelToken.
        ASTLiteralNode new
            sourcePosition: token sourcePosition;
            value: token value;
            yourself
    }.

let SysmelGrammar::ExpandableName := SysmelGrammar::LiteralIdentifier.

let SysmelGrammar::BinaryOperatorToken
    := Grammar::Token::Operator
    | Grammar::Token::Bar
    | Grammar::Token::Star
    | Grammar::Token::LessThan
    | Grammar::Token::GreaterThan
    .
SysmelGrammar::LiteralBinaryOperator := SysmelGrammar::BinaryOperatorToken
    ::==> {:(MonadicParserResult)parserResult :: AnyValue |
        let token := parserResult valueAsSysmelToken.
        ASTLiteralNode new
            sourcePosition: token sourcePosition;
            value: token value;
            yourself
    }.
SysmelGrammar::LiteralLowPrecedenceBinaryOperator := Grammar::Token::ColonColon -- SysmelGrammar::BinaryOperatorToken
    ::==> {:(MonadicParserResult)parserResult :: AnyValue |
        let token => SysmelToken := parserResult value second.
        ASTLiteralNode new
            sourcePosition: parserResult sourcePosition;
            value: token value;
            yourself
    }.

SysmelGrammar::Identifier
    := Grammar::Token::Identifier
    | Grammar::Token::Ellipsis
    | Grammar::Token::Operator
    | Grammar::Token::Bar
    | Grammar::Token::Star
    | Grammar::Token::LessThan
    | Grammar::Token::GreaterThan
    | Grammar::Token::Keyword
    | Grammar::Token::MultiKeyword
    ::==> {:(MonadicParserResult)parserResult :: AnyValue |
        let token := parserResult valueAsSysmelToken.
        ASTIdentifierReferenceNode new
            sourcePosition: token sourcePosition;
            value: token value;
            yourself
    }.

let SysmelGrammar::KeywordPragmaElement := Grammar::Token::Keyword -- SysmelGrammar::UnaryExpression.

SysmelGrammar::KeywordPragma := (Grammar::Token::LessThan -- SysmelGrammar::KeywordPragmaElement plus -- Grammar::Token::GreaterThan) ==> {:(MonadicParserResult)parserResult :: AnyValue |
        let keywordsWithArguments => OrderedCollection := parserResult value second.
        let selectorBuilder := StringStream new.
        let arguments := Array new: keywordsWithArguments size.
        keywordsWithArguments doWithIndex: {:each :(Size)index :: Void |
            selectorBuilder string: each first value.
            arguments at: index put: each second.
        }.

        let selector := selectorBuilder asSymbol.

        ASTPragmaNode new
            sourcePosition: parserResult sourcePosition;
            selector: (ASTLiteralNode new
                sourcePosition: (parserResult sourcePositionWithoutFirst: 1sz last: 1sz);
                value: selector;
                yourself);
            arguments: arguments;
            yourself
    }.

SysmelGrammar::UnaryPragma := (Grammar::Token::LessThan -- SysmelGrammar::LiteralIdentifier -- Grammar::Token::GreaterThan) ==> {:(MonadicParserResult)parserResult :: AnyValue |
        ASTPragmaNode new
            sourcePosition: parserResult sourcePosition;
            selector: parserResult value second;
            arguments: #();
            yourself
    }.

SysmelGrammar::Pragma := SysmelGrammar::UnaryPragma | SysmelGrammar::KeywordPragma.
SysmelGrammar::PragmaList := SysmelGrammar::Pragma star.

SysmelGrammar::ParenthesisExpression
    := (Grammar::Token::LeftParent -- Grammar::Token::Keyword -- Grammar::Token::RightParent) ==> {:(MonadicParserResult)parserResult :: AnyValue |
            let token => SysmelToken := parserResult value second.
            ASTIdentifierReferenceNode new
                sourcePosition: token sourcePosition;
                value: token value;
                yourself
        }
    | (Grammar::Token::LeftParent -- SysmelGrammar::ExpressionList -- Grammar::Token::RightParent) ==> {:(MonadicParserResult)parserResult :: AnyValue |
        let expressionList => Array := parserResult value second.
        expressionList size = 1sz ifTrue: {
            expressionList first
        } ifFalse: {
            expressionList isEmpty ifTrue: {
                ASTMakeArrayNode new
                    sourcePosition: parserResult sourcePosition;
                    elements: #();
                    yourself
            } ifFalse: {
                ASTSequenceNode new
                    sourcePosition: parserResult sourcePosition;
                    pragmas: #();
                    expressions: expressionList;
                    yourself
            }
        }
    }
    .

SysmelGrammar::LambdaArgument := Grammar::Token::Colon -- Grammar::Token::Star optional
     -- (Grammar::Token::LeftParent -- SysmelGrammar::Expression -- Grammar::Token::RightParent) optional
     -- SysmelGrammar::ExpandableName
    ==> {:(MonadicParserResult)parserResult :: AnyValue |
        let parseElements => Array := parserResult value.
        let typeExpression => Array := parseElements third.
        ASTArgumentNode new
            isForAll: parseElements second isNotNil;
            name: parseElements fourth;
            type: (typeExpression ifNotNil: (typeExpression second));
            yourself
    }.

SysmelGrammar::LambdaHeader := SysmelGrammar::LambdaArgument star -- (Grammar::Token::ColonColon -- SysmelGrammar::UnaryExpression) optional --  Grammar::Token::Bar optional
    ==> {:(MonadicParserResult)parserResult :: AnyValue |
        let parseElements => Array := parserResult value.
        let resultTypeExpression => Array := parseElements second.
        parseElements first isEmpty && resultTypeExpression isNil && parseElements third isNil ifTrue: {
            nil
        } ifFalse: {
            ASTLambdaNode new
                arguments: parseElements first asArray;
                resultType: (resultTypeExpression ifNotNil: resultTypeExpression second);
                yourself
        }.
    }.

SysmelGrammar::BlockExpression := Grammar::Token::LeftCurlyBracket -- SysmelGrammar::LambdaHeader optional -- SysmelGrammar::PragmaList -- SysmelGrammar::ExpressionList -- Grammar::Token::RightCurlyBracket
    ==> {:(MonadicParserResult)parserResult :: AnyValue |
        let parseElements => Array := parserResult value.
        let sourcePosition := parserResult sourcePosition.
        let lambda => ASTLambdaNode := parseElements second.
        let pragmas := parseElements third asArray.
        let body := parseElements fourth.
        let sequenceNode := ASTSequenceNode new
            pragmas: pragmas;
            expressions: body;
            yourself.

        lambda ifNil: {
            ASTLexicalBlockNode new
                sourcePosition: sourcePosition;
                body: sequenceNode;
                yourself
        } ifNotNil: {
            lambda copy
                sourcePosition: sourcePosition;
                body: sequenceNode;
                yourself
        }.
    }.

SysmelGrammar::LiteralArrayIdentifier
    := Grammar::Token::Identifier
    | Grammar::Token::Ellipsis
    | Grammar::Token::Operator
    | Grammar::Token::Bar
    | Grammar::Token::Star
    | Grammar::Token::LessThan
    | Grammar::Token::GreaterThan
    | Grammar::Token::Keyword
    | Grammar::Token::MultiKeyword
    | Grammar::Token::Dot
    | Grammar::Token::Colon
    | Grammar::Token::ColonColon
    | Grammar::Token::Ellipsis
    ::==> {:(MonadicParserResult)parserResult :: AnyValue |
        let token := parserResult valueAsSysmelToken.
        ASTLiteralNode new
            sourcePosition: token sourcePosition;
            value: token value;
            yourself
    }.

let SysmelGrammar::LiteralArrayWithParent := Grammar::Token::LeftParent -- SysmelGrammar::LiteralArrayElement star -- Grammar::Token::RightParent ::==> {:(MonadicParserResult)parserResult :: AnyValue |
        ASTMakeArrayNode new
            sourcePosition: parserResult sourcePosition;
            elements: parserResult value second;
            yourself.
    }.

SysmelGrammar::LiteralArrayElement
    := SysmelGrammar::Literal
    | SysmelGrammar::LiteralArrayIdentifier
    | SysmelGrammar::LiteralArrayWithParent
    | SysmelGrammar::LiteralArray
    .

SysmelGrammar::LiteralArray := Grammar::Token::LiteralArrayStart -- SysmelGrammar::LiteralArrayElement star -- Grammar::Token::RightParent ::==> {:(MonadicParserResult)parserResult :: AnyValue |
        ASTMakeArrayNode new
            sourcePosition: parserResult sourcePosition;
            elements: parserResult value second asArray;
            yourself.
    }.

SysmelGrammar::MakeByteArray
    := Grammar::Token::ByteArrayStart -- SysmelGrammar::ExpressionList -- Grammar::Token::RightBracket ::==> {:(MonadicParserResult)parserResult :: AnyValue |
        ASTMakeByteArrayNode new
            sourcePosition: parserResult sourcePosition;
            elements: parserResult value second asArray;
            yourself.
    }.

let SysmelGrammar::DictionaryElementKeywordKey
    := Grammar::Token::Keyword
    | Grammar::Token::MultiKeyword
    .

let SysmelGrammar::DictionaryElementKey
    := ((SysmelGrammar::BinaryExpression -- Grammar::Token::Colon) ==> {:(MonadicParserResult)parserResult :: AnyValue |
        parserResult value first
    })
    | (SysmelGrammar::DictionaryElementKeywordKey ==> {:(MonadicParserResult)parserResult :: AnyValue |
        let token => SysmelToken := parserResult value.
        let tokenValue => StringSymbol := token value.
        ASTLiteralNode new
            sourcePosition: token sourcePosition;
            value: (tokenValue asString withoutSuffix: ":") asSymbol;
            yourself.
    })
    .

SysmelGrammar::DictionaryElement
    := SysmelGrammar::DictionaryElementKey -- SysmelGrammar::Expression optional ::==> {:(MonadicParserResult)parserResult :: AnyValue |
        ASTMakeAssociationNode new
            sourcePosition: parserResult sourcePosition;
            key: parserResult value first;
            value: parserResult value second;
            yourself.
    }.

SysmelGrammar::DictionaryElementList := Grammar::Token::Dot star withoutValue -- SysmelGrammar::DictionaryElement optional -- (Grammar::Token::Dot plus withoutValue -- SysmelGrammar::DictionaryElement) star -- Grammar::Token::Dot star withoutValue ::==> {:(MonadicParserResult)parserResult :: AnyValue |
    let elements => Array := parserResult value.
    let optionalElement := elements second.
    let listedElements := elements third asArray collect: {:(Array)dotExpression | dotExpression second}.
    (optionalElement ifNil: #() ifNotNil: (Array with: optionalElement)) -- listedElements
}.

SysmelGrammar::MakeDictionary
    := Grammar::Token::DictionaryStart -- SysmelGrammar::DictionaryElementList -- Grammar::Token::RightCurlyBracket ::==> {:(MonadicParserResult)parserResult :: AnyValue |
        ASTMakeDictionaryNode new
            sourcePosition: parserResult sourcePosition;
            elements: parserResult value second;
            yourself.
    }.

SysmelGrammar::PrimaryTerm
    := SysmelGrammar::Identifier
    | SysmelGrammar::Literal
    | SysmelGrammar::ErrorToken
    | SysmelGrammar::ParenthesisExpression
    | SysmelGrammar::BlockExpression
    | SysmelGrammar::MakeByteArray
    | SysmelGrammar::MakeDictionary
    | SysmelGrammar::LiteralArray
    .

SysmelGrammar::Quote := Grammar::Token::Quote -- SysmelGrammar::PrimaryTerm ::==> {:(MonadicParserResult)parserResult :: AnyValue |
        ASTQuoteNode new
            sourcePosition: parserResult sourcePosition;
            node: parserResult value second;
            yourself.
    }.

SysmelGrammar::QuasiQuote := Grammar::Token::QuasiQuote -- SysmelGrammar::PrimaryTerm ::==> {:(MonadicParserResult)parserResult :: AnyValue |
        ASTQuasiQuoteNode new
            sourcePosition: parserResult sourcePosition;
            node: parserResult value second;
            yourself.
    }.

SysmelGrammar::QuasiUnquote := Grammar::Token::QuasiUnquote -- SysmelGrammar::PrimaryTerm ::==> {:(MonadicParserResult)parserResult :: AnyValue |
        ASTQuasiUnquoteNode new
            sourcePosition: parserResult sourcePosition;
            expression: parserResult value second;
            yourself.
    }.

SysmelGrammar::Splice := Grammar::Token::Splice -- SysmelGrammar::PrimaryTerm ::==> {:(MonadicParserResult)parserResult :: AnyValue |
        ASTSpliceNode new
            sourcePosition: parserResult sourcePosition;
            expression: parserResult value second;
            yourself.
    }.

SysmelGrammar::Primary
    := SysmelGrammar::Quote
    | SysmelGrammar::QuasiQuote
    | SysmelGrammar::QuasiUnquote
    | SysmelGrammar::Splice
    | SysmelGrammar::PrimaryTerm.

let SysmelGrammar::UnarySuffixMessage := (SysmelGrammar::LiteralIdentifier | SysmelGrammar::QuasiUnquote) ==> {:(MonadicParserResult)parserResult :: AnyValue |
        let selector => ASTNode := parserResult value.
        ASTMessageSendNode new
            sourcePosition: selector sourcePosition;
            selector: selector;
            arguments: #();
            yourself.
    }.

let SysmelGrammar::ApplicationArgumentList := SysmelGrammar::CommaExpressionElement -- (Grammar::Token::Comma -- SysmelGrammar::CommaExpressionElement) star   ==> {:(MonadicParserResult)parserResult :: AnyValue |
        let parseElements => Array := parserResult value.
        (Array with: parseElements first) -- (parseElements second collect: {:each | each second}) asArray
    }.

let SysmelGrammar::FunctionApplicationSuffix := Grammar::Token::LeftParent -- SysmelGrammar::ApplicationArgumentList optional --  Grammar::Token::RightParent  ==> {:(MonadicParserResult)parserResult :: AnyValue |
        let parseElements => Array := parserResult value.
        let arguments => Array := parseElements second.
        ASTUnexpandedApplicationNode new
            sourcePosition: parserResult sourcePosition;
            arguments: (arguments ifNil: #());
            yourself.
    }.
let SysmelGrammar::ApplyByteArraySuffix := SysmelGrammar::MakeByteArray  ==> {:(MonadicParserResult)parserResult :: AnyValue |
        let byteArray => ASTNode := parserResult value.
        ASTMessageSendNode new
            sourcePosition: byteArray sourcePosition;
            selector: (ASTLiteralNode new
                sourcePosition: byteArray sourcePosition;
                value: #"#[]:";
                yourself);
            arguments: (Array with: byteArray);
            yourself.
    }.

let SysmelGrammar::ApplyBlockSuffix := SysmelGrammar::BlockExpression  ==> {:(MonadicParserResult)parserResult :: AnyValue |
        let block => ASTNode := parserResult value.
        ASTMessageSendNode new
            sourcePosition: block sourcePosition;
            selector: (ASTLiteralNode new
                sourcePosition: block sourcePosition;
                value: #"{}:";
                yourself);
            arguments: (Array with: block);
            yourself.
    }.

let SysmelGrammar::ApplyDictionarySuffix := SysmelGrammar::MakeDictionary  ==> {:(MonadicParserResult)parserResult :: AnyValue |
        let dictionary => ASTNode := parserResult value.
        ASTMessageSendNode new
            sourcePosition: dictionary sourcePosition;
            selector: (ASTLiteralNode new
                sourcePosition: dictionary sourcePosition;
                value: #"#{}:";
                yourself);
            arguments: (Array with: dictionary);
            yourself.
    }.

let SysmelGrammar::ApplyLiteralArraySuffix := SysmelGrammar::LiteralArray  ==> {:(MonadicParserResult)parserResult :: AnyValue |
        let literalArray => ASTNode := parserResult value.
        ASTMessageSendNode new
            sourcePosition: literalArray sourcePosition;
            selector: (ASTLiteralNode new
                sourcePosition: literalArray sourcePosition;
                value: #"#():";
                yourself);
            arguments: (Array with: literalArray);
            yourself.
    }.

let SysmelGrammar::SubscriptSuffix := Grammar::Token::LeftBracket -- SysmelGrammar::Expression optional -- Grammar::Token::RightBracket   ==> {:(MonadicParserResult)parserResult :: AnyValue |
        let parseElements => Array := parserResult value.
        let argument := parseElements second.
        let sourcePosition := parserResult sourcePosition.
        ASTMessageSendNode new
            sourcePosition: sourcePosition;
            selector: (ASTLiteralNode new
                sourcePosition: sourcePosition;
                value: (argument ifNil: #"[]" ifNotNil: #"[]:");
                yourself);
            arguments: (argument ifNil: #() ifNotNil: (Array with: argument));
            yourself.
    }.

SysmelGrammar::UnarySuffixExpression
    := SysmelGrammar::UnarySuffixMessage
    | SysmelGrammar::FunctionApplicationSuffix
    | SysmelGrammar::ApplyByteArraySuffix
    | SysmelGrammar::ApplyBlockSuffix
    | SysmelGrammar::ApplyDictionarySuffix
    | SysmelGrammar::ApplyLiteralArraySuffix
    | SysmelGrammar::SubscriptSuffix
    .

SysmelGrammar::UnaryExpression := SysmelGrammar::Primary -- SysmelGrammar::UnarySuffixExpression star ==> {:(MonadicParserResult)parserResult :: AnyValue |
        let parseElements => Array := parserResult value.
        let receiver mutable => ASTNode := parseElements first.
        let suffixes => OrderedCollection := parseElements second.
        suffixes do: {:(ASTNode)eachSuffix :: Void |
            receiver := (eachSuffix copyWithNewReceiverOrFunction: receiver)
                sourcePosition: (receiver sourcePosition makeUnionWith: eachSuffix sourcePosition);
                yourself
        }.

        receiver
    }.

SysmelGrammar::BinaryExpression := SysmelGrammar::UnaryExpression -- (SysmelGrammar::LiteralBinaryOperator -- SysmelGrammar::UnaryExpression) star
    ==> {:(MonadicParserResult)parserResult :: AnyValue |
        let parseElements => Array := parserResult value.
        let operatorsWithOperands => OrderedCollection := parseElements second.
        operatorsWithOperands isEmpty ifTrue: {
            parseElements first
        } ifFalse: {
            operatorsWithOperands size = 1sz ifTrue: {
                ASTMessageSendNode new
                    sourcePosition: parserResult sourcePosition;
                    receiver: parseElements first;
                    selector: operatorsWithOperands first first;
                    arguments: (Array with: operatorsWithOperands first second);
                    yourself
            } ifFalse: {
                let operands := (Array with: parseElements first) -- (operatorsWithOperands collect: {:each | each second}) asArray.
                let operators := (operatorsWithOperands collect: {:each | each first}) asArray.
                ASTBinaryExpressionSequenceNode new
                    sourcePosition: parserResult sourcePosition;
                    operands: operands;
                    operators: operators;
                    yourself
            }
        }.
    }.

let SysmelGrammar::ChainedKeywordMessage := (Grammar::Token::Keyword -- SysmelGrammar::BinaryExpression) plus ==> {:(MonadicParserResult)parserResult :: AnyValue |
        let pairs => OrderedCollection := parserResult value.
        let selectorBuilder := StringStream new.
        let arguments := Array new: pairs size.
        pairs doWithIndex: {:(Array)selectorWithArgument :(Size)index :: Void |
            selectorBuilder string: selectorWithArgument first value.
            arguments at: index put: selectorWithArgument second
        }.
        let sourcePosition := parserResult sourcePosition.
        ASTMessageChainMessageNode new
            sourcePosition: sourcePosition;
            selector: (ASTLiteralNode new
                sourcePosition: sourcePosition;
                value: selectorBuilder asSymbol;
                yourself);
            arguments: arguments;
            yourself
    }.

let SysmelGrammar::ChainedBinaryMessage := SysmelGrammar::LiteralBinaryOperator -- SysmelGrammar::UnaryExpression  ==> {:(MonadicParserResult)parserResult :: AnyValue |
        let parseElements => Array := parserResult value.
        ASTMessageChainMessageNode new
            sourcePosition: parserResult sourcePosition;
            selector: parseElements first;
            arguments: (Array with: parseElements second);
            yourself
    }.

let SysmelGrammar::ChainedUnaryMessage := SysmelGrammar::LiteralIdentifier ==> {:(MonadicParserResult)parserResult :: AnyValue |
        let selector => ASTNode := parserResult value.
        ASTMessageChainMessageNode new
            sourcePosition: selector sourcePosition;
            selector: selector;
            arguments: #();
            yourself
    }.

let SysmelGrammar::ChainedMessage
    := SysmelGrammar::ChainedUnaryMessage
    | SysmelGrammar::ChainedBinaryMessage
    | SysmelGrammar::ChainedKeywordMessage.

let SysmelGrammar::MessageWithoutReceiver := SysmelGrammar::ChainedKeywordMessage ==> {:(MonadicParserResult)parserResult :: AnyValue |
        parserResult value asUnexpandedSExpression
    }.

SysmelGrammar::ChainExpression
    := ((SysmelGrammar::MessageWithoutReceiver -- (Grammar::Token::Semicolon -- SysmelGrammar::MessageWithoutReceiver) star) ==> {:(MonadicParserResult)parserResult :: AnyValue |
            let parseElements => Array := parserResult value.
            let firstMessage => ASTNode := parseElements first.
            let remainingMessages => OrderedCollection := parseElements second.
            remainingMessages isEmpty ifTrue: {
                firstMessage
            } ifFalse: {
                ASTSequenceNode new
                    sourcePosition: parserResult sourcePosition;
                    pragmas: #();
                    expressions: (Array with: firstMessage) -- remainingMessages asArray;
                    yourself
            }
        })
    | ((SysmelGrammar::BinaryExpression -- SysmelGrammar::ChainedKeywordMessage optional -- (Grammar::Token::Semicolon -- SysmelGrammar::ChainedMessage) star) ==> {:(MonadicParserResult)parserResult :: AnyValue |
        let parseElements => Array := parserResult value.
        let receiver => ASTNode := parseElements first.
        let firstKeywordChainedMessage => ASTMessageChainMessageNode := parseElements second.
        let chainedMessages => OrderedCollection := parseElements third collect: {:(Array)each :: ASTNode | each second}.
        firstKeywordChainedMessage isNil && chainedMessages isEmpty ifTrue: {
            receiver
        } ifFalse: {
            firstKeywordChainedMessage isNotNil && chainedMessages isEmpty ifTrue: {
                (firstKeywordChainedMessage asMessageSendNodeWithReceiver: receiver)
                    sourcePosition: parserResult sourcePosition;
                    yourself

            } ifFalse: {
                let actualReceiver mutable := receiver.
                let firstChainedMessage := firstKeywordChainedMessage ifNil: {
                    receiver isMessageSendNode ifTrue: {
                        let receiverMessage := receiver downCastTo: ASTMessageSendNode.
                        actualReceiver := receiverMessage receiver.

                        Array with: (ASTMessageChainMessageNode new
                            sourcePosition: receiverMessage sourcePosition;
                            selector: receiverMessage selector;
                            arguments: receiverMessage arguments;
                            yourself)
                    } ifFalse: {
                        #()
                    }
                } ifNotNil: {
                    Array with: firstKeywordChainedMessage
                }.

                ASTMessageChainNode new
                    sourcePosition: parserResult sourcePosition;
                    receiver: actualReceiver;
                    messages: firstChainedMessage -- chainedMessages asArray;
                    yourself
            }.
        }.
    }).

SysmelGrammar::LowPrecedenceBinaryExpression := SysmelGrammar::ChainExpression -- (SysmelGrammar::LiteralLowPrecedenceBinaryOperator -- SysmelGrammar::ChainExpression) star
    ==> {:(MonadicParserResult)parserResult :: AnyValue |
        let parseElements => Array := parserResult value.
        let result mutable => ASTNode := parseElements first.
        let operationList => OrderedCollection := parseElements second.
        operationList doWithIndex: {:(Array)eachOperation :(Size)index :: Void |
            let selector => ASTNode := eachOperation first.
            let argument => ASTNode := eachOperation second.
            result := ASTMessageSendNode new
                sourcePosition: (result sourcePosition makeUnionWith: argument sourcePosition);
                receiver: result;
                selector: selector;
                arguments: (Array with: argument);
                yourself
        }.
        result
    }.

SysmelGrammar::AssignmentExpression
    := (SysmelGrammar::LowPrecedenceBinaryExpression -- Grammar::Token::Assignment -- SysmelGrammar::AssignmentExpression ==> {:(MonadicParserResult)parserResult :: AnyValue |
        let parseElements => Array := parserResult value.
        let receiver => ASTNode := parseElements first.
        let selector => SysmelToken := parseElements second.
        let argument => ASTNode := parseElements third.
        ASTMessageSendNode new
            sourcePosition: (receiver sourcePosition makeUnionWith: argument sourcePosition);
            receiver: receiver;
            selector: (ASTLiteralNode new
                sourcePosition: selector sourcePosition;
                value: selector value;
                yourself);
            arguments: (Array with: argument);
            yourself
    })
    | SysmelGrammar::LowPrecedenceBinaryExpression.

SysmelGrammar::CommaExpressionElement := SysmelGrammar::AssignmentExpression.

SysmelGrammar::CommaExpression
    := SysmelGrammar::CommaExpressionElement -- (Grammar::Token::Comma -- SysmelGrammar::CommaExpressionElement) star -- Grammar::Token::Comma optional
        ==> {:(MonadicParserResult)parserResult :: AnyValue |
        let elements => Array := parserResult value.
        elements second isEmpty && elements third isNil ifTrue: {
            elements first
        } ifFalse: {
            let arrayElements => Array := (Array with: elements first) -- (elements second asArray collect: {:(Array)each | each second }).
            ASTMakeArrayNode new
                sourcePosition: parserResult sourcePosition;
                elements: arrayElements;
                yourself
        }
    }
    .

SysmelGrammar::Expression := SysmelGrammar::CommaExpression.
SysmelGrammar::ExpressionList := Grammar::Token::Dot star withoutValue -- SysmelGrammar::Expression optional -- (Grammar::Token::Dot plus withoutValue -- SysmelGrammar::Expression) star -- Grammar::Token::Dot star withoutValue ::==> {:(MonadicParserResult)parserResult :: AnyValue |
    let elements => Array := parserResult value.
    let optionalElement := elements second.
    let listedElements := elements third asArray collect: {:(Array)dotExpression | dotExpression second}.
    (optionalElement ifNil: #() ifNotNil: (Array with: optionalElement)) -- listedElements
}.

let SysmelGrammar::ExpressionSequence := SysmelGrammar::ExpressionList ::==> {:(MonadicParserResult)parserResult :: AnyValue |
    ASTSequenceNode new
        sourcePosition: parserResult sourcePosition;
        pragmas: #();
        expressions: parserResult value;
        yourself
}.

public class SysmelLanguage superclass: Object; definition: {
    __Meta__ extend: {
        public method scanSourceCode: (sourceCode: SourceCode) ::=> Array
            := self new scanSourceCode: sourceCode.

        public method parseSourceCode: (sourceCode: SourceCode) ::=> ASTNode
            := self new parseSourceCode: sourceCode.

        public method analyzeAndEvaluateSourceCode: (sourceCode: SourceCode) withEnvironment: (evaluationEnvironment: Environment) ::=> AnyValue
            := self new analyzeAndEvaluateSourceCode: sourceCode withEnvironment: evaluationEnvironment.

        public method analyzeAndEvaluateSourceCode: (sourceCode: SourceCode) ::=> AnyValue
            := self new analyzeAndEvaluateSourceCode: sourceCode.
    }.

    public virtual method scanSourceCode: (sourceCode: SourceCode) ::=> Array := {
        let parseState := MonadicParserState forSourceCode: sourceCode.
        let parseResult := Scanner::Grammar parseWithState: parseState.
        self assert: parseResult isValid.

        let resultValue => OrderedCollection := parseResult value second.
        parseState atEnd ifFalse: {
            resultValue add: (SysmelToken kind: SysmelTokenKind::Error value: "Expected end of stream" asSymbol sourcePosition: parseState sourcePositionUntilEnd)
        }.

        resultValue asArray
    }.

    public virtual method parseSourceCode: (sourceCode: SourceCode) ::=> ASTNode
        := self parseTokens: (self scanSourceCode: sourceCode) sourceCode: sourceCode.

    public virtual method parseTokens: (tokens: Array) sourceCode: (sourceCode: SourceCode) ::=> ASTNode := {
        let parseState := SysmelTokenMonadicParserState new
            sourceCollection: tokens;
            sourceCode: sourceCode;
            yourself.
        
        let parseResult := self grammar parseWithState: parseState.
        parseResult isError ifTrue: {
            return: (ASTErrorNode new
                errorMessage: parseResult errorMessage;
                yourself).
        }.

        let resultNode => ASTNode := parseResult value.
        resultNode isErrorNode ifFalse: {
            parseState atEnd ifFalse: {
                self assert: resultNode isSequenceNode.

                let sequenceNode := resultNode downCastTo: ASTSequenceNode.
                sequenceNode expressions: sequenceNode expressions -- (ASTErrorNode new
                    errorMessage: "Expected expressions.";
                    yourself,)
            }.
        }.

        resultNode
    }.

    public virtual method grammar => MonadicParser
        := SysmelGrammar::ExpressionSequence.

    public virtual method analyzeAndEvaluateSourceCode: (sourceCode: SourceCode) withEnvironment: (evaluationEnvironment: Environment) ::=> AnyValue := {
        let ast := self parseSourceCode: sourceCode.
        ast analyzeAndEvaluateWithEnvironment: evaluationEnvironment
    }.

    public virtual method analyzeAndEvaluateSourceCode: (sourceCode: SourceCode) ::=> AnyValue
        := self analyzeAndEvaluateSourceCode: sourceCode withEnvironment: Environment defaultForEvaluation.
}.

public class SysmelLispLanguage superclass: SysmelLanguage; definition: {
    public override method grammar => MonadicParser
        := LispGrammar::ExpressionSequence.
}.
