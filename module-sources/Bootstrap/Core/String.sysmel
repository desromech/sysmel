Char8 extend: {
    public method asLowercase => Char8 := {
        if: ('A'asChar8 <= self) && (self <= 'Z'asChar8)
        then: self + 'a'asChar8 - 'A'asChar8
        else: self
    }.

    public method asUppercase => Char8 := {
        if: ('a'asChar8 <= self) && (self <= 'z'asChar8)
        then: self + 'A'asChar8 - 'z'asChar8
        else: self
    }.
}.

String extend: {
    __Meta__ definition: {
        public final method fromCString: (cstring: Char8 const pointer) ::=> self := {
            let stringLength := cstrlen(cstring).
            let result := self basicAllocate: stringLength.
            memcpy(result __rawContentsPointer__, cstring reinterpretCastTo: Void const pointer, stringLength).
            result
        }.

        public final method withBuffer: (string: Char8 const pointer) size: (stringLength: Size) ::=> self := {
            let result := self basicAllocate: stringLength.
            memcpy(result __rawContentsPointer__, string reinterpretCastTo: Void const pointer, stringLength).
            result
        }.

        public final method withReverseBuffer: (string: Char8 const pointer) size: (stringLength: Size) ::=> self := {
            let result := self basicAllocate: stringLength.
            reverseMemcpy(result __rawContentsPointer__, string reinterpretCastTo: Void const pointer, stringLength).
            result
        }.
    }.

    public final method writeOntoStdout => Void := {
        sysmel_pal_writeToFile(sysmel_pal_getStdoutFileHandle(), self size, self __rawContentsPointer__).
    }.

    public final method writeOntoStderr => Void := {
        sysmel_pal_writeToFile(sysmel_pal_getStderrFileHandle(), self size, self __rawContentsPointer__).
    }.
    
    public method asLowercase => String
        := self collect: {:(Char8)c :: Char8 | c asLowercase }.

    public method asUppercase => String
        := self collect: {:(Char8)c :: Char8 | c asUppercase }.

    public pure method asLiteralCString => Char8 const pointer
        := Char8 const pointer withStorage: self.
}.

UInt8 extend: {
    public method printHexDigitOn: (stream: Stream) ::=> Void := {
        (0u8 <= self) && (self <= 9u8)
            ifTrue: (stream nextPut: self asChar8 + '0'asChar8)
            ifFalse: (stream nextPut: self asChar8 + 'A'asChar8 - 10c8).
    }.

    public method printHexOn: (stream: Stream) ::=> Void := {
        self >> 4u8 printHexDigitOn: stream.
        self & 16rF u8 printHexDigitOn: stream.
    }.

    public override final method asString => String
        := self asUInt32 asString.

    public override final method printString => String
        := self asUInt32 asString.
}.

UInt16 extend: {
    public method printHexOn: (stream: Stream) ::=> Void := {
        (self >> 8u16) asUInt8 printHexOn: stream.
        self asUInt8 printHexOn: stream.
    }.

    public override final method asString => String
        := self asUInt32 asString.

    public override final method printString => String
        := self asUInt32 asString.
}.

UInt32 extend: {
    public method printHexOn: (stream: Stream) ::=> Void := {
        (self >> 16u32) asUInt16 printHexOn: stream.
        self asUInt16 printHexOn: stream.
    }.

    public override final method asString => String := {
        let digitCount mutable := 0sz.
        let currentValue mutable := self.

        ## Count the required number of digits.
        do: {
            currentValue := currentValue / 10u32.
            digitCount := digitCount + 1sz.
        } while: (currentValue ~= 0u32).

        let result := String basicAllocate: digitCount.
        
        ## Emit the string
        currentValue := self.
        let digitIndex mutable := 0sz.
        do: {
            let digit := currentValue % 10u32.
            currentValue := currentValue / 10u32.
            result at: digitCount - digitIndex - 1sz put: '0'asChar8 + digit asChar8.
            digitIndex := digitIndex + 1sz
        } while: (currentValue ~= 0u32).

        result
    }.

    public override final method printString => String
        := self asString.
}.

UInt64 extend: {
    public method printHexOn: (stream: Stream) ::=> Void := {
        (self >> 32u64) asUInt32 printHexOn: stream.
        self asUInt32 printHexOn: stream.
    }.

    public override final method asString => String := {
        let digitCount mutable := 0sz.
        let currentValue mutable := self.

        ## Count the required number of digits.
        do: {
            currentValue := currentValue / 10u64.
            digitCount := digitCount + 1sz.
        } while: (currentValue ~= 0u64).

        let result := String basicAllocate: digitCount.
        
        ## Emit the string
        currentValue := self.
        let digitIndex mutable := 0sz.
        do: {
            let digit := currentValue % 10u64.
            currentValue := currentValue / 10u64.
            result at: digitCount - digitIndex - 1sz put: '0'asChar8 + digit asChar8.
            digitIndex := digitIndex + 1sz
        } while: (currentValue ~= 0u64).

        result
    }.

    public override final method printString => String
        := self asString.
}.

Int8 extend: {
    public method printHexOn: (stream: Stream) ::=> Void := {
        self asUInt8 printHexOn: stream.
    }.

    public override final method asString => String
        := self asInt32 asString.

    public override final method printString => String
        := self asInt32 asString.
}.

Int16 extend: {
    public method printHexOn: (stream: Stream) ::=> Void := {
        self asUInt16 printHexOn: stream.
    }.

    public override final method asString => String
        := self asInt32 asString.

    public override final method printString => String
        := self asInt32 asString.
}.

Int32 extend: {
    public method printHexOn: (stream: Stream) ::=> Void := {
        self asUInt32 printHexOn: stream.
    }.

    public override final method asString => String := {
        let absoluteValue := self >= 0i32 ifTrue: self asUInt32 ifFalse: self negated asUInt32.
        let isNegative := self < 0i32.
        let digitCount mutable := 0sz.
        let currentValue mutable := absoluteValue.

        ## Count the required number of digits.
        do: {
            currentValue := currentValue / 10u32.
            digitCount := digitCount + 1sz.
        } while: (currentValue ~= 0u32).

        let prefixSize := isNegative ifTrue: 1sz ifFalse: 0sz.
        let result := String basicAllocate: prefixSize + digitCount.
        
        ## Emit the string
        isNegative ifTrue: (result at: 0sz put: '-'asChar8).
        currentValue := absoluteValue.
        let digitIndex mutable := 0sz.
        do: {
            let digit := currentValue % 10u32.
            currentValue := currentValue / 10u32.
            result at: prefixSize + digitCount - digitIndex - 1sz put: '0'asChar8 + digit asChar8.
            digitIndex := digitIndex + 1sz
        } while: (currentValue ~= 0u32).

        result
    }.

    public override final method printString => String
        := self asString.
}.

Int64 extend: {
    public method printHexOn: (stream: Stream) ::=> Void := {
        self asUInt64 printHexOn: stream.
    }.

    public override final method asString => String := {
        let absoluteValue := self >= 0i64 ifTrue: self asUInt64 ifFalse: self negated asUInt64.
        let isNegative := self < 0i64.
        let digitCount mutable := 0sz.
        let currentValue mutable := absoluteValue.

        ## Count the required number of digits.
        do: {
            currentValue := currentValue / 10u64.
            digitCount := digitCount + 1sz.
        } while: (currentValue ~= 0u64).

        let prefixSize := isNegative ifTrue: 1sz ifFalse: 0sz.
        let result := String basicAllocate: prefixSize + digitCount.
        
        ## Emit the string
        isNegative ifTrue: (result at: 0sz put: '-'asChar8).
        currentValue := absoluteValue.
        let digitIndex mutable := 0sz.
        do: {
            let digit := currentValue % 10u64.
            currentValue := currentValue / 10u64.
            result at: prefixSize + digitCount - digitIndex - 1sz put: '0'asChar8 + digit asChar8.
            digitIndex := digitIndex + 1sz
        } while: (currentValue ~= 0u64).

        result
    }.

    public override final method printString => String
        := self asString.
}.
