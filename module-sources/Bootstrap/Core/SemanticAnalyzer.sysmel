SymbolBinding definition: {
    public abstract method analyzeAndEvaluateWithEnvironment: (environment: Environment) at: (sourcePosition: SourcePosition) ::=> Untyped
        := self subclassResponsibility.

    public abstract eager method analyzeIdentifierReference: (node: ASTIdentifierReferenceNode) withEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode
        := self subclassResponsibility.
    
    public abstract method evaluateWithActivationEnvironment: (environment: FunctionActivationEnvironment) ::=> Untyped
        := self subclassResponsibility.
}.

SymbolValueBinding definition: {
    public override method analyzeAndEvaluateWithEnvironment: (environment: Environment) at: (sourcePosition: SourcePosition) ::=> Untyped
        := self value.

    public override eager method analyzeIdentifierReference: (node: ASTIdentifierReferenceNode) withEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode
        := environment newLiteral: self value at: node sourcePosition.

    public override method evaluateWithActivationEnvironment: (environment: FunctionActivationEnvironment) ::=> Untyped
        := self value.
}.

SymbolMacroValueBinding definition: {
    public override eager method analyzeIdentifierReference: (node: ASTIdentifierReferenceNode) withEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode
        := self expansion analyzeWithEnvironment: environment.
}.

SymbolAnalysisBinding definition: {
    public override eager method analyzeIdentifierReference: (node: ASTIdentifierReferenceNode) withEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode
        := node copy
            analyzerToken: environment validAnalyzerToken;
            analyzedType: self type;
            binding: self;
            yourself.
}.

SymbolArgumentBinding definition: {
    public override method evaluateWithActivationEnvironment: (environment: FunctionActivationEnvironment) ::=> Untyped
        := environment valueVector at: vectorIndex.
}.

SymbolCaptureBinding definition: {
    public override method evaluateWithActivationEnvironment: (environment: FunctionActivationEnvironment) ::=> Untyped
        := environment captureVector at: vectorIndex.
}.

SymbolLocalBinding definition: {
    public override method evaluateWithActivationEnvironment: (environment: FunctionActivationEnvironment) ::=> Untyped
        := environment valueVector at: environment argumentVectorSize + vectorIndex.
}.

function concretizeMetaValueWithEnvironment(value: Untyped, environment: Environment) => Untyped := {
    let type := RawTuple::type(value).
    type
        ifNil: value
        ifNotNil: (type analyzeAndEvaluateConcreteMetaValue: value withEnvironment: environment)
}.

ASTNode definition: {
    public virtual eager method analyzeConcreteMetaValueWithEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode
        := self.

    public virtual eager method semanticError: (errorMessage: String) ::=> Unwinds := {
        self error: self sourcePosition printString -- ": " -- errorMessage
    }.
}.

ASTArgumentNode definition: {
    public eager override method analyzeWithEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode := {
        let result := self copy
            analyzerToken: environment validAnalyzerToken;
            yourself.

        result name ifNotNil: { result name: (environment analyze: result name withExpectedType: Symbol) }.
        result type ifNotNil: {
            result type: (environment analyze: result type withExpectedType: Type)
        } ifNil: {
            result type: (environment newLiteral: AnyValue at: result sourcePosition)
        }.

        let evaluatedName => Symbol := (result name isNotNil && result name isLiteralNode)
            ifTrue: (result name downCastTo: ASTLiteralNode) value
            ifFalse: nil.
        let evaluatedType => Type := (result type isNotNil && result type isLiteralNode)
            ifTrue: (result type downCastTo: ASTLiteralNode) value
            ifFalse: AnyValue.
        result
            analyzedType: evaluatedType;
            binding: (environment setNewSymbol: evaluatedName argumentBindingOfType: evaluatedType at: result sourcePosition);
            yourself
    }
}.

ASTCoerceValueNode definition: {
    public override method analyzeAndEvaluateWithEnvironment: (environment: Environment) ::=> Untyped := {
        let type => Type := self typeExpression analyzeAndEvaluateWithEnvironment: environment.
        let value := self valueExpression analyzeAndEvaluateWithEnvironment: environment.
        type coerceValue: value.
    }.

    public eager override method analyzeWithEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode := {
        (environment analyze: self valueExpression withExpectedTypeExpression: self typeExpression at: self sourcePosition)
            node
    }.

    public override method evaluateWithEnvironment: (environment: FunctionActivationEnvironment) ::=> Untyped := {
        let type => Type := self typeExpression evaluateWithEnvironment: environment.
        let value := self valueExpression evaluateWithEnvironment: environment.
        type coerceValue: value.
    }.
}.

ASTDownCastNode definition: {
    public override method analyzeAndEvaluateWithEnvironment: (environment: Environment) ::=> Untyped := {
        let type => Type := self typeExpression analyzeAndEvaluateWithEnvironment: environment.
        let value := self valueExpression analyzeAndEvaluateWithEnvironment: environment.
        (RawTuple::type(value) isSubtypeOf: type) ifFalse: {
            self semanticError: "Expected a value whose type is " -- type printString
        }.
        value
    }.

    public eager override method analyzeWithEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode := {
        let result := self copy
            analyzerToken: environment validAnalyzerToken;
            typeExpression: (environment analyze: self typeExpression withExpectedType: Type);
            yourself.

        let hasLiteralType := result typeExpression isLiteralNode.
        result analyzedType: (hasLiteralType
            ifTrue: (result typeExpression downCastTo: ASTLiteralNode) value
            ifFalse: (result typeExpression analyzedType asCanonicalPendingInstanceType)
        ).
        result valueExpression: (environment analyzeWithDecayedType: result valueExpression).

        hasLiteralType && (result valueExpression analyzedType isDirectSubtypeOf: result analyzedType)
            ifTrue: result valueExpression
            ifFalse: result
    }.

    public override method evaluateWithEnvironment: (environment: FunctionActivationEnvironment) ::=> Untyped := {
        let type => Type := self typeExpression evaluateWithEnvironment: environment.
        let value := self valueExpression evaluateWithEnvironment: environment.
        (RawTuple::type(value) isSubtypeOf: type) ifFalse: {
            self semanticError: "Expected a value whose type is " -- type printString.
        }.
        value
    }.
}.

ASTErrorNode definition: {
    public override method analyzeAndEvaluateWithEnvironment: (environment: Environment) ::=> Untyped
        := self semanticError: self errorMessage.

    public override eager method analyzeWithEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode
        := self semanticError: self errorMessage.

    public override method evaluateWithEnvironment: (environment: FunctionActivationEnvironment) ::=> Untyped
        := self semanticError: self errorMessage.
}.

ASTIdentifierReferenceNode definition: {
    public override method analyzeAndEvaluateWithEnvironment: (environment: Environment) ::=> Untyped := {
        let binding := environment lookSymbolRecursively: self value.
        binding ifNil: {
            self semanticError: "Failed to find binding for symbol " -- self value printString
        }.

        binding analyzeAndEvaluateWithEnvironment: environment at: self sourcePosition
    }.

    public override eager method analyzeWithEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode := {
        let binding := environment lookSymbolRecursively: self value.
        binding ifNil: {
            self semanticError: "Failed to find binding for symbol " -- self value printString
        }.

        binding analyzeIdentifierReference: self withEnvironment: environment
    }.

    public override method evaluateWithEnvironment: (environment: FunctionActivationEnvironment) ::=> Untyped
        := binding evaluateWithActivationEnvironment: environment.
}.

ASTLiteralNode definition: {
    public override method analyzeAndEvaluateWithEnvironment: (environment: Environment) ::=> Untyped
        := self value.

    public override eager method analyzeWithEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode
        := self copy
            analyzerToken: environment validAnalyzerToken;
            analyzedType: RawTuple::type(self value);
            yourself.

    public override method evaluateWithEnvironment: (environment: FunctionActivationEnvironment) ::=> Untyped
        := self value.

    public override eager method analyzeConcreteMetaValueWithEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode := {
        analyzedType
            ifNil: (self)
            ifNotNil: (analyzedType analyzeConcreteMetaValue: self withEnvironment: environment)
    }.
}.

ASTLexicalBlockNode definition: {
    public override method analyzeAndEvaluateWithEnvironment: (environment: Environment) ::=> Untyped := {
        let childEnvironment := AnalysisAndEvaluationEnvironment parent: environment.
        body analyzeAndEvaluateWithEnvironment: childEnvironment
    }.

    public override eager method analyzeWithEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode := {
        let childEnvironment := LocalAnalysisEnvironment parent: environment.
        (childEnvironment analyzeWithCurrentExpectedType: body)
    }.

    public override method evaluateWithEnvironment: (environment: FunctionActivationEnvironment) ::=> Untyped := {
        body evaluateWithEnvironment: environment
    }.
}.

ASTLocalDefinitionNode definition: {
    public override method analyzeAndEvaluateWithEnvironment: (environment: Environment) ::=> Untyped := {
        let name := self nameExpression ifNotNil: (self nameExpression analyzeAndEvaluateWithEnvironment: environment).
        self isMacroSymbol ifTrue: {
            environment setNewMacro: name valueBinding: self valueExpression at: self sourcePosition.
            return: void
        }.

        let type => Type := self typeExpression ifNotNil: (self typeExpression analyzeAndEvaluateWithEnvironment: environment).
        let value := self valueExpression ifNotNil: (self valueExpression analyzeAndEvaluateWithEnvironment: environment).
        let coercedValue := type ifNil: value ifNotNil: (type coerceValue: value).

        let mutableValue := self isMutable
            ifTrue: ((type ifNil: value __type__) refForFunction untypedWithBoxForValue: value)
            ifFalse: value.

        environment setNewSymbol: name valueBinding: mutableValue at: self sourcePosition.
        mutableValue
    }.

    public eager override method analyzeWithEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode := {
        let result := self copy
            analyzerToken: environment validAnalyzerToken;
            yourself.

        result nameExpression ifNotNil: {
            result nameExpression: (environment analyze: result nameExpression withExpectedType: Symbol)
        }.
        let evaluatedName => Symbol := (result nameExpression isNotNil && result nameExpression isLiteralNode)
            ifTrue: (result nameExpression downCastTo: ASTLiteralNode) value
            ifFalse: nil.

        result isMacroSymbol ifTrue: {
            environment setNewMacro: evaluatedName valueBinding: result valueExpression at: result sourcePosition.
            return: (environment newLiteral: void at: result sourcePosition)
        }.

        result typeExpression ifNotNil: {
            result typeExpression: (environment analyze: result typeExpression withExpectedType: Type)
        }.

        let nodeWithCanonicalType := environment analyze: result valueExpression withExpectedTypeExpression: result typeExpression at: result sourcePosition.
        result valueExpression: nodeWithCanonicalType node.

        let evaluatedValueType := nodeWithCanonicalType canonicalType.
        let evaluatedType := result isMutable
            ifTrue: (evaluatedValueType refForFunction)
            ifFalse: (evaluatedValueType).

        result nameExpression ifNil: {
            return: result valueExpression
        }.

        result isMutable not && result valueExpression isLiteralNode ifTrue: {
            let value := (result valueExpression downCastTo: ASTLiteralNode) value.
            environment setNewSymbol: evaluatedName valueBinding: value at: result sourcePosition.
            result valueExpression
        } ifFalse: {
            let binding := environment setNewSymbol: evaluatedName localBindingOfType: evaluatedType at: result sourcePosition.
            result
                analyzedType: evaluatedType;
                binding: binding;
                yourself
        }.
    }.

    public override method evaluateWithEnvironment: (environment: FunctionActivationEnvironment) ::=> Untyped := {
        let value := self valueExpression ifNotNil: (self valueExpression evaluateWithEnvironment: environment).
        let mutableValue => Untyped := self isMutable
            ifTrue: ((self analyzedType downCastTo: ReferenceType) untypedWithBoxForValue: value)
            ifFalse: value.
        environment setBinding: self binding activationValue: mutableValue.
        mutableValue
    }.
}.

ASTMakeAssociationNode definition: {
    public override eager method analyzeAndEvaluateWithEnvironment: (environment: Environment) ::=> Untyped
        := Association
            key: (self key analyzeAndEvaluateWithEnvironment: environment)
            value: (self value ifNotNil: (self value analyzeAndEvaluateWithEnvironment: environment)).

    public override eager method analyzeWithEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode
        := self copy
            analyzerToken: environment validAnalyzerToken;
            analyzedType: Association;
            key: (environment analyzeWithDecayedType: self key);
            value: (self value ifNotNil: (environment analyzeWithDecayedType: self value));
            yourself.

    public override eager method evaluateWithEnvironment: (environment: FunctionActivationEnvironment) ::=> Untyped
        := Association
            key: (self key evaluateWithEnvironment: environment)
            value: (self value ifNotNil: (self value evaluateWithEnvironment: environment)).
}.

ASTMakeArrayNode definition: {
    public override eager method analyzeAndEvaluateWithEnvironment: (environment: Environment) ::=> Untyped
        := self elements collect: {:(ASTNode)each | each analyzeAndEvaluateWithEnvironment: environment }.

    public override eager method analyzeWithEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode
        := self copy
            analyzerToken: environment validAnalyzerToken;
            analyzedType: Array;
            elements: (self elements collect: {:(ASTNode)each :: ASTNode | environment analyzeWithDecayedType: each});
            yourself.

    public override eager method evaluateWithEnvironment: (environment: FunctionActivationEnvironment) ::=> Untyped
        := self elements collect: {:(ASTNode)each | each evaluateWithEnvironment: environment }.
}.

ASTMakeByteArrayNode definition: {
    public override eager method analyzeAndEvaluateWithEnvironment: (environment: Environment) ::=> Untyped := {
        let result := ByteArray new: elements size.
        self elements doWithIndex: {:(ASTNode)each :(Size)index :: Void |
            result at: index put: (each analyzeAndEvaluateWithEnvironment: environment) u8 ## FIXME: Use the asUInt8 message on integer.
        }.
        result
    }.

    public override eager method analyzeWithEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode
        := self copy
            analyzerToken: environment validAnalyzerToken;
            analyzedType: ByteArray;
            elements: (self elements collect: {:(ASTNode)each :: ASTNode | environment analyzeWithDecayedType: each});
            yourself.

    public override eager method evaluateWithEnvironment: (environment: FunctionActivationEnvironment) ::=> Untyped := {
        let result := ByteArray new: elements size.
        self elements doWithIndex: {:(ASTNode)each :(Size)index :: Void |
            result at: index put: (each evaluateWithEnvironment: environment)
        }.
        result
    }.
}.

ASTMakeDictionaryNode definition: {
    public override eager method analyzeAndEvaluateWithEnvironment: (environment: Environment) ::=> Untyped := {
        let result := Dictionary new: elements size.
        self elements doWithIndex: {:(ASTNode)each :(Size)index :: Void |
            result add: (each analyzeAndEvaluateWithEnvironment: environment)
        }.
        result
    }.

    public override eager method analyzeWithEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode
        := self copy
            analyzerToken: environment validAnalyzerToken;
            analyzedType: Dictionary;
            elements: (self elements collect: {:(ASTNode)each :: ASTNode | environment analyzeWithDecayedType: each});
            yourself.

    public override eager method evaluateWithEnvironment: (environment: FunctionActivationEnvironment) ::=> Untyped := {
        let result := Dictionary new: elements size.
        self elements doWithIndex: {:(ASTNode)each :(Size)index :: Void |
            result add: (each evaluateWithEnvironment: environment)
        }.
        result
    }.
}.

ASTSequenceNode definition: {
    public override method analyzeAndEvaluateWithEnvironment: (environment: Environment) ::=> Untyped := {
        let resultBox := ValueBox with: void.
        self expressions do: {:(ASTNode)eachExpression :: Void |
            let expressionValue := eachExpression analyzeAndEvaluateWithEnvironment: environment.
            resultBox value: concretizeMetaValueWithEnvironment(expressionValue, environment)
        }.

        resultBox value
    }.

    public override eager method analyzeWithEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode := {
        let expressionCount := self expressions size.
        let result := self copy
            analyzerToken: environment validAnalyzerToken;
            pragmas: (self pragmas collect: {:(ASTNode)eachPragma :: ASTNode |
                environment analyze: eachPragma withExpectedType: Pragma
            });
            expressions: (self expressions collectWithIndex: {:(ASTNode)eachExpression :(Size)index :: ASTNode |
                (index + 1sz = expressionCount
                    ifFalse: (environment analyze: eachExpression withExpectedType: Void)
                    ifTrue: (environment analyzeWithCurrentExpectedType: eachExpression))
                    analyzeConcreteMetaValueWithEnvironment: environment
            });
            yourself.
        result analyzedType: (expressionCount = 0sz ifTrue: Void ifFalse: result expressions last analyzedType).
        result
    }.

    public override method evaluateWithEnvironment: (environment: FunctionActivationEnvironment) ::=> Untyped := {
        let resultBox := ValueBox with: void.
        self expressions do: {:(ASTNode)eachExpression :: Void |
            resultBox value: (eachExpression evaluateWithEnvironment: environment)
        }.

        resultBox value
    }.
}.

ASTUnexpandedSExpressionNode definition: {
    public method asUnexpandedApplicationNode => ASTUnexpandedApplicationNode
        := ASTUnexpandedApplicationNode new
            sourcePosition: self sourcePosition;
            functionOrMacroExpression: self elements first;
            arguments: self elements allButFirst;
            yourself.

    public override method analyzeAndEvaluateWithEnvironment: (environment: Environment) ::=> Untyped := {
        self elements isEmpty ifTrue: {
            #()
        } ifFalse: {
            self asUnexpandedApplicationNode analyzeAndEvaluateWithEnvironment: environment
        }
    }.

    public override eager method analyzeWithEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode := {
        self elements isEmpty ifTrue: {
            environment newLiteral: #() at: self sourcePosition
        } ifFalse: {
            self asUnexpandedApplicationNode analyzeWithEnvironment: environment
        }
    }.
}.

ASTUnexpandedApplicationNode definition: {
    public eager method asFunctionApplicationNode => ASTFunctionApplicationNode
        := ASTFunctionApplicationNode new
            sourcePosition: self sourcePosition;
            functionExpression: self functionOrMacroExpression;
            arguments: self arguments;
            yourself.

    public eager method expandWithMacro: macroFunction environment: (environment: Environment) ::=> ASTNode := {
        let macroContext := MacroContext new
            sourceNode: self;
            sourcePosition: self sourcePosition;
            environment: environment;
            yourself.
        macroFunction applyWithArguments: (Array with: macroContext) -- self arguments
    }.
}.

## Temporal definition to avoid cyclic issues.
Function class definition: {
    public virtual eager method analyzeAndEvaluateUnexpandedApplicationNode: (node: ASTUnexpandedApplicationNode) of: (functional: Untyped) withEnvironment: (environment: Environment) ::=> Untyped := {
        functional isMacro ifTrue: {
            (node expandWithMacro: functional environment: environment) analyzeAndEvaluateWithEnvironment: environment
        } ifFalse: {
            node asFunctionApplicationNode
                functionExpression: (ASTLiteralNode new
                    sourcePosition: node functionOrMacroExpression sourcePosition;
                    value: functional;
                    yourself);
                analyzeAndEvaluateWithEnvironment: environment
        }.
    }.

    public virtual eager method analyzeUnexpandedApplicationNode: (node: ASTUnexpandedApplicationNode) withEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> Untyped := {
        node functionOrMacroExpression isLiteralNode && (node functionOrMacroExpression downCastTo: ASTLiteralNode) value isMacro ifTrue: {
            (node expandWithMacro: (node functionOrMacroExpression downCastTo: ASTLiteralNode) value environment: environment) analyzeWithEnvironment: environment
        } ifFalse: {
            node asFunctionApplicationNode analyzeWithEnvironment: environment
        }.
    }.
}.

FunctionType definition: {
    public virtual eager method analyzeAndEvaluateUnexpandedApplicationNode: (node: ASTUnexpandedApplicationNode) of: (functional: Untyped) withEnvironment: (environment: Environment) ::=> Untyped := {
        functional isMacro ifTrue: {
            (node expandWithMacro: functional environment: environment) analyzeAndEvaluateWithEnvironment: environment
        } ifFalse: {
            node asFunctionApplicationNode
                functionExpression: (ASTLiteralNode new
                    sourcePosition: node functionOrMacroExpression sourcePosition;
                    value: functional;
                    yourself);
                analyzeAndEvaluateWithEnvironment: environment
        }.
    }.

    public virtual eager method analyzeUnexpandedApplicationNode: (node: ASTUnexpandedApplicationNode) withEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> Untyped := {
        node functionOrMacroExpression isLiteralNode && (node functionOrMacroExpression downCastTo: ASTLiteralNode) value isMacro ifTrue: {
            (node expandWithMacro: (node functionOrMacroExpression downCastTo: ASTLiteralNode) value environment: environment) analyzeWithEnvironment: environment
        } ifFalse: {
            node asFunctionApplicationNode analyzeWithEnvironment: environment
        }.
    }.
}.

Type definition: {
    public virtual eager method analyzeAndEvaluateUnexpandedApplicationNode: (node: ASTUnexpandedApplicationNode) of: (functional: Untyped) withEnvironment: (environment: Environment) ::=> Untyped := {
        node asFunctionApplicationNode
            functionExpression: (ASTLiteralNode new
                sourcePosition: node functionOrMacroExpression sourcePosition;
                value: functional;
                yourself);
            analyzeAndEvaluateWithEnvironment: environment
    }.

    public virtual eager method analyzeUnexpandedApplicationNode: (node: ASTUnexpandedApplicationNode) withEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> Untyped := {
        node asFunctionApplicationNode analyzeWithEnvironment: environment
    }.
}.

Function class definition: {
    public virtual eager method analyzeAndEvaluateUnexpandedApplicationNode: (node: ASTUnexpandedApplicationNode) of: (functional: Untyped) withEnvironment: (environment: Environment) ::=> Untyped := {
        functional isMacro ifTrue: {
            (node expandWithMacro: functional environment: environment) analyzeAndEvaluateWithEnvironment: environment
        } ifFalse: {
            super analyzeAndEvaluateUnexpandedApplicationNode: node of: functional withEnvironment: environment
        }.
    }.

    public virtual eager method analyzeUnexpandedApplicationNode: (node: ASTUnexpandedApplicationNode) withEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> Untyped := {
        node functionOrMacroExpression isLiteralNode && (node functionOrMacroExpression downCastTo: ASTLiteralNode) value isMacro ifTrue: {
            (node expandWithMacro: (node functionOrMacroExpression downCastTo: ASTLiteralNode) value environment: environment) analyzeWithEnvironment: environment
        } ifFalse: {
            super analyzeUnexpandedApplicationNode: node withEnvironment: environment
        }.
    }.
}.

FunctionType definition: {
    public virtual eager method analyzeAndEvaluateUnexpandedApplicationNode: (node: ASTUnexpandedApplicationNode) of: (functional: Untyped) withEnvironment: (environment: Environment) ::=> Untyped := {
        functional isMacro ifTrue: {
            (node expandWithMacro: functional environment: environment) analyzeAndEvaluateWithEnvironment: environment
        } ifFalse: {
            super analyzeAndEvaluateUnexpandedApplicationNode: node of: functional withEnvironment: environment
        }.
    }.

    public virtual eager method analyzeUnexpandedApplicationNode: (node: ASTUnexpandedApplicationNode) withEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> Untyped := {
        node functionOrMacroExpression isLiteralNode && (node functionOrMacroExpression downCastTo: ASTLiteralNode) value isMacro ifTrue: {
            (node expandWithMacro: (node functionOrMacroExpression downCastTo: ASTLiteralNode) value environment: environment) analyzeWithEnvironment: environment
        } ifFalse: {
            super analyzeUnexpandedApplicationNode: node withEnvironment: environment
        }.
    }.
}.

MetaBuilder class definition: {
    public virtual eager method analyzeUnexpandedApplicationNode: (node: ASTUnexpandedApplicationNode) withEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> Untyped := {
        node functionOrMacroExpression isLiteralNode ifTrue: {
            (node functionOrMacroExpression downCastTo: ASTLiteralNode) value analyzeUnexpandedApplicationNode: node withEnvironment: environment
        } ifFalse: {
            super analyzeUnexpandedApplicationNode: node withEnvironment: environment
        }.
    }.
}.

ASTUnexpandedApplicationNode definition: {
    public override method analyzeAndEvaluateWithEnvironment: (environment: Environment) ::=> Untyped := {
        let functionOrMacro := self functionOrMacroExpression analyzeAndEvaluateWithEnvironment: environment.
        RawTuple::type(functionOrMacro) analyzeAndEvaluateUnexpandedApplicationNode: self of: functionOrMacro withEnvironment: environment
    }.

    public override eager method analyzeWithEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode := {
        let result := self copy
            analyzerToken: environment validAnalyzerToken;
            functionOrMacroExpression: (environment analyzeWithDecayedType: self functionOrMacroExpression);
            yourself.
        result functionOrMacroExpression analyzedType analyzeUnexpandedApplicationNode: result withEnvironment: environment
    }.
}.

ASTFunctionApplicationNode definition: {
    public eager method optimizePureApplicationWithEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode := {
        let canOptimize := self functionExpression isLiteralPureFunctionNode
            && (self arguments allSatisfy: {:(ASTNode)each :: Boolean | each isLiteralNode }).
        canOptimize
            ifTrue: (environment newLiteral: (self analyzeAndEvaluateWithEnvironment: environment) at: self sourcePosition)
            ifFalse: (self)
    }.
}.

Type definition: {
    public virtual eager method analyzeAndTypeCheckFunctionApplicationNode: (node: ASTFunctionApplicationNode) withEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode := {
        node
            analyzedType: AnyValue;
            arguments: (node arguments collect: {:(ASTNode)each :: ASTNode | environment analyzeWithDecayedType: each});
            optimizePureApplicationWithEnvironment: environment
    }.

    public virtual eager method analyzeAndTypeCheckSolvedMessageSendNode: (node: ASTMessageSendNode) withEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode := {
        node
            analyzedType: AnyValue;
            receiver: (node receiver ifNotNil: (environment analyzeWithDecayedType: node receiver));
            arguments: (node arguments collect: {:(ASTNode)each :: ASTNode | environment analyzeWithDecayedType: each});
            yourself
    }.

    #*public virtual eager method analyzeMessageSendNode: (node: ASTMessageSendNode) withEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode := {
        error("TODO").
    }.*#
}.

SimpleFunctionType definition: {
    public virtual eager method analyzeAndTypeCheckFunctionApplicationNode: (node: ASTFunctionApplicationNode) withEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode := {
        let isVariadic := self isVariadic.
        let isMemoizedTemplate := self isMemoizedTemplate.

        let typeArgumentCount := argumentTypes size.
        let expectedArgumentCount mutable := typeArgumentCount.
        let applicationArgumentCount := node arguments size.
        let startingArgumentIndex := isMemoizedTemplate ifTrue: 1sz ifFalse: 0sz.
        isVariadic && typeArgumentCount ifTrue: {
            node semanticError: "Variadic applications require at least a single argument."
        }.

        let directApplicationArgumentCount mutable := isVariadic ifTrue: (typeArgumentCount - 1sz) ifFalse: (typeArgumentCount).
        isMemoizedTemplate ifTrue: {
            expectedArgumentCount = 0sz ifTrue: {
                node semanticError: "Memoized template requires at least a single argument."
            }.

            expectedArgumentCount := expectedArgumentCount - 1sz.
            directApplicationArgumentCount := directApplicationArgumentCount - 1sz.
        }.

        isVariadic && (applicationArgumentCount < directApplicationArgumentCount) ifTrue: {
            node semanticError: "Missing required arguments."
        }.
        isVariadic not && (applicationArgumentCount ~= expectedArgumentCount) ifTrue: {
            node semanticError: "Expected number of arguments is mismatching."
        }.

        node
            arguments: (node arguments collectWithIndex: {:(ASTNode)eachArgument :(Size)eachArgumentIndex :: ASTNode |
                let expectedType := eachArgumentIndex < directApplicationArgumentCount
                    ifTrue: (argumentTypes at: startingArgumentIndex + eachArgumentIndex)
                    ifFalse: AnyValue.
                environment analyze: eachArgument withExpectedType: expectedType
            });
            analyzedType: self canonicalResultType;
            optimizePureApplicationWithEnvironment: environment
    }.

    public override eager method analyzeAndTypeCheckSolvedMessageSendNode: (node: ASTMessageSendNode) withEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode := {
        let firstArgumentIndex := node receiver ifNil: 0sz ifNotNil: 1sz.
        node
            analyzedType: self canonicalResultType;
            receiver: (node receiver ifNotNil: (environment analyze: node receiver withExpectedType: argumentTypes first));
            arguments: (node arguments collectWithIndex: {:(ASTNode)eachArgument :(Size)eachArgumentIndex :: ASTNode |
                environment analyze: eachArgument withExpectedType: (argumentTypes at: firstArgumentIndex + eachArgumentIndex)
            });
            yourself
    }.
}.

ASTFunctionApplicationNode definition: {
    public override method analyzeAndEvaluateWithEnvironment: (environment: Environment) ::=> Untyped := {
        let function := self functionExpression analyzeAndEvaluateWithEnvironment: environment.
        let arguments := self arguments collect: {:(ASTNode)each :: Untyped | each analyzeAndEvaluateWithEnvironment: environment}.
        function applyWithArguments: arguments
    }.

    public override eager method analyzeWithEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode := {
        let result := self copy
            analyzerToken: environment validAnalyzerToken;
            functionExpression: (environment analyzeWithDecayedType: self functionExpression);
            yourself.
        result functionExpression analyzedType analyzeAndTypeCheckFunctionApplicationNode: self withEnvironment: environment
    }.

    public override method evaluateWithEnvironment: (environment: FunctionActivationEnvironment) ::=> Untyped := {
        let function := self functionExpression evaluateWithEnvironment: environment.
        let arguments := self arguments collect: {:(ASTNode)each :: Untyped | each evaluateWithEnvironment: environment}.
        function applyWithArguments: arguments
    }.
}.
