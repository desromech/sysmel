SymbolBinding definition: {
    public abstract method analyzeAndEvaluateWithEnvironment: (environment: Environment) at: (sourcePosition: SourcePosition) ::=> Untyped
        := self subclassResponsibility.

    public abstract eager method analyzeIdentifierReference: (node: ASTIdentifierReferenceNode) withEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode
        := self subclassResponsibility.
    
    public abstract method evaluateWithActivationEnvironment: (environment: FunctionActivationEnvironment) ::=> Untyped
        := self subclassResponsibility.
}.

SymbolValueBinding definition: {
    public override method analyzeAndEvaluateWithEnvironment: (environment: Environment) at: (sourcePosition: SourcePosition) ::=> Untyped
        := self value.

    public override eager method analyzeIdentifierReference: (node: ASTIdentifierReferenceNode) withEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode
        := environment newLiteral: self value at: node sourcePosition.

    public override method evaluateWithActivationEnvironment: (environment: FunctionActivationEnvironment) ::=> Untyped
        := self value.
}.

SymbolMacroValueBinding definition: {
    public override eager method analyzeIdentifierReference: (node: ASTIdentifierReferenceNode) withEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode
        := self expansion analyzeWithEnvironment: environment.
}.

SymbolAnalysisBinding definition: {
    public override eager method analyzeIdentifierReference: (node: ASTIdentifierReferenceNode) withEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode
        := node copy
            analyzerToken: environment validAnalyzerToken;
            analyzedType: self type;
            binding: self;
            yourself.
}.

SymbolArgumentBinding definition: {
    public override method evaluateWithActivationEnvironment: (environment: FunctionActivationEnvironment) ::=> Untyped
        := environment valueVector at: vectorIndex.
}.

SymbolCaptureBinding definition: {
    public override method evaluateWithActivationEnvironment: (environment: FunctionActivationEnvironment) ::=> Untyped
        := environment captureVector at: vectorIndex.
}.

SymbolLocalBinding definition: {
    public override method evaluateWithActivationEnvironment: (environment: FunctionActivationEnvironment) ::=> Untyped
        := environment valueVector at: environment argumentVectorSize + vectorIndex.
}.

function concretizeMetaValueWithEnvironment(value: Untyped, environment: Environment) => Untyped := {
    let type := RawTuple::type(value).
    type
        ifNil: value
        ifNotNil: (type analyzeAndEvaluateConcreteMetaValue: value withEnvironment: environment)
}.

ASTNode definition: {
    public virtual eager method analyzeConcreteMetaValueWithEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode
        := self.

    public virtual eager method semanticError: (errorMessage: String) ::=> Unwinds := {
        self error: self sourcePosition printString -- ": " -- errorMessage
    }.
}.

ASTArgumentNode definition: {
    public eager override method analyzeWithEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode := {
        let result := self copy
            analyzerToken: environment validAnalyzerToken;
            yourself.

        result name ifNotNil: { result name: (environment analyze: result name withExpectedType: Symbol) }.
        result type ifNotNil: {
            result type: (environment analyze: result type withExpectedType: Type)
        } ifNil: {
            result type: (environment newLiteral: AnyValue at: result sourcePosition)
        }.

        let evaluatedName => Symbol := (result name isNotNil && result name isLiteralNode)
            ifTrue: (result name downCastTo: ASTLiteralNode) value
            ifFalse: nil.
        let evaluatedType => Type := (result type isNotNil && result type isLiteralNode)
            ifTrue: (result type downCastTo: ASTLiteralNode) value
            ifFalse: AnyValue.
        result
            analyzedType: evaluatedType;
            binding: (environment setNewSymbol: evaluatedName argumentBindingOfType: evaluatedType at: result sourcePosition);
            yourself
    }
}.

ASTCoerceValueNode definition: {
    public override method analyzeAndEvaluateWithEnvironment: (environment: Environment) ::=> Untyped := {
        let type => Type := self typeExpression analyzeAndEvaluateWithEnvironment: environment.
        let value := self valueExpression analyzeAndEvaluateWithEnvironment: environment.
        type coerceValue: value.
    }.

    #*
    public eager override method analyzeWithEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode := {
        (environment analyze: self valueExpression withExpectedTypeExpression: self typeExpression at: self sourcePosition)
            node
    }.
    *#

    public override method evaluateWithEnvironment: (environment: FunctionActivationEnvironment) ::=> Untyped := {
        let type => Type := self typeExpression evaluateWithEnvironment: environment.
        let value := self valueExpression evaluateWithEnvironment: environment.
        type coerceValue: value.
    }.
}.

ASTDownCastNode definition: {
    public override method analyzeAndEvaluateWithEnvironment: (environment: Environment) ::=> Untyped := {
        let type => Type := self typeExpression analyzeAndEvaluateWithEnvironment: environment.
        let value := self valueExpression analyzeAndEvaluateWithEnvironment: environment.
        (RawTuple::type(value) isSubtypeOf: type) ifFalse: {
            self semanticError: "Expected a value whose type is " -- type printString
        }.
        value
    }.

    public override method evaluateWithEnvironment: (environment: FunctionActivationEnvironment) ::=> Untyped := {
        let type => Type := self typeExpression evaluateWithEnvironment: environment.
        let value := self valueExpression evaluateWithEnvironment: environment.
        (RawTuple::type(value) isSubtypeOf: type) ifFalse: {
            self semanticError: "Expected a value whose type is " -- type printString.
        }.
        value
    }.
}.

ASTErrorNode definition: {
    public override method analyzeAndEvaluateWithEnvironment: (environment: Environment) ::=> Untyped
        := self semanticError: self errorMessage.

    public override eager method analyzeWithEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode
        := self semanticError: self errorMessage.

    public override method evaluateWithEnvironment: (environment: FunctionActivationEnvironment) ::=> Untyped
        := self semanticError: self errorMessage.
}.

ASTIdentifierReferenceNode definition: {
    public override method analyzeAndEvaluateWithEnvironment: (environment: Environment) ::=> Untyped := {
        let binding := environment lookSymbolRecursively: self value.
        binding ifNil: {
            self semanticError: "Failed to find binding for symbol " -- self value printString
        }.

        binding analyzeAndEvaluateWithEnvironment: environment at: self sourcePosition
    }.

    public override eager method analyzeWithEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode := {
        let binding := environment lookSymbolRecursively: self value.
        binding ifNil: {
            self semanticError: "Failed to find binding for symbol " -- self value printString
        }.

        binding analyzeIdentifierReference: self withEnvironment: environment
    }.

    public override method evaluateWithEnvironment: (environment: FunctionActivationEnvironment) ::=> Untyped
        := binding evaluateWithActivationEnvironment: environment.
}.

ASTLiteralNode definition: {
    public override method analyzeAndEvaluateWithEnvironment: (environment: Environment) ::=> Untyped
        := self value.

    public override eager method analyzeWithEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode
        := self copy
            analyzerToken: environment validAnalyzerToken;
            analyzedType: RawTuple::type(self value);
            yourself.

    public override method evaluateWithEnvironment: (environment: FunctionActivationEnvironment) ::=> Untyped
        := self value.

    public override eager method analyzeConcreteMetaValueWithEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode := {
        analyzedType
            ifNil: (self)
            ifNotNil: (analyzedType analyzeConcreteMetaValue: self withEnvironment: environment)
    }.
}.

ASTLexicalBlockNode definition: {
    public override method analyzeAndEvaluateWithEnvironment: (environment: Environment) ::=> Untyped := {
        let childEnvironment := AnalysisAndEvaluationEnvironment parent: environment.
        body analyzeAndEvaluateWithEnvironment: childEnvironment
    }.

    public override eager method analyzeWithEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode := {
        let childEnvironment := LocalAnalysisEnvironment parent: environment.
        (childEnvironment analyzeWithCurrentExpectedType: body)
    }.

    public override method evaluateWithEnvironment: (environment: FunctionActivationEnvironment) ::=> Untyped := {
        body evaluateWithEnvironment: environment
    }.
}.

ASTLocalDefinitionNode definition: {
    public override method analyzeAndEvaluateWithEnvironment: (environment: Environment) ::=> Untyped := {
        let name := self nameExpression ifNotNil: (self nameExpression analyzeAndEvaluateWithEnvironment: environment).
        self isMacroSymbol ifTrue: {
            environment setNewMacro: name valueBinding: self valueExpression at: self sourcePosition.
            return: void
        }.

        let type => Type := self typeExpression ifNotNil: (self typeExpression analyzeAndEvaluateWithEnvironment: environment).
        let value := self valueExpression ifNotNil: (self valueExpression analyzeAndEvaluateWithEnvironment: environment).
        let coercedValue := type ifNil: value ifNotNil: (type coerceValue: value).

        let mutableValue := self isMutable
            ifTrue: ((type ifNil: value __type__) refForFunction untypedWithBoxForValue: value)
            ifFalse: value.

        environment setNewSymbol: name valueBinding: mutableValue at: self sourcePosition.
        mutableValue
    }.

    public eager override method analyzeWithEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode := {
        let result := self copy
            analyzerToken: environment validAnalyzerToken;
            yourself.

        result nameExpression ifNotNil: {
            result nameExpression: (environment analyze: result nameExpression withExpectedType: Symbol)
        }.
        let evaluatedName => Symbol := (result nameExpression isNotNil && result nameExpression isLiteralNode)
            ifTrue: (result nameExpression downCastTo: ASTLiteralNode) value
            ifFalse: nil.

        result isMacroSymbol ifTrue: {
            environment setNewMacro: evaluatedName valueBinding: result valueExpression at: result sourcePosition.
            return: (environment newLiteral: void at: result sourcePosition)
        }.

        result typeExpression ifNotNil: {
            result typeExpression: (environment analyze: result typeExpression withExpectedType: Type)
        }.

        let nodeWithCanonicalType := environment analyze: result valueExpression withExpectedTypeExpression: result typeExpression at: result sourcePosition.
        result valueExpression: nodeWithCanonicalType node.

        let evaluatedValueType := nodeWithCanonicalType canonicalType.
        let evaluatedType := result isMutable
            ifTrue: (evaluatedValueType refForFunction)
            ifFalse: (evaluatedValueType).

        result nameExpression ifNil: {
            return: result valueExpression
        }.

        result isMutable not && result valueExpression isLiteralNode ifTrue: {
            let value := (result valueExpression downCastTo: ASTLiteralNode) value.
            environment setNewSymbol: evaluatedName valueBinding: value at: result sourcePosition.
            result valueExpression
        } ifFalse: {
            let binding := environment setNewSymbol: evaluatedName localBindingOfType: evaluatedType at: result sourcePosition.
            result
                analyzedType: evaluatedType;
                binding: binding;
                yourself
        }.
    }.

    public override method evaluateWithEnvironment: (environment: FunctionActivationEnvironment) ::=> Untyped := {
        let value := self valueExpression ifNotNil: (self valueExpression evaluateWithEnvironment: environment).
        let mutableValue => Untyped := self isMutable
            ifTrue: ((self analyzedType downCastTo: ReferenceType) untypedWithBoxForValue: value)
            ifFalse: value.
        environment setBinding: self binding activationValue: mutableValue.
        mutableValue
    }.
}.

ASTMakeAssociationNode definition: {
    public override eager method analyzeAndEvaluateWithEnvironment: (environment: Environment) ::=> Untyped
        := Association
            key: (self key analyzeAndEvaluateWithEnvironment: environment)
            value: (self value ifNotNil: (self value analyzeAndEvaluateWithEnvironment: environment)).

    public override eager method analyzeWithEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode
        := self copy
            analyzerToken: environment validAnalyzerToken;
            analyzedType: Association;
            key: (environment analyzeWithDecayedType: self key);
            value: (self value ifNotNil: (environment analyzeWithDecayedType: self value));
            yourself.

    public override eager method evaluateWithEnvironment: (environment: FunctionActivationEnvironment) ::=> Untyped
        := Association
            key: (self key evaluateWithEnvironment: environment)
            value: (self value ifNotNil: (self value evaluateWithEnvironment: environment)).
}.

ASTMakeArrayNode definition: {
    public override eager method analyzeAndEvaluateWithEnvironment: (environment: Environment) ::=> Untyped
        := self elements collect: {:(ASTNode)each | each analyzeAndEvaluateWithEnvironment: environment }.

    public override eager method analyzeWithEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode
        := self copy
            analyzerToken: environment validAnalyzerToken;
            analyzedType: Array;
            elements: (self elements collect: {:(ASTNode)each :: ASTNode | environment analyzeWithDecayedType: each});
            yourself.

    public override eager method evaluateWithEnvironment: (environment: FunctionActivationEnvironment) ::=> Untyped
        := self elements collect: {:(ASTNode)each | each evaluateWithEnvironment: environment }.
}.

ASTMakeByteArrayNode definition: {
    public override eager method analyzeAndEvaluateWithEnvironment: (environment: Environment) ::=> Untyped := {
        let result := ByteArray new: elements size.
        self elements doWithIndex: {:(ASTNode)each :(Size)index :: Void |
            result at: index put: (each analyzeAndEvaluateWithEnvironment: environment) u8 ## FIXME: Use the asUInt8 message on integer.
        }.
        result
    }.

    public override eager method analyzeWithEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode
        := self copy
            analyzerToken: environment validAnalyzerToken;
            analyzedType: ByteArray;
            elements: (self elements collect: {:(ASTNode)each :: ASTNode | environment analyzeWithDecayedType: each});
            yourself.

    public override eager method evaluateWithEnvironment: (environment: FunctionActivationEnvironment) ::=> Untyped := {
        let result := ByteArray new: elements size.
        self elements doWithIndex: {:(ASTNode)each :(Size)index :: Void |
            result at: index put: (each evaluateWithEnvironment: environment)
        }.
        result
    }.
}.

ASTMakeDictionaryNode definition: {
    public override eager method analyzeAndEvaluateWithEnvironment: (environment: Environment) ::=> Untyped := {
        let result := Dictionary new: elements size.
        self elements doWithIndex: {:(ASTNode)each :(Size)index :: Void |
            result add: (each analyzeAndEvaluateWithEnvironment: environment)
        }.
        result
    }.

    public override eager method analyzeWithEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode
        := self copy
            analyzerToken: environment validAnalyzerToken;
            analyzedType: Dictionary;
            elements: (self elements collect: {:(ASTNode)each :: ASTNode | environment analyzeWithDecayedType: each});
            yourself.

    public override eager method evaluateWithEnvironment: (environment: FunctionActivationEnvironment) ::=> Untyped := {
        let result := Dictionary new: elements size.
        self elements doWithIndex: {:(ASTNode)each :(Size)index :: Void |
            result add: (each evaluateWithEnvironment: environment)
        }.
        result
    }.
}.

ASTSequenceNode definition: {
    public override method analyzeAndEvaluateWithEnvironment: (environment: Environment) ::=> Untyped := {
        let resultBox := ValueBox with: void.
        self expressions do: {:(ASTNode)eachExpression :: Void |
            let expressionValue := eachExpression analyzeAndEvaluateWithEnvironment: environment.
            resultBox value: concretizeMetaValueWithEnvironment(expressionValue, environment)
        }.

        resultBox value
    }.

    public override eager method analyzeWithEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode := {
        let expressionCount := self expressions size.
        let result := self copy
            analyzerToken: environment validAnalyzerToken;
            pragmas: (self pragmas collect: {:(ASTNode)eachPragma :: ASTNode |
                environment analyze: eachPragma withExpectedType: Pragma
            });
            expressions: (self expressions collectWithIndex: {:(ASTNode)eachExpression :(Size)index :: ASTNode |
                (index + 1sz = expressionCount
                    ifFalse: (environment analyze: eachExpression withExpectedType: Void)
                    ifTrue: (environment analyzeWithCurrentExpectedType: eachExpression))
                    analyzeConcreteMetaValueWithEnvironment: environment
            });
            yourself.
        result analyzedType: (expressionCount = 0sz ifTrue: Void ifFalse: result expressions last analyzedType).
        result
    }.

    public override method evaluateWithEnvironment: (environment: FunctionActivationEnvironment) ::=> Untyped := {
        let resultBox := ValueBox with: void.
        self expressions do: {:(ASTNode)eachExpression :: Void |
            resultBox value: (eachExpression evaluateWithEnvironment: environment)
        }.

        resultBox value
    }.
}.

ASTUnexpandedSExpressionNode definition: {
    public override method analyzeAndEvaluateWithEnvironment: (environment: Environment) ::=> Untyped := {
        self elements isEmpty ifTrue: {
            #()
        } ifFalse: {
            ASTUnexpandedApplicationNode new
                sourcePosition: self sourcePosition;
                functionOrMacroExpression: self elements first;
                arguments: self elements allButFirst;
                analyzeAndEvaluateWithEnvironment: environment
        }
    }.

    public override eager method analyzeWithEnvironment: (environment: AnalysisAndEvaluationEnvironment) ::=> ASTNode := {
        self elements isEmpty ifTrue: {
            environment newLiteral: #() at: self sourcePosition
        } ifFalse: {
            ASTUnexpandedApplicationNode new
                sourcePosition: self sourcePosition;
                functionOrMacroExpression: self elements first;
                arguments: self elements allButFirst;
                analyzeWithEnvironment: environment
        }
    }.
}.
