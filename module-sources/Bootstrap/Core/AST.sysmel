ASTNode
    withSelector: #analyzeWithEnvironment: addMethod: {:(ASTNode)self :(Environment)environment | self subclassResponsibility };
    withSelector: #analyzeAndEvaluateWithEnvironment: addMethod: {:(ASTNode)self :(Environment)environment | self subclassResponsibility };
    withSelector: #evaluateWithEnvironment: addMethod: {:(ASTNode)self :(Environment)environment | self subclassResponsibility };

    withSelector: #childrenDo: addMethod: {:(ASTNode)self :aBlock :: Void | self subclassResponsibility };

    withSelector: #transformWith: addMethod: {:(ASTNode)self :aBlock :: Void | self subclassResponsibility };
    withSelector: #transformedWith: addMethod: {:(ASTNode)self :aBlock :: self class | self copy transformWith: aBlock; yourself };
    
    withSelector: #hasPragmaNamed: addMethod: {:(ASTNode)self :selector :: Boolean | false };
    withSelector: #hasLiteralValueEqualTo: addMethod: {:(ASTNode)self :expectedValue :: Boolean | false };

    withSelector: #isLiteralNode addMethod: {:(ASTNode)self :: Boolean | false };
    withSelector: #literalFunctionPrimitiveName addMethod: {:(ASTNode)self :: Symbol | nil }.

ASTArgumentNode
    withSelector: #childrenDo: addMethod: {:(ASTArgumentNode)self :aBlock :: Void |
        if: (self name isNotNil) then: aBlock(self name).
        if: (self type isNotNil) then: aBlock(self type).
    };
    withSelector: #transformWith: addMethod: {:(ASTArgumentNode)self :aBlock :: Void |
        if: (self name isNotNil) then: (self name: aBlock(self name)).
        if: (self type isNotNil) then: (self type: aBlock(self type)).
    }.

ASTBinaryExpressionSequenceNode
    withSelector: #asExpandedNodeWithEnvironment: addMethod: {:(ASTBinaryExpressionSequenceNode)self :(Environment)environment :: ASTNode |
        ## TODO: perform proper operator precedence parsing.
        let: #operands mutableWith: self operands.
        let: #receiver mutableWith: operands first.
        let: #nextOperandIndex mutableWith: 1sz.
        self operators do: {:(ASTNode)operator :: Void |
            let: #nextOperand with: (operands at: nextOperandIndex).
            nextOperandIndex := nextOperandIndex + 1sz.
            receiver := ASTMessageSendNode new
                sourcePosition: operator sourcePosition;
                receiver: receiver;
                selector: operator;
                arguments: (Array with: nextOperand);
                yourself
        }.

        receiver
    };
    withSelector: #analyzeWithEnvironment: addMethod: {:(ASTBinaryExpressionSequenceNode)self :(Environment)environment |
        (self asExpandedNodeWithEnvironment: environment) analyzeWithEnvironment: environment
    };
    withSelector: #analyzeAndEvaluateWithEnvironment: addMethod: {:(ASTBinaryExpressionSequenceNode)self :(Environment)environment |
        (self asExpandedNodeWithEnvironment: environment) analyzeAndEvaluateWithEnvironment: environment
    };
    withSelector: #evaluateWithEnvironment: addMethod: {:(ASTBinaryExpressionSequenceNode)self :(Environment)environment |
        self error: "This node should be expanded." 
    };


    withSelector: #childrenDo: addMethod: {:(ASTBinaryExpressionSequenceNode)self :aBlock :: Void |
        self operands do: aBlock.
        self operators do: aBlock.
    };
    withSelector: #transformWith: addMethod: {:(ASTBinaryExpressionSequenceNode)self :aBlock :: Void |
        self operands: (self operands collect: aBlock).
        self operators: (self operators collect: aBlock).
    }.

ASTCoerceValueNode
    withSelector: #childrenDo: addMethod: {:(ASTCoerceValueNode)self :aBlock :: Void |
        if: (self typeExpression isNotNil) then: aBlock(self typeExpression).
        if: (self valueExpression isNotNil) then: aBlock(self valueExpression).
    };
    withSelector: #transformWith: addMethod: {:(ASTCoerceValueNode)self :aBlock :: Void |
        if: (self typeExpression isNotNil) then: (self typeExpression: aBlock(self typeExpression)).
        if: (self valueExpression isNotNil) then: (self valueExpression: aBlock(self valueExpression)).
    }.

ASTDoWhileContinueWithNode
    withSelector: #childrenDo: addMethod: {:(ASTDoWhileContinueWithNode)self :aBlock :: Void |
        if: (self bodyExpression isNotNil) then: aBlock(self bodyExpression).
        if: (self conditionExpression isNotNil) then: aBlock(self conditionExpression).
        if: (self continueExpression isNotNil) then: aBlock(self continueExpression).
    };
    withSelector: #transformWith: addMethod: {:(ASTDoWhileContinueWithNode)self :aBlock :: Void |
        if: (self bodyExpression isNotNil) then: (self bodyExpression: aBlock(self bodyExpression)).
        if: (self conditionExpression isNotNil) then: (self conditionExpression: aBlock(self conditionExpression)).
        if: (self continueExpression isNotNil) then: (self continueExpression: aBlock(self continueExpression)).
    }.

ASTErrorNode
    withSelector: #transformWith: addMethod: {:(ASTErrorNode)self :aBlock :: Void |
    }.

ASTFunctionApplicationNode
    withSelector: #initialize addMethod: {:(ASTFunctionApplicationNode)self :: Void |
        (tuple: self withLookupStartingFrom: ASTFunctionApplicationNode supertype) initialize.
        self applicationFlags: 0sz
    };
    withSelector: #hasApplicationFlag: addMethod: {:(ASTFunctionApplicationNode)self :(Bitflags)flag :: Boolean |
        (self applicationFlags & flag) ~= 0bflgs
    };
    withSelector: #isNoTypechecked addMethod: {:(ASTFunctionApplicationNode)self :: Boolean |
        self hasApplicationFlag: FunctionApplicationFlags::NoTypecheck
    };
    withSelector: #childrenDo: addMethod: {:(ASTFunctionApplicationNode)self :aBlock :: Void |
        if: (self functionExpression isNotNil) then: aBlock(self functionExpression).
        self arguments do: aBlock.
    };
    withSelector: #transformWith: addMethod: {:(ASTFunctionApplicationNode)self :aBlock :: Void |
        if: (self functionExpression isNotNil) then: (self functionExpression: aBlock(self functionExpression)).
        self arguments: (self arguments collect: aBlock).
    };
    withSelector: #fullPrintOn: addMethod: {:(ASTFunctionApplicationNode)self :(Stream)stream :: Void |
        stream print: self class; 
            nextPutAll: " analyzedType: "; fullPrint: self analyzedType;
            nextPutAll: " functionExpression: ("; fullPrint: self functionExpression;
            nextPutAll: ") arguments: "; fullPrint: self arguments;
            nextPutAll: " applicationFlags: "; print: self applicationFlags
    }.

ASTLambdaNode
    withSelector: #childrenDo: addMethod: {:(ASTLambdaNode)self :aBlock :: Void |
        self arguments do: aBlock.
        if: (self resultType isNotNil) then: aBlock(self resultType).
        if: (self body isNotNil) then: aBlock(self body).
    };
    withSelector: #transformWith: addMethod: {:(ASTLambdaNode)self :aBlock :: Void |
        self arguments: (self arguments collect: aBlock).
        if: (self resultType isNotNil) then: (self resultType: aBlock(self resultType)).
        if: (self body isNotNil) then: (self body: aBlock(self body)).
    }.

ASTLexicalBlockNode
    withSelector: #hasPragmaNamed: addMethod: {:(ASTLexicalBlockNode)self :selector :: Boolean |
        self body hasPragmaNamed: selector
    };
    withSelector: #childrenDo: addMethod: {:(ASTLexicalBlockNode)self :aBlock :: Void |
        if: (self body isNotNil) then: aBlock(self body).
    };
    withSelector: #transformWith: addMethod: {:(ASTLexicalBlockNode)self :aBlock :: Void |
        if: (self body isNotNil) then: (self body: aBlock(self body)).
    };
    withSelector: #fullPrintOn: addMethod: {:(ASTLexicalBlockNode)self :(Stream)stream :: Void |
        stream print: self class; 
            nextPutAll: " body: ("; fullPrint: self body; nextPut: ')'
    }.

ASTLiteralNode
    withSelector: #analyzeAndEvaluateWithEnvironment: addMethod: {:(ASTLiteralNode)self :(Environment)environment | self value };
    withSelector: #evaluateWithEnvironment: addMethod: {:(ASTLiteralNode)self :(Environment)environment | self value };
    withSelector: #isLiteralNode addMethod: {:(ASTLiteralNode)self :: Boolean | true };
    withSelector: #hasLiteralValueEqualTo: addMethod: {:(ASTLiteralNode)self :expectedValue :: Boolean | self value = expectedValue };

    withSelector: #hasPragmaNamed: addMethod: {:(ASTLiteralNode)self :selector :: Boolean |
        (self analyzedType == Pragma) && (self value selector == selector)
    };

    withSelector: #childrenDo: addMethod: {:(ASTLiteralNode)self :aBlock :: Void | };
    withSelector: #transformWith: addMethod: {:(ASTLiteralNode)self :aBlock :: Void | };

    withSelector: #literalFunctionPrimitiveName addMethod: {:(ASTLiteralNode)self :: Symbol |
        if: (self value __type__ lookupSelector: #primitiveName) ~~ nil
            then: (self value ensureAnalysis; primitiveName)
            else: nil
    };
    withSelector: #fullPrintOn: addMethod: {:(ASTLiteralNode)self :(Stream)stream :: Void |
        stream print: self class; 
            nextPutAll: " analyzedType: "; fullPrint: self analyzedType;
            nextPutAll: " value: "; fullPrint: self value
    }.

ASTLocalDefinitionNode
    withSelector: #childrenDo: addMethod: {:(ASTLocalDefinitionNode)self :aBlock :: Void |
        if: (self nameExpression isNotNil) then: aBlock(self nameExpression).
        if: (self valueExpression isNotNil) then: aBlock(self valueExpression).
    };
    withSelector: #transformWith: addMethod: {:(ASTLocalDefinitionNode)self :aBlock :: Void |
        if: (self nameExpression isNotNil) then: (self nameExpression: aBlock(self nameExpression)).
        if: (self valueExpression isNotNil) then: (self valueExpression: aBlock(self valueExpression)).
    };
    withSelector: #fullPrintOn: addMethod: {:(ASTLocalDefinitionNode)self :(Stream)stream :: Void |
        stream print: self class; 
            nextPutAll: " analyzedType: "; fullPrint: self analyzedType;
            nextPutAll: " nameExpression: ("; fullPrint: self nameExpression;
            nextPutAll: ") valueExpression: ("; fullPrint: self valueExpression; nextPut: ')'
    }.

ASTIdentifierReferenceNode
    withSelector: #childrenDo: addMethod: {:(ASTIdentifierReferenceNode)self :aBlock :: Void | };
    withSelector: #transformWith: addMethod: {:(ASTIdentifierReferenceNode)self :aBlock :: Void | };
    withSelector: #asLiteralNode addMethod: {:(ASTIdentifierReferenceNode)self :: ASTLiteralNode |
        ASTLiteralNode new
            sourcePosition: self sourcePosition;
            value: self value;
            yourself
    };
    withSelector: #fullPrintOn: addMethod: {:(ASTIdentifierReferenceNode)self :(Stream)stream :: Void |
        stream print: self class; 
            nextPutAll: " analyzedType: "; fullPrint: self analyzedType;
            nextPutAll: " value: ("; fullPrint: self value;
            nextPutAll: ") binding: ("; fullPrint: self binding; nextPut: ')'
    }.

ASTIfNode
    withSelector: #childrenDo: addMethod: {:(ASTIfNode)self :aBlock :: Void |
        if: (self conditionExpression isNotNil) then: aBlock(self conditionExpression).
        if: (self trueExpression isNotNil) then: aBlock(self trueExpression).
        if: (self falseExpression isNotNil) then: aBlock(self falseExpression).
    };
    withSelector: #transformWith: addMethod: {:(ASTIfNode)self :aBlock :: Void |
        if: (self conditionExpression isNotNil) then: (self conditionExpression: aBlock(self conditionExpression)).
        if: (self trueExpression isNotNil) then: (self trueExpression: aBlock(self trueExpression)).
        if: (self falseExpression isNotNil) then: (self falseExpression: aBlock(self falseExpression)).
    }.

ASTMakeAssociationNode
    withSelector: #childrenDo: addMethod: {:(ASTMakeAssociationNode)self :aBlock :: Void |
        if: (self key isNotNil) then: aBlock(self key).
        if: (self value isNotNil) then: aBlock(self value).
    };
    withSelector: #transformWith: addMethod: {:(ASTMakeAssociationNode)self :aBlock :: Void |
        if: (self key isNotNil) then: (self key: aBlock(self key)).
        if: (self value isNotNil) then: (self value: aBlock(self value)).
    }.

ASTMakeByteArrayNode
    withSelector: #childrenDo: addMethod: {:(ASTMakeByteArrayNode)self :aBlock :: Void |
        self elements do: aBlock
    };
    withSelector: #transformWith: addMethod: {:(ASTMakeByteArrayNode)self :aBlock :: Void |
        self elements: (self elements collect: aBlock)
    }.

ASTMakeDictionaryNode
    withSelector: #childrenDo: addMethod: {:(ASTMakeDictionaryNode)self :aBlock :: Void |
        self elements do: aBlock
    };
    withSelector: #transformWith: addMethod: {:(ASTMakeDictionaryNode)self :aBlock :: Void |
        self elements: (self elements collect: aBlock)
    }.

ASTMakeArrayNode
    withSelector: #childrenDo: addMethod: {:(ASTMakeArrayNode)self :aBlock :: Void |
        self elements do: aBlock
    };
    withSelector: #transformWith: addMethod: {:(ASTMakeArrayNode)self :aBlock :: Void |
        self elements: (self elements collect: aBlock)
    }.

ASTMessageSendNode
    withSelector: #childrenDo: addMethod: {:(ASTMessageSendNode)self :aBlock :: Void |
        if: (self receiver isNotNil) then: aBlock(self receiver).
        if: (self receiverLookupType isNotNil) then: aBlock(self receiverLookupType).
        if: (self selector isNotNil) then: aBlock(self selector).
        self arguments do: aBlock
    };
    withSelector: #transformWith: addMethod: {:(ASTMessageSendNode)self :aBlock :: Void |
        if: (self receiver isNotNil) then: (self receiver: aBlock(self receiver)).
        if: (self receiverLookupType isNotNil) then: (self receiverLookupType: aBlock(self receiverLookupType)).
        if: (self selector isNotNil) then: (self selector: aBlock(self selector)).
        self arguments: (self arguments collect: aBlock)
    };
    withSelector: #fullPrintOn: addMethod: {:(ASTMessageSendNode)self :(Stream)stream :: Void |
        stream print: self class; 
            nextPutAll: " analyzedType: "; fullPrint: self analyzedType;
            nextPutAll: " receiver: ("; fullPrint: self receiver;
            nextPutAll: ") selector: ("; fullPrint: self selector;
            nextPutAll: ") arguments: "; fullPrint: self arguments
    }.

ASTMessageChainNode
    withSelector: #childrenDo: addMethod: {:(ASTMessageChainNode)self :aBlock :: Void |
        if: (self receiver isNotNil) then: aBlock(self receiver).
        if: (self receiverLookupType isNotNil) then: aBlock(self receiverLookupType).
        self messages do: aBlock
    };
    withSelector: #transformWith: addMethod: {:(ASTMessageChainNode)self :aBlock :: Void |
        if: (self receiver isNotNil) then: (self receiver: aBlock(self receiver)).
        if: (self receiverLookupType isNotNil) then: (self receiverLookupType: aBlock(self receiverLookupType)).
        self messages: (self messages collect: aBlock)
    }.

ASTMessageChainMessageNode
    withSelector: #asMessageSendNodeWithReceiver: addMethod: {:(ASTMessageChainMessageNode)self :(ASTNode)receiver :: ASTMessageSendNode |
        ASTMessageSendNode new
            sourcePosition: self sourcePosition;
            receiver: receiver;
            selector: self selector;
            arguments: self arguments;
            yourself
    };
    withSelector: #childrenDo: addMethod: {:(ASTMessageChainMessageNode)self :aBlock :: Void |
        if: (self selector isNotNil) then: aBlock(self selector).
        self arguments do: aBlock
    };
    withSelector: #transformWith: addMethod: {:(ASTMessageChainMessageNode)self :aBlock :: Void |
        if: (self selector isNotNil) then: (self selector: aBlock(self selector)).
        self arguments: (self arguments collect: aBlock)
    }.

ASTTupleWithLookupStartingFromNode
    withSelector: #childrenDo: addMethod: {:(ASTTupleWithLookupStartingFromNode)self :aBlock :: Void |
        if: (self tupleExpression isNotNil) then: aBlock(self tupleExpression).
        if: (self typeExpression isNotNil) then: aBlock(self typeExpression).
    };
    withSelector: #transformWith: addMethod: {:(ASTTupleWithLookupStartingFromNode)self :aBlock :: Void |
        if: (self tupleExpression isNotNil) then: (self tupleExpression: aBlock(self tupleExpression)).
        if: (self typeExpression isNotNil) then: (self typeExpression: aBlock(self typeExpression)).
    }.

ASTPragmaNode
    withSelector: #hasPragmaNamed: addMethod: {:(ASTPragmaNode)self :expectedSelector :: Boolean |
        let: #selector with: self selector.
        if: selector isNotNil
            then: (selector hasLiteralValueEqualTo: expectedSelector)
            else: false
    };
    withSelector: #childrenDo: addMethod: {:(ASTPragmaNode)self :aBlock :: Void |
        if: (self selector isNotNil) then: aBlock(self selector).
        self arguments do: aBlock
    };
    withSelector: #transformWith: addMethod: {:(ASTPragmaNode)self :aBlock :: Void |
        if: (self selector isNotNil) then: (self selector: aBlock(self selector)).
        self arguments: (self arguments collect: aBlock)
    }.

ASTSequenceNode
    withSelector: #hasPragmaNamed: addMethod: {:(ASTSequenceNode)self :selector :: Boolean |
        self pragmas anySatisfy: {:pragma :: Boolean | pragma hasPragmaNamed: selector}
    };
    withSelector: #childrenDo: addMethod: {:(ASTSequenceNode)self :aBlock :: Void |
        self pragmas do: aBlock.
        self expressions do: aBlock.
    };
    withSelector: #transformWith: addMethod: {:(ASTSequenceNode)self :aBlock :: Void |
        self pragmas: (self pragmas collect: aBlock).
        self expressions: (self expressions collect: aBlock)
    };
    withSelector: #fullPrintOn: addMethod: {:(ASTSequenceNode)self :(Stream)stream :: Void |
        stream print: self class; 
            nextPutAll: " analyzedType: "; fullPrint: self analyzedType;
            nextPutAll: " pragmas: "; fullPrint: self pragmas;
            nextPutAll: " expressions: "; fullPrint: self expressions
    }.

ASTUnexpandedApplicationNode
    withSelector: #childrenDo: addMethod: {:(ASTUnexpandedApplicationNode)self :aBlock :: Void |
        if: (self functionOrMacroExpression isNotNil) then: aBlock(self functionOrMacroExpression).
        self arguments do: aBlock
    };
    withSelector: #transformWith: addMethod: {:(ASTUnexpandedApplicationNode)self :aBlock :: Void |
        if: (self functionOrMacroExpression isNotNil) then: (self functionOrMacroExpression: aBlock(self functionOrMacroExpression)).
        self arguments: (self arguments collect: aBlock)
    }.

ASTUnexpandedSExpressionNode
    withSelector: #childrenDo: addMethod: {:(ASTUnexpandedSExpressionNode)self :aBlock :: Void |
        self elements do: aBlock
    };
    withSelector: #transformWith: addMethod: {:(ASTUnexpandedSExpressionNode)self :aBlock :: Void |
        self elements: (self elements collect: aBlock)
    }.

ASTNode
    withSelector: #analyzeQuasiQuoteWithEnvironment:parameterList: addMethod: {:(ASTNode)self :(Environment)environment :(OrderedCollection)parameterList :: ASTNode |
        self transformedWith: {:child | child analyzeQuasiQuoteWithEnvironment: environment parameterList: parameterList }
    };
    withSelector: #analyzeAndEvaluateQuasiQuoteWithEnvironment: addMethod: {:(ASTNode)self :(Environment)environment :: ASTNode |
        self transformedWith: {:child | child analyzeAndEvaluateQuasiQuoteWithEnvironment: environment }
    };
    withSelector: #evaluateQuasiQuoteWithParameters: addMethod: {:(ASTNode)self :(Array)parameters :: ASTNode |
        self transformedWith: {:child | child evaluateQuasiQuoteWithParameters: parameters }
    }.

let: #expandASTTemplateWithParameters with: {:(ASTNode)templateNode :(Array)templateParameters :: ASTNode |
    templateNode evaluateQuasiQuoteWithParameters: templateParameters
}.

ASTQuasiQuoteNode
    withSelector: #analyzeWithEnvironment: addMethod: {:(ASTQuasiQuoteNode)self :(Environment)environment |
        let: #parameterList with: OrderedCollection new.
        let: #analyzedTemplate with: (self node analyzeQuasiQuoteWithEnvironment: environment parameterList: parameterList).
        let: #analyzedParameterList with: (ASTMakeArrayNode new
            sourcePosition: self sourcePosition;
            elements: parameterList asArray;
            yourself).
        let: #analyzedTemplateNode with: (ASTLiteralNode new
            sourcePosition: self node sourcePosition;
            analyzedType: analyzedTemplate __type__;
            value: analyzedTemplate;
            yourself).

        (ASTUnexpandedApplicationNode new
            sourcePosition: self sourcePosition;
            functionOrMacroExpression: (ASTLiteralNode new
                sourcePosition: self sourcePosition;
                analyzedType: expandASTTemplateWithParameters __type__;
                value: expandASTTemplateWithParameters;
                yourself);
            arguments: (Array with: analyzedTemplateNode with: analyzedParameterList);
            yourself) analyzeWithEnvironment: environment
    };
    withSelector: #analyzeAndEvaluateWithEnvironment: addMethod: {:(ASTQuasiQuoteNode)self :(Environment)environment |
        self node analyzeAndEvaluateQuasiQuoteWithEnvironment: environment
    };
    withSelector: #evaluateWithEnvironment: addMethod: {:(ASTQuasiQuoteNode)self :(Environment)environment |
        self node evaluateQuasiQuoteWithEnvironment: environment
    };
    withSelector: #childrenDo: addMethod: {:(ASTQuasiQuoteNode)self :aBlock :: Void |
        if: (self node isNotNil) then: aBlock(self node)
    };
    withSelector: #transformWith: addMethod: {:(ASTQuasiQuoteNode)self :aBlock :: Void |
        if: (self node isNotNil) then: (self node: aBlock(self node))
    }.

ASTQuasiUnquoteNode
    withSelector: #analyzeQuasiQuoteWithEnvironment:parameterList: addMethod: {:(ASTQuasiUnquoteNode)self :(Environment)environment :(OrderedCollection)parameterList :: ASTNode |
        let: #astTemplateParameterIndex with: parameterList size.
        parameterList add: self expression.
        self copy
            astTemplateParameterIndex: astTemplateParameterIndex;
            yourself
    };
    withSelector: #analyzeAndEvaluateQuasiQuoteWithEnvironment: addMethod: {:(ASTQuasiUnquoteNode)self :(Environment)environment |
        self expression analyzeAndEvaluateWithEnvironment: environment
    };
    withSelector: #evaluateQuasiQuoteWithParameters: addMethod: {:(ASTQuasiUnquoteNode)self :(Array)parameters :: ASTNode |
        parameters at: self astTemplateParameterIndex
    };
    withSelector: #childrenDo: addMethod: {:(ASTQuasiUnquoteNode)self :aBlock :: Void |
        if: (self expression) then: aBlock(self expression)
    };
    withSelector: #transformWith: addMethod: {:(ASTQuasiUnquoteNode)self :aBlock :: Void |
        if: (self expression) then: (self expression: aBlock(self expression))
    }.

ASTQuoteNode
    withSelector: #analyzeWithEnvironment: addMethod: {:(ASTQuoteNode)self :(Environment)environment |
        ASTLiteralNode new
            sourcePosition: self sourcePosition;
            value: self node;
            analyzedType: self node __type__;
            yourself
    };
    withSelector: #analyzeAndEvaluateWithEnvironment: addMethod: {:(ASTQuoteNode)self :(Environment)environment | self node};
    withSelector: #evaluateWithEnvironment: addMethod: {:(ASTQuoteNode)self :(Environment)environment | self node};
    withSelector: #childrenDo: addMethod: {:(ASTQuoteNode)self :aBlock :: Void |
        if: (self node) then: aBlock(self node)
    };
    withSelector: #transformWith: addMethod: {:(ASTQuoteNode)self :aBlock :: Void |
        if: (self node) then: (self node: aBlock(self node))
    }.

ASTSpliceNode
    withSelector: #analyzeWithEnvironment: addMethod: {:(ASTSpliceNode)self :(Environment)environment | self invalidLocationError };
    withSelector: #analyzeAndEvaluateWithEnvironment: addMethod: {:(ASTSpliceNode)self :(Environment)environment | self invalidLocationError };
    withSelector: #evaluateWithEnvironment: addMethod: {:(ASTSpliceNode)self :(Environment)environment | self invalidLocationError };
    withSelector: #childrenDo: addMethod: {:(ASTSpliceNode)self :aBlock :: Void |
        if: (self expression) then: aBlock(self expression)
    };
    withSelector: #transformWith: addMethod: {:(ASTSpliceNode)self :aBlock :: Void |
        if: (self expression) then: (self expression: aBlock(self expression))
    };

    withSelector: #analyzeQuasiQuoteWithEnvironment:parameterList: addMethod: {:(ASTSpliceNode)self :(Environment)environment :(OrderedCollection)parameterList | self invalidLocationError };
    withSelector: #analyzeAndEvaluateQuasiQuoteWithEnvironment: addMethod: {:(ASTSpliceNode)self :(Environment)environment | self invalidLocationError };
    withSelector: #evaluateQuasiQuoteWithParameters: addMethod: {:(ASTSpliceNode)self :(Array)parameters | self invalidLocationError };

    withSelector: #invalidLocationError addMethod: {:(ASTSpliceNode)self |
        self error: "Invalid location for a splice expression."
    }.

ASTWhileContinueWithNode
    withSelector: #childrenDo: addMethod: {:(ASTWhileContinueWithNode)self :aBlock :: Void |
        if: (self conditionExpression isNotNil) then: aBlock(self conditionExpression).
        if: (self bodyExpression isNotNil) then: aBlock(self bodyExpression).
        if: (self continueExpression isNotNil) then: aBlock(self bodyExpression).
    };
    withSelector: #transformWith: addMethod: {:(ASTWhileContinueWithNode)self :aBlock :: Void |
        if: (self conditionExpression isNotNil) then: (self conditionExpression: aBlock(self conditionExpression)).
        if: (self bodyExpression isNotNil) then: (self bodyExpression: aBlock(self bodyExpression)).
        if: (self continueExpression isNotNil) then: (self continueExpression: aBlock(self continueExpression)).
    };
    withSelector: #fullPrintOn: addMethod: {:(ASTWhileContinueWithNode)self :(Stream)stream :: Void |
        stream print: self class; 
            nextPutAll: " conditionExpression: ("; fullPrint: self conditionExpression;
            nextPutAll: ") bodyExpression: ("; fullPrint: self bodyExpression;
            nextPutAll: ") continueExpression: ("; fullPrint: self continueExpression; nextPut: ')'
    }.
