__Global__
    name: #__Global__;
    setSymbol: #__OwnerProgramEntity__ value: __Global__;
    setSymbol: #public:with: value: {:macroContext :(ASTNode)symbol :(ASTNode)value :: ASTNode |
        ``(__OwnerProgramEntity__ setPublicSymbol: `,symbol value: `,value)
    } makeMacro.

Class
    withSelector: #publicSubclass:classSlots:slots: addMacroMethod: {:macroContext :(ASTNode)self :(ASTNode)name :(ASTNode)classSlots :(ASTNode)instanceSlots :: ASTNode |
        ``(public: `,name with: (`,self subclass: `,name classSlots: `,classSlots slots: `,instanceSlots))
    } makeMacro;
    withSelector: #publicSubclass:slots: addMacroMethod: {:macroContext :(ASTNode)self :(ASTNode)name :(ASTNode)instanceSlots :: ASTNode |
        ``(public: `,name with: (`,self subclass: `,name slots: `,instanceSlots))
    } makeMacro.

Object publicSubclass: #MetaBuilder slots: ().

MetaBuilder
    withSelector: #analyzeAndEvaluateMessageSendNode:forReceiver:withEnvironment: addClassMethod: {:self :(ASTMessageSendNode)messageSendNode :(Untyped)receiver :(Environment)environment |
        let: #selfReceiver with: (ASTLiteralNode new
            sourcePosition: messageSendNode receiver sourcePosition;
            value: receiver;
            yourself). 
        let: #messageWithSelfReceiver with: (messageSendNode copy
            receiver: selfReceiver;
            yourself).

        receiver analyzeAndEvaluateMessageSendNode: messageWithSelfReceiver withEnvironment: environment
    };
    withSelector: #analyzeMessageSendNode:withEnvironment: addClassMethod: {:self :(ASTMessageSendNode)messageSendNode :(Environment)environment |
        ## FIXME: Guard against non-literal functionOrMacroExpression here.
        messageSendNode receiver value analyzeMessageSendNode: messageSendNode withEnvironment: environment
    };
    withSelector: #analyzeAndEvaluateUnexpandedApplicationNode:of:withEnvironment: addClassMethod: {:self :(ASTUnexpandedApplicationNode)unexpandedApplicationNode :(Untyped)functional :(Environment)environment |
        let: #selfReceiver with: (ASTLiteralNode new
            sourcePosition: unexpandedApplicationNode functionOrMacroExpression sourcePosition;
            value: functional;
            yourself). 
        let: #unexpandedApplicationWithSelfReceiver with: (unexpandedApplicationNode copy
            functionOrMacroExpression: selfReceiver;
            yourself).

        functional analyzeAndEvaluateUnexpandedApplicationNode: unexpandedApplicationWithSelfReceiver withEnvironment: environment
    };
    withSelector: #analyzeUnexpandedApplicationNode:withEnvironment: addClassMethod: {:self :(ASTUnexpandedApplicationNode)unexpandedApplicationNode :(Environment)environment |
        ## FIXME: Guard against non-literal functionOrMacroExpression here.
        unexpandedApplicationNode functionOrMacroExpression value analyzeUnexpandedApplicationNode: unexpandedApplicationNode withEnvironment: environment
    };
    withSelector: #analyzeAndEvaluateMessageChainNode:forReceiver:withEnvironment: addClassMethod: {:self :messageChainNode :(Untyped)receiver :(Environment)environment :: Untyped |
        let: #selfReceiver with: (ASTLiteralNode new
            sourcePosition: messageChainNode receiver sourcePosition;
            value: receiver;
            yourself). 
        
        let: #result type: Untyped mutableWith: receiver.

        messageChainNode messages do: {:messageChainMessageNode :: Void |
            result := receiver analyzeAndEvaluateMessageSendNode: (messageChainMessageNode asMessageSendNodeWithReceiver: selfReceiver) withEnvironment: environment
        }.

        result
    };
    withSelector: #analyzeMessageChainNode:withEnvironment: addClassMethod: {:self :messageChainNode :(Environment)environment |
        let: #selfReceiver with: messageChainNode receiver.
        let: #receiver with: selfReceiver value.
        let: #result type: ASTNode mutableWith: selfReceiver.

        messageChainNode messages do: {:messageChainMessageNode :: Void |
            result := receiver analyzeMessageSendNode: (messageChainMessageNode asMessageSendNodeWithReceiver: selfReceiver) withEnvironment: environment
        }.

        result
    };
    withSelector: #analyzeAndEvaluateConcreteMetaValue:withEnvironment: addClassMethod: {:self :metaBuilderInstance :(Environment)environment |
        metaBuilderInstance analyzeAndEvaluateConcreteMetaValueWithEnvironment: environment
    };
    withSelector: #analyzeConcreteMetaValue:withEnvironment: addClassMethod: {:self :metaBuilderLiteralNode :(Environment)environment |
        metaBuilderLiteralNode value analyzeConcreteMetaValue: metaBuilderLiteralNode withEnvironment: environment
    };
    withSelector: #analyzeAndEvaluateMessageSendNode:withEnvironment: addMethod: {:self :(ASTMessageSendNode)messageSendNode :(Environment)environment |
        self subclassResponsibility
    };
    withSelector: #analyzeMessageSendNode:withEnvironment: addMethod: {:self :(ASTMessageSendNode)messageSendNode :(Environment)environment |
        self subclassResponsibility
    };
    withSelector: #analyzeAndEvaluateUnexpandedApplicationNode:withEnvironment: addMethod: {:self :(ASTUnexpandedApplicationNode)node :(Environment)environment |
        self subclassResponsibility
    };
    withSelector: #analyzeUnexpandedApplicationNode:withEnvironment: addMethod: {:self :(ASTMessageSendNode)messageSendNode :(Environment)environment |
        self subclassResponsibility
    };
    withSelector: #analyzeAndEvaluateConcreteMetaValueWithEnvironment: addMethod: {:self :(Environment)environment |
        self
    };
    withSelector: #analyzeConcreteMetaValue:withEnvironment: addMethod: {:self :metaBuilderLiteralNode :(Environment)environment |
        metaBuilderLiteralNode
    }.

MetaBuilder publicSubclass: #MetaBuilderFactory slots: (
    TypeSlot publicNamed: #metaBuilderClass type: Class,
).

MetaBuilderFactory
    withSelector: #for: addClassMethod: {:self :metaBuilderClass :: self |
        self new
            metaBuilderClass: metaBuilderClass;
            yourself
    };
    withSelector: #analyzeAndEvaluateMessageSendNode:withEnvironment: addMethod: {:self :(ASTMessageSendNode)messageSendNode :(Environment)environment |
        let: #metaBuilderInstance with: self metaBuilderClass new.
        let: #metaBuilderInstanceNode with: (ASTLiteralNode new
            sourcePosition: messageSendNode receiver sourcePosition;
            value: metaBuilderInstance;
            yourself).
        let: #messageWithMetaBuilderInstance with: (messageSendNode copy
            receiver: metaBuilderInstanceNode;
            yourself).
        metaBuilderInstance analyzeAndEvaluateMessageSendNode: messageWithMetaBuilderInstance withEnvironment: environment
    };
    withSelector: #analyzeMessageSendNode:withEnvironment: addMethod: {:self :(ASTMessageSendNode)messageSendNode :(Environment)environment |
        let: #metaBuilderInstance with: self metaBuilderClass new.
        let: #metaBuilderInstanceNode with: (ASTLiteralNode new
            sourcePosition: messageSendNode receiver sourcePosition;
            value: metaBuilderInstance;
            yourself).
        let: #messageWithMetaBuilderInstance with: (messageSendNode copy
            receiver: metaBuilderInstanceNode;
            yourself).
        metaBuilderInstance analyzeMessageSendNode: messageWithMetaBuilderInstance withEnvironment: environment
    };
    withSelector: #analyzeUnexpandedApplicationNode:withEnvironment: addMethod: {:self :(ASTUnexpandedApplicationNode)unexpandedApplicationNode :(Environment)environment |
        let: #metaBuilderInstance with: self metaBuilderClass new.
        let: #metaBuilderInstanceNode with: (ASTLiteralNode new
            sourcePosition: unexpandedApplicationNode functionOrMacroExpression sourcePosition;
            value: metaBuilderInstance;
            yourself).
        let: #unexpandedApplicationNodeWithInstance with: (unexpandedApplicationNode copy
            functionOrMacroExpression: metaBuilderInstanceNode;
            yourself).
        metaBuilderInstance analyzeUnexpandedApplicationNode: unexpandedApplicationNodeWithInstance withEnvironment: environment
    }.

MetaBuilder publicSubclass: #MacroMetaBuilder slots: (
    TypeSlot publicNamed: #environment type: Environment ,
    TypeSlot publicNamed: #sourcePosition type: SourcePosition ,
    TypeSlot publicNamed: #continueExpansion type: ASTNode
).

MacroMetaBuilder
    withSelector: #analyzeAndEvaluateMessageSendNode:withEnvironment: addMethod: {:self :(ASTMessageSendNode)messageSendNode :(Environment)environment |
        (self expandMessageSendNode: messageSendNode withEnvironment: environment) analyzeAndEvaluateWithEnvironment: environment
    };
    withSelector: #analyzeMessageSendNode:withEnvironment: addMethod: {:self :(ASTMessageSendNode)messageSendNode :(Environment)environment |
        (self expandMessageSendNode: messageSendNode withEnvironment: environment) analyzeWithEnvironment: environment
    };
    withSelector: #analyzeAndEvaluateUnexpandedApplicationNode:withEnvironment: addMethod: {:self :(ASTUnexpandedApplicationNode)unexpandedApplicationNode :(Environment)environment |
        (self expandUnexpandedApplicationNode: unexpandedApplicationNode withEnvironment: environment) analyzeAndEvaluateWithEnvironment: environment
    };
    withSelector: #analyzeUnexpandedApplicationNode:withEnvironment: addMethod: {:self :(ASTUnexpandedApplicationNode)unexpandedApplicationNode :(Environment)environment |
        (self expandUnexpandedApplicationNode: unexpandedApplicationNode withEnvironment: environment) analyzeWithEnvironment: environment
    };
    withSelector: #expandMessageSendNode:withEnvironment: addMethod: {:self :(ASTMessageSendNode)messageSendNode :(Environment)environment :: ASTNode |
        self
            environment: environment;
            sourcePosition: messageSendNode sourcePosition;
            continueExpansion: messageSendNode receiver;
            expandMessageSendNode: messageSendNode
    };
    withSelector: #expandUnexpandedApplicationNode:withEnvironment: addMethod: {:self :(ASTUnexpandedApplicationNode)unexpandedApplicationNode :(Environment)environment :: ASTNode |
        self
            environment: environment;
            sourcePosition: unexpandedApplicationNode sourcePosition;
            continueExpansion: unexpandedApplicationNode functionOrMacroExpression;
            expandUnexpandedApplicationNode: unexpandedApplicationNode
    };
    withSelector: #analyzeAndEvaluateConcreteMetaValueWithEnvironment: addMethod: {:self :(Environment)environment |
        (self
            environment: environment;
            finishExpansion) analyzeAndEvaluateWithEnvironment: environment
    };
    withSelector: #analyzeConcreteMetaValue:withEnvironment: addMethod: {:self :metaBuilderLiteralNode :(Environment)environment |
        self
            environment: environment;
            sourcePosition: metaBuilderLiteralNode sourcePosition;
            finishExpansion
    };
    withSelector: #expandMessageSendNode: addMethod: {:self :(ASTMessageSendNode)messageSendNode :: ASTNode |
        self expandMessageSendNodeWithMetaBuilderMethod: messageSendNode
    };
    withSelector: #expandUnexpandedApplicationNode: addMethod: {:self :(ASTUnexpandedApplicationNode)unexpandedApplicationNode :: ASTNode |
        self finishExpansion
    };
    withSelector: #expandMessageSendNodeWithMetaBuilderMethod: addMethod: {:self :(ASTMessageSendNode)messageSendNode :: ASTNode |
        let: #metaBuilderMethod with: (
            if: messageSendNode selector isLiteralNode
                then: (self class lookupSelector: messageSendNode selector value)
                else: (nil)
        ).

        if: metaBuilderMethod isNotNil && (metaBuilderMethod hasPragmaNamed: #metaBuilder)
            then: apply(metaBuilderMethod, self, messageSendNode arguments)
            else: self finishExpansion
    };
    withSelector: #finishExpansionWithMessageSendNode:environment: addMethod: {:self :(ASTMessageSendNode)messageSendNode :(Environment)environment :: ASTNode |
        messageSendNode copy
            receiver: (self finishExpansionWithEnvironment: environment);
            yourself
    };
    withSelector: #finishExpansionWithMessageSendNode: addMethod: {:self :(ASTMessageSendNode)messageSendNode :: ASTNode |
        self finishExpansionWithMessageSendNode: messageSendNode environment: self environment
    };
    withSelector: #finishExpansionWithEnvironment: addMethod: {:self :(Environment)environment :: ASTNode |
        self subclassResponsibility
    };
    withSelector: #finishExpansion addMethod: {:self :: ASTNode |
        self finishExpansionWithEnvironment: self environment
    };
    withSelector: #delegateToMetaBuilder: addMethod: {:self :metaBuilder :: ASTNode |
        ASTLiteralNode new
            sourcePosition: self sourcePosition;
            value: metaBuilder;
            yourself
    }.

MacroMetaBuilder publicSubclass: #NamedMetaBuilder slots: (
    TypeSlot publicNamed: #name type: ASTNode ,
    TypeSlot publicNamed: #nameIsNotExpectedAnymore type: Boolean ,
).

NamedMetaBuilder
    withSelector: #expandMessageSendNode: addMethod: {:self :(ASTMessageSendNode)messageSendNode :: ASTNode |
        if: (self name == nil) && messageSendNode arguments isEmpty && self nameIsNotExpectedAnymore not then: {
            self name: messageSendNode selector.
            self continueExpansion
        } else: {
            self expandMessageSendNodeWithMetaBuilderMethod: messageSendNode
        }.
    }.

NamedMetaBuilder publicSubclass: #TypeMetaBuilder slots: (
    TypeSlot publicNamed: #isPublic type: Boolean ,
    TypeSlot publicNamed: #typeFlags type: Bitflags ,
    TypeSlot publicNamed: #metaSlotsExpression type: ASTNode ,
    TypeSlot publicNamed: #supertypeExpression type: ASTNode ,
    TypeSlot publicNamed: #definitionExpression type: ASTNode ,
).

TypeMetaBuilder
    withSelector: #initialize addMethod: {:self :: Void |
        (tuple: self withLookupStartingFrom: TypeMetaBuilder supertype) initialize.
        self isPublic: false.
        self typeFlags: TypeFlags::None
    };
    withSelector: #metaSlots: addMethod: {:self :(ASTNode)metaSlotsExpression :: ASTNode |
        <metaBuilder>
        self metaSlotsExpression: metaSlotsExpression.
        self continueExpansion
    };
    withSelector: #supertype: addMethod: {:self :(ASTNode)supertypeExpression :: ASTNode |
        <metaBuilder>
        self supertypeExpression: supertypeExpression.
        self continueExpansion
    };
    withSelector: #definition: addMethod: {:self :(ASTNode)definitionExpression :: ASTNode |
        <metaBuilder>
        self definitionExpression: definitionExpression.
        self finishExpansion
    };
    withSelector: #":=" addMethod: {:self :(ASTNode)definitionExpression :: ASTNode |
        <metaBuilder>
        self definitionExpression: definitionExpression.
        self finishExpansion
    };
    
    withSelector: #validMetaSlotsExpression addMethod: {:self :: ASTNode |
        self metaSlotsExpression ifNil: `'()
    }.

TypeMetaBuilder publicSubclass: #ClassMetaBuilder slots: (
).

ClassMetaBuilder
    withSelector: #classSlots: addMethod: {:self :(ASTNode)classSlotsExpression :: ASTNode |
        <metaBuilder>
        self metaSlotsExpression: classSlotsExpression.
        self continueExpansion
    };
    withSelector: #superclass: addMethod: {:self :(ASTNode)superclassExpression :: ASTNode |
        <metaBuilder>
        self supertypeExpression: superclassExpression.
        self continueExpansion
    };
    withSelector: #validSuperclassExpression addMethod: {:self :: ASTNode |
        self supertypeExpression ifNil: `'Object
    };
    withSelector: #finishExpansionWithEnvironment: addMethod: {:self :(Environment)environment :: ASTNode |
        let: #flagsExpression with: (ASTLiteralNode new
            sourcePosition: self sourcePosition;
            value: self typeFlags;
            yourself).

        let: #makeClassExpression with: ``(
            (`,(self validSuperclassExpression) subclassWithClassSlots: `,(self validMetaSlotsExpression))
                addFlags: `,flagsExpression;
                yourself
        ).

        let: #name with: self name.

        let: #classValueExpression with: (name
            ifNil: makeClassExpression
            ifNotNil: (if: self isPublic
                then: ``(public: `,name with: (`,makeClassExpression name: `,name; yourself))
                else: ``(let: `,name with: `,makeClassExpression) 
            )
        ).

        let: #definitionExpression with: self definitionExpression.
        definitionExpression
        ifNil: classValueExpression
        ifNotNil: ``(`,classValueExpression definition: `,definitionExpression)
    }.

public: #class with: (MetaBuilderFactory for: ClassMetaBuilder).

NamedMetaBuilder publicSubclass: #VariableMetaBuilder slots: (
    TypeSlot publicNamed: #typeExpression type: ASTNode ,
    TypeSlot publicNamed: #initialValue type: ASTNode ,
).

VariableMetaBuilder
    withSelector: #type: addMethod: {:self :(ASTNode)typeExpression :: ASTNode |
        <metaBuilder>
        self typeExpression: typeExpression.
        self continueExpansion
    };
    withSelector: #=> addMethod: {:self :(ASTNode)typeExpression :: ASTNode |
        <metaBuilder>
        self typeExpression: typeExpression.
        self continueExpansion
    };
    withSelector: #":=" addMethod: {:self :(ASTNode)initialValue :: ASTNode |
        <metaBuilder>
        self initialValue: initialValue.
        self finishExpansion
    }.

VariableMetaBuilder publicSubclass: #LetMetaBuilder slots: (
    TypeSlot publicNamed: #isMutable type: Boolean ,
    TypeSlot publicNamed: #typeExpression type: ASTNode ,
    TypeSlot publicNamed: #initialValue type: ASTNode ,
).

LetMetaBuilder
    withSelector: #initialize addMethod: {:self :: Void |
        (tuple: self withLookupStartingFrom: TypeMetaBuilder supertype) initialize.
        self isMutable: false
    };
    withSelector: #mutable addMethod: {:self :: ASTNode |
        <metaBuilder>
        self isMutable: true.
        self continueExpansion
    };
    withSelector: #finishExpansionWithEnvironment: addMethod: {:self :(Environment)environment :: ASTNode |
        ASTLocalDefinitionNode new
            sourcePosition: self sourcePosition;
            nameExpression: self name;
            typeExpression: self typeExpression;
            valueExpression: self initialValue;
            isMutable: self isMutable;
            yourself
    }.

public: #let with: (MetaBuilderFactory for: LetMetaBuilder).

LetMetaBuilder publicSubclass: #GlobalMetaBuilder slots: (
    TypeSlot publicNamed: #isPublic type: Boolean ,
).

GlobalMetaBuilder
    withSelector: #finishExpansionWithEnvironment: addMethod: {:self :(Environment)environment :: ASTNode |
        let: #name with: self name.
        let: #localDefinitionNode with: (ASTLocalDefinitionNode new
            sourcePosition: self sourcePosition;
            nameExpression: self name;
            typeExpression: self typeExpression;
            valueExpression: self initialValue;
            isMutable: self isMutable;
            yourself).

        if: self isPublic then: {
            ``(public: `,name with: `,localDefinitionNode)
        } else: {
            localDefinitionNode
        }
    }.

VariableMetaBuilder publicSubclass: #FieldMetaBuilder slots: (
    TypeSlot publicNamed: #fieldFlags type: Bitflags ,
    TypeSlot publicNamed: #bitsExpression type: ASTNode
).

FieldMetaBuilder
    withSelector: #initialize addMethod: {:self :: Void |
        (tuple: self withLookupStartingFrom: FieldMetaBuilder supertype) initialize.
        self fieldFlags: TypeSlotFlags::None
    };
    withSelector: #addFieldFlags: addMethod: {:self :(Bitflags)flags :: Void |
        self fieldFlags: self fieldFlags | flags
    };
    withSelector: #bits: addMethod: {:self :(ASTNode)bitsExpression :: Void |
        <metaBuilder>
        self bitsExpression: bitsExpression.
        self continueExpansion
    };
    withSelector: #finishExpansionWithEnvironment: addMethod: {:self :(Environment)environment :: ASTNode |
        let: #typeExpression with: self typeExpression.
        let: #flagsExpression with: (ASTLiteralNode new
            sourcePosition: self sourcePosition;
            value: self fieldFlags;
            yourself).
        let: #initialValue with: self initialValue.
        let: #initialValueBlock with: (initialValue ifNotNil: (``{:(SelfType)self :: `,typeExpression | `,initialValue })).

        initialValueBlock
            ifNil: (
                typeExpression
                    ifNil: ``(__OwnerProgramEntity__ addTypeSlot: (TypeSlot named: `,(self name) flags: `,flagsExpression))
                    ifNotNil: ``(__OwnerProgramEntity__ addTypeSlot: (TypeSlot named: `,(self name) type: `,typeExpression flags: `,flagsExpression))
            ) ifNotNil: (
                typeExpression
                    ifNil: ``(__OwnerProgramEntity__ addTypeSlot: (TypeSlot named: `,(self name) flags: `,flagsExpression) initialValueBlock: `,initialValueBlock)
                    ifNotNil: ``(__OwnerProgramEntity__ addTypeSlot: (TypeSlot named: `,(self name) type: `,typeExpression flags: `,flagsExpression) initialValueBlock: `,initialValueBlock)
            )
    }.

ASTNode
    withSelector: #parseAsArgumentNode addMethod: {:self :: ASTArgumentNode |
        self error: self asString -- " is not a valid argument expression."
    }.

ASTArgumentNode
    withSelector: #parseAsArgumentNode addMethod: {:self :: ASTArgumentNode | self }.

ASTIdentifierReferenceNode
    withSelector: #parseKeywordAsLiteralWithoutColon addMethod: {:self :: ASTLiteralNode |
        ASTLiteralNode new
            sourcePosition: self sourcePosition;
            value: (self value asString withoutSuffix: ":") asSymbol;
            yourself
    };
    withSelector: #parseAsArgumentNode addMethod: {:self :: ASTArgumentNode |
        ASTArgumentNode new
            sourcePosition: self sourcePosition;
            isForAll: false;
            name: (ASTLiteralNode new
                sourcePosition: self sourcePosition;
                value: self value;
                yourself);
            yourself
    }.

ASTUnexpandedApplicationNode
    withSelector: #parseAsArgumentNode addMethod: {:self :: ASTArgumentNode |
        if: self arguments size ~= 1 then: self asString -- " is not a valid argument expression.".
        let: #name with: self functionOrMacroExpression parseKeywordAsLiteralWithoutColon.
        let: #type with: self arguments first.
        ASTArgumentNode new
            sourcePosition: self sourcePosition;
            isForAll: false;
            name: name;
            type: type;
            yourself
    }.

NamedMetaBuilder publicSubclass: #FunctionMetaBuilder slots: (
    TypeSlot publicNamed: #functionFlags type: Bitflags ,
    TypeSlot publicNamed: #isMacro type: Boolean ,
    TypeSlot publicNamed: #isPublic type: Boolean ,
    TypeSlot publicNamed: #resultType type: ASTNode ,
    TypeSlot publicNamed: #body type: ASTNode ,
    TypeSlot publicNamed: #arguments type: Array
).

public: #noFFIAvailableError with: {:: Unwinds | error("FFI is not available for external call. ")}.

FunctionMetaBuilder
    withSelector: #expandUnexpandedApplicationNode: addMethod: {:self :(ASTUnexpandedApplicationNode)unexpandedApplicationNode :: ASTNode |
        if: self arguments == nil then: {
            self nameIsNotExpectedAnymore: true.
            self arguments: (unexpandedApplicationNode arguments collect: {:each | each parseAsArgumentNode}).
            self continueExpansion
        } else: {
            self finishExpansion
        }.
    };
    withSelector: #addFunctionFlags: addMethod: {:self :(Bitflags)flags :: Void |
        self functionFlags: self functionFlags | flags
    };
    withSelector: #isExternC addMethod: {:self :: Boolean |
        (self functionFlags & FunctionFlags::ExternC) ~= 0bflgs
    };
    withSelector: #":=" addMethod: {:self :(ASTNode)bodyNode :: ASTNode |
        <metaBuilder>
        self body: bodyNode.
        self finishExpansion
    };
    withSelector: #=> addMethod: {:self :(ASTNode)resultType :: ASTNode |
        <metaBuilder>
        self resultType: resultType.
        self continueExpansion
    };
    withSelector: #finishMacroFunction addMethod: {:self :: ASTNode |
        let: #macroContextArgument with: (ASTArgumentNode new
            sourcePosition: self sourcePosition;
            isForAll: false;
            name: `'#__macroContext__;
            type: `'MacroContext;
            yourself).
        let: #arguments with: (Array with: macroContextArgument) -- self arguments.
        ASTLambdaNode new
            sourcePosition: self sourcePosition;
            flags: self functionFlags;
            name: self name;
            arguments: arguments;
            body: self body;
            resultType: self resultType;
            yourself
    };
    withSelector: #expansionBody addMethod: {:self  :: ASTNode |
        let: #body with: self body.
        if: body ~~ nil then: {
            body
        } else: {
            if: self isExternC
                then: `'(noFFIAvailableError())
                else: nil
        }
    };
    withSelector: #finishFunctionExpansion addMethod: {:self :: ASTNode |
        ASTLambdaNode new
            sourcePosition: self sourcePosition;
            flags: self functionFlags;
            name: self name;
            arguments: self arguments;
            body: self expansionBody;
            resultType: self resultType;
            yourself
    };
    withSelector: #finishExpansionWithEnvironment: addMethod: {:self :(Environment)environment :: ASTNode |
        let: #name with: self name.
        let: #functionNode with: (if: self isMacro
            then: self finishMacroFunction
            else: self finishFunctionExpansion).
        let: #exportNode with: (if: self isPublic
            then: ``(public: `,(self name) with: `,functionNode)
            else: functionNode).

        if: (name ~~ nil) && self isExternC then: {
            if: self body == nil
                then: ``(`,exportNode importWithSymbol: `,name; yourself)
                else: ``(`,exportNode exportWithSymbol: `,name; yourself)
        } else: {
            exportNode
        }
    }.

public: #function with: (MetaBuilderFactory for: FunctionMetaBuilder).

FunctionMetaBuilder publicSubclass: #TemplateMetaBuilder slots: (
).

TemplateMetaBuilder
    withSelector: #initialize addMethod: {:self :: Void |
        (tuple: self withLookupStartingFrom: TemplateMetaBuilder supertype) initialize.
        self functionFlags: FunctionFlags::Memoized | FunctionFlags::Template.
    };
    withSelector: #finishFunctionExpansion addMethod: {:self :: ASTNode |
        let: #templateResultArgument with: (ASTArgumentNode new
            sourcePosition: self sourcePosition;
            isForAll: false;
            name: `'#__templateResult__;
            type: `'WeakValueAssociation;
            yourself).

        ASTLambdaNode new
            sourcePosition: self sourcePosition;
            flags: self functionFlags;
            name: self name;
            arguments: (Array with: templateResultArgument) -- self arguments;
            body: self expansionBody;
            resultType: self resultType;
            yourself
    }.

MacroMetaBuilder publicSubclass: #MethodMetaBuilder slots: (
    TypeSlot publicNamed: #methodFlags type: Bitflags ,
    TypeSlot publicNamed: #isMacro type: Boolean ,
    TypeSlot publicNamed: #isFallbackMethod type: Boolean ,
    TypeSlot publicNamed: #selector type: ASTNode ,
    TypeSlot publicNamed: #resultType type: ASTNode ,
    TypeSlot publicNamed: #body type: ASTNode ,
    TypeSlot publicNamed: #arguments type: Array
).

MethodMetaBuilder
    withSelector: #initialize addMethod: {:self :: Void |
        (tuple: self withLookupStartingFrom: MethodMetaBuilder supertype) initialize.
        self methodFlags: FunctionFlags::None.
        self isMacro: false.
        self isFallbackMethod: false.
    };
    withSelector: #expandMessageSendNode: addMethod: {:self :(ASTMessageSendNode)messageSendNode :: ASTNode |
        if: self selector == nil then: {
            self selector: messageSendNode selector.
            self arguments: (messageSendNode arguments collect: {:each | each parseAsArgumentNode}).
            self continueExpansion
        } else: {
            self expandMessageSendNodeWithMetaBuilderMethod: messageSendNode
        }.
    };
    withSelector: #addMethodFlags: addMethod: {:self :(Bitflags)flags :: Void |
        self methodFlags: self methodFlags | flags
    };
    withSelector: #":=" addMethod: {:self :(ASTNode)bodyNode :: ASTNode |
        <metaBuilder>
        self body: bodyNode.
        self finishExpansion
    };
    withSelector: #=> addMethod: {:self :(ASTNode)resultType :: ASTNode |
        <metaBuilder>
        self resultType: resultType.
        self continueExpansion
    };
    withSelector: #bodyWithInjectedCode addMethod: {:self :: ASTNode |
        let: #selfIdentifier with: (ASTIdentifierReferenceNode new
            sourcePosition: self sourcePosition;
            value: #self;
            yourself).
        let: #useSelf with: (ASTUseNamedSlotsOfNode new
            sourcePosition: self sourcePosition;
            tupleExpression: selfIdentifier;
            yourself).
        let: #sequence with: (ASTSequenceNode new
            sourcePosition: self sourcePosition;
            expressions: (Array with: useSelf with: self body);
            yourself)
    };
    withSelector: #finishMacroMethod addMethod: {:self :: ASTNode |
        let: #macroContextArgument with: (ASTArgumentNode new
            sourcePosition: self sourcePosition;
            isForAll: false;
            name: `'#__macroContext__;
            type: `'MacroContext;
            yourself).
        let: #selfArgument with: (ASTArgumentNode new
            sourcePosition: self sourcePosition;
            isForAll: false;
            name: `'#self;
            type: `'ASTNode;
            yourself).
        let: #arguments with: (Array with: macroContextArgument with: selfArgument) -- self arguments.
        let: #methodNode with: (ASTLambdaNode new
            sourcePosition: self sourcePosition;
            flags: self methodFlags;
            arguments: arguments;
            body: self bodyWithInjectedCode;
            resultType: self resultType;
            yourself
        ).
        
        if: self isFallbackMethod
        then: ``(__OwnerProgramEntity__ withSelector: `,(self selector) addFallbackMethod: `,methodNode)
        else: ``(__OwnerProgramEntity__ withSelector: `,(self selector) addMacroMethod: `,methodNode)
    };
    withSelector: #finishMethodExpansion addMethod: {:self :: ASTNode |
        let: #selfArgument with: (ASTArgumentNode new
            sourcePosition: self sourcePosition;
            isForAll: false;
            name: `'#self;
            type: `'ReceiverType;
            yourself).
        let: #arguments with: (Array with: selfArgument) -- self arguments.
        let: #methodNode with: (ASTLambdaNode new
            sourcePosition: self sourcePosition;
            flags: self methodFlags;
            arguments: arguments;
            body: self bodyWithInjectedCode;
            resultType: self resultType;
            yourself
        ).
        
        ``(__OwnerProgramEntity__ withSelector: `,(self selector) addMethod: `,methodNode)
    };
    withSelector: #finishExpansionWithEnvironment: addMethod: {:self :(Environment)environment :: ASTNode |
        if: self isMacro
        then: self finishMacroMethodExpansion
        else: self finishMethodExpansion
    }.

MacroMetaBuilder publicSubclass: #MacroMethodMetaBuilder slots: (
    TypeSlot publicNamed: #methodFlags type: Bitflags ,
    TypeSlot publicNamed: #isFallbackMethod type: Boolean ,
    TypeSlot publicNamed: #isPublic type: Boolean ,
).

MacroMethodMetaBuilder
    withSelector: #initialize addMethod: {:self :: Void |
        (tuple: self withLookupStartingFrom: MacroMethodMetaBuilder supertype) initialize.
        self methodFlags: FunctionFlags::Macro.
        self isFallbackMethod: false.
    };
    withSelector: #addMethodFlags: addMethod: {:self :(Bitflags)flags :: Void |
        self methodFlags: self methodFlags | flags
    };
    withSelector: #fallback addMethod: {:self :: ASTNode |
        <metaBuilder>
        self isFallbackMethod: true.
        self continueExpansion
    };
    withSelector: #method addMethod: {:self :: ASTNode |
        <metaBuilder>
        self delegateToMetaBuilder: (MethodMetaBuilder new
            methodFlags: self methodFlags;
            isMacro: true;
            isFallbackMethod: self isFallbackMethod;
            yourself)
    };
    withSelector: #function addMethod: {:self :: ASTNode |
        <metaBuilder>
        self delegateToMetaBuilder: (FunctionMetaBuilder new
            functionFlags: self functionFlags;
            isMacro: true;
            isPublic: self isPublic;
            yourself)
    }.

MacroMetaBuilder publicSubclass: #FlagMetaBuilder slots: (
    TypeSlot publicNamed: #methodFlags type: Bitflags ,
    TypeSlot publicNamed: #typeFlags type: Bitflags ,
    TypeSlot publicNamed: #fieldFlags type: Bitflags ,
    TypeSlot publicNamed: #isPublic type: Boolean ,
).

FlagMetaBuilder
    withSelector: #initialize addMethod: {:self :: Void |
        (tuple: self withLookupStartingFrom: FlagMetaBuilder supertype) initialize.
        self methodFlags: FunctionFlags::None.
        self typeFlags: TypeFlags::None.
        self fieldFlags: TypeSlotFlags::None.
        self isPublic: false.
    };
    withSelector: #expandMessageSendNode: addMethod: {:self :(ASTMessageSendNode)messageSendNode :: ASTNode |
        let: #selector with: messageSendNode selector.
        if: (selector isLiteralNode && selector value) == #class then: {
            self delegateToMetaBuilder: (ClassMetaBuilder new
                isPublic: self isPublic;
                typeFlags: self typeFlags;
                yourself)
        } else: {
            self expandMessageSendNodeWithMetaBuilderMethod: messageSendNode
        }.
    };
    withSelector: #addFieldFlags: addMethod: {:self :(Bitflags)flags :: Void |
        self fieldFlags: self fieldFlags | flags
    };
    withSelector: #addMethodFlags: addMethod: {:self :(Bitflags)flags :: Void |
        self methodFlags: self methodFlags | flags
    };
    withSelector: #addTypeFlags: addMethod: {:self :(Bitflags)flags :: Void |
        self typeFlags: self typeFlags | flags
    };
    withSelector: #pure addMethod: {:self :: ASTNode |
        <metaBuilder>
        self addMethodFlags: FunctionFlags::Pure.
        self continueExpansion
    };
    withSelector: #final addMethod: {:self :: ASTNode |
        <metaBuilder>
        self addTypeFlags: TypeFlags::Final.
        self addMethodFlags: FunctionFlags::Final.
        self continueExpansion
    };
    withSelector: #virtual addMethod: {:self :: ASTNode |
        <metaBuilder>
        self addMethodFlags: FunctionFlags::Virtual.
        self continueExpansion
    };
    withSelector: #abstract addMethod: {:self :: ASTNode |
        <metaBuilder>
        self addTypeFlags: TypeFlags::Abstract.
        self addMethodFlags: FunctionFlags::Abstract.
        self continueExpansion
    };
    withSelector: #override addMethod: {:self :: ASTNode |
        <metaBuilder>
        self addMethodFlags: FunctionFlags::Override.
        self continueExpansion
    };
    withSelector: #static addMethod: {:self :: ASTNode |
        <metaBuilder>
        self addMethodFlags: FunctionFlags::Static.
        self continueExpansion
    };
    withSelector: #readonly addMethod: {:self :: ASTNode |
        <metaBuilder>
        self addFieldFlags: TypeSlotFlags::ReadOnly.
        self continueExpansion
    };
    withSelector: #externC addMethod: {:self :: ASTNode |
        <metaBuilder>
        self addMethodFlags: FunctionFlags::ExternC.
        self continueExpansion
    };
    withSelector: #dllImport addMethod: {:self :: ASTNode |
        <metaBuilder>
        self addMethodFlags: FunctionFlags::DLLImport.
        self continueExpansion
    };
    withSelector: #dllExport addMethod: {:self :: ASTNode |
        <metaBuilder>
        self addMethodFlags: FunctionFlags::DLLExport.
        self continueExpansion
    };
    withSelector: #method addMethod: {:self :: ASTNode |
        <metaBuilder>
        self delegateToMetaBuilder: (MethodMetaBuilder new
            addMethodFlags: self methodFlags;
            yourself)
    };
    withSelector: #macro addMethod: {:self :: ASTNode |
        <metaBuilder>
        self delegateToMetaBuilder: (MacroMethodMetaBuilder new
            addMethodFlags: self methodFlags;
            isPublic: self isPublic;
            yourself)
    };
    withSelector: #field addMethod: {:self :: ASTNode |
        <metaBuilder>
        self delegateToMetaBuilder: (FieldMetaBuilder new
            addFieldFlags: self fieldFlags;
            yourself)
    };
    withSelector: #function addMethod: {:self :: ASTNode |
        <metaBuilder>
        self delegateToMetaBuilder: (FunctionMetaBuilder new
            addFunctionFlags: self methodFlags;
            isPublic: self isPublic;
            yourself)
    };
    withSelector: #global addMethod: {:self :: ASTNode |
        <metaBuilder>
        self delegateToMetaBuilder: (GlobalMetaBuilder new
            isPublic: self isPublic;
            yourself)
    };
    withSelector: #template addMethod: {:self :: ASTNode |
        <metaBuilder>
        self delegateToMetaBuilder: (TemplateMetaBuilder new
            addFunctionFlags: self methodFlags;
            isPublic: self isPublic;
            yourself)
    }.

FlagMetaBuilder publicSubclass: #PublicMetaBuilder slots: (
).

PublicMetaBuilder
    withSelector: #initialize addMethod: {:self :: Void |
        (tuple: self withLookupStartingFrom: PublicMetaBuilder supertype) initialize.
        self fieldFlags: TypeSlotFlags::Public.
        self isPublic: true.
    }.

FlagMetaBuilder publicSubclass: #ProtectedMetaBuilder slots: (
).

FlagMetaBuilder publicSubclass: #PrivateMetaBuilder slots: (
).

public: #public with: (MetaBuilderFactory for: PublicMetaBuilder).
public: #protected with: (MetaBuilderFactory for: ProtectedMetaBuilder).
public: #private with: (MetaBuilderFactory for: PrivateMetaBuilder).

{
    let: #typeExtendMacro with: {:macroContext :self :extensionBlock :: ASTNode |
            ``{
                let: #SelfType with: `,self.
                let: #ReceiverType with: SelfType asReceiverType.
                let: #SuperType with: SelfType supertype.
                let: #__Meta__ with: SelfType __type__.
                let: #__OwnerProgramEntity__ with: SelfType.
                macroLet: #super with: (tuple: self withLookupStartingFrom: SuperType).
                `,extensionBlock
            }
        } makeMacro.
    Type
        withSelector: #extend: addMacroMethod: typeExtendMacro;
        withSelector: #definition: addMacroMethod: typeExtendMacro.
}.
