public global ObjectModel::Tag::Bits := 4u8.
public global ObjectModel::Tag::Mask := 15u8.
public global ObjectModel::MinimalAlignment := 16u32.

public global ObjectModel::Tag::Pointer := 0u8.
public global ObjectModel::Tag::Nil := 0u8.

public global ObjectModel::Tag::Integer := 1u8.
public global ObjectModel::Tag::Int8 := 2u8.
public global ObjectModel::Tag::Int16 := 3u8.
public global ObjectModel::Tag::Int32 := 4u8.
public global ObjectModel::Tag::Int64 := 5u8.

public global ObjectModel::Tag::SignedIntegerFirst := ObjectModel::Tag::Integer.
public global ObjectModel::Tag::SignedIntegerLast := ObjectModel::Tag::Int64.

public global ObjectModel::Tag::Char8 := 6u8.
public global ObjectModel::Tag::UInt8 := 7u8.

public global ObjectModel::Tag::Char16 := 8u8.
public global ObjectModel::Tag::UInt16 := 9u8.

public global ObjectModel::Tag::Char32 := 10u8.
public global ObjectModel::Tag::UInt32 := 11u8.

public global ObjectModel::Tag::UInt64 := 12u8.

public global ObjectModel::Tag::Float32 := 13u8.
public global ObjectModel::Tag::Float64 := 14u8.

public global ObjectModel::Tag::Trivial := 15u8.

public global ObjectModel::ImmediateTagTypeTable := (
    UndefinedObject,
    Integer, Int8, Int16, Int32, Int64,
    Char8, UInt8,
    Char16, UInt16,
    Char32, UInt32,
    UInt64, Float32, Float64,
    nil
).

public global ObjectModel32::Immediate::Bits := 32u32 - ObjectModel::Tag::Bits asUInt32.
public global ObjectModel32::Immediate::UInt::Min := 0u32.
public global ObjectModel32::Immediate::UInt::Max := (1u32 << ObjectModel32::Immediate::Bits) - 1u32.
public global ObjectModel32::Immediate::Int::Min := (1i32 << (ObjectModel32::Immediate::Bits - 1u32) asInt32) negated.
public global ObjectModel32::Immediate::Int::Max := (1i32 << (ObjectModel32::Immediate::Bits - 1u32) asInt32) - 1i32.

public global ObjectModel64::Immediate::Bits := 64u64 - ObjectModel::Tag::Bits asUInt64.
public global ObjectModel64::Immediate::UInt::Min := 0u64.
public global ObjectModel64::Immediate::UInt::Max := (1u64 << ObjectModel64::Immediate::Bits) - 1u64.
public global ObjectModel64::Immediate::Int::Min := (1i64 << (ObjectModel64::Immediate::Bits - 1u64) asInt64) negated.
public global ObjectModel64::Immediate::Int::Max := (1i64 << (ObjectModel64::Immediate::Bits - 1u64) asInt64) - 1i64.

public global ObjectModel::ImmediateTrivialIndex::False := 0u32.
public global ObjectModel::ImmediateTrivialIndex::True := 1u32.
public global ObjectModel::ImmediateTrivialIndex::Void := 2u32.
public global ObjectModel::ImmediateTrivialIndex::HashtableEmptyElement := 3u32.
public global ObjectModel::ImmediateTrivialIndex::Tombstone := 4u32.
public global ObjectModel::ImmediateTrivialIndex::PendingMemoizationValue := 5u32.

public global ObjectModel::ImmediateTrivialTypeTable := (
    False, True, Void, HashtableEmpty, ObjectTombstone, PendingMemoizationValue
).

public global ObjectModel::TypePointerFlag::GCColorMask := 3uptr.
public global ObjectModel::TypePointerFlag::Bytes := 4uptr.
public global ObjectModel::TypePointerFlag::Weak := 8uptr.

public global ObjectModel::IdentityHashFlag::Immutable := 1uptr.
public global ObjectModel::IdentityHashFlag::NeedsFinalization := 2uptr.
public global ObjectModel::IdentityHashFlag::DummyValue := 4uptr.

public final struct ObjectModel::TupleHeader32 definition: {
    public field typePointerAndFlags => UInt32.
    public field identityHashAndFlags => UInt32.
    public field objectSize => UInt32.
    public field forwardingPointer => UInt32.

    public method gcColor => UInt8
        := (typePointerAndFlags & ObjectModel::TypePointerFlag::GCColorMask asUInt32) asUInt8.

    public method gcColor: (newColor: UInt8) ::=> Void := {
        typePointerAndFlags := (typePointerAndFlags & ObjectModel::TypePointerFlag::GCColorMask asUInt32 bitInvert) | newColor asUInt32
    }.

    public method isBytes => Boolean
        := (typePointerAndFlags & ObjectModel::TypePointerFlag::Bytes asUInt32) ~= 0u32.

    public method isBytes: (flag: Boolean) ::=> Void := {
        flag
            ifTrue: (typePointerAndFlags := typePointerAndFlags & ObjectModel::TypePointerFlag::Bytes asUInt32 bitInvert)
            ifFalse: (typePointerAndFlags := typePointerAndFlags | ObjectModel::TypePointerFlag::Bytes asUInt32).
    }.

    public method isWeak => Boolean
        := (typePointerAndFlags & ObjectModel::TypePointerFlag::Weak asUInt32) ~= 0u32.

    public method isWeak: (flag: Boolean) ::=> Void := {
        flag
            ifTrue: (typePointerAndFlags := identityHashAndFlags & ObjectModel::TypePointerFlag::Weak asUInt32 bitInvert)
            ifFalse: (typePointerAndFlags := identityHashAndFlags | ObjectModel::TypePointerFlag::Weak asUInt32).
    }.

    public method identityHashValue ::=> UInt32
        := identityHashAndFlags >> 4u32.

    public method identityHashValue: (identityHash: UInt32) ::=> Void := {
        identityHashAndFlags := (identityHash << 4u32) | (identityHashAndFlags & 15u32)
    }.

}.

public final struct ObjectModel::TupleHeader64 definition: {
    public field typePointerAndFlags => UInt64.
    public field identityHashAndFlags => UInt64.
    public field objectSize => UInt64.
    public field forwardingPointer => UInt64.

    public method gcColor => UInt8
        := (typePointerAndFlags & ObjectModel::TypePointerFlag::GCColorMask asUInt64) asUInt8.

    public method gcColor: (newColor: UInt8) ::=> Void := {
        typePointerAndFlags := (typePointerAndFlags & ObjectModel::TypePointerFlag::GCColorMask asUInt64 bitInvert) | newColor asUInt64
    }.

    public method isBytes => Boolean
        := (typePointerAndFlags & ObjectModel::TypePointerFlag::Bytes asUInt64) ~= 0u64.

    public method isBytes: (flag: Boolean) ::=> Void := {
        flag
            ifTrue: (typePointerAndFlags := identityHashAndFlags & ObjectModel::TypePointerFlag::Bytes asUInt64 bitInvert)
            ifFalse: (typePointerAndFlags := identityHashAndFlags | ObjectModel::TypePointerFlag::Bytes asUInt64).
    }.

    public method isWeak => Boolean
        := (typePointerAndFlags & ObjectModel::TypePointerFlag::Weak asUInt64) ~= 0u64.

    public method isWeak: (flag: Boolean) ::=> Void := {
        flag
            ifTrue: (typePointerAndFlags := identityHashAndFlags & ObjectModel::TypePointerFlag::Weak asUInt64 bitInvert)
            ifFalse: (typePointerAndFlags := identityHashAndFlags | ObjectModel::TypePointerFlag::Weak asUInt64).
    }.

    public method identityHashValue ::=> UInt64
        := identityHashAndFlags >> 4u64.

    public method identityHashValue: (identityHash: UInt64) ::=> Void := {
        identityHashAndFlags := (identityHash << 4u64) | (identityHashAndFlags & 15u64)
    }.
}.

public abstract class ObjectModelVariant superclass: Object; definition: {
    public abstract method pointerSize => UInt64 := self subclassResponsibility.

    public virtual method minimalObjectAlignment => UInt64 := ObjectModel::MinimalAlignment asUInt64.

    public abstract method objectHeaderSize => UInt64
        := self subclassResponsibility.

    public virtual method isImmediateReference: (reference: Untyped) ::=> Boolean
        := self subclassResponsibility.

    public virtual method encodeImmediateReference32: (reference: Untyped) ::=> UInt32 := {
        let type => Type := RawTuple::type(reference).
        type encodeImmediateReference32: reference
    }.

    public virtual method encodeImmediateReference64: (reference: Untyped) ::=> UInt64 := {
        let type => Type := RawTuple::type(reference).
        type encodeImmediateReference64: reference
    }.

    public virtual method computeSizeOfObjectInstanceContent: (object: Untyped) ::=> UInt64 := {
        let isBytes := RawTuple::isBytes(object).
        isBytes ifTrue: {
            let byteSize := RawTuple::byteSize(object).
            byteSize asUInt64
        } ifFalse: {
            let totalSlotCount := RawTuple::size(object).
            let type := RawTuple::type(object).
            let typeSlotCount := type ifNil: (0sz) ifNotNil: (type totalSlotCount).
            let variantSlotCount := totalSlotCount - typeSlotCount.
            let fixedInstanceSize := type ifNil: (0sz) ifNotNil: (type validInstanceSize).
            fixedInstanceSize asUInt64 + (variantSlotCount asUInt64 * self pointerSize)
        }
    }.

    public virtual method computeSizeOfObjectInstance: (object: Untyped) ::=> UInt64
        := self objectHeaderSize + (self computeSizeOfObjectInstanceContent: object).

    public virtual method computeAlignmentOfObjectInstance: (object: Untyped) ::=> UInt64
        := RawTuple::type(object)
            ifNil: {self minimalObjectAlignment}
            ifNotNil: {:(Type)type :: UInt64 | type validInstanceAlignment asUInt64 max: self minimalObjectAlignment}.
}.

public final class ObjectModelVariant32 superclass: ObjectModelVariant; definition: {
    public override method pointerSize => UInt64 := 4u64.

    let singleton := SelfType new.

    public override method isImmediateReference: (reference: Untyped) ::=> Boolean := {
        let type => Type := RawTuple::type(reference).
        type isNotNil && (type isImmediateReference32: reference)
    }.

    __Meta__ definition: {
        public method uniqueInstance => ObjectModelVariant32
            := singleton.
    }.
}.

public final class ObjectModelVariant64 superclass: ObjectModelVariant; definition: {
    public override method pointerSize => UInt64 := 8u64.

    public override method objectHeaderSize => UInt64
        := ObjectModel::TupleHeader64 valueSize asUInt64.

    public override method isImmediateReference: (reference: Untyped) ::=> Boolean := {
        let type => Type := RawTuple::type(reference).
        type isNotNil && (type isImmediateReference64: reference)
    }.

    let singleton := SelfType new.
    __Meta__ definition: {
        public method uniqueInstance => ObjectModelVariant64
            := singleton.
    }.
}.

Type extend: {
    public virtual method isImmediateReference32: (reference: Untyped) ::=> Boolean := false.
    public virtual method isImmediateReference64: (reference: Untyped) ::=> Boolean := false.

    public virtual method encodeImmediateReference32: (reference: Untyped) ::=> UInt32
        := self error: "Cannot encode 32 bits immediate reference.".

    public virtual method encodeImmediateReference64: (reference: Untyped) ::=> UInt64
        := self error: "Cannot encode 64 bits immediate reference.".

    public virtual method objectHeaderSizeForObjectModel: (objectModel: ObjectModelVariant) ::=> UInt64
        := objectModel objectHeaderSize.
}.

PointerLikeType extend: {
    public override method objectHeaderSizeForObjectModel: (objectModel: ObjectModelVariant) ::=> Size
        := 0sz.
}.

Char8 __type__ extend: {
    public override method isImmediateReference32: (reference: Untyped) ::=> Boolean := true.
    public override method isImmediateReference64: (reference: Untyped) ::=> Boolean := true.

    public override method encodeImmediateReference32: (reference: Untyped) ::=> UInt32 := (reference asUInt32 << ObjectModel::Tag::Bits asUInt32) | ObjectModel::Tag::Char8 asUInt32.
    public override method encodeImmediateReference64: (reference: Untyped) ::=> UInt64 := (reference asUInt64 << ObjectModel::Tag::Bits asUInt64) | ObjectModel::Tag::Char8 asUInt64.
}.

UInt8 __type__ extend: {
    public override method isImmediateReference32: (reference: Untyped) ::=> Boolean := true.
    public override method isImmediateReference64: (reference: Untyped) ::=> Boolean := true.

    public override method encodeImmediateReference32: (reference: Untyped) ::=> UInt32 := (reference asUInt32 << ObjectModel::Tag::Bits asUInt32) | ObjectModel::Tag::UInt8 asUInt32.
    public override method encodeImmediateReference64: (reference: Untyped) ::=> UInt64 := (reference asUInt64 << ObjectModel::Tag::Bits asUInt64) | ObjectModel::Tag::UInt8 asUInt64.
}.

Int8 __type__ extend: {
    public override method isImmediateReference32: (reference: Untyped) ::=> Boolean := true.
    public override method isImmediateReference64: (reference: Untyped) ::=> Boolean := true.

    public override method encodeImmediateReference32: (reference: Untyped) ::=> UInt32 := (reference asUInt32 << ObjectModel::Tag::Bits asUInt32) | ObjectModel::Tag::Int8 asUInt32.
    public override method encodeImmediateReference64: (reference: Untyped) ::=> UInt64 := (reference asUInt64 << ObjectModel::Tag::Bits asUInt64) | ObjectModel::Tag::Int8 asUInt64.
}.

Char16 __type__ extend: {
    public override method isImmediateReference32: (reference: Untyped) ::=> Boolean := true.
    public override method isImmediateReference64: (reference: Untyped) ::=> Boolean := true.

    public override method encodeImmediateReference32: (reference: Untyped) ::=> UInt32 := (reference asUInt32 << ObjectModel::Tag::Bits asUInt32) | ObjectModel::Tag::Char16 asUInt32.
    public override method encodeImmediateReference64: (reference: Untyped) ::=> UInt64 := (reference asUInt64 << ObjectModel::Tag::Bits asUInt64) | ObjectModel::Tag::Char16 asUInt64.
}.

UInt16 __type__ extend: {
    public override method isImmediateReference32: (reference: Untyped) ::=> Boolean := true.
    public override method isImmediateReference64: (reference: Untyped) ::=> Boolean := true.

    public override method encodeImmediateReference32: (reference: Untyped) ::=> UInt32 := (reference asUInt32 << ObjectModel::Tag::Bits asUInt32) | ObjectModel::Tag::UInt16 asUInt32.
    public override method encodeImmediateReference64: (reference: Untyped) ::=> UInt64 := (reference asUInt64 << ObjectModel::Tag::Bits asUInt64) | ObjectModel::Tag::UInt16 asUInt64.
}.

Int16 __type__ extend: {
    public override method isImmediateReference32: (reference: Untyped) ::=> Boolean := true.
    public override method isImmediateReference64: (reference: Untyped) ::=> Boolean := true.

    public override method encodeImmediateReference32: (reference: Untyped) ::=> UInt32 := (reference asUInt32 << ObjectModel::Tag::Bits asUInt32) | ObjectModel::Tag::Int16 asUInt32.
    public override method encodeImmediateReference64: (reference: Untyped) ::=> UInt64 := (reference asUInt64 << ObjectModel::Tag::Bits asUInt64) | ObjectModel::Tag::Int16 asUInt64.
}.

Char32 __type__ extend: {
    public override method isImmediateReference32: (reference: Untyped) ::=> Boolean := {
        let value := reference asUInt32.
        (ObjectModel32::Immediate::UInt::Min <= value) && (value <= ObjectModel32::Immediate::UInt::Max)
    }.

    public override method isImmediateReference64: (reference: Untyped) ::=> Boolean := true.

    public override method encodeImmediateReference32: (reference: Untyped) ::=> UInt32 := (reference asUInt32 << ObjectModel::Tag::Bits asUInt32) | ObjectModel::Tag::Char32 asUInt32.
    public override method encodeImmediateReference64: (reference: Untyped) ::=> UInt64 := (reference asUInt64 << ObjectModel::Tag::Bits asUInt64) | ObjectModel::Tag::Char32 asUInt64.
}.

UInt32 __type__ extend: {
    public override method isImmediateReference32: (reference: Untyped) ::=> Boolean := {
        let value := reference asUInt32.
        (ObjectModel32::Immediate::UInt::Min <= value) && (value <= ObjectModel32::Immediate::UInt::Max)
    }.

    public override method isImmediateReference64: (reference: Untyped) ::=> Boolean := true.

    public override method encodeImmediateReference32: (reference: Untyped) ::=> UInt32 := (reference asUInt32 << ObjectModel::Tag::Bits asUInt32) | ObjectModel::Tag::UInt32 asUInt32.
    public override method encodeImmediateReference64: (reference: Untyped) ::=> UInt64 := (reference asUInt64 << ObjectModel::Tag::Bits asUInt64) | ObjectModel::Tag::UInt32 asUInt64.
}.

Int32 __type__ extend: {
    public override method isImmediateReference32: (reference: Untyped) ::=> Boolean := {
        let value := reference asInt32.
        (ObjectModel32::Immediate::Int::Min <= value) && (value <= ObjectModel32::Immediate::Int::Max)
    }.

    public override method isImmediateReference64: (reference: Untyped) ::=> Boolean := true.

    public override method encodeImmediateReference32: (reference: Untyped) ::=> UInt32 := (reference asUInt32 << ObjectModel::Tag::Bits asUInt32) | ObjectModel::Tag::Int32 asUInt32.
    public override method encodeImmediateReference64: (reference: Untyped) ::=> UInt64 := (reference asUInt64 << ObjectModel::Tag::Bits asUInt64) | ObjectModel::Tag::Int32 asUInt64.
}.

UInt64 __type__ extend: {
    public override method isImmediateReference32: (reference: Untyped) ::=> Boolean := {
        let value := reference asUInt64.
        (ObjectModel32::Immediate::UInt::Min asUInt64 <= value) && (value <= ObjectModel32::Immediate::UInt::Max asUInt64)
    }.

    public override method isImmediateReference64: (reference: Untyped) ::=> Boolean := {
        let value := reference asUInt64.
        (ObjectModel64::Immediate::UInt::Min <= value) && (value <= ObjectModel64::Immediate::UInt::Max)
    }.

    public override method encodeImmediateReference32: (reference: Untyped) ::=> UInt32 := (reference asUInt32 << ObjectModel::Tag::Bits asUInt32) | ObjectModel::Tag::UInt64 asUInt32.
    public override method encodeImmediateReference64: (reference: Untyped) ::=> UInt64 := (reference asUInt64 << ObjectModel::Tag::Bits asUInt64) | ObjectModel::Tag::UInt64 asUInt64.
}.

Int64 __type__ extend: {
    public override method isImmediateReference32: (reference: Untyped) ::=> Boolean := {
        let value := reference asInt64.
        (ObjectModel32::Immediate::Int::Min asUInt64 <= value) && (value <= ObjectModel32::Immediate::Int::Max asUInt64)
    }.

    public override method isImmediateReference64: (reference: Untyped) ::=> Boolean := {
        let value := reference asInt64.
        (ObjectModel64::Immediate::Int::Min <= value) && (value <= ObjectModel64::Immediate::Int::Max)
    }.

    public override method encodeImmediateReference32: (reference: Untyped) ::=> UInt32 := (reference asUInt32 << ObjectModel::Tag::Bits asUInt32) | ObjectModel::Tag::Int64 asUInt32.
    public override method encodeImmediateReference64: (reference: Untyped) ::=> UInt64 := (reference asUInt64 << ObjectModel::Tag::Bits asUInt64) | ObjectModel::Tag::Int64 asUInt64.
}.

UndefinedObject __type__ extend: {
    public override method isImmediateReference32: (reference: Untyped) ::=> Boolean := nil == reference.
    public override method isImmediateReference64: (reference: Untyped) ::=> Boolean := nil == reference.

    public virtual method encodeImmediateReference32: (reference: Untyped) ::=> UInt32 := 0u32.
    public virtual method encodeImmediateReference64: (reference: Untyped) ::=> UInt64 := 0u64.
}.

False __type__ extend: {
    public override method isImmediateReference32: (reference: Untyped) ::=> Boolean := false == reference.
    public override method isImmediateReference64: (reference: Untyped) ::=> Boolean := false == reference.

    public override method encodeImmediateReference32: (reference: Untyped) ::=> UInt32 := (ObjectModel::ImmediateTrivialIndex::False << ObjectModel::Tag::Bits asUInt32) | ObjectModel::Tag::Trivial asUInt32.
    public override method encodeImmediateReference64: (reference: Untyped) ::=> UInt64 := (ObjectModel::ImmediateTrivialIndex::False asUInt64 << ObjectModel::Tag::Bits asUInt64) | ObjectModel::Tag::Trivial asUInt64.
}.

True __type__ extend: {
    public override method isImmediateReference32: (reference: Untyped) ::=> Boolean := false == reference.
    public override method isImmediateReference64: (reference: Untyped) ::=> Boolean := false == reference.

    public override method encodeImmediateReference32: (reference: Untyped) ::=> UInt32 := (ObjectModel::ImmediateTrivialIndex::True << ObjectModel::Tag::Bits asUInt32) | ObjectModel::Tag::Trivial asUInt32.
    public override method encodeImmediateReference64: (reference: Untyped) ::=> UInt64 := (ObjectModel::ImmediateTrivialIndex::True asUInt64 << ObjectModel::Tag::Bits asUInt64) | ObjectModel::Tag::Trivial asUInt64.
}.

Void __type__ extend: {
    public override method isImmediateReference32: (reference: Untyped) ::=> Boolean := void == reference.
    public override method isImmediateReference64: (reference: Untyped) ::=> Boolean := void == reference.

    public override method encodeImmediateReference32: (reference: Untyped) ::=> UInt32 := (ObjectModel::ImmediateTrivialIndex::Void << ObjectModel::Tag::Bits asUInt32) | ObjectModel::Tag::Trivial asUInt32.
    public override method encodeImmediateReference64: (reference: Untyped) ::=> UInt64 := (ObjectModel::ImmediateTrivialIndex::Void asUInt64 << ObjectModel::Tag::Bits asUInt64) | ObjectModel::Tag::Trivial asUInt64.
}.

HashtableEmpty __type__ extend: {
    public override method isImmediateReference32: (reference: Untyped) ::=> Boolean := __hashtableEmptyElement__ == reference.
    public override method isImmediateReference64: (reference: Untyped) ::=> Boolean := __hashtableEmptyElement__ == reference.

    public override method encodeImmediateReference32: (reference: Untyped) ::=> UInt32 := (ObjectModel::ImmediateTrivialIndex::HashtableEmptyElement << ObjectModel::Tag::Bits asUInt32) | ObjectModel::Tag::Trivial asUInt32.
    public override method encodeImmediateReference64: (reference: Untyped) ::=> UInt64 := (ObjectModel::ImmediateTrivialIndex::HashtableEmptyElement asUInt64 << ObjectModel::Tag::Bits asUInt64) | ObjectModel::Tag::Trivial asUInt64.
}.

ObjectTombstone __type__ extend: {
    public override method isImmediateReference32: (reference: Untyped) ::=> Boolean := __tombstone__ == reference.
    public override method isImmediateReference64: (reference: Untyped) ::=> Boolean := __tombstone__ == reference.

    public override method encodeImmediateReference32: (reference: Untyped) ::=> UInt32 := (ObjectModel::ImmediateTrivialIndex::Tombstone << ObjectModel::Tag::Bits asUInt32) | ObjectModel::Tag::Trivial asUInt32.
    public override method encodeImmediateReference64: (reference: Untyped) ::=> UInt64 := (ObjectModel::ImmediateTrivialIndex::Tombstone asUInt64 << ObjectModel::Tag::Bits asUInt64) | ObjectModel::Tag::Trivial asUInt64.
}.

PendingMemoizationValue __type__ extend: {
    public override method isImmediateReference32: (reference: Untyped) ::=> Boolean := __pendingMemoizationValue__ == reference.
    public override method isImmediateReference64: (reference: Untyped) ::=> Boolean := __pendingMemoizationValue__ == reference.

    public override method encodeImmediateReference32: (reference: Untyped) ::=> UInt32 := (ObjectModel::ImmediateTrivialIndex::PendingMemoizationValue << ObjectModel::Tag::Bits asUInt32) | ObjectModel::Tag::Trivial asUInt32.
    public override method encodeImmediateReference64: (reference: Untyped) ::=> UInt64 := (ObjectModel::ImmediateTrivialIndex::PendingMemoizationValue asUInt64 << ObjectModel::Tag::Bits asUInt64) | ObjectModel::Tag::Trivial asUInt64.
}.

public global ObjectModel::PointerSize := UIntPointer valueSize.

public global ObjectModel::TupleHeader := if: ObjectModel::PointerSize = 4sz
    then: ObjectModel::TupleHeader32
    else: ObjectModel::TupleHeader64.
public global ObjectModel::TupleHeaderSize := ObjectModel::TupleHeader valueSize.

public function ObjectModel::isNonNullPointerValue(value: UIntPointer) => Boolean
    := (value ~= 0uptr) && ((value & 15uptr) = 0uptr).

public global ObjectModel::getTuplePointerUIntValue := {:(Untyped)object :: UIntPointer |
    <primitive: #PointerLikeType::reinterpretCast>
    0uptr
}.

public global ObjectModel::getTupleHeaderPointerOf := {:(Untyped)object :: ObjectModel::TupleHeader pointer |
    <primitive: #PointerLikeType::reinterpretCast>
    nil
}.

(PointerType::reinterpretCastTo:) adoptDefinitionOf: {:(AnyPointer)self :(Type)targetPointerType :: targetPointerType |
    <primitive: #PointerType::reinterpretCastTo>
    nil
}.

(UIntPointer::reinterpretCastTo:) adoptDefinitionOf: {:(UIntPointer)self :(Type)targetPointerType :: targetPointerType |
    <primitive: #UIntPointer::reinterpretCastTo>
    nil
}.

(IntPointer::reinterpretCastTo:) adoptDefinitionOf: {:(IntPointer)self :(Type)targetPointerType :: targetPointerType |
    <primitive: #IntPointer::reinterpretCastTo>
    nil
}.

AnyValue extend: {
    public final method __rawContentsPointer__ => Void pointer
        := ObjectModel::getTupleHeaderPointerOf(self) + 1iptr reinterpretCastTo: Void pointer.
}.

let HashBitCount := Size valueSize*8sz - 4sz.
let HashBitMask := (1sz << HashBitCount) - 1sz.

Size extend: {
    public final method hashMultiply => UIntPointer
        := (self * 1103515245sz) & HashBitMask
}.


identityHash adoptDefinitionOf: {:(Untyped)self :: Size |
    let pointerValue := ObjectModel::getTuplePointerUIntValue(self).
    ObjectModel::isNonNullPointerValue(pointerValue) ifTrue: {
        (pointerValue reinterpretCastTo: ObjectModel::TupleHeader pointer) _ identityHashAndFlags >> 4uptr
    } ifFalse: {
        pointerValue asSize hashMultiply
    }
}.

RawTuple::isBytes adoptDefinitionOf: {:(Untyped)self :: Boolean |
    let pointerValue := ObjectModel::getTuplePointerUIntValue(self).
    ObjectModel::isNonNullPointerValue(pointerValue) ifTrue: {
        (pointerValue reinterpretCastTo: ObjectModel::TupleHeader pointer) _ isBytes
    } ifFalse: {
        false
    }
}.

RawTuple::size adoptDefinitionOf: {:(Untyped)self :: Size |
    let pointerValue := ObjectModel::getTuplePointerUIntValue(self).
    ObjectModel::isNonNullPointerValue(pointerValue) ifTrue: {
        (pointerValue reinterpretCastTo: ObjectModel::TupleHeader pointer) _ objectSize / ObjectModel::PointerSize
    } ifFalse: {
        0sz
    }.
}.

RawTuple::type adoptDefinitionOf: {:(Untyped)self :: Type |
    let pointerValue := ObjectModel::getTuplePointerUIntValue(self).
    let tag := pointerValue & 15uptr.
    (pointerValue ~= 0uptr) && (tag = 0uptr) ifTrue: {
        (pointerValue reinterpretCastTo: ObjectModel::TupleHeader pointer) _ typePointerAndFlags & -16uptr reinterpretCastTo: Type
    } ifFalse: {
        tag = 15uptr ifTrue: {
            let trivialTypeIndex := pointerValue >> 4uptr.
            ObjectModel::ImmediateTrivialTypeTable at: trivialTypeIndex asSize
        } ifFalse: {
            ObjectModel::ImmediateTagTypeTable at: tag asSize
        }
    }
}.

(RawTuple::slotAt:) adoptDefinitionOf: {:(Untyped)self :(Size)index :: Untyped |
    let pointerValue := ObjectModel::getTuplePointerUIntValue(self).
    ObjectModel::isNonNullPointerValue(pointerValue) ifTrue: {
        let header := pointerValue reinterpretCastTo: ObjectModel::TupleHeader pointer.
        let contents := header + 1iptr.
        header _ isBytes ifTrue: {
            ((contents reinterpretCastTo: UInt8 pointer)[index asIntPointer] asUIntPointer << ObjectModel::Tag::Bits asUIntPointer) | ObjectModel::Tag::UInt8 asUIntPointer reinterpretCastTo: Untyped
        } ifFalse: {
            (contents reinterpretCastTo: Untyped pointer)[index asIntPointer]
        }.
    } ifFalse: {
        let shiftAmount := (index asUIntPointer * 8uptr) + ObjectModel::Tag::Bits asUIntPointer.
        let tag := pointerValue & ObjectModel::Tag::Mask asUIntPointer.
        let isSigned := (ObjectModel::Tag::SignedIntegerFirst asUIntPointer <= tag) && (tag <= ObjectModel::Tag::SignedIntegerLast asUIntPointer).
        let byteValue := isSigned
            ifTrue: (pointerValue asIntPointer >> shiftAmount asIntPointer) asUInt8
            ifFalse: (pointerValue >> shiftAmount) asUInt8.

        (byteValue asUIntPointer << ObjectModel::Tag::Bits asUIntPointer) | ObjectModel::Tag::UInt8 asUIntPointer reinterpretCastTo: Untyped
    }
}.

(RawTuple::slotAt:put:) adoptDefinitionOf: {:(Untyped)self :(Size)index :(Untyped)value :: Void |
    let pointerValue := ObjectModel::getTuplePointerUIntValue(self).
    ObjectModel::isNonNullPointerValue(pointerValue) ifTrue: {
        let header := pointerValue reinterpretCastTo: ObjectModel::TupleHeader pointer.
        let contents := header + 1iptr.
        let isBytes := (header _ typePointerAndFlags & ObjectModel::TypePointerFlag::Bytes asUIntPointer) ~= 0uptr.
        isBytes ifTrue: {
            (contents reinterpretCastTo: UInt8 pointer)[index asIntPointer] := (ObjectModel::getTuplePointerUIntValue(value) >> ObjectModel::Tag::Bits asUIntPointer) asUInt8
        } ifFalse: {
            (contents reinterpretCastTo: Untyped pointer)[index asIntPointer] := value
        }
    }
}.

(RawTuple::byteSlotAt:) adoptDefinitionOf: {:(Untyped)self :(Size)index :: UInt8 |
    let pointerValue := ObjectModel::getTuplePointerUIntValue(self).
    ObjectModel::isNonNullPointerValue(pointerValue) ifTrue: {
        let header := pointerValue reinterpretCastTo: ObjectModel::TupleHeader pointer.
        let contents := header + 1iptr.
        let isBytes := (header _ typePointerAndFlags & ObjectModel::TypePointerFlag::Bytes asUIntPointer) ~= 0uptr.
        isBytes ifFalse: (error("Expected a byte tuple.")).
        
        (contents reinterpretCastTo: UInt8 pointer)[index asIntPointer]
    } ifFalse: {
        let shiftAmount := (index asUIntPointer * 8uptr) + ObjectModel::Tag::Bits asUIntPointer.
        let tag := pointerValue & ObjectModel::Tag::Mask asUIntPointer.
        let isSigned := (ObjectModel::Tag::SignedIntegerFirst asUIntPointer <= tag) && (tag <= ObjectModel::Tag::SignedIntegerLast asUIntPointer).
        isSigned
            ifTrue: (pointerValue asIntPointer >> shiftAmount asIntPointer) asUInt8
            ifFalse: (pointerValue >> shiftAmount) asUInt8
    }
}.

(RawTuple::byteSlotAt:put:) adoptDefinitionOf: {:(Untyped)self :(Size)index :(UInt8)value :: Void |
    let pointerValue := ObjectModel::getTuplePointerUIntValue(self).
    ObjectModel::isNonNullPointerValue(pointerValue) ifTrue: {
        let header := pointerValue reinterpretCastTo: ObjectModel::TupleHeader pointer.
        let contents := header + 1iptr.
        let isBytes := (header _ typePointerAndFlags & ObjectModel::TypePointerFlag::Bytes asUIntPointer) ~= 0uptr.
        isBytes ifFalse: (error("Expected a byte tuple.")).

        (contents reinterpretCastTo: UInt8 pointer)[index asIntPointer] := value
    } ifFalse: {
        error("Cannot modifiy immutable object.").
    }
}.

RawTuple::byteSize adoptDefinitionOf: {:(Untyped)self :: Size |
    let pointerValue := ObjectModel::getTuplePointerUIntValue(self).
    ObjectModel::isNonNullPointerValue(pointerValue) ifTrue: {
        (pointerValue reinterpretCastTo: ObjectModel::TupleHeader pointer) _ objectSize
    } ifFalse: {
        0sz
    }
}.

public function ObjectModel::lookupVirtualSelector(object: Untyped, selector: Symbol) => Untyped
    := RawTuple::type(object) lookupVirtualSelector: selector.

public function ObjectModel::lookupVirtualSelectorWithReceiverType(receiverType: Type, selector: Symbol) => Untyped
    := receiverType lookupVirtualSelector: selector.

(RawTuple::basicAllocateWithType:instanceSize:alignment:slotCount:variableSize:isBytes:isWeak:) adoptDefinitionOf: {
    :(Type)type :(Size)instanceSize :(Size)instanceAlignment :(Size)slotCount :(Size)variableSize :(Boolean)isBytes :(Boolean)isWeak :: Untyped |
    let allocationAlignment := instanceAlignment max: ObjectModel::MinimalAlignment asSize.
    let variableDataSize := isBytes ifTrue: variableSize ifFalse: variableSize * ObjectModel::PointerSize.
    let contentSize := instanceSize + variableDataSize.
    let allocationSize := ObjectModel::TupleHeaderSize + contentSize.
    let allocationPointer := sysmel_pal_malloc(allocationSize).
    memset(allocationPointer, 0i8, allocationSize).

    let objectHeader := allocationPointer reinterpretCastTo: ObjectModel::TupleHeader pointer.
    let typePointerFlags :=
        (isBytes ifTrue: ObjectModel::TypePointerFlag::Bytes asUIntPointer ifFalse: (0uptr)) |
        (isWeak ifTrue: ObjectModel::TypePointerFlag::Weak asUIntPointer ifFalse: (0uptr)).
    objectHeader _
        typePointerAndFlags: ObjectModel::getTuplePointerUIntValue(type) | typePointerFlags;
        objectSize: contentSize.

    allocationPointer reinterpretCastTo: Untyped.
}.

let emptyArray := #().
public function ObjectModel::makeArrayWithSize(size: Size) => Array := {
    size = 0sz
        ifTrue: emptyArray
        ifFalse: (Array basicAllocate: size)
}.
