public global ObjectModel::Tag::Bits := 4u8.
public global ObjectModel::Tag::Mask := 15u8.
public global ObjectModel::MinimalAlignment := 16u32.

public global ObjectModel::Tag::Pointer := 0u8.
public global ObjectModel::Tag::Nil := 0u8.

public global ObjectModel::Tag::Integer := 1u8.
public global ObjectModel::Tag::Int8 := 2u8.
public global ObjectModel::Tag::Int16 := 3u8.
public global ObjectModel::Tag::Int32 := 4u8.
public global ObjectModel::Tag::Int64 := 5u8.

public global ObjectModel::Tag::SignedIntegerFirst := ObjectModel::Tag::Integer.
public global ObjectModel::Tag::SignedIntegerLast := ObjectModel::Tag::Int64.

public global ObjectModel::Tag::Char8 := 6u8.
public global ObjectModel::Tag::UInt8 := 7u8.

public global ObjectModel::Tag::Char16 := 8u8.
public global ObjectModel::Tag::UInt16 := 9u8.

public global ObjectModel::Tag::Char32 := 10u8.
public global ObjectModel::Tag::UInt32 := 11u8.

public global ObjectModel::Tag::UInt64 := 12u8.

public global ObjectModel::Tag::Float32 := 13u8.
public global ObjectModel::Tag::Float64 := 14u8.

public global ObjectModel::Tag::Trivial := 15u8.

public global ObjectModel::ImmediateTagTypeTable := (
    UndefinedObject,
    Integer, Int8, Int16, Int32, Int64,
    Char8, UInt8,
    Char16, UInt16,
    Char32, UInt32,
    UInt64, Float32, Float64,
    nil
).

public global ObjectModel32::Immediate::Bits := 32u32 - ObjectModel::Tag::Bits asUInt32.
public global ObjectModel32::Immediate::UInt::Min := 0u32.
public global ObjectModel32::Immediate::UInt::Max := (1u32 << ObjectModel32::Immediate::Bits) - 1u32.
public global ObjectModel32::Immediate::Int::Min := (1i32 << (ObjectModel32::Immediate::Bits - 1u32) asInt32) negated.
public global ObjectModel32::Immediate::Int::Max := (1i32 << (ObjectModel32::Immediate::Bits - 1u32) asInt32) - 1i32.

public global ObjectModel64::Immediate::Bits := 64u64 - ObjectModel::Tag::Bits asUInt64.
public global ObjectModel64::Immediate::UInt::Min := 0u64.
public global ObjectModel64::Immediate::UInt::Max := (1u64 << ObjectModel64::Immediate::Bits) - 1u64.
public global ObjectModel64::Immediate::Int::Min := (1i64 << (ObjectModel64::Immediate::Bits - 1u64) asInt64) negated.
public global ObjectModel64::Immediate::Int::Max := (1i64 << (ObjectModel64::Immediate::Bits - 1u64) asInt64) - 1i64.

public global ObjectModel::ImmediateTrivialIndex::False := 0u32.
public global ObjectModel::ImmediateTrivialIndex::True := 1u32.
public global ObjectModel::ImmediateTrivialIndex::Void := 2u32.
public global ObjectModel::ImmediateTrivialIndex::HashtableEmptyElement := 3u32.
public global ObjectModel::ImmediateTrivialIndex::Tombstone := 4u32.
public global ObjectModel::ImmediateTrivialIndex::PendingMemoizationValue := 5u32.

public global ObjectModel::ImmediateTrivialConstant::False := (ObjectModel::ImmediateTrivialIndex::False << ObjectModel::Tag::Bits asUInt32) | ObjectModel::Tag::Trivial asUInt32.
public global ObjectModel::ImmediateTrivialConstant::True := (ObjectModel::ImmediateTrivialIndex::True << ObjectModel::Tag::Bits asUInt32) | ObjectModel::Tag::Trivial asUInt32.
public global ObjectModel::ImmediateTrivialConstant::Void := (ObjectModel::ImmediateTrivialIndex::Void << ObjectModel::Tag::Bits asUInt32) | ObjectModel::Tag::Trivial asUInt32.
public global ObjectModel::ImmediateTrivialConstant::HashtableEmptyElement := (ObjectModel::ImmediateTrivialIndex::HashtableEmptyElement << ObjectModel::Tag::Bits asUInt32) | ObjectModel::Tag::Trivial asUInt32.
public global ObjectModel::ImmediateTrivialConstant::Tombstone := (ObjectModel::ImmediateTrivialIndex::Tombstone << ObjectModel::Tag::Bits asUInt32) | ObjectModel::Tag::Trivial asUInt32.
public global ObjectModel::ImmediateTrivialConstant::PendingMemoizationValue := (ObjectModel::ImmediateTrivialIndex::PendingMemoizationValue << ObjectModel::Tag::Bits asUInt32) | ObjectModel::Tag::Trivial asUInt32.

public global ObjectModel::ImmediateTrivialTypeTable := (
    False, True, Void, HashtableEmpty, ObjectTombstone, PendingMemoizationValue
).

public global ObjectModel::TypePointerFlag::GCColorMask := 3uptr.
public global ObjectModel::TypePointerFlag::Bytes := 4uptr.
public global ObjectModel::TypePointerFlag::Weak := 8uptr.

public global ObjectModel::IdentityHashFlag::Immutable := 1uptr.
public global ObjectModel::IdentityHashFlag::NeedsFinalization := 2uptr.
public global ObjectModel::IdentityHashFlag::DummyValue := 4uptr.

public global ObjectModel::PointerSize := UIntPointer valueSize.

if: ObjectModel::PointerSize = 4sz then: {
    public global ObjectModel::Immediate::Bits      := ObjectModel32::Immediate::Bits.
    public global ObjectModel::Immediate::UInt::Min := ObjectModel32::Immediate::UInt::Min.
    public global ObjectModel::Immediate::UInt::Max := ObjectModel32::Immediate::UInt::Max.
    public global ObjectModel::Immediate::Int::Min  := ObjectModel32::Immediate::Int::Min.
    public global ObjectModel::Immediate::Int::Max  := ObjectModel32::Immediate::Int::Max.
} else: {
    public global ObjectModel::Immediate::Bits      := ObjectModel64::Immediate::Bits.
    public global ObjectModel::Immediate::UInt::Min := ObjectModel64::Immediate::UInt::Min.
    public global ObjectModel::Immediate::UInt::Max := ObjectModel64::Immediate::UInt::Max.
    public global ObjectModel::Immediate::Int::Min  := ObjectModel64::Immediate::Int::Min.
    public global ObjectModel::Immediate::Int::Max  := ObjectModel64::Immediate::Int::Max.
}.

public final struct ObjectModel::TupleHeader32 definition: {
    public field typePointerAndFlags => UInt32.
    public field identityHashAndFlags => UInt32.
    public field objectSize => UInt32.
    public field forwardingPointer => UInt32.

    public method typePointer => UInt32
        := typePointerAndFlags & -16u32.

    public method gcColor => UInt8
        := (typePointerAndFlags & ObjectModel::TypePointerFlag::GCColorMask asUInt32) asUInt8.

    public method gcColor: (newColor: UInt8) ::=> Void := {
        typePointerAndFlags := (typePointerAndFlags & ObjectModel::TypePointerFlag::GCColorMask asUInt32 bitInvert) | newColor asUInt32
    }.

    public method isBytes => Boolean
        := (typePointerAndFlags & ObjectModel::TypePointerFlag::Bytes asUInt32) ~= 0u32.

    public method isBytes: (flag: Boolean) ::=> Void := {
        flag
            ifTrue: (typePointerAndFlags := typePointerAndFlags | ObjectModel::TypePointerFlag::Bytes asUInt32)
            ifFalse: (typePointerAndFlags := typePointerAndFlags & ObjectModel::TypePointerFlag::Bytes asUInt32 bitInvert).
    }.

    public method isWeak => Boolean
        := (typePointerAndFlags & ObjectModel::TypePointerFlag::Weak asUInt32) ~= 0u32.

    public method isWeak: (flag: Boolean) ::=> Void := {
        flag
            ifTrue: (typePointerAndFlags := typePointerAndFlags | ObjectModel::TypePointerFlag::Weak asUInt32)
            ifFalse: (typePointerAndFlags := typePointerAndFlags & ObjectModel::TypePointerFlag::Weak asUInt32 bitInvert).
    }.

    public method identityHashValue ::=> UInt32
        := identityHashAndFlags >> 4u32.

    public method identityHashValue: (identityHash: UInt32) ::=> Void := {
        identityHashAndFlags := (identityHash << 4u32) | (identityHashAndFlags & 15u32)
    }.

    public method isDummyValue => Boolean
        := (identityHashAndFlags & ObjectModel::IdentityHashFlag::DummyValue asUInt32) ~= 0u32.

    public method isDummyValue: (flag: Boolean) ::=> Void := {
        flag
            ifTrue: (identityHashAndFlags := identityHashAndFlags | ObjectModel::IdentityHashFlag::DummyValue asUInt32)
            ifFalse: (identityHashAndFlags := identityHashAndFlags & ObjectModel::IdentityHashFlag::DummyValue asUInt32 bitInvert).
    }.

    public method slotCount => UInt32
        := objectSize >> 2u32.
}.

public final struct ObjectModel::TupleHeader64 definition: {
    public field typePointerAndFlags => UInt64.
    public field identityHashAndFlags => UInt64.
    public field objectSize => UInt64.
    public field forwardingPointer => UInt64.

    public method typePointer => UInt64
        := typePointerAndFlags & -16u64.

    public method gcColor => UInt8
        := (typePointerAndFlags & ObjectModel::TypePointerFlag::GCColorMask asUInt64) asUInt8.

    public method gcColor: (newColor: UInt8) ::=> Void := {
        typePointerAndFlags := (typePointerAndFlags & ObjectModel::TypePointerFlag::GCColorMask asUInt64 bitInvert) | newColor asUInt64
    }.

    public method isBytes => Boolean
        := (typePointerAndFlags & ObjectModel::TypePointerFlag::Bytes asUInt64) ~= 0u64.

    public method isBytes: (flag: Boolean) ::=> Void := {
        flag
            ifTrue: (typePointerAndFlags := typePointerAndFlags | ObjectModel::TypePointerFlag::Bytes asUInt64)
            ifFalse: (typePointerAndFlags := typePointerAndFlags & ObjectModel::TypePointerFlag::Bytes asUInt64 bitInvert).
    }.

    public method isWeak => Boolean
        := (typePointerAndFlags & ObjectModel::TypePointerFlag::Weak asUInt64) ~= 0u64.

    public method isWeak: (flag: Boolean) ::=> Void := {
        flag
            ifTrue: (typePointerAndFlags := typePointerAndFlags | ObjectModel::TypePointerFlag::Weak asUInt64)
            ifFalse: (typePointerAndFlags := typePointerAndFlags & ObjectModel::TypePointerFlag::Weak asUInt64 bitInvert).
    }.

    public method isDummyValue => Boolean
        := (identityHashAndFlags & ObjectModel::IdentityHashFlag::DummyValue asUInt64) ~= 0u64.

    public method isDummyValue: (flag: Boolean) ::=> Void := {
        flag
            ifTrue: (identityHashAndFlags := identityHashAndFlags | ObjectModel::IdentityHashFlag::DummyValue asUInt64)
            ifFalse: (identityHashAndFlags := identityHashAndFlags & ObjectModel::IdentityHashFlag::DummyValue asUInt64 bitInvert).
    }.

    public method identityHashValue ::=> UInt64
        := identityHashAndFlags >> 4u64.

    public method identityHashValue: (identityHash: UInt64) ::=> Void := {
        identityHashAndFlags := (identityHash << 4u64) | (identityHashAndFlags & 15u64)
    }.

    public method slotCount => UInt64
        := objectSize >> 3u64.
}.

public abstract class ObjectModelVariant superclass: Object; definition: {
    __Meta__ definition: {
        public method current => ObjectModelVariant
            := UIntPointer valueSize = 4sz
                ifTrue: ObjectModelVariant32 uniqueInstance
                ifFalse: ObjectModelVariant64 uniqueInstance.
    }.

    public abstract method pointerSize => UInt64 := self subclassResponsibility.

    public virtual method minimalObjectAlignment => UInt64 := ObjectModel::MinimalAlignment asUInt64.

    public abstract method objectHeaderSize => UInt64
        := self subclassResponsibility.

    public abstract method objectHeaderType => Type
        := self subclassResponsibility.

    public virtual method isImmediateReference: (reference: Untyped) ::=> Boolean
        := self subclassResponsibility.

    public virtual method encodeImmediateReference32: (reference: Untyped) ::=> UInt32 := {
        let type => Type := RawTuple::type(reference).
        type encodeImmediateReference32: reference
    }.

    public virtual method encodeImmediateReference64: (reference: Untyped) ::=> UInt64 := {
        let type => Type := RawTuple::type(reference).
        type encodeImmediateReference64: reference
    }.

    public virtual method computeSizeOfObjectInstanceContent: (object: Untyped) ::=> UInt64 := {
        let isBytes := RawTuple::isBytes(object).
        isBytes ifTrue: {
            let byteSize := RawTuple::byteSize(object).
            byteSize asUInt64
        } ifFalse: {
            let totalSlotCount := RawTuple::size(object).
            let type := RawTuple::type(object).
            let typeSlotCount := type ifNil: (0sz) ifNotNil: (type totalSlotCount).
            let variantSlotCount := totalSlotCount - typeSlotCount.
            let fixedInstanceSize := type ifNil: (0sz) ifNotNil: (type validInstanceSize).
            fixedInstanceSize asUInt64 + (variantSlotCount asUInt64 * self pointerSize)
        }
    }.

    public virtual method computeSizeOfObjectInstance: (object: Untyped) ::=> UInt64
        := self objectHeaderSize + (self computeSizeOfObjectInstanceContent: object).

    public virtual method computeAlignmentOfObjectInstance: (object: Untyped) ::=> UInt64
        := RawTuple::type(object)
            ifNil: {self minimalObjectAlignment}
            ifNotNil: {:(Type)type :: UInt64 | type validInstanceAlignment asUInt64 max: self minimalObjectAlignment}.
}.

public final class ObjectModelVariant32 superclass: ObjectModelVariant; definition: {
    public override method pointerSize => UInt64 := 4u64.

    public override method objectHeaderSize => UInt64 := ObjectModel::TupleHeader32 valueSize asUInt64.
    public override method objectHeaderType => Type := ObjectModel::TupleHeader32.

    let singleton := SelfType new.

    public override method isImmediateReference: (reference: Untyped) ::=> Boolean := {
        let type => Type := RawTuple::type(reference).
        type isNotNil && (type isImmediateReference32: reference)
    }.

    __Meta__ definition: {
        public method uniqueInstance => ObjectModelVariant32
            := singleton.
    }.
}.

public final class ObjectModelVariant64 superclass: ObjectModelVariant; definition: {
    public override method pointerSize => UInt64 := 8u64.

    public override method objectHeaderSize => UInt64 := ObjectModel::TupleHeader64 valueSize asUInt64.
    public override method objectHeaderType => Type := ObjectModel::TupleHeader64.

    public override method isImmediateReference: (reference: Untyped) ::=> Boolean := {
        let type => Type := RawTuple::type(reference).
        type isNotNil && (type isImmediateReference64: reference)
    }.

    let singleton := SelfType new.
    __Meta__ definition: {
        public method uniqueInstance => ObjectModelVariant64
            := singleton.
    }.
}.

Type extend: {
    public virtual method isImmediateReference32: (reference: Untyped) ::=> Boolean := false.
    public virtual method isImmediateReference64: (reference: Untyped) ::=> Boolean := false.

    public virtual method encodeImmediateReference32: (reference: Untyped) ::=> UInt32
        := self error: "Cannot encode 32 bits immediate reference.".

    public virtual method encodeImmediateReference64: (reference: Untyped) ::=> UInt64
        := self error: "Cannot encode 64 bits immediate reference.".

    public virtual method objectHeaderSizeForObjectModel: (objectModel: ObjectModelVariant) ::=> UInt64
        := objectModel objectHeaderSize.
}.

ValueType extend: {
    public override method objectHeaderSizeForObjectModel: (objectModel: ObjectModelVariant) ::=> Size
        := 0sz.
}.

Char8 __type__ extend: {
    public override method isImmediateReference32: (reference: Untyped) ::=> Boolean := true.
    public override method isImmediateReference64: (reference: Untyped) ::=> Boolean := true.

    public override method encodeImmediateReference32: (reference: Untyped) ::=> UInt32 := (reference asUInt32 << ObjectModel::Tag::Bits asUInt32) | ObjectModel::Tag::Char8 asUInt32.
    public override method encodeImmediateReference64: (reference: Untyped) ::=> UInt64 := (reference asUInt64 << ObjectModel::Tag::Bits asUInt64) | ObjectModel::Tag::Char8 asUInt64.
}.

UInt8 __type__ extend: {
    public override method isImmediateReference32: (reference: Untyped) ::=> Boolean := true.
    public override method isImmediateReference64: (reference: Untyped) ::=> Boolean := true.

    public override method encodeImmediateReference32: (reference: Untyped) ::=> UInt32 := (reference asUInt32 << ObjectModel::Tag::Bits asUInt32) | ObjectModel::Tag::UInt8 asUInt32.
    public override method encodeImmediateReference64: (reference: Untyped) ::=> UInt64 := (reference asUInt64 << ObjectModel::Tag::Bits asUInt64) | ObjectModel::Tag::UInt8 asUInt64.
}.

Int8 __type__ extend: {
    public override method isImmediateReference32: (reference: Untyped) ::=> Boolean := true.
    public override method isImmediateReference64: (reference: Untyped) ::=> Boolean := true.

    public override method encodeImmediateReference32: (reference: Untyped) ::=> UInt32 := (reference asUInt32 << ObjectModel::Tag::Bits asUInt32) | ObjectModel::Tag::Int8 asUInt32.
    public override method encodeImmediateReference64: (reference: Untyped) ::=> UInt64 := (reference asUInt64 << ObjectModel::Tag::Bits asUInt64) | ObjectModel::Tag::Int8 asUInt64.
}.

Char16 __type__ extend: {
    public override method isImmediateReference32: (reference: Untyped) ::=> Boolean := true.
    public override method isImmediateReference64: (reference: Untyped) ::=> Boolean := true.

    public override method encodeImmediateReference32: (reference: Untyped) ::=> UInt32 := (reference asUInt32 << ObjectModel::Tag::Bits asUInt32) | ObjectModel::Tag::Char16 asUInt32.
    public override method encodeImmediateReference64: (reference: Untyped) ::=> UInt64 := (reference asUInt64 << ObjectModel::Tag::Bits asUInt64) | ObjectModel::Tag::Char16 asUInt64.
}.

UInt16 __type__ extend: {
    public override method isImmediateReference32: (reference: Untyped) ::=> Boolean := true.
    public override method isImmediateReference64: (reference: Untyped) ::=> Boolean := true.

    public override method encodeImmediateReference32: (reference: Untyped) ::=> UInt32 := (reference asUInt32 << ObjectModel::Tag::Bits asUInt32) | ObjectModel::Tag::UInt16 asUInt32.
    public override method encodeImmediateReference64: (reference: Untyped) ::=> UInt64 := (reference asUInt64 << ObjectModel::Tag::Bits asUInt64) | ObjectModel::Tag::UInt16 asUInt64.
}.

Int16 __type__ extend: {
    public override method isImmediateReference32: (reference: Untyped) ::=> Boolean := true.
    public override method isImmediateReference64: (reference: Untyped) ::=> Boolean := true.

    public override method encodeImmediateReference32: (reference: Untyped) ::=> UInt32 := (reference asUInt32 << ObjectModel::Tag::Bits asUInt32) | ObjectModel::Tag::Int16 asUInt32.
    public override method encodeImmediateReference64: (reference: Untyped) ::=> UInt64 := (reference asUInt64 << ObjectModel::Tag::Bits asUInt64) | ObjectModel::Tag::Int16 asUInt64.
}.

Char32 __type__ extend: {
    public override method isImmediateReference32: (reference: Untyped) ::=> Boolean := {
        let value := reference asUInt32.
        (ObjectModel32::Immediate::UInt::Min <= value) && (value <= ObjectModel32::Immediate::UInt::Max)
    }.

    public override method isImmediateReference64: (reference: Untyped) ::=> Boolean := true.

    public override method encodeImmediateReference32: (reference: Untyped) ::=> UInt32 := (reference asUInt32 << ObjectModel::Tag::Bits asUInt32) | ObjectModel::Tag::Char32 asUInt32.
    public override method encodeImmediateReference64: (reference: Untyped) ::=> UInt64 := (reference asUInt64 << ObjectModel::Tag::Bits asUInt64) | ObjectModel::Tag::Char32 asUInt64.
}.

UInt32 __type__ extend: {
    public override method isImmediateReference32: (reference: Untyped) ::=> Boolean := {
        let value := reference asUInt32.
        (ObjectModel32::Immediate::UInt::Min <= value) && (value <= ObjectModel32::Immediate::UInt::Max)
    }.

    public override method isImmediateReference64: (reference: Untyped) ::=> Boolean := true.

    public override method encodeImmediateReference32: (reference: Untyped) ::=> UInt32 := (reference asUInt32 << ObjectModel::Tag::Bits asUInt32) | ObjectModel::Tag::UInt32 asUInt32.
    public override method encodeImmediateReference64: (reference: Untyped) ::=> UInt64 := (reference asUInt64 << ObjectModel::Tag::Bits asUInt64) | ObjectModel::Tag::UInt32 asUInt64.
}.

Int32 __type__ extend: {
    public override method isImmediateReference32: (reference: Untyped) ::=> Boolean := {
        let value := reference asInt32.
        (ObjectModel32::Immediate::Int::Min <= value) && (value <= ObjectModel32::Immediate::Int::Max)
    }.

    public override method isImmediateReference64: (reference: Untyped) ::=> Boolean := true.

    public override method encodeImmediateReference32: (reference: Untyped) ::=> UInt32 := (reference asUInt32 << ObjectModel::Tag::Bits asUInt32) | ObjectModel::Tag::Int32 asUInt32.
    public override method encodeImmediateReference64: (reference: Untyped) ::=> UInt64 := (reference asUInt64 << ObjectModel::Tag::Bits asUInt64) | ObjectModel::Tag::Int32 asUInt64.
}.

UInt64 __type__ extend: {
    public override method isImmediateReference32: (reference: Untyped) ::=> Boolean := {
        let value := reference asUInt64.
        (ObjectModel32::Immediate::UInt::Min asUInt64 <= value) && (value <= ObjectModel32::Immediate::UInt::Max asUInt64)
    }.

    public override method isImmediateReference64: (reference: Untyped) ::=> Boolean := {
        let value := reference asUInt64.
        (ObjectModel64::Immediate::UInt::Min <= value) && (value <= ObjectModel64::Immediate::UInt::Max)
    }.

    public override method encodeImmediateReference32: (reference: Untyped) ::=> UInt32 := (reference asUInt32 << ObjectModel::Tag::Bits asUInt32) | ObjectModel::Tag::UInt64 asUInt32.
    public override method encodeImmediateReference64: (reference: Untyped) ::=> UInt64 := (reference asUInt64 << ObjectModel::Tag::Bits asUInt64) | ObjectModel::Tag::UInt64 asUInt64.
}.

Int64 __type__ extend: {
    public override method isImmediateReference32: (reference: Untyped) ::=> Boolean := {
        let value := reference asInt64.
        (ObjectModel32::Immediate::Int::Min asUInt64 <= value) && (value <= ObjectModel32::Immediate::Int::Max asUInt64)
    }.

    public override method isImmediateReference64: (reference: Untyped) ::=> Boolean := {
        let value := reference asInt64.
        (ObjectModel64::Immediate::Int::Min <= value) && (value <= ObjectModel64::Immediate::Int::Max)
    }.

    public override method encodeImmediateReference32: (reference: Untyped) ::=> UInt32 := (reference asUInt32 << ObjectModel::Tag::Bits asUInt32) | ObjectModel::Tag::Int64 asUInt32.
    public override method encodeImmediateReference64: (reference: Untyped) ::=> UInt64 := (reference asUInt64 << ObjectModel::Tag::Bits asUInt64) | ObjectModel::Tag::Int64 asUInt64.
}.

UndefinedObject __type__ extend: {
    public override method isImmediateReference32: (reference: Untyped) ::=> Boolean := nil == reference.
    public override method isImmediateReference64: (reference: Untyped) ::=> Boolean := nil == reference.

    public virtual method encodeImmediateReference32: (reference: Untyped) ::=> UInt32 := 0u32.
    public virtual method encodeImmediateReference64: (reference: Untyped) ::=> UInt64 := 0u64.
}.

False __type__ extend: {
    public override method isImmediateReference32: (reference: Untyped) ::=> Boolean := false == reference.
    public override method isImmediateReference64: (reference: Untyped) ::=> Boolean := false == reference.

    public override method encodeImmediateReference32: (reference: Untyped) ::=> UInt32 := (ObjectModel::ImmediateTrivialIndex::False << ObjectModel::Tag::Bits asUInt32) | ObjectModel::Tag::Trivial asUInt32.
    public override method encodeImmediateReference64: (reference: Untyped) ::=> UInt64 := (ObjectModel::ImmediateTrivialIndex::False asUInt64 << ObjectModel::Tag::Bits asUInt64) | ObjectModel::Tag::Trivial asUInt64.
}.

True __type__ extend: {
    public override method isImmediateReference32: (reference: Untyped) ::=> Boolean := false == reference.
    public override method isImmediateReference64: (reference: Untyped) ::=> Boolean := false == reference.

    public override method encodeImmediateReference32: (reference: Untyped) ::=> UInt32 := (ObjectModel::ImmediateTrivialIndex::True << ObjectModel::Tag::Bits asUInt32) | ObjectModel::Tag::Trivial asUInt32.
    public override method encodeImmediateReference64: (reference: Untyped) ::=> UInt64 := (ObjectModel::ImmediateTrivialIndex::True asUInt64 << ObjectModel::Tag::Bits asUInt64) | ObjectModel::Tag::Trivial asUInt64.
}.

Void __type__ extend: {
    public override method isImmediateReference32: (reference: Untyped) ::=> Boolean := void == reference.
    public override method isImmediateReference64: (reference: Untyped) ::=> Boolean := void == reference.

    public override method encodeImmediateReference32: (reference: Untyped) ::=> UInt32 := (ObjectModel::ImmediateTrivialIndex::Void << ObjectModel::Tag::Bits asUInt32) | ObjectModel::Tag::Trivial asUInt32.
    public override method encodeImmediateReference64: (reference: Untyped) ::=> UInt64 := (ObjectModel::ImmediateTrivialIndex::Void asUInt64 << ObjectModel::Tag::Bits asUInt64) | ObjectModel::Tag::Trivial asUInt64.
}.

HashtableEmpty __type__ extend: {
    public override method isImmediateReference32: (reference: Untyped) ::=> Boolean := __hashtableEmptyElement__ == reference.
    public override method isImmediateReference64: (reference: Untyped) ::=> Boolean := __hashtableEmptyElement__ == reference.

    public override method encodeImmediateReference32: (reference: Untyped) ::=> UInt32 := (ObjectModel::ImmediateTrivialIndex::HashtableEmptyElement << ObjectModel::Tag::Bits asUInt32) | ObjectModel::Tag::Trivial asUInt32.
    public override method encodeImmediateReference64: (reference: Untyped) ::=> UInt64 := (ObjectModel::ImmediateTrivialIndex::HashtableEmptyElement asUInt64 << ObjectModel::Tag::Bits asUInt64) | ObjectModel::Tag::Trivial asUInt64.
}.

ObjectTombstone __type__ extend: {
    public override method isImmediateReference32: (reference: Untyped) ::=> Boolean := __tombstone__ == reference.
    public override method isImmediateReference64: (reference: Untyped) ::=> Boolean := __tombstone__ == reference.

    public override method encodeImmediateReference32: (reference: Untyped) ::=> UInt32 := (ObjectModel::ImmediateTrivialIndex::Tombstone << ObjectModel::Tag::Bits asUInt32) | ObjectModel::Tag::Trivial asUInt32.
    public override method encodeImmediateReference64: (reference: Untyped) ::=> UInt64 := (ObjectModel::ImmediateTrivialIndex::Tombstone asUInt64 << ObjectModel::Tag::Bits asUInt64) | ObjectModel::Tag::Trivial asUInt64.
}.

PendingMemoizationValue __type__ extend: {
    public override method isImmediateReference32: (reference: Untyped) ::=> Boolean := __pendingMemoizationValue__ == reference.
    public override method isImmediateReference64: (reference: Untyped) ::=> Boolean := __pendingMemoizationValue__ == reference.

    public override method encodeImmediateReference32: (reference: Untyped) ::=> UInt32 := (ObjectModel::ImmediateTrivialIndex::PendingMemoizationValue << ObjectModel::Tag::Bits asUInt32) | ObjectModel::Tag::Trivial asUInt32.
    public override method encodeImmediateReference64: (reference: Untyped) ::=> UInt64 := (ObjectModel::ImmediateTrivialIndex::PendingMemoizationValue asUInt64 << ObjectModel::Tag::Bits asUInt64) | ObjectModel::Tag::Trivial asUInt64.
}.

public global ObjectModel::TupleHeader := if: ObjectModel::PointerSize = 4sz
    then: ObjectModel::TupleHeader32
    else: ObjectModel::TupleHeader64.
public global ObjectModel::TupleHeaderSize := ObjectModel::TupleHeader valueSize.

public function ObjectModel::isNonNullPointerValue(value: UIntPointer) => Boolean
    := (value ~= 0uptr) && ((value & 15uptr) = 0uptr).

public global ObjectModel::getTuplePointerUIntValue := {:(Untyped)object :: UIntPointer |
    <primitive: #PointerLikeType::reinterpretCast>
    0uptr
}.

public global ObjectModel::getTuplePointerIntValue := {:(Untyped)object :: IntPointer |
    <primitive: #PointerLikeType::reinterpretCast>
    0iptr
}.

public global ObjectModel::tupleAsType := {:(Untyped)object :: Type |
    <primitive: #PointerLikeType::reinterpretCast>
    object downCastTo: Type
}.


public global ObjectModel::tupleAsFunction := {:(Untyped)object :: Function |
    <primitive: #PointerLikeType::reinterpretCast>
    object downCastTo: Function
}.

public global ObjectModel::getTupleHeaderPointerOf := {:(Untyped)object :: ObjectModel::TupleHeader pointer |
    <primitive: #PointerLikeType::reinterpretCast>
    nil
}.

(PointerType::reinterpretCastTo:) adoptDefinitionOf: {:(AnyPointer)self :(Type)targetPointerType :: targetPointerType |
    <primitive: #PointerType::reinterpretCastTo>
    nil
}.

(UIntPointer::reinterpretCastTo:) adoptDefinitionOf: {:(UIntPointer)self :(Type)targetPointerType :: targetPointerType |
    <primitive: #UIntPointer::reinterpretCastTo>
    nil
}.

(IntPointer::reinterpretCastTo:) adoptDefinitionOf: {:(IntPointer)self :(Type)targetPointerType :: targetPointerType |
    <primitive: #IntPointer::reinterpretCastTo>
    nil
}.

AnyValue extend: {
    public final method __rawContentsPointer__ => Void pointer
        := ObjectModel::getTupleHeaderPointerOf(self) + 1iptr reinterpretCastTo: Void pointer.
}.

identityHash adoptDefinitionOf: {:(Untyped)self :: Size |
    <primitive: #identityHash >
    let pointerValue := ObjectModel::getTuplePointerUIntValue(self).
    ObjectModel::isNonNullPointerValue(pointerValue) ifTrue: {
        (pointerValue reinterpretCastTo: ObjectModel::TupleHeader pointer) _ identityHashAndFlags >> 4uptr
    } ifFalse: {
        pointerValue asSize hashMultiply
    }
} makePure makeFinal withEagerAnalysis.

RawTuple::isBytes adoptDefinitionOf: {:(Untyped)self :: Boolean |
    <primitive: #RawTuple::isBytes>
    let pointerValue := ObjectModel::getTuplePointerUIntValue(self).
    ObjectModel::isNonNullPointerValue(pointerValue) ifTrue: {
        (pointerValue reinterpretCastTo: ObjectModel::TupleHeader pointer) _ isBytes
    } ifFalse: {
        false
    }
} withEagerAnalysis.

RawTuple::isDummyValue adoptDefinitionOf: {:(Untyped)self :: Boolean |
    <primitive: #RawTuple::isDummyValue>
    let pointerValue := ObjectModel::getTuplePointerUIntValue(self).
    ObjectModel::isNonNullPointerValue(pointerValue) ifTrue: {
        (pointerValue reinterpretCastTo: ObjectModel::TupleHeader pointer) _ isDummyValue
    } ifFalse: {
        false
    }
} withEagerAnalysis.

RawTuple::markDummyValue adoptDefinitionOf: {:(Untyped)self :: Void |
    <primitive: #RawTuple::markDummy>
    let pointerValue := ObjectModel::getTuplePointerUIntValue(self).
    ObjectModel::isNonNullPointerValue(pointerValue) ifTrue: {
        (pointerValue reinterpretCastTo: ObjectModel::TupleHeader pointer) _ isDummyValue: true
    }.
} withEagerAnalysis.

RawTuple::isWeak adoptDefinitionOf: {:(Untyped)self :: Boolean |
    <primitive: #RawTuple::isWeak>
    let pointerValue := ObjectModel::getTuplePointerUIntValue(self).
    ObjectModel::isNonNullPointerValue(pointerValue) ifTrue: {
        (pointerValue reinterpretCastTo: ObjectModel::TupleHeader pointer) _ isWeak
    } ifFalse: {
        false
    }
} withEagerAnalysis.

RawTuple::markWeak adoptDefinitionOf: {:(Untyped)self :: Void |
    <primitive: #RawTuple::markWeak>
    let pointerValue := ObjectModel::getTuplePointerUIntValue(self).
    ObjectModel::isNonNullPointerValue(pointerValue) ifTrue: {
        (pointerValue reinterpretCastTo: ObjectModel::TupleHeader pointer) _ isWeak: true
    }.
} withEagerAnalysis.

RawTuple::size adoptDefinitionOf: {:(Untyped)self :: Size |
    <primitive: #RawTuple::size>
    let pointerValue := ObjectModel::getTuplePointerUIntValue(self).
    ObjectModel::isNonNullPointerValue(pointerValue) ifTrue: {
        (pointerValue reinterpretCastTo: ObjectModel::TupleHeader pointer) _ slotCount
    } ifFalse: {
        0sz
    }.
} withEagerAnalysis.

RawTuple::type adoptDefinitionOf: {:(Untyped)self :: Type |
    <primitive: #RawTuple::type>
    let pointerValue := ObjectModel::getTuplePointerUIntValue(self).
    let tag := pointerValue & 15uptr.
    (pointerValue ~= 0uptr) && (tag = 0uptr) ifTrue: {
        (pointerValue reinterpretCastTo: ObjectModel::TupleHeader pointer) _ typePointer reinterpretCastTo: Type
    } ifFalse: {
        tag = 15uptr ifTrue: {
            let trivialTypeIndex := pointerValue >> 4uptr.
            ObjectModel::tupleAsType(ObjectModel::ImmediateTrivialTypeTable at: trivialTypeIndex asSize)
        } ifFalse: {
            ObjectModel::tupleAsType(ObjectModel::ImmediateTagTypeTable at: tag asSize)
        }
    }
} withEagerAnalysis.

(RawTuple::type:) adoptDefinitionOf: {:(Untyped)self :(Type)newType :: Void |
    <primitive: #RawTuple::type>
    let pointerValue := ObjectModel::getTuplePointerUIntValue(self).
    let newTypeValue := ObjectModel::getTuplePointerUIntValue(newType).
    (pointerValue & 15uptr) ~= 0uptr ifTrue: error("Types cannot be immediate values.").

    ObjectModel::isNonNullPointerValue(pointerValue) ifTrue: {
        let header := pointerValue reinterpretCastTo: ObjectModel::TupleHeader pointer.
        header _ typePointerAndFlags: newTypeValue | (header _ typePointerAndFlags & 15uptr)
    }.
} withEagerAnalysis.

(RawTuple::slotAt:) adoptDefinitionOf: {:(Untyped)self :(Size)index :: Untyped |
    <primitive: #RawTuple::slotAt:>
    let pointerValue := ObjectModel::getTuplePointerUIntValue(self).
    ObjectModel::isNonNullPointerValue(pointerValue) ifTrue: {
        let header := pointerValue reinterpretCastTo: ObjectModel::TupleHeader pointer.
        let contents := header + 1iptr.
        header _ isBytes ifTrue: {
            ((contents reinterpretCastTo: UInt8 pointer)[index asIntPointer] asUIntPointer << ObjectModel::Tag::Bits asUIntPointer) | ObjectModel::Tag::UInt8 asUIntPointer reinterpretCastTo: Untyped
        } ifFalse: {
            (contents reinterpretCastTo: Untyped pointer)[index asIntPointer] __refLoad__
        }.
    } ifFalse: {
        let shiftAmount := (index asUIntPointer * 8uptr) + ObjectModel::Tag::Bits asUIntPointer.
        let tag := pointerValue & ObjectModel::Tag::Mask asUIntPointer.
        let isSigned := (ObjectModel::Tag::SignedIntegerFirst asUIntPointer <= tag) && (tag <= ObjectModel::Tag::SignedIntegerLast asUIntPointer).
        let byteValue := isSigned
            ifTrue: (pointerValue asIntPointer >> shiftAmount asIntPointer) asUInt8
            ifFalse: (pointerValue >> shiftAmount) asUInt8.

        (byteValue asUIntPointer << ObjectModel::Tag::Bits asUIntPointer) | ObjectModel::Tag::UInt8 asUIntPointer reinterpretCastTo: Untyped
    }
} withEagerAnalysis.

(RawTuple::slotAt:put:) adoptDefinitionOf: {:(Untyped)self :(Size)index :(Untyped)value :: Void |
    <primitive: #RawTuple::slotAt:put:>
    let pointerValue := ObjectModel::getTuplePointerUIntValue(self).
    ObjectModel::isNonNullPointerValue(pointerValue) ifTrue: {
        let header := pointerValue reinterpretCastTo: ObjectModel::TupleHeader pointer.
        let contents := header + 1iptr.
        header _ isBytes ifTrue: {
            (contents reinterpretCastTo: UInt8 pointer)[index asIntPointer] := (ObjectModel::getTuplePointerUIntValue(value) >> ObjectModel::Tag::Bits asUIntPointer) asUInt8
        } ifFalse: {
            (contents reinterpretCastTo: Untyped pointer)[index asIntPointer] := value
        }
    }
} withEagerAnalysis.

(RawTuple::byteSlotAt:) adoptDefinitionOf: {:(Untyped)self :(Size)index :: UInt8 |
    <primitive: #RawTuple::byteSlotAt:>
    let pointerValue := ObjectModel::getTuplePointerUIntValue(self).
    ObjectModel::isNonNullPointerValue(pointerValue) ifTrue: {
        let header := pointerValue reinterpretCastTo: ObjectModel::TupleHeader pointer.
        let contents := header + 1iptr.
        header _ isBytes ifFalse: (error("Expected a byte tuple.")).
        
        (contents reinterpretCastTo: UInt8 pointer)[index asIntPointer]
    } ifFalse: {
        let shiftAmount := (index asUIntPointer * 8uptr) + ObjectModel::Tag::Bits asUIntPointer.
        let tag := pointerValue & ObjectModel::Tag::Mask asUIntPointer.
        let isSigned := (ObjectModel::Tag::SignedIntegerFirst asUIntPointer <= tag) && (tag <= ObjectModel::Tag::SignedIntegerLast asUIntPointer).
        isSigned
            ifTrue: (pointerValue asIntPointer >> shiftAmount asIntPointer) asUInt8
            ifFalse: (pointerValue >> shiftAmount) asUInt8
    }
} withEagerAnalysis.

(RawTuple::byteSlotAt:put:) adoptDefinitionOf: {:(Untyped)self :(Size)index :(UInt8)value :: Void |
    <primitive: #RawTuple::byteSlotAt:put:>
    let pointerValue := ObjectModel::getTuplePointerUIntValue(self).
    ObjectModel::isNonNullPointerValue(pointerValue) ifTrue: {
        let header := pointerValue reinterpretCastTo: ObjectModel::TupleHeader pointer.
        let contents := header + 1iptr.
        let isBytes := header _ isBytes.
        isBytes ifFalse: (error("Expected a byte tuple.")).

        (contents reinterpretCastTo: UInt8 pointer)[index asIntPointer] := value
    } ifFalse: {
        error("Cannot modifiy immutable object.").
    }
} withEagerAnalysis.

RawTuple::byteSize adoptDefinitionOf: {:(Untyped)self :: Size |
    <primitive: #RawTuple::byteSize>
    let pointerValue := ObjectModel::getTuplePointerUIntValue(self).
    ObjectModel::isNonNullPointerValue(pointerValue) ifTrue: {
        (pointerValue reinterpretCastTo: ObjectModel::TupleHeader pointer) _ objectSize
    } ifFalse: {
        0sz
    }
} withEagerAnalysis.

(RawTuple::basicAllocateWithType:instanceSize:alignment:slotCount:variableSize:isBytes:isWeak:) adoptDefinitionOf: {
    :(Type)type :(Size)instanceSize :(Size)instanceAlignment :(Size)slotCount :(Size)variableSize :(Boolean)isBytes :(Boolean)isWeak :: Untyped |
    <primitive: #RawTuple::basicAllocateWithType:instanceSize:alignment:slotCount:variableSize:isBytes:isWeak:>
    let allocationAlignment := instanceAlignment max: ObjectModel::MinimalAlignment asSize.
    let variableDataSize := isBytes ifTrue: variableSize ifFalse: variableSize * ObjectModel::PointerSize.
    let contentSize := instanceSize + variableDataSize.
    let allocationSize := ObjectModel::TupleHeaderSize + contentSize.
    let allocationPointer := sysmel_pal_malloc(allocationSize).
    memset(allocationPointer, 0i8, allocationSize).

    let objectHeader := allocationPointer reinterpretCastTo: ObjectModel::TupleHeader pointer.
    objectHeader _
        typePointerAndFlags: ObjectModel::getTuplePointerUIntValue(type);
        isBytes: isBytes;
        isWeak: isWeak;
        objectSize: contentSize.

    allocationPointer reinterpretCastTo: Untyped.
} withEagerAnalysis.

RawTuple::new adoptDefinitionOf: {:(Size)slotCount :: Untyped |
    <primitive: #RawTuple::new>
    error("TODO: RawTuple::new")
} withEagerAnalysis.

RawTuple::byteNew adoptDefinitionOf: {:(Size)slotCount :: Untyped |
    <primitive: #RawTuple::new>
    error("TODO: RawTuple::new")
} withEagerAnalysis.

RawTuple::shallowCopy adoptDefinitionOf: {:(Size)slotCount :: Untyped |
    <primitive: #RawTuple::new>
    error("TODO: RawTuple::new")
} withEagerAnalysis.

RawTuple::firstInstanceWithType adoptDefinitionOf: {:(Type)type :: Untyped | nil}.
RawTuple::nextInstanceWithSameType adoptDefinitionOf: {:(Untyped)iterator :: Untyped | nil}.

(RawTuple::typeSlotAt:) adoptDefinitionOf: {:(Untyped)self :(TypeSlot)typeSlot :: Untyped |
    <primitive: #RawTuple::typeSlotAt:>
    error("TODO: RawTuple::typeSlotAt:")
} withEagerAnalysis.

(RawTuple::typeSlotAt:put:) adoptDefinitionOf: {:(Untyped)self :(TypeSlot)typeSlot :(Untyped)value :: Void |
    <primitive: #RawTuple::typeSlotAt:put:>
    error("TODO: RawTuple::typeSlotAt:put:")
} withEagerAnalysis.

(RawTuple::refTypeSlotAt:) adoptDefinitionOf: {:(Untyped)self :(TypeSlot)typeSlot :: Untyped |
    <primitive: #RawTuple::refTypeSlotAt:>
    error("TODO: RawTuple::refTypeSlotAt:")
} withEagerAnalysis.

(RawTuple::refTypeSlotAt:put:) adoptDefinitionOf: {:(Untyped)self :(TypeSlot)typeSlot :(Untyped)value :: Void |
    <primitive: #RawTuple::refTypeSlotAt:put:>
    error("TODO: RawTuple::refTypeSlotAt:put:")
} withEagerAnalysis.

let emptyArray := #().
public function ObjectModel::makeArrayWithSize(size: Size) => Array := {
    size = 0sz
        ifTrue: emptyArray
        ifFalse: (Array basicAllocate: size)
}.

public function ObjectModel::makeAssociation(key: Untyped, value: Untyped) => Association
    := Association basicAllocate
        __slotNamedAt__: #key put: key;
        __slotNamedAt__: #value put: value;
        yourself.

public function ObjectModel::makeClosure(functionDefinition: FunctionDefinition, captureVector: AnyValue) => Function
    := Function basicAllocate
        __slotNamedAt__: #definition put: functionDefinition;
        __slotNamedAt__: #captureVector put: captureVector;
        yourself.

let emptyByteArray := #[].
public function ObjectModel::makeByteArrayWithSize(size: Size) => ByteArray := {
    size = 0sz
        ifTrue: emptyByteArray
        ifFalse: (ByteArray basicAllocate: size)
}.

public function ObjectModel::makeDictionaryWithCapacity(initialCapacity: Size) => Dictionary
    := Dictionary new: initialCapacity.

public function ObjectModel::Dictionary::add(dictionary: Dictionary, association: Association) => Void
    := dictionary add: association.

public function ObjectModel::isFunction(value: Untyped) => Boolean := {
    let type := RawTuple::type(value).
    type isNotNil && type isFunction
}.

## Boxing methods.
public function ObjectModel::allocateBoxForValueOfTypeWithSize(type: Type, contentSize: Size) => ObjectModel::TupleHeader pointer := {
    let allocationSize := ObjectModel::TupleHeaderSize + contentSize.
    let allocationPointer := sysmel_pal_malloc(allocationSize).
    memset(allocationPointer, 0i8, allocationSize).

    let objectHeader := allocationPointer reinterpretCastTo: ObjectModel::TupleHeader pointer.
    objectHeader _
        typePointerAndFlags: ObjectModel::getTuplePointerUIntValue(type);
        isBytes: true;
        objectSize: contentSize.
    objectHeader
}.

public function ObjectModel::boxChar8(value: Char8) => AnyValue
    := (value asUIntPointer << ObjectModel::Tag::Bits asUIntPointer) | ObjectModel::Tag::Char8 asUIntPointer reinterpretCastTo: AnyValue.

public function ObjectModel::boxUInt8(value: UInt8) => AnyValue
    := (value asUIntPointer << ObjectModel::Tag::Bits asUIntPointer) | ObjectModel::Tag::UInt8 asUIntPointer reinterpretCastTo: AnyValue.

public function ObjectModel::boxInt8(value: Int8) => AnyValue
    := (value asIntPointer << ObjectModel::Tag::Bits asIntPointer) | ObjectModel::Tag::Int8 asIntPointer reinterpretCastTo: AnyValue.

public function ObjectModel::boxBoolean(value: Boolean) => AnyValue := {
    if: value
    then: (ObjectModel::ImmediateTrivialConstant::False asUIntPointer reinterpretCastTo: AnyValue)
    else: (ObjectModel::ImmediateTrivialConstant::True asUIntPointer reinterpretCastTo: AnyValue)
}.

public function ObjectModel::boxChar16(value: Char16) => AnyValue
    := (value asUIntPointer << ObjectModel::Tag::Bits asUIntPointer) | ObjectModel::Tag::Char16 asUIntPointer reinterpretCastTo: AnyValue.

public function ObjectModel::boxUInt16(value: UInt16) => AnyValue
    := (value asUIntPointer << ObjectModel::Tag::Bits asUIntPointer) | ObjectModel::Tag::UInt16 asUIntPointer reinterpretCastTo: AnyValue.

public function ObjectModel::boxInt16(value: Int16) => AnyValue
    := (value asIntPointer << ObjectModel::Tag::Bits asIntPointer) | ObjectModel::Tag::Int16 asIntPointer reinterpretCastTo: AnyValue.

if: ObjectModel::PointerSize = 4sz then: {
    public function ObjectModel::boxChar32(value: Char32) => AnyValue := {
        value <= ObjectModel::Immediate::UInt::Max asChar32 ifTrue: {
            (value asUIntPointer << ObjectModel::Tag::Bits asUIntPointer) | ObjectModel::Tag::Char32 asUIntPointer reinterpretCastTo: AnyValue.
        } ifFalse: {
            let box := ObjectModel::allocateBoxForValueOfTypeWithSize(Char32, 4sz).
            (box + 1iptr reinterpretCastTo: Char32 pointer) _ := value.
            box reinterpretCastTo: AnyValue
        }.
    }.

    public function ObjectModel::boxUInt32(value: UInt32) => AnyValue := {
        value <= ObjectModel::Immediate::UInt::Max asUInt32 ifTrue: {
            (value asUIntPointer << ObjectModel::Tag::Bits asUIntPointer) | ObjectModel::Tag::UInt32 asUIntPointer reinterpretCastTo: AnyValue.
        } ifFalse: {
            let box := ObjectModel::allocateBoxForValueOfTypeWithSize(UInt32, 4sz).
            (box + 1iptr reinterpretCastTo: UInt32 pointer) _ := value.
            box reinterpretCastTo: AnyValue
        }.
    }.

    public function ObjectModel::boxInt32(value: Int32) => AnyValue := {
        (ObjectModel::Immediate::Int::Min asInt32 <= value) && (value <= ObjectModel::Immediate::Int::Max asInt32) ifTrue: {
            (value asIntPointer << ObjectModel::Tag::Bits asIntPointer) | ObjectModel::Tag::Int32 asIntPointer reinterpretCastTo: AnyValue.
        } ifFalse: {
            let box := ObjectModel::allocateBoxForValueOfTypeWithSize(Int32, 4sz).
            (box + 1iptr reinterpretCastTo: Int32 pointer) _ := value.
            box reinterpretCastTo: AnyValue
        }.
    }.

    public function ObjectModel::boxFloat32(value: Float32) => AnyValue := {
        let box := ObjectModel::allocateBoxForValueOfTypeWithSize(Float32, 4sz).
        (box + 1iptr reinterpretCastTo: Float32 pointer) _ := value.
        box reinterpretCastTo: AnyValue
    }.
} else: {
    public function ObjectModel::boxChar32(value: Char32) => AnyValue
        := (value asUIntPointer << ObjectModel::Tag::Bits asUIntPointer) | ObjectModel::Tag::Char32 asUIntPointer reinterpretCastTo: AnyValue.

    public function ObjectModel::boxUInt32(value: UInt32) => AnyValue
        := (value asUIntPointer << ObjectModel::Tag::Bits asUIntPointer) | ObjectModel::Tag::UInt32 asUIntPointer reinterpretCastTo: AnyValue.

    public function ObjectModel::boxInt32(value: Int32) => AnyValue
        := (value asIntPointer << ObjectModel::Tag::Bits asIntPointer) | ObjectModel::Tag::Int32 asIntPointer reinterpretCastTo: AnyValue.

    public function ObjectModel::boxFloat32(value: Float32) => AnyValue := {
        let ieeeValue := value asIEEEFloat32Encoding.
        (ieeeValue asUIntPointer << ObjectModel::Tag::Bits asUIntPointer asUIntPointer) | ObjectModel::Tag::Float32 asUIntPointer reinterpretCastTo: AnyValue.        
    }.
}.

public function ObjectModel::boxUInt64(value: UInt64) => AnyValue := {
    value <= ObjectModel::Immediate::UInt::Max asUInt64 ifTrue: {
        (value asUIntPointer << ObjectModel::Tag::Bits asUIntPointer) | ObjectModel::Tag::UInt64 asUIntPointer reinterpretCastTo: AnyValue.
    } ifFalse: {
        let box := ObjectModel::allocateBoxForValueOfTypeWithSize(UInt64, 8sz).
        (box + 1iptr reinterpretCastTo: UInt64 pointer) _ := value.
        box reinterpretCastTo: AnyValue
    }.
}.

public function ObjectModel::boxInt64(value: Int64) => AnyValue := {
    (ObjectModel::Immediate::Int::Min asInt64 <= value) && (value <= ObjectModel::Immediate::Int::Max asInt64) ifTrue: {
        (value asIntPointer << ObjectModel::Tag::Bits asIntPointer) | ObjectModel::Tag::Int64 asIntPointer reinterpretCastTo: AnyValue.
    } ifFalse: {
        let box := ObjectModel::allocateBoxForValueOfTypeWithSize(Int64, 8sz).
        (box + 1iptr reinterpretCastTo: Int64 pointer) _ := value.
        box reinterpretCastTo: AnyValue
    }.
}.

public function ObjectModel::boxFloat64(value: Float64) => AnyValue := {
    let box := ObjectModel::allocateBoxForValueOfTypeWithSize(Float64, 8sz).
    (box + 1iptr reinterpretCastTo: Float64 pointer) _ := value.
    box reinterpretCastTo: AnyValue
}.

## Unboxing methods.
public function ObjectModel::checkAndUnboxChar8(value: Untyped) => Char8 := {
    let pointerValue := ObjectModel::getTuplePointerUIntValue(value).
    let tag := pointerValue & ObjectModel::Tag::Mask asUIntPointer.
    tag = ObjectModel::Tag::Char8 asUIntPointer ifFalse: {
        error("Expected a Char8 value.").
    }.

    (pointerValue >> ObjectModel::Tag::Bits asUIntPointer) asChar8
}.

public function ObjectModel::checkAndUnboxUInt8(value: Untyped) => UInt8 := {
    let pointerValue := ObjectModel::getTuplePointerUIntValue(value).
    let tag := pointerValue & ObjectModel::Tag::Mask asUIntPointer.
    tag = ObjectModel::Tag::UInt8 asUIntPointer ifFalse: {
        error("Expected an UInt8 value.").
    }.

    (pointerValue >> ObjectModel::Tag::Bits asUIntPointer) asUInt8
}.

public function ObjectModel::checkAndUnboxInt8(value: Untyped) => Int8 := {
    let pointerValue := ObjectModel::getTuplePointerIntValue(value).
    let tag := pointerValue & ObjectModel::Tag::Mask asIntPointer.
    tag = ObjectModel::Tag::Int8 asIntPointer ifFalse: {
        error("Expected an Int8 value.").
    }.

    (pointerValue >> ObjectModel::Tag::Bits asIntPointer) asInt8
}.

public function ObjectModel::checkAndUnboxBoolean(value: Untyped) => Boolean := {
    let pointerValue := ObjectModel::getTuplePointerUIntValue(value).
    pointerValue = ObjectModel::ImmediateTrivialConstant::False asUIntPointer ifTrue: {
        return: false
    }.
    pointerValue = ObjectModel::ImmediateTrivialConstant::True asUIntPointer ifTrue: {
        return: true
    }.

    error("Expected a Boolean value.")
}.

public function ObjectModel::checkAndUnboxChar16(value: Untyped) => Char16 := {
    let pointerValue := ObjectModel::getTuplePointerUIntValue(value).
    let tag := pointerValue & ObjectModel::Tag::Mask asUIntPointer.
    tag = ObjectModel::Tag::Char16 asUIntPointer ifFalse: {
        error("Expected a Char16 value.").
    }.

    (pointerValue >> ObjectModel::Tag::Bits asUIntPointer) asChar16
}.

public function ObjectModel::checkAndUnboxUInt16(value: Untyped) => UInt16 := {
    let pointerValue := ObjectModel::getTuplePointerUIntValue(value).
    let tag := pointerValue & ObjectModel::Tag::Mask asUIntPointer.
    tag = ObjectModel::Tag::UInt16 asUIntPointer ifFalse: {
        error("Expected an UInt16 value.").
    }.

    (pointerValue >> ObjectModel::Tag::Bits asUIntPointer) asUInt16
}.

public function ObjectModel::checkAndUnboxInt16(value: Untyped) => Int16 := {
    let pointerValue := ObjectModel::getTuplePointerIntValue(value).
    let tag := pointerValue & ObjectModel::Tag::Mask asIntPointer.
    tag = ObjectModel::Tag::Int16 asIntPointer ifFalse: {
        error("Expected an Int16 value.").
    }.

    (pointerValue >> ObjectModel::Tag::Bits asIntPointer) asInt16
}.

if: ObjectModel::PointerSize = 4sz then: {
    public function ObjectModel::checkAndUnboxChar32(value: Untyped) => Char32 := {
        let pointerValue := ObjectModel::getTuplePointerUIntValue(value).
        let tag := pointerValue & ObjectModel::Tag::Mask asUIntPointer.
        tag = ObjectModel::Tag::Char32 asUIntPointer ifTrue: {
            (pointerValue >> ObjectModel::Tag::Bits asUIntPointer) asChar32
        } ifFalse: {
            pointerValue = 0uptr ifTrue: {
                error("Expected an Char32 boxed value instead of nil.").
            }.

            let objectHeader := pointerValue reinterpretCastTo: ObjectModel::TupleHeader pointer.
            let objectType := objectHeader _ typePointer reinterpretCastTo: Type.
            objectType ~~ Char32 ifTrue: {
                error("Expected an Char32 boxed value.").
            }.

            (objectHeader + 1iptr reinterpretCastTo: Char32 pointer) _
        }.
    }.

    public function ObjectModel::checkAndUnboxUInt32(value: Untyped) => UInt32 := {
        let pointerValue := ObjectModel::getTuplePointerUIntValue(value).
        let tag := pointerValue & ObjectModel::Tag::Mask asUIntPointer.
        tag = ObjectModel::Tag::UInt32 asUIntPointer ifTrue: {
            (pointerValue >> ObjectModel::Tag::Bits asUIntPointer) asUInt32
        } ifFalse: {
            pointerValue = 0uptr ifTrue: {
                error("Expected an UInt32 boxed value instead of nil.").
            }.

            let objectHeader := pointerValue reinterpretCastTo: ObjectModel::TupleHeader pointer.
            let objectType := objectHeader _ typePointer reinterpretCastTo: Type.
            objectType ~~ UInt32 ifTrue: {
                error("Expected an UInt32 boxed value.").
            }.

            (objectHeader + 1iptr reinterpretCastTo: UInt32 pointer) _
        }.
    }.

    public function ObjectModel::checkAndUnboxInt64(value: Untyped) => Int32 := {
        let pointerValue := ObjectModel::getTuplePointerIntValue(value).
        let tag := pointerValue & ObjectModel::Tag::Mask asIntPointer.
        tag = ObjectModel::Tag::Int32 asIntPointer ifTrue: {
            (pointerValue >> ObjectModel::Tag::Bits asIntPointer) asUInt32
        } ifFalse: {
            pointerValue = 0iptr ifTrue: {
                error("Expected an UInt32 value instead of nil.").
            }.

            let objectHeader := pointerValue reinterpretCastTo: ObjectModel::TupleHeader pointer.
            let objectType := objectHeader _ typePointer reinterpretCastTo: Type.
            objectType ~~ Int32 ifTrue: {
                error("Expected an Int32 boxed value.").
            }.

            (objectHeader + 1iptr reinterpretCastTo: Int32 pointer) _
        }.
    }.

    public function ObjectModel::checkAndUnboxFloat64(value: Untyped) => Float64 := {
        let pointerValue := ObjectModel::getTuplePointerUIntValue(value).
        let tag := pointerValue & ObjectModel::Tag::Mask asUIntPointer.
        tag = ObjectModel::Tag::Float64 asUIntPointer ifTrue: {
            (pointerValue >> ObjectModel::Tag::Bits asUIntPointer) asUInt64 asIEEEFloat64Decoded
        } ifFalse: {
            pointerValue = 0uptr ifTrue: {
                error("Expected a Float64 boxed value instead of nil.").
            }.

            let objectHeader := pointerValue reinterpretCastTo: ObjectModel::TupleHeader pointer.
            let objectType := objectHeader _ typePointer reinterpretCastTo: Type.
            objectType ~~ Float64 ifTrue: {
                error("Expected a Float64 boxed value.").
            }.

            (objectHeader + 1iptr reinterpretCastTo: Float64 pointer) _
        }.
    }.
} else: {
    public function ObjectModel::checkAndUnboxChar32(value: Untyped) => Char32 := {
        let pointerValue := ObjectModel::getTuplePointerUIntValue(value).
        let tag := pointerValue & ObjectModel::Tag::Mask asUIntPointer.
        tag = ObjectModel::Tag::Char32 asUIntPointer ifFalse: {
            error("Expected a Char32 value.").
        }.

        (pointerValue >> ObjectModel::Tag::Bits asUIntPointer) asChar32
    }.

    public function ObjectModel::checkAndUnboxUInt32(value: Untyped) => UInt32 := {
        let pointerValue := ObjectModel::getTuplePointerUIntValue(value).
        let tag := pointerValue & ObjectModel::Tag::Mask asUIntPointer.
        tag = ObjectModel::Tag::UInt32 asUIntPointer ifFalse: {
            error("Expected an UInt32 value.").
        }.

        (pointerValue >> ObjectModel::Tag::Bits asUIntPointer) asUInt32
    }.

    public function ObjectModel::checkAndUnboxInt32(value: Untyped) => Int32 := {
        let pointerValue := ObjectModel::getTuplePointerIntValue(value).
        let tag := pointerValue & ObjectModel::Tag::Mask asIntPointer.
        tag = ObjectModel::Tag::Int32 asIntPointer ifFalse: {
            error("Expected an Int32 boxed value.").
        }.

        (pointerValue >> ObjectModel::Tag::Bits asIntPointer) asInt32
    }.

    public function ObjectModel::checkAndUnboxFloat32(value: Untyped) => Float32 := {
        let pointerValue := ObjectModel::getTuplePointerUIntValue(value).
        let tag := pointerValue & ObjectModel::Tag::Mask asUIntPointer.
        tag = ObjectModel::Tag::Float32 asUIntPointer ifFalse: {
            error("Expected a Float32 value.").
        }.

        (pointerValue >> ObjectModel::Tag::Bits asUIntPointer) asUInt32 asIEEEFloat32Decoded
    }.
}.

public function ObjectModel::checkAndUnboxUInt64(value: Untyped) => UInt64 := {
    let pointerValue := ObjectModel::getTuplePointerUIntValue(value).
    let tag := pointerValue & ObjectModel::Tag::Mask asUIntPointer.
    tag = ObjectModel::Tag::UInt64 asUIntPointer ifTrue: {
        (pointerValue >> ObjectModel::Tag::Bits asUIntPointer) asUInt64
    } ifFalse: {
        pointerValue = 0uptr ifTrue: {
            error("Expected an UInt32 boxed value instead of nil.").
        }.

        let objectHeader := pointerValue reinterpretCastTo: ObjectModel::TupleHeader pointer.
        let objectType := objectHeader _ typePointer reinterpretCastTo: Type.
        objectType ~~ UInt64 ifTrue: {
            error("Expected an UInt32 boxed value.").
        }.

        (objectHeader + 1iptr reinterpretCastTo: UInt64 pointer) _
    }.
}.

public function ObjectModel::checkAndUnboxInt64(value: Untyped) => Int64 := {
    let pointerValue := ObjectModel::getTuplePointerIntValue(value).
    let tag := pointerValue & ObjectModel::Tag::Mask asIntPointer.
    tag = ObjectModel::Tag::Int64 asIntPointer ifTrue: {
        (pointerValue >> ObjectModel::Tag::Bits asIntPointer) asInt64
    } ifFalse: {
        pointerValue = 0iptr ifTrue: {
            error("Expected an UInt32 value instead of nil.").
        }.

        let objectHeader := pointerValue reinterpretCastTo: ObjectModel::TupleHeader pointer.
        let objectType := objectHeader _ typePointer reinterpretCastTo: Type.
        objectType ~~ Int64 ifTrue: {
            error("Expected an UInt32 boxed value.").
        }.

        (objectHeader + 1iptr reinterpretCastTo: Int64 pointer) _
    }.
}.

public function ObjectModel::checkAndUnboxFloat64(value: Untyped) => Float64 := {
    let pointerValue := ObjectModel::getTuplePointerUIntValue(value).
    let tag := pointerValue & ObjectModel::Tag::Mask asUIntPointer.
    tag = ObjectModel::Tag::Float64 asUIntPointer ifTrue: {
        (pointerValue >> ObjectModel::Tag::Bits asUIntPointer) asUInt64
    } ifFalse: {
        pointerValue = 0uptr ifTrue: {
            error("Expected a Float64 boxed value instead of nil.").
        }.

        let objectHeader := pointerValue reinterpretCastTo: ObjectModel::TupleHeader pointer.
        let objectType := objectHeader _ typePointer reinterpretCastTo: Type.
        objectType ~~ Float64 ifTrue: {
            error("Expected a Float64 boxed value.").
        }.

        (objectHeader + 1iptr reinterpretCastTo: Float64 pointer) _
    }.
}.

public function ObjectModel::coerceValue(expectedType: Type, value: Untyped) => Untyped := {
    let valueType := RawTuple::type(value).
    (valueType isDirectSubtypeOf: expectedType) ifTrue: (return: value).
    
    error("TODO: ObjectModel::coerceValue").
}.

public function ObjectModel::coerceNullableValue(expectedType: Type, value: Untyped) => Untyped := {
    Untyped::==(value, nil) ifTrue: (return: nil).

    ObjectModel::coerceValue(expectedType, value)
}.

public function ObjectModel::typecheckValue(expectedType: Type, value: Untyped) => Void := {
    let valueType := RawTuple::type(value).
    (valueType isDirectSubtypeOf: expectedType) ifTrue: (return: value).

    error("Value with unexpected type.").
}.

public function ObjectModel::typecheckNullableValue(expectedType: Type, value: Untyped) => Void := {
    Untyped::==(value, nil) ifTrue: (return: void).

    ObjectModel::typecheckValue(expectedType, value)
}.

## Generate the trampolines via macro metaprogramming.
public global ObjectModel::CheckedFunctionApplicationTrampolines := Array new: 16.
public global ObjectModel::SendWithReceiverTypeTrampolines := Array new: 16.
public global ObjectModel::SendTrampolines := Array new: 16.

(0sz until: 16sz) macroDo: {:ArgumentCount |
    let argumentNames := (0sz until: ArgumentCount) collect: {:(Size)each | ("arg" -- each asString) asSymbol}.
    let argumentNodes := argumentNames collect: {:(Symbol)eachName | eachName asMacroArgumentWithType: Untyped asMacroLiteral}.
    let argumentIdentifiers := argumentNames collect: {:(Symbol)eachName | eachName asMacroIdentifier}.
    let applyName := ("ObjectModel::apply" -- ArgumentCount asString) asSymbol.
    let sendWithReceiverTypeName := ("ObjectModel::sendWithReceiverType" -- ArgumentCount asString) asSymbol.
    let sendName := ("ObjectModel::send" -- ArgumentCount asString) asSymbol.

    ``{
        public function `,(applyName asMacroLiteral)(functional: Untyped, `@argumentNodes) => Untyped := {
            ObjectModel::isFunction(functional) ifTrue: {
                let function := ObjectModel::tupleAsFunction(functional).
                let definition := function definition.
                definition ifNotNil: {
                    let checkedEntryPoint := definition checkedEntryPoint asUIntPointer.
                    checkedEntryPoint ~= 0uptr ifTrue: {
                        error("TODO: Checked function application trampoline.")
                    } ifFalse: {
                        let bytecode := definition bytecode.
                        bytecode ifNotNil: {
                            error("TODO: Attempt to interpret bytecoded function.")
                        } ifNil: {
                            error("Cannot evaluate function without native compiled definition or bytecode.")
                        }
                    }
                }.
            }.

            functional applyWithArguments: (`@argumentIdentifiers,)
        }.
        ObjectModel::CheckedFunctionApplicationTrampolines at: `,(ArgumentCount asMacroLiteral) put: `,(applyName asMacroIdentifier).

        public function `,(sendWithReceiverTypeName asMacroLiteral)(receiver: Untyped, receiverType: Type, selector: Symbol, `@argumentNodes) => Untyped := {
            let foundMethod := (receiverType ifNil: Untyped) lookupSelector: selector.
            foundMethod ifNotNil: {
                foundMethod(receiver, `@argumentIdentifiers)
            } ifNil: {
                if: (1sz = `,(ArgumentCount asMacroLiteral)) && (selector == #doesNotUnderstand:) then: {
                    error("Message not understood")
                }.

                ObjectModel::sendWithReceiverType1(receiver, receiverType, #doesNotUnderstand:, Message basicAllocate
                    selector: selector;
                    arguments: (`@argumentIdentifiers,);
                    yourself)
            }.
        }.
        ObjectModel::SendWithReceiverTypeTrampolines at: `,(ArgumentCount asMacroLiteral) put: `,(sendWithReceiverTypeName asMacroIdentifier).

        public function `,(sendName asMacroLiteral)(receiver: Untyped, selector: Symbol, `@argumentNodes) => Untyped
            := `,(sendWithReceiverTypeName asMacroIdentifier)(receiver, RawTuple::type(receiver), selector, `@argumentIdentifiers).

        ObjectModel::SendTrampolines at: `,(ArgumentCount asMacroLiteral) put: `,(sendName asMacroIdentifier).
    } macroEvalHere
}.
