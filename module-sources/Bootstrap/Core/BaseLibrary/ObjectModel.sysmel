public global ObjectModel::Tag::Bits := 4u8.
public global ObjectModel::Tag::Mask := 15u8.
public global ObjectModel::MinimalAlignment := 16u32.

public global ObjectModel::Tag::Pointer := 0u8.
public global ObjectModel::Tag::Nil := 0u8.

public global ObjectModel::Tag::Integer := 1u8.
public global ObjectModel::Tag::Int8 := 2u8.
public global ObjectModel::Tag::Int16 := 3u8.
public global ObjectModel::Tag::Int32 := 4u8.
public global ObjectModel::Tag::Int64 := 5u8.

public global ObjectModel::Tag::SignedIntegerFirst := ObjectModel::Tag::Integer.
public global ObjectModel::Tag::SignedIntegerLast := ObjectModel::Tag::Int64.

public global ObjectModel::Tag::Char8 := 6u8.
public global ObjectModel::Tag::UInt8 := 7u8.

public global ObjectModel::Tag::Char16 := 8u8.
public global ObjectModel::Tag::UInt16 := 9u8.

public global ObjectModel::Tag::Char32 := 10u8.
public global ObjectModel::Tag::UInt32 := 11u8.

public global ObjectModel::Tag::UInt64 := 12u8.

public global ObjectModel::Tag::Float32 := 13u8.
public global ObjectModel::Tag::Float64 := 14u8.

public global ObjectModel::Tag::Trivial := 15u8.

public global ObjectModel::ImmediateTagTypeTable := (
    UndefinedObject,
    SmallInteger, Int8, Int16, Int32, Int64,
    Char8, UInt8,
    Char16, UInt16,
    Char32, UInt32,
    UInt64, Float32, Float64,
    nil
).

public global ObjectModel32::Immediate::Bits := 32u32 - ObjectModel::Tag::Bits asUInt32.
public global ObjectModel32::Immediate::UInt::Min := 0u32.
public global ObjectModel32::Immediate::UInt::Max := (1u32 << ObjectModel32::Immediate::Bits) - 1u32.
public global ObjectModel32::Immediate::Int::Min := (1i32 << (ObjectModel32::Immediate::Bits - 1u32) asInt32) negated.
public global ObjectModel32::Immediate::Int::Max := (1i32 << (ObjectModel32::Immediate::Bits - 1u32) asInt32) - 1i32.

public global ObjectModel64::Immediate::Bits := 64u64 - ObjectModel::Tag::Bits asUInt64.
public global ObjectModel64::Immediate::UInt::Min := 0u64.
public global ObjectModel64::Immediate::UInt::Max := (1u64 << ObjectModel64::Immediate::Bits) - 1u64.
public global ObjectModel64::Immediate::Int::Min := (1i64 << (ObjectModel64::Immediate::Bits - 1u64) asInt64) negated.
public global ObjectModel64::Immediate::Int::Max := (1i64 << (ObjectModel64::Immediate::Bits - 1u64) asInt64) - 1i64.

public global ObjectModel::ImmediateTrivialIndex::False := 0u32.
public global ObjectModel::ImmediateTrivialIndex::True := 1u32.
public global ObjectModel::ImmediateTrivialIndex::Void := 2u32.
public global ObjectModel::ImmediateTrivialIndex::HashtableEmptyElement := 3u32.
public global ObjectModel::ImmediateTrivialIndex::Tombstone := 4u32.
public global ObjectModel::ImmediateTrivialIndex::PendingMemoizationValue := 5u32.

public global ObjectModel::ImmediateTrivialConstant::False := (ObjectModel::ImmediateTrivialIndex::False << ObjectModel::Tag::Bits asUInt32) | ObjectModel::Tag::Trivial asUInt32.
public global ObjectModel::ImmediateTrivialConstant::True := (ObjectModel::ImmediateTrivialIndex::True << ObjectModel::Tag::Bits asUInt32) | ObjectModel::Tag::Trivial asUInt32.
public global ObjectModel::ImmediateTrivialConstant::Void := (ObjectModel::ImmediateTrivialIndex::Void << ObjectModel::Tag::Bits asUInt32) | ObjectModel::Tag::Trivial asUInt32.
public global ObjectModel::ImmediateTrivialConstant::HashtableEmptyElement := (ObjectModel::ImmediateTrivialIndex::HashtableEmptyElement << ObjectModel::Tag::Bits asUInt32) | ObjectModel::Tag::Trivial asUInt32.
public global ObjectModel::ImmediateTrivialConstant::Tombstone := (ObjectModel::ImmediateTrivialIndex::Tombstone << ObjectModel::Tag::Bits asUInt32) | ObjectModel::Tag::Trivial asUInt32.
public global ObjectModel::ImmediateTrivialConstant::PendingMemoizationValue := (ObjectModel::ImmediateTrivialIndex::PendingMemoizationValue << ObjectModel::Tag::Bits asUInt32) | ObjectModel::Tag::Trivial asUInt32.

public global ObjectModel::ImmediateTrivialTypeTable := (
    False, True, Void, HashtableEmpty, ObjectTombstone, PendingMemoizationValue
).

public global ObjectModel::IdentityHash::Bits := 22u32.
public global ObjectModel::IdentityHash::Mask := (1u32 << ObjectModel::IdentityHash::Bits) - 1u32.

public global ObjectModel::ObjectType::Shift := ObjectModel::IdentityHash::Bits.
public global ObjectModel::ObjectType::Bits := 2u32.
public global ObjectModel::ObjectType::Mask := ((1u32 << ObjectModel::ObjectType::Bits) - 1u32) << ObjectModel::ObjectType::Shift.
public global ObjectModel::ObjectType::Pointers := 0u32.
public global ObjectModel::ObjectType::WeakPointers := 1u32.
public global ObjectModel::ObjectType::Bytes := 2u32.
public global ObjectModel::ObjectType::Complex := 3u32.

public global ObjectModel::GCColor::Shift := ObjectModel::ObjectType::Shift + ObjectModel::ObjectType::Bits.
public global ObjectModel::GCColor::Bits := 2u32.
public global ObjectModel::GCColor::Mask := ((1u32 << ObjectModel::GCColor::Bits) - 1u32) << ObjectModel::GCColor::Shift.

public global ObjectModel::Flags::Shift := ObjectModel::GCColor::Shift + ObjectModel::GCColor::Bits.
public global ObjectModel::Flags::Immutable := 1u32 << ObjectModel::Flags::Shift.
public global ObjectModel::Flags::NeedsFinalization := 1u32 << (ObjectModel::Flags::Shift + 1u32).
public global ObjectModel::Flags::DummyValue := 1u32 << (ObjectModel::Flags::Shift + 2u32).

public global ObjectModel::PointerSize := UIntPointer valueSize.

if: ObjectModel::PointerSize = 4sz then: {
    public global ObjectModel::Immediate::Bits      := ObjectModel32::Immediate::Bits.
    public global ObjectModel::Immediate::UInt::Min := ObjectModel32::Immediate::UInt::Min.
    public global ObjectModel::Immediate::UInt::Max := ObjectModel32::Immediate::UInt::Max.
    public global ObjectModel::Immediate::Int::Min  := ObjectModel32::Immediate::Int::Min.
    public global ObjectModel::Immediate::Int::Max  := ObjectModel32::Immediate::Int::Max.
} else: {
    public global ObjectModel::Immediate::Bits      := ObjectModel64::Immediate::Bits.
    public global ObjectModel::Immediate::UInt::Min := ObjectModel64::Immediate::UInt::Min.
    public global ObjectModel::Immediate::UInt::Max := ObjectModel64::Immediate::UInt::Max.
    public global ObjectModel::Immediate::Int::Min  := ObjectModel64::Immediate::Int::Min.
    public global ObjectModel::Immediate::Int::Max  := ObjectModel64::Immediate::Int::Max.
}.

public class ObjectModelState definition: {
    public field identityHashSeed => UInt32.

    public override method initialize => Void := {
        self reset
    }.

    public final inline method reset => Void := {
        identityHashSeed := 1u32.
    }.

    public final inline method newIdentityHash => UInt32
        := identityHashSeed := identityHashSeed identityHashMultiply.

    let uniqueInstance := SelfType new.
    __Meta__ definition: {
        public final inline method current => ObjectModelState
            := uniqueInstance.
    }.
}.

public final struct ObjectModel::TupleHeader32 definition: {
    public field typePointer => UInt32.
    public field padding => UInt32.
    public field identityHashAndFlags => UInt32.
    public field objectSize => UInt32.

    public inline method type => Type
        := typePointer asUIntPointer reinterpretCastTo: Type.

    public inline method type: (newType: Type) ::=> Void := {
        typePointer := ObjectModel::getTuplePointerUIntValue(newType) asUInt32
    }.

    public inline method objectType => UInt32
        := (identityHashAndFlags & ObjectModel::ObjectType::Mask) >> ObjectModel::ObjectType::Shift.

    public inline method objectType: (objectType: UInt32) ::=> Void := {
        identityHashAndFlags := (identityHashAndFlags & ObjectModel::ObjectType::Mask bitInvert) | (objectType << ObjectModel::ObjectType::Shift)
    }.

    public inline method gcColor => UInt32
        := (identityHashAndFlags & ObjectModel::GCColor::Mask) >> ObjectModel::GCColor::Shift.

    public inline method gcColor: (gcColor: UInt32) ::=> Void := {
        identityHashAndFlags := (identityHashAndFlags & ObjectModel::GCColor::Mask bitInvert) | (gcColor << ObjectModel::GCColor::Shift)
    }.

    public inline method isBytes => Boolean
        := self objectType = ObjectModel::ObjectType::Bytes.

    public inline method isWeak => Boolean
        := self objectType = ObjectModel::ObjectType::WeakPointers.

    public inline method isDummyValue => Boolean
        := (identityHashAndFlags & ObjectModel::Flags::DummyValue) ~= 0u32.

    public inline method isDummyValue: (flag: Boolean) ::=> Void := {
        flag
            ifTrue: (identityHashAndFlags := identityHashAndFlags | ObjectModel::Flags::DummyValue)
            ifFalse: (identityHashAndFlags := identityHashAndFlags & ObjectModel::Flags::DummyValue bitInvert).
    }.

    public inline method identityHashValue ::=> UInt32
        := identityHashAndFlags & ObjectModel::IdentityHash::Mask.

    public inline method identityHashValue: (identityHash: UInt32) ::=> Void := {
        identityHashAndFlags := (identityHash & ObjectModel::IdentityHash::Mask) | (identityHashAndFlags & ObjectModel::IdentityHash::Mask bitInvert)
    }.

    public method slotCount => UInt32
        := objectSize >> 2u32.
}.

public final struct ObjectModel::TupleHeader64 definition: {
    public field typePointer => UInt64.
    public field identityHashAndFlags => UInt32.
    public field objectSize => UInt32.

    public inline method type => Type
        := typePointer asUIntPointer reinterpretCastTo: Type.

    public inline method type: (newType: Type) ::=> Void := {
        typePointer := ObjectModel::getTuplePointerUIntValue(newType) asUInt64
    }.

    public inline method objectType => UInt32
        := (identityHashAndFlags & ObjectModel::ObjectType::Mask) >> ObjectModel::ObjectType::Shift.

    public inline method objectType: (objectType: UInt32) ::=> Void := {
        identityHashAndFlags := (identityHashAndFlags & ObjectModel::ObjectType::Mask bitInvert) | (objectType << ObjectModel::ObjectType::Shift)
    }.

    public inline method gcColor => UInt32
        := (identityHashAndFlags & ObjectModel::GCColor::Mask) >> ObjectModel::GCColor::Shift.

    public inline method gcColor: (gcColor: UInt32) ::=> Void := {
        identityHashAndFlags := (identityHashAndFlags & ObjectModel::GCColor::Mask bitInvert) | (gcColor << ObjectModel::GCColor::Shift)
    }.

    public inline method isBytes => Boolean
        := self objectType = ObjectModel::ObjectType::Bytes.

    public inline method isWeak => Boolean
        := self objectType = ObjectModel::ObjectType::WeakPointers.

    public inline method isDummyValue => Boolean
        := (identityHashAndFlags & ObjectModel::Flags::DummyValue) ~= 0u32.

    public inline method isDummyValue: (flag: Boolean) ::=> Void := {
        flag
            ifTrue: (identityHashAndFlags := identityHashAndFlags | ObjectModel::Flags::DummyValue)
            ifFalse: (identityHashAndFlags := identityHashAndFlags & ObjectModel::Flags::DummyValue bitInvert).
    }.

    public inline method identityHashValue ::=> UInt32
        := identityHashAndFlags & ObjectModel::IdentityHash::Mask.

    public inline method identityHashValue: (identityHash: UInt32) ::=> Void := {
        identityHashAndFlags := (identityHash & ObjectModel::IdentityHash::Mask) | (identityHashAndFlags & ObjectModel::IdentityHash::Mask bitInvert)
    }.

    public inline method slotCount => UInt32
        := objectSize >> 3u32.
}.

public abstract class ObjectModelVariant superclass: Object; definition: {
    __Meta__ definition: {
        public method current => ObjectModelVariant
            := UIntPointer valueSize = 4sz
                ifTrue: ObjectModelVariant32 uniqueInstance
                ifFalse: ObjectModelVariant64 uniqueInstance.
    }.

    public abstract method pointerSize => UInt64 := self subclassResponsibility.

    public virtual method minimalObjectAlignment => UInt64 := ObjectModel::MinimalAlignment asUInt64.

    public abstract method objectHeaderSize => UInt64
        := self subclassResponsibility.

    public abstract method objectHeaderType => Type
        := self subclassResponsibility.

    public virtual method isImmediateReference: (reference: Untyped) ::=> Boolean
        := self subclassResponsibility.

    public virtual method encodeImmediateReference32: (reference: Untyped) ::=> UInt32 := {
        let type => Type := RawTuple::type(reference).
        type encodeImmediateReference32: reference
    }.

    public virtual method encodeImmediateReference64: (reference: Untyped) ::=> UInt64 := {
        let type => Type := RawTuple::type(reference).
        type encodeImmediateReference64: reference
    }.

    public virtual method computeSizeOfObjectInstanceContent: (object: Untyped) ::=> UInt64 := {
        let isBytes := RawTuple::isBytes(object).
        isBytes ifTrue: {
            let byteSize := RawTuple::byteSize(object).
            byteSize asUInt64
        } ifFalse: {
            let totalSlotCount := RawTuple::size(object).
            let type := RawTuple::type(object).
            let typeSlotCount := type ifNil: (0sz) ifNotNil: (type totalSlotCount).
            let variantSlotCount := totalSlotCount - typeSlotCount.
            let fixedInstanceSize := type ifNil: (0sz) ifNotNil: (type validInstanceSize).
            fixedInstanceSize asUInt64 + (variantSlotCount asUInt64 * self pointerSize)
        }
    }.

    public virtual method computeSizeOfObjectInstance: (object: Untyped) ::=> UInt64
        := self objectHeaderSize + (self computeSizeOfObjectInstanceContent: object).

    public virtual method computeAlignmentOfObjectInstance: (object: Untyped) ::=> UInt64
        := RawTuple::type(object)
            ifNil: {self minimalObjectAlignment}
            ifNotNil: {:(Type)type :: UInt64 | type validInstanceAlignment asUInt64 max: self minimalObjectAlignment}.
}.

public final class ObjectModelVariant32 superclass: ObjectModelVariant; definition: {
    public override method pointerSize => UInt64 := 4u64.

    public override method objectHeaderSize => UInt64 := ObjectModel::TupleHeader32 valueSize asUInt64.
    public override method objectHeaderType => Type := ObjectModel::TupleHeader32.

    let singleton := SelfType new.

    public override method isImmediateReference: (reference: Untyped) ::=> Boolean := {
        let type => Type := RawTuple::type(reference).
        type isNotNil && (type isImmediateReference32: reference)
    }.

    __Meta__ definition: {
        public method uniqueInstance => ObjectModelVariant32
            := singleton.
    }.
}.

public final class ObjectModelVariant64 superclass: ObjectModelVariant; definition: {
    public override method pointerSize => UInt64 := 8u64.

    public override method objectHeaderSize => UInt64 := ObjectModel::TupleHeader64 valueSize asUInt64.
    public override method objectHeaderType => Type := ObjectModel::TupleHeader64.

    public override method isImmediateReference: (reference: Untyped) ::=> Boolean := {
        let type => Type := RawTuple::type(reference).
        type isNotNil && (type isImmediateReference64: reference)
    }.

    let singleton := SelfType new.
    __Meta__ definition: {
        public method uniqueInstance => ObjectModelVariant64
            := singleton.
    }.
}.

Type extend: {
    public virtual method isImmediateReference32: (reference: Untyped) ::=> Boolean := false.
    public virtual method isImmediateReference64: (reference: Untyped) ::=> Boolean := false.

    public virtual method encodeImmediateReference32: (reference: Untyped) ::=> UInt32
        := self error: "Cannot encode 32 bits immediate reference.".

    public virtual method encodeImmediateReference64: (reference: Untyped) ::=> UInt64
        := self error: "Cannot encode 64 bits immediate reference.".

    public virtual method objectHeaderSizeForObjectModel: (objectModel: ObjectModelVariant) ::=> UInt64
        := objectModel objectHeaderSize.
}.

ValueType extend: {
    public override method objectHeaderSizeForObjectModel: (objectModel: ObjectModelVariant) ::=> Size
        := 0sz.
}.

Char8 __type__ extend: {
    public override method isImmediateReference32: (reference: Untyped) ::=> Boolean := true.
    public override method isImmediateReference64: (reference: Untyped) ::=> Boolean := true.

    public override method encodeImmediateReference32: (reference: Untyped) ::=> UInt32 := (reference asUInt32 << ObjectModel::Tag::Bits asUInt32) | ObjectModel::Tag::Char8 asUInt32.
    public override method encodeImmediateReference64: (reference: Untyped) ::=> UInt64 := (reference asUInt64 << ObjectModel::Tag::Bits asUInt64) | ObjectModel::Tag::Char8 asUInt64.
}.

UInt8 __type__ extend: {
    public override method isImmediateReference32: (reference: Untyped) ::=> Boolean := true.
    public override method isImmediateReference64: (reference: Untyped) ::=> Boolean := true.

    public override method encodeImmediateReference32: (reference: Untyped) ::=> UInt32 := (reference asUInt32 << ObjectModel::Tag::Bits asUInt32) | ObjectModel::Tag::UInt8 asUInt32.
    public override method encodeImmediateReference64: (reference: Untyped) ::=> UInt64 := (reference asUInt64 << ObjectModel::Tag::Bits asUInt64) | ObjectModel::Tag::UInt8 asUInt64.
}.

Int8 __type__ extend: {
    public override method isImmediateReference32: (reference: Untyped) ::=> Boolean := true.
    public override method isImmediateReference64: (reference: Untyped) ::=> Boolean := true.

    public override method encodeImmediateReference32: (reference: Untyped) ::=> UInt32 := (reference asUInt32 << ObjectModel::Tag::Bits asUInt32) | ObjectModel::Tag::Int8 asUInt32.
    public override method encodeImmediateReference64: (reference: Untyped) ::=> UInt64 := (reference asUInt64 << ObjectModel::Tag::Bits asUInt64) | ObjectModel::Tag::Int8 asUInt64.
}.

Char16 __type__ extend: {
    public override method isImmediateReference32: (reference: Untyped) ::=> Boolean := true.
    public override method isImmediateReference64: (reference: Untyped) ::=> Boolean := true.

    public override method encodeImmediateReference32: (reference: Untyped) ::=> UInt32 := (reference asUInt32 << ObjectModel::Tag::Bits asUInt32) | ObjectModel::Tag::Char16 asUInt32.
    public override method encodeImmediateReference64: (reference: Untyped) ::=> UInt64 := (reference asUInt64 << ObjectModel::Tag::Bits asUInt64) | ObjectModel::Tag::Char16 asUInt64.
}.

UInt16 __type__ extend: {
    public override method isImmediateReference32: (reference: Untyped) ::=> Boolean := true.
    public override method isImmediateReference64: (reference: Untyped) ::=> Boolean := true.

    public override method encodeImmediateReference32: (reference: Untyped) ::=> UInt32 := (reference asUInt32 << ObjectModel::Tag::Bits asUInt32) | ObjectModel::Tag::UInt16 asUInt32.
    public override method encodeImmediateReference64: (reference: Untyped) ::=> UInt64 := (reference asUInt64 << ObjectModel::Tag::Bits asUInt64) | ObjectModel::Tag::UInt16 asUInt64.
}.

Int16 __type__ extend: {
    public override method isImmediateReference32: (reference: Untyped) ::=> Boolean := true.
    public override method isImmediateReference64: (reference: Untyped) ::=> Boolean := true.

    public override method encodeImmediateReference32: (reference: Untyped) ::=> UInt32 := (reference asUInt32 << ObjectModel::Tag::Bits asUInt32) | ObjectModel::Tag::Int16 asUInt32.
    public override method encodeImmediateReference64: (reference: Untyped) ::=> UInt64 := (reference asUInt64 << ObjectModel::Tag::Bits asUInt64) | ObjectModel::Tag::Int16 asUInt64.
}.

Char32 __type__ extend: {
    public override method isImmediateReference32: (reference: Untyped) ::=> Boolean := {
        let value => Char32 := reference.
        (ObjectModel32::Immediate::UInt::Min asChar32 <= value) && (value <= ObjectModel32::Immediate::UInt::Max asChar32)
    }.

    public override method isImmediateReference64: (reference: Untyped) ::=> Boolean := true.

    public override method encodeImmediateReference32: (reference: Untyped) ::=> UInt32 := (reference asUInt32 << ObjectModel::Tag::Bits asUInt32) | ObjectModel::Tag::Char32 asUInt32.
    public override method encodeImmediateReference64: (reference: Untyped) ::=> UInt64 := (reference asUInt64 << ObjectModel::Tag::Bits asUInt64) | ObjectModel::Tag::Char32 asUInt64.
}.

UInt32 __type__ extend: {
    public override method isImmediateReference32: (reference: Untyped) ::=> Boolean := {
        let value => UInt32 := reference.
        (ObjectModel32::Immediate::UInt::Min <= value) && (value <= ObjectModel32::Immediate::UInt::Max)
    }.

    public override method isImmediateReference64: (reference: Untyped) ::=> Boolean := true.

    public override method encodeImmediateReference32: (reference: Untyped) ::=> UInt32 := (reference asUInt32 << ObjectModel::Tag::Bits asUInt32) | ObjectModel::Tag::UInt32 asUInt32.
    public override method encodeImmediateReference64: (reference: Untyped) ::=> UInt64 := (reference asUInt64 << ObjectModel::Tag::Bits asUInt64) | ObjectModel::Tag::UInt32 asUInt64.
}.

Int32 __type__ extend: {
    public override method isImmediateReference32: (reference: Untyped) ::=> Boolean := {
        let value => Int32 := reference.
        (ObjectModel32::Immediate::Int::Min <= value) && (value <= ObjectModel32::Immediate::Int::Max)
    }.

    public override method isImmediateReference64: (reference: Untyped) ::=> Boolean := true.

    public override method encodeImmediateReference32: (reference: Untyped) ::=> UInt32 := (reference asUInt32 << ObjectModel::Tag::Bits asUInt32) | ObjectModel::Tag::Int32 asUInt32.
    public override method encodeImmediateReference64: (reference: Untyped) ::=> UInt64 := (reference asUInt64 << ObjectModel::Tag::Bits asUInt64) | ObjectModel::Tag::Int32 asUInt64.
}.

UInt64 __type__ extend: {
    public override method isImmediateReference32: (reference: Untyped) ::=> Boolean := {
        let value => UInt64 := reference.
        (ObjectModel32::Immediate::UInt::Min asUInt64 <= value) && (value <= ObjectModel32::Immediate::UInt::Max asUInt64)
    }.

    public override method isImmediateReference64: (reference: Untyped) ::=> Boolean := {
        let value => UInt64 := reference.
        (ObjectModel64::Immediate::UInt::Min <= value) && (value <= ObjectModel64::Immediate::UInt::Max)
    }.

    public override method encodeImmediateReference32: (reference: Untyped) ::=> UInt32 := (reference asUInt32 << ObjectModel::Tag::Bits asUInt32) | ObjectModel::Tag::UInt64 asUInt32.
    public override method encodeImmediateReference64: (reference: Untyped) ::=> UInt64 := (reference asUInt64 << ObjectModel::Tag::Bits asUInt64) | ObjectModel::Tag::UInt64 asUInt64.
}.

Int64 __type__ extend: {
    public override method isImmediateReference32: (reference: Untyped) ::=> Boolean := {
        let value => Int64 := reference.
        (ObjectModel32::Immediate::Int::Min asInt64 <= value) && (value <= ObjectModel32::Immediate::Int::Max asInt64)
    }.

    public override method isImmediateReference64: (reference: Untyped) ::=> Boolean := {
        let value => Int64  := reference.
        (ObjectModel64::Immediate::Int::Min <= value) && (value <= ObjectModel64::Immediate::Int::Max)
    }.

    public override method encodeImmediateReference32: (reference: Untyped) ::=> UInt32 := (reference asUInt32 << ObjectModel::Tag::Bits asUInt32) | ObjectModel::Tag::Int64 asUInt32.
    public override method encodeImmediateReference64: (reference: Untyped) ::=> UInt64 := (reference asUInt64 << ObjectModel::Tag::Bits asUInt64) | ObjectModel::Tag::Int64 asUInt64.
}.

Integer __type__ extend: {
    public override method isImmediateReference32: (reference: Untyped) ::=> Boolean := {
        let value => Integer := reference.
        (ObjectModel32::Immediate::Int::Min asInteger <= value) && (value <= ObjectModel32::Immediate::Int::Max asInteger)
    }.

    public override method isImmediateReference64: (reference: Untyped) ::=> Boolean := {
        let value => Integer := reference.
        (ObjectModel64::Immediate::Int::Min asInteger <= value) && (value <= ObjectModel64::Immediate::Int::Max asInteger)
    }.

    public override method encodeImmediateReference32: (reference: Untyped) ::=> UInt32 := {
        let value => Integer := reference.
        (value asUInt32 << ObjectModel::Tag::Bits asUInt32) | ObjectModel::Tag::Integer asUInt32.
    }.

    public override method encodeImmediateReference64: (reference: Untyped) ::=> UInt64 := {
        let value => Integer := reference.
        (value asUInt64 << ObjectModel::Tag::Bits asUInt64) | ObjectModel::Tag::Integer asUInt64.
    }.
}.

Float32 __type__ extend: {
    public override method isImmediateReference64: (reference: Untyped) ::=> Boolean := true.

    public override method encodeImmediateReference64: (reference: Untyped) ::=> UInt64 := {
        let value => Float32 := reference.
        (value asIEEEFloat32Encoding asUInt64 << ObjectModel::Tag::Bits asUInt64) | ObjectModel::Tag::Float32 asUInt64.
    }.
}.

UndefinedObject __type__ extend: {
    public override method isImmediateReference32: (reference: Untyped) ::=> Boolean := nil == reference.
    public override method isImmediateReference64: (reference: Untyped) ::=> Boolean := nil == reference.

    public virtual method encodeImmediateReference32: (reference: Untyped) ::=> UInt32 := 0u32.
    public virtual method encodeImmediateReference64: (reference: Untyped) ::=> UInt64 := 0u64.
}.

False __type__ extend: {
    public override method isImmediateReference32: (reference: Untyped) ::=> Boolean := false == reference.
    public override method isImmediateReference64: (reference: Untyped) ::=> Boolean := false == reference.

    public override method encodeImmediateReference32: (reference: Untyped) ::=> UInt32 := (ObjectModel::ImmediateTrivialIndex::False << ObjectModel::Tag::Bits asUInt32) | ObjectModel::Tag::Trivial asUInt32.
    public override method encodeImmediateReference64: (reference: Untyped) ::=> UInt64 := (ObjectModel::ImmediateTrivialIndex::False asUInt64 << ObjectModel::Tag::Bits asUInt64) | ObjectModel::Tag::Trivial asUInt64.
}.

True __type__ extend: {
    public override method isImmediateReference32: (reference: Untyped) ::=> Boolean := true == reference.
    public override method isImmediateReference64: (reference: Untyped) ::=> Boolean := true == reference.

    public override method encodeImmediateReference32: (reference: Untyped) ::=> UInt32 := (ObjectModel::ImmediateTrivialIndex::True << ObjectModel::Tag::Bits asUInt32) | ObjectModel::Tag::Trivial asUInt32.
    public override method encodeImmediateReference64: (reference: Untyped) ::=> UInt64 := (ObjectModel::ImmediateTrivialIndex::True asUInt64 << ObjectModel::Tag::Bits asUInt64) | ObjectModel::Tag::Trivial asUInt64.
}.

Void __type__ extend: {
    public override method isImmediateReference32: (reference: Untyped) ::=> Boolean := void == reference.
    public override method isImmediateReference64: (reference: Untyped) ::=> Boolean := void == reference.

    public override method encodeImmediateReference32: (reference: Untyped) ::=> UInt32 := (ObjectModel::ImmediateTrivialIndex::Void << ObjectModel::Tag::Bits asUInt32) | ObjectModel::Tag::Trivial asUInt32.
    public override method encodeImmediateReference64: (reference: Untyped) ::=> UInt64 := (ObjectModel::ImmediateTrivialIndex::Void asUInt64 << ObjectModel::Tag::Bits asUInt64) | ObjectModel::Tag::Trivial asUInt64.
}.

HashtableEmpty __type__ extend: {
    public override method isImmediateReference32: (reference: Untyped) ::=> Boolean := __hashtableEmptyElement__ == reference.
    public override method isImmediateReference64: (reference: Untyped) ::=> Boolean := __hashtableEmptyElement__ == reference.

    public override method encodeImmediateReference32: (reference: Untyped) ::=> UInt32 := (ObjectModel::ImmediateTrivialIndex::HashtableEmptyElement << ObjectModel::Tag::Bits asUInt32) | ObjectModel::Tag::Trivial asUInt32.
    public override method encodeImmediateReference64: (reference: Untyped) ::=> UInt64 := (ObjectModel::ImmediateTrivialIndex::HashtableEmptyElement asUInt64 << ObjectModel::Tag::Bits asUInt64) | ObjectModel::Tag::Trivial asUInt64.
}.

ObjectTombstone __type__ extend: {
    public override method isImmediateReference32: (reference: Untyped) ::=> Boolean := __tombstone__ == reference.
    public override method isImmediateReference64: (reference: Untyped) ::=> Boolean := __tombstone__ == reference.

    public override method encodeImmediateReference32: (reference: Untyped) ::=> UInt32 := (ObjectModel::ImmediateTrivialIndex::Tombstone << ObjectModel::Tag::Bits asUInt32) | ObjectModel::Tag::Trivial asUInt32.
    public override method encodeImmediateReference64: (reference: Untyped) ::=> UInt64 := (ObjectModel::ImmediateTrivialIndex::Tombstone asUInt64 << ObjectModel::Tag::Bits asUInt64) | ObjectModel::Tag::Trivial asUInt64.
}.

PendingMemoizationValue __type__ extend: {
    public override method isImmediateReference32: (reference: Untyped) ::=> Boolean := __pendingMemoizationValue__ == reference.
    public override method isImmediateReference64: (reference: Untyped) ::=> Boolean := __pendingMemoizationValue__ == reference.

    public override method encodeImmediateReference32: (reference: Untyped) ::=> UInt32 := (ObjectModel::ImmediateTrivialIndex::PendingMemoizationValue << ObjectModel::Tag::Bits asUInt32) | ObjectModel::Tag::Trivial asUInt32.
    public override method encodeImmediateReference64: (reference: Untyped) ::=> UInt64 := (ObjectModel::ImmediateTrivialIndex::PendingMemoizationValue asUInt64 << ObjectModel::Tag::Bits asUInt64) | ObjectModel::Tag::Trivial asUInt64.
}.

public global ObjectModel::TupleHeader := if: ObjectModel::PointerSize = 4sz
    then: ObjectModel::TupleHeader32
    else: ObjectModel::TupleHeader64.
public global ObjectModel::TupleHeaderSize := ObjectModel::TupleHeader valueSize.

public inline function ObjectModel::isNonNullPointerValue(value: UIntPointer) => Boolean
    := (value ~= 0uptr) && ((value & 15uptr) = 0uptr).

public global ObjectModel::getTuplePointerUIntValue := {:(Untyped)object :: UIntPointer |
    <primitive: #PointerLikeType::reinterpretCast>
    0uptr
}.

public global ObjectModel::getTuplePointerIntValue := {:(Untyped)object :: IntPointer |
    <primitive: #PointerLikeType::reinterpretCast>
    0iptr
}.

public global ObjectModel::getTupleHeaderPointerOf := {:(Untyped)object :: ObjectModel::TupleHeader pointer |
    <primitive: #PointerLikeType::reinterpretCast>
    nil
}.

(PointerType::reinterpretCastTo:) adoptDefinitionOf: {:(AnyPointer)self :(Type)targetPointerType :: targetPointerType |
    <primitive: #PointerType::reinterpretCastTo>
    nil
}.

(UIntPointer::reinterpretCastTo:) adoptDefinitionOf: {:(UIntPointer)self :(Type)targetPointerType :: targetPointerType |
    <primitive: #UIntPointer::reinterpretCastTo>
    nil
}.

(IntPointer::reinterpretCastTo:) adoptDefinitionOf: {:(IntPointer)self :(Type)targetPointerType :: targetPointerType |
    <primitive: #IntPointer::reinterpretCastTo>
    nil
}.

Untyped extend: {
    public final method __rawContentsPointer__ => Void pointer
        := ObjectModel::getTupleHeaderPointerOf(self) + 1iptr reinterpretCastTo: Void pointer.

    public final method __rawContentsBytePointer__ => UInt8 pointer
        := ObjectModel::getTupleHeaderPointerOf(self) + 1iptr reinterpretCastTo: UInt8 pointer.
}.

identityHash adoptDefinitionOf: {:(AnyValue)self :: Size |
    <primitive: #identityHash >
    let pointerValue := ObjectModel::getTuplePointerUIntValue(self).
    ObjectModel::isNonNullPointerValue(pointerValue) ifTrue: {
        (pointerValue reinterpretCastTo: ObjectModel::TupleHeader pointer) _ identityHashValue asSize
    } ifFalse: {
        pointerValue asSize identityHashMultiply
    }
} makePure makeFinal makeAlwaysInline makeWithoutSourceDebugging withEagerAnalysis.

Untyped::identityHash adoptDefinitionOf: {:(Untyped)self :: Size |
    <primitive: #identityHash >
    let pointerValue := ObjectModel::getTuplePointerUIntValue(self).
    ObjectModel::isNonNullPointerValue(pointerValue) ifTrue: {
        (pointerValue reinterpretCastTo: ObjectModel::TupleHeader pointer) _ identityHashValue asSize
    } ifFalse: {
        pointerValue asSize identityHashMultiply
    }
} makePure makeFinal makeAlwaysInline makeWithoutSourceDebugging withEagerAnalysis.

(RawTuple::identityHash:) adoptDefinitionOf: {:(Untyped)self :(Size)newHash :: Void |
    <primitive: #RawTuple::isBytes>
    let pointerValue := ObjectModel::getTuplePointerUIntValue(self).
    ObjectModel::isNonNullPointerValue(pointerValue) ifTrue: {
        (pointerValue reinterpretCastTo: ObjectModel::TupleHeader pointer) _ identityHashValue: newHash asUInt32
    } ifFalse: {
        error("Cannot set the identity hash of an immediate object.")
    }
} withEagerAnalysis.

RawTuple::isBytes adoptDefinitionOf: {:(Untyped)self :: Boolean |
    <primitive: #RawTuple::isBytes>
    let pointerValue := ObjectModel::getTuplePointerUIntValue(self).
    ObjectModel::isNonNullPointerValue(pointerValue) ifTrue: {
        (pointerValue reinterpretCastTo: ObjectModel::TupleHeader pointer) _ isBytes
    } ifFalse: {
        false
    }
} withEagerAnalysis.

RawTuple::isDummyValue adoptDefinitionOf: {:(Untyped)self :: Boolean |
    <primitive: #RawTuple::isDummyValue>
    let pointerValue := ObjectModel::getTuplePointerUIntValue(self).
    ObjectModel::isNonNullPointerValue(pointerValue) ifTrue: {
        (pointerValue reinterpretCastTo: ObjectModel::TupleHeader pointer) _ isDummyValue
    } ifFalse: {
        false
    }
} withEagerAnalysis.

RawTuple::markDummyValue adoptDefinitionOf: {:(Untyped)self :: Void |
    <primitive: #RawTuple::markDummy>
    let pointerValue := ObjectModel::getTuplePointerUIntValue(self).
    ObjectModel::isNonNullPointerValue(pointerValue) ifTrue: {
        (pointerValue reinterpretCastTo: ObjectModel::TupleHeader pointer) _ isDummyValue: true
    }.
} withEagerAnalysis.

RawTuple::isWeak adoptDefinitionOf: {:(Untyped)self :: Boolean |
    <primitive: #RawTuple::isWeak>
    let pointerValue := ObjectModel::getTuplePointerUIntValue(self).
    ObjectModel::isNonNullPointerValue(pointerValue) ifTrue: {
        (pointerValue reinterpretCastTo: ObjectModel::TupleHeader pointer) _ isWeak
    } ifFalse: {
        false
    }
} withEagerAnalysis.

RawTuple::markWeak adoptDefinitionOf: {:(Untyped)self :: Void |
    <primitive: #RawTuple::markWeak>
    let pointerValue := ObjectModel::getTuplePointerUIntValue(self).
    ObjectModel::isNonNullPointerValue(pointerValue) ifTrue: {
        (pointerValue reinterpretCastTo: ObjectModel::TupleHeader pointer) _ objectType: ObjectModel::ObjectType::WeakPointers
    }.
} withEagerAnalysis.

RawTuple::size adoptDefinitionOf: {:(Untyped)self :: Size |
    <primitive: #RawTuple::size>
    let pointerValue := ObjectModel::getTuplePointerUIntValue(self).
    ObjectModel::isNonNullPointerValue(pointerValue) ifTrue: {
        let type := (pointerValue reinterpretCastTo: ObjectModel::TupleHeader pointer) _ type.
        let objectSize := (pointerValue reinterpretCastTo: ObjectModel::TupleHeader pointer) _ objectSize asSize.
        type ifNotNil: {
            let fixedSize := type instanceSize.
            let fixedSlotCount := type totalSlotCount uncheckedDownCastTo: Size.
            let variableSlotCount := objectSize > fixedSize
                ifTrue: (objectSize - fixedSize) / ObjectModel::PointerSize
                ifFalse: 0sz.
            fixedSlotCount + variableSlotCount
        } ifNil: {
            objectSize / ObjectModel::PointerSize
        }.

    } ifFalse: {
        0sz
    }.
} withEagerAnalysis.

RawTuple::uncheckedPointersSize adoptDefinitionOf: {:(Untyped)self :: Size |
    <primitive: #RawTuple::uncheckedSize>
    let pointerValue := ObjectModel::getTuplePointerUIntValue(self).
    ObjectModel::isNonNullPointerValue(pointerValue) ifTrue: {
        let type := (pointerValue reinterpretCastTo: ObjectModel::TupleHeader pointer) _ type.
        (pointerValue reinterpretCastTo: ObjectModel::TupleHeader pointer) _ objectSize asSize / ObjectModel::PointerSize
    } ifFalse: {
        0sz
    }.
} makeFinal makeAlwaysInline makeWithoutSourceDebugging withEagerAnalysis.

RawTuple::type adoptDefinitionOf: {:(Untyped)self :: Type |
    <primitive: #RawTuple::type>
    let pointerValue := ObjectModel::getTuplePointerUIntValue(self).
    let tag := pointerValue & 15uptr.
    (pointerValue ~= 0uptr) && (tag = 0uptr) ifTrue: {
        (pointerValue reinterpretCastTo: ObjectModel::TupleHeader pointer) _ type
    } ifFalse: {
        tag = 15uptr ifTrue: {
            let trivialTypeIndex := pointerValue >> 4uptr.
            (ObjectModel::ImmediateTrivialTypeTable at: trivialTypeIndex asSize) uncheckedDownCastTo: Type
        } ifFalse: {
            (ObjectModel::ImmediateTagTypeTable at: tag asSize) uncheckedDownCastTo: Type
        }
    }
} withEagerAnalysis.

(RawTuple::type:) adoptDefinitionOf: {:(Untyped)self :(Type)newType :: Void |
    <primitive: #RawTuple::type>
    let pointerValue := ObjectModel::getTuplePointerUIntValue(self).

    ObjectModel::isNonNullPointerValue(pointerValue) ifFalse: error("Cannot set the type of an immediate value.").

    let header := pointerValue reinterpretCastTo: ObjectModel::TupleHeader pointer.
    header _ type: newType
} withEagerAnalysis.

(RawTuple::refSlotAt:) adoptDefinitionOf: {:(Untyped)self :(Size)index :: Untyped |
    <primitive: #RawTuple::refSlotAt:>
    error("TODO:refSlotAt:")
} withEagerAnalysis.

(RawTuple::refSlotAt:put:) adoptDefinitionOf: {:(Untyped)self :(Size)index :(Untyped)value :: Void |
    <primitive: #RawTuple::refSlotAt:put:>
    error("TODO:refSlotAt:")
} withEagerAnalysis.

(RawTuple::slotAt:) adoptDefinitionOf: {:(Untyped)self :(Size)index :: Untyped |
    <primitive: #RawTuple::slotAt:>
    let pointerValue := ObjectModel::getTuplePointerUIntValue(self).
    ObjectModel::isNonNullPointerValue(pointerValue) ifTrue: {
        let header := pointerValue reinterpretCastTo: ObjectModel::TupleHeader pointer.
        header _ isBytes ifTrue: {
            let contents := header + 1iptr reinterpretCastTo: UInt8 pointer.
            (contents[index asIntPointer] asUIntPointer << ObjectModel::Tag::Bits asUIntPointer) | ObjectModel::Tag::UInt8 asUIntPointer reinterpretCastTo: Untyped
        } ifFalse: {
            let type := (pointerValue reinterpretCastTo: ObjectModel::TupleHeader pointer) _ type.
            type ifNil: {
                let contents := header + 1iptr reinterpretCastTo: Untyped pointer.
                contents[index asIntPointer] __refLoad__
            } ifNotNil: {
                let fixedSlotCount => Size := type totalSlotCount.
                index < fixedSlotCount ifTrue: {
                    let typeSlot => TypeSlot := type allValidSlots at: index.
                    let slotPointerValue := pointerValue + ObjectModel::TupleHeaderSize + typeSlot offset.
                    (typeSlot type ifNil: Untyped) loadValueFromPointer: (slotPointerValue reinterpretCastTo: Void const pointer)
                } ifFalse: {
                    let baseOffset := type instanceSize.
                    let contents := pointerValue + ObjectModel::TupleHeaderSize + baseOffset reinterpretCastTo: Untyped pointer.
                    contents[(index - fixedSlotCount) asIntPointer] __refLoad__
                }
            }
        }.
    } ifFalse: {
        let shiftAmount := (index asUIntPointer * 8uptr) + ObjectModel::Tag::Bits asUIntPointer.
        let tag := pointerValue & ObjectModel::Tag::Mask asUIntPointer.
        let isSigned := (ObjectModel::Tag::SignedIntegerFirst asUIntPointer <= tag) && (tag <= ObjectModel::Tag::SignedIntegerLast asUIntPointer).
        let byteValue := isSigned
            ifTrue: (pointerValue asIntPointer >> shiftAmount asIntPointer) asUInt8
            ifFalse: (pointerValue >> shiftAmount) asUInt8.

        (byteValue asUIntPointer << ObjectModel::Tag::Bits asUIntPointer) | ObjectModel::Tag::UInt8 asUIntPointer reinterpretCastTo: Untyped
    }
} withEagerAnalysis.

(RawTuple::slotAt:put:) adoptDefinitionOf: {:(Untyped)self :(Size)index :(Untyped)value :: Void |
    <primitive: #RawTuple::slotAt:put:>
    let pointerValue := ObjectModel::getTuplePointerUIntValue(self).
    ObjectModel::isNonNullPointerValue(pointerValue) ifTrue: {
        let header := pointerValue reinterpretCastTo: ObjectModel::TupleHeader pointer.
        let contents := header + 1iptr.
        header _ isBytes ifTrue: {
            (contents reinterpretCastTo: UInt8 pointer)[index asIntPointer] := (ObjectModel::getTuplePointerUIntValue(value) >> ObjectModel::Tag::Bits asUIntPointer) asUInt8
        } ifFalse: {
            let type := (pointerValue reinterpretCastTo: ObjectModel::TupleHeader pointer) _ type.
            type ifNil: {
                let contents := header + 1iptr reinterpretCastTo: Untyped pointer.
                contents[index asIntPointer] __refLoad__
            } ifNotNil: {
                let fixedSlotCount => Size := type totalSlotCount.
                index < fixedSlotCount ifTrue: {
                    let typeSlot => TypeSlot := type allValidSlots at: index.
                    let slotPointerValue := pointerValue + ObjectModel::TupleHeaderSize + typeSlot offset.
                    (typeSlot type ifNil: Untyped) storeValue: value inPointer: (slotPointerValue reinterpretCastTo: Void pointer)
                } ifFalse: {
                    let baseOffset := type instanceSize.
                    let contents := pointerValue + ObjectModel::TupleHeaderSize + baseOffset reinterpretCastTo: Untyped pointer.
                    contents[(index - fixedSlotCount) asIntPointer] := value
                }
            }
        }
    }
} withEagerAnalysis.

(RawTuple::uncheckedSlotAt:) adoptDefinitionOf: {:(Untyped)self :(Size)index :: Untyped |
    <primitive: #RawTuple::uncheckedSlotAt:>
    let pointerValue := ObjectModel::getTuplePointerUIntValue(self).
    let header := pointerValue reinterpretCastTo: ObjectModel::TupleHeader pointer.
    let contents := header + 1iptr reinterpretCastTo: Untyped pointer.
    contents[index asIntPointer] __refLoad__
} makeFinal makeAlwaysInline makeWithoutSourceDebugging withEagerAnalysis.

(RawTuple::uncheckedSlotAt:put:) adoptDefinitionOf: {:(Untyped)self :(Size)index :(Untyped)value :: Void |
    <primitive: #RawTuple::uncheckedSlotAt:put:>
    let pointerValue := ObjectModel::getTuplePointerUIntValue(self).
    let header := pointerValue reinterpretCastTo: ObjectModel::TupleHeader pointer.
    let contents := header + 1iptr reinterpretCastTo: Untyped pointer.
    contents[index asIntPointer] := value
} makeFinal makeAlwaysInline makeWithoutSourceDebugging withEagerAnalysis.

(RawTuple::byteSlotAt:) adoptDefinitionOf: {:(Untyped)self :(Size)index :: UInt8 |
    <primitive: #RawTuple::byteSlotAt:>
    let pointerValue := ObjectModel::getTuplePointerUIntValue(self).
    ObjectModel::isNonNullPointerValue(pointerValue) ifTrue: {
        let header := pointerValue reinterpretCastTo: ObjectModel::TupleHeader pointer.
        let contents := header + 1iptr.
        header _ isBytes ifFalse: (error("Expected a byte tuple.")).
        
        (contents reinterpretCastTo: UInt8 pointer)[index asIntPointer]
    } ifFalse: {
        let shiftAmount := (index asUIntPointer * 8uptr) + ObjectModel::Tag::Bits asUIntPointer.
        let tag := pointerValue & ObjectModel::Tag::Mask asUIntPointer.
        let isSigned := (ObjectModel::Tag::SignedIntegerFirst asUIntPointer <= tag) && (tag <= ObjectModel::Tag::SignedIntegerLast asUIntPointer).
        isSigned
            ifTrue: (pointerValue asIntPointer >> shiftAmount asIntPointer) asUInt8
            ifFalse: (pointerValue >> shiftAmount) asUInt8
    }
} withEagerAnalysis.

(RawTuple::byteSlotAt:put:) adoptDefinitionOf: {:(Untyped)self :(Size)index :(UInt8)value :: Void |
    <primitive: #RawTuple::byteSlotAt:put:>
    let pointerValue := ObjectModel::getTuplePointerUIntValue(self).
    ObjectModel::isNonNullPointerValue(pointerValue) ifTrue: {
        let header := pointerValue reinterpretCastTo: ObjectModel::TupleHeader pointer.
        let contents := header + 1iptr.
        header _ isBytes ifFalse: (error("Expected a byte tuple.")).
        index < header _ objectSize asSize ifFalse: (error("Out of bounds access")).

        (contents reinterpretCastTo: UInt8 pointer)[index asIntPointer] := value
    } ifFalse: {
        error("Cannot modifiy immutable object.").
    }
} withEagerAnalysis.

(RawTuple::uncheckedByteSlotAt:) adoptDefinitionOf: {:(Untyped)self :(Size)index :: UInt8 |
    <primitive: #RawTuple::uncheckedSlotAt:>
    let pointerValue := ObjectModel::getTuplePointerUIntValue(self).
    let header := pointerValue reinterpretCastTo: ObjectModel::TupleHeader pointer.
    let contents := header + 1iptr reinterpretCastTo: UInt8 pointer.
    contents[index asIntPointer] __refLoad__
} makeFinal makeAlwaysInline makeWithoutSourceDebugging withEagerAnalysis.

(RawTuple::uncheckedByteSlotAt:put:) adoptDefinitionOf: {:(Untyped)self :(Size)index :(UInt8)value :: Void |
    <primitive: #RawTuple::uncheckedSlotAt:put:>
    let pointerValue := ObjectModel::getTuplePointerUIntValue(self).
    let header := pointerValue reinterpretCastTo: ObjectModel::TupleHeader pointer.
    let contents := header + 1iptr reinterpretCastTo: UInt8 pointer.
    contents[index asIntPointer] := value
} makeFinal makeAlwaysInline makeWithoutSourceDebugging withEagerAnalysis.

RawTuple::byteSize adoptDefinitionOf: {:(Untyped)self :: Size |
    <primitive: #RawTuple::byteSize>
    let pointerValue := ObjectModel::getTuplePointerUIntValue(self).
    ObjectModel::isNonNullPointerValue(pointerValue) ifTrue: {
        (pointerValue reinterpretCastTo: ObjectModel::TupleHeader pointer) _ objectSize asSize
    } ifFalse: {
        0sz
    }
} makeFinal makeAlwaysInline withEagerAnalysis makeWithoutSourceDebugging.

(RawTuple::basicAllocateWithType:instanceSize:alignment:slotCount:variableSize:isBytes:isWeak:) adoptDefinitionOf: {
    :(Type)type :(Size)instanceSize :(Size)instanceAlignment :(Size)slotCount :(Size)variableSize :(Boolean)isBytes :(Boolean)isWeak :: Untyped |
    <primitive: #RawTuple::basicAllocateWithType:instanceSize:alignment:slotCount:variableSize:isBytes:isWeak:>
    ##let allocationAlignment := instanceAlignment max: ObjectModel::MinimalAlignment asSize.
    let variableDataSize := isBytes ifTrue: variableSize ifFalse: variableSize * ObjectModel::PointerSize.
    let contentSize := instanceSize + variableDataSize.
    let allocationSize := ObjectModel::TupleHeaderSize + contentSize.
    let allocationPointer := sysmel_pal_gcalloc(allocationSize).
    memset(allocationPointer, 0i8, allocationSize).

    let objectHeader := allocationPointer reinterpretCastTo: ObjectModel::TupleHeader pointer.
    objectHeader _
        type: type;
        objectType: (isBytes ifTrue: ObjectModel::ObjectType::Bytes ifFalse: ObjectModel::ObjectType::Complex);
        identityHashValue: ObjectModelState current newIdentityHash;
        objectSize: contentSize asUInt32.

    allocationPointer reinterpretCastTo: Untyped.
} withEagerAnalysis.

RawTuple::new adoptDefinitionOf: {:(Size)slotCount :: Untyped |
    <primitive: #RawTuple::new>
    let contentSize := slotCount * ObjectModel::PointerSize.

    let allocationSize := ObjectModel::TupleHeaderSize + contentSize.
    let allocationPointer := sysmel_pal_gcalloc(allocationSize).
    memset(allocationPointer, 0i8, allocationSize).

    let objectHeader := allocationPointer reinterpretCastTo: ObjectModel::TupleHeader pointer.
    objectHeader _
        type: Untyped;
        identityHashValue: ObjectModelState current newIdentityHash;
        objectSize: contentSize asUInt32.

    allocationPointer reinterpretCastTo: Untyped.
} withEagerAnalysis.

RawTuple::byteNew adoptDefinitionOf: {:(Size)slotCount :: Untyped |
    <primitive: #RawTuple::byteNew>
    let contentSize := slotCount.

    let allocationSize := ObjectModel::TupleHeaderSize + contentSize.
    let allocationPointer := sysmel_pal_gcalloc(allocationSize).
    memset(allocationPointer, 0i8, allocationSize).

    let objectHeader := allocationPointer reinterpretCastTo: ObjectModel::TupleHeader pointer.
    objectHeader _
        type: Untyped;
        identityHashValue: ObjectModelState current newIdentityHash;
        objectType: ObjectModel::ObjectType::Bytes;
        objectSize: contentSize asUInt32.

    allocationPointer reinterpretCastTo: Untyped.
} withEagerAnalysis.

RawTuple::shallowCopy adoptDefinitionOf: {:(Untyped)sourceObject :: Untyped |
    <primitive: #RawTuple::shallowCopy>
    let pointerValue := ObjectModel::getTuplePointerUIntValue(sourceObject).
    ObjectModel::isNonNullPointerValue(pointerValue) ifTrue: {
        let sourceObjectSize := ObjectModel::TupleHeaderSize + (pointerValue reinterpretCastTo: ObjectModel::TupleHeader pointer) _ objectSize asSize.

        let allocationPointer := sysmel_pal_gcalloc(sourceObjectSize).
        memcpy(allocationPointer, (pointerValue reinterpretCastTo: Void const pointer), sourceObjectSize).

        (allocationPointer reinterpretCastTo: ObjectModel::TupleHeader pointer) _
            identityHashValue: ObjectModelState current newIdentityHash.

        allocationPointer reinterpretCastTo: Untyped
    } ifFalse: {
        sourceObject
    }
} withEagerAnalysis.

RawTuple::firstInstanceWithType adoptDefinitionOf: {:(Type)type :: Untyped | nil}.
RawTuple::nextInstanceWithSameType adoptDefinitionOf: {:(Untyped)iterator :: Untyped | nil}.

(RawTuple::typeSlotAt:) adoptDefinitionOf: {:(Untyped)self :(TypeSlot)typeSlot :: Untyped |
    <primitive: #RawTuple::typeSlotAt:>
    let slotPointerValue := ObjectModel::getTuplePointerUIntValue(self) + ObjectModel::TupleHeaderSize + typeSlot offset.
    (typeSlot type ifNil: Untyped) loadValueFromPointer: (slotPointerValue reinterpretCastTo: Void const pointer)
} withEagerAnalysis.

(RawTuple::typeSlotAt:put:) adoptDefinitionOf: {:(Untyped)self :(TypeSlot)typeSlot :(Untyped)value :: Void |
    <primitive: #RawTuple::typeSlotAt:put:>
    let slotPointerValue := ObjectModel::getTuplePointerUIntValue(self) + ObjectModel::TupleHeaderSize + typeSlot offset.
    (typeSlot type ifNil: Untyped) storeValue: value inPointer: (slotPointerValue reinterpretCastTo: Void pointer)
} withEagerAnalysis.

(RawTuple::refTypeSlotAt:) adoptDefinitionOf: {:(Untyped)self :(TypeSlot)typeSlot :: Untyped |
    <primitive: #RawTuple::refTypeSlotAt:>
    error("TODO: RawTuple::refTypeSlotAt:")
} withEagerAnalysis.

(RawTuple::refTypeSlotAt:put:) adoptDefinitionOf: {:(Untyped)self :(TypeSlot)typeSlot :(Untyped)value :: Void |
    <primitive: #RawTuple::refTypeSlotAt:put:>
    error("TODO: RawTuple::refTypeSlotAt:put:")
} withEagerAnalysis.

let emptyArray := #().
public function ObjectModel::makeArrayWithSize(size: Size) => Array := {
    size = 0sz
        ifTrue: emptyArray
        ifFalse: (Array basicAllocate: size)
}.

public function ObjectModel::makeAssociation(key: Untyped, value: Untyped) => Association
    := Association basicAllocate
        __slotNamedAt__: #key put: key;
        __slotNamedAt__: #value put: value;
        yourself.

public function ObjectModel::makeClosure(functionDefinition: FunctionDefinition, captureVector: AnyValue) => Function
    := Function basicAllocate
        __slotNamedAt__: #definition put: functionDefinition;
        __slotNamedAt__: #captureVector put: captureVector;
        yourself.

let emptyByteArray := #[].
public function ObjectModel::makeByteArrayWithSize(size: Size) => ByteArray := {
    size = 0sz
        ifTrue: emptyByteArray
        ifFalse: (ByteArray basicAllocate: size)
}.

public function ObjectModel::makeDictionaryWithCapacity(initialCapacity: Size) => Dictionary
    := Dictionary new: initialCapacity.

public function ObjectModel::Dictionary::add(dictionary: Dictionary, association: Association) => Void
    := dictionary add: association.

public inline function ObjectModel::isFunction(value: Untyped) => Boolean := {
    let type := RawTuple::type(value).
    type isNotNil && type isFunction
}.

## Boxing methods.
public function ObjectModel::allocateBoxForValueOfTypeWithSize(type: Type, contentSize: Size) => ObjectModel::TupleHeader pointer := {
    let allocationSize := ObjectModel::TupleHeaderSize + contentSize.
    let allocationPointer := sysmel_pal_gcalloc(allocationSize).
    memset(allocationPointer, 0i8, allocationSize).

    let objectHeader := allocationPointer reinterpretCastTo: ObjectModel::TupleHeader pointer.
    objectHeader _
        type: type;
        identityHashValue: ObjectModelState current newIdentityHash;
        objectType: ObjectModel::ObjectType::Bytes;
        objectSize: contentSize asUInt32.
    objectHeader
}.

public function ObjectModel::boxChar8(value: Char8) => AnyValue
    := (value asUIntPointer << ObjectModel::Tag::Bits asUIntPointer) | ObjectModel::Tag::Char8 asUIntPointer reinterpretCastTo: AnyValue.

public function ObjectModel::boxUInt8(value: UInt8) => AnyValue
    := (value asUIntPointer << ObjectModel::Tag::Bits asUIntPointer) | ObjectModel::Tag::UInt8 asUIntPointer reinterpretCastTo: AnyValue.

public function ObjectModel::boxInt8(value: Int8) => AnyValue
    := (value asIntPointer << ObjectModel::Tag::Bits asIntPointer) | ObjectModel::Tag::Int8 asIntPointer reinterpretCastTo: AnyValue.

public function ObjectModel::boxBoolean(value: Boolean) => AnyValue := {
    if: value
    then: (ObjectModel::ImmediateTrivialConstant::True asUIntPointer reinterpretCastTo: AnyValue)
    else: (ObjectModel::ImmediateTrivialConstant::False asUIntPointer reinterpretCastTo: AnyValue)
}.

public function ObjectModel::boxChar16(value: Char16) => AnyValue
    := (value asUIntPointer << ObjectModel::Tag::Bits asUIntPointer) | ObjectModel::Tag::Char16 asUIntPointer reinterpretCastTo: AnyValue.

public function ObjectModel::boxUInt16(value: UInt16) => AnyValue
    := (value asUIntPointer << ObjectModel::Tag::Bits asUIntPointer) | ObjectModel::Tag::UInt16 asUIntPointer reinterpretCastTo: AnyValue.

public function ObjectModel::boxInt16(value: Int16) => AnyValue
    := (value asIntPointer << ObjectModel::Tag::Bits asIntPointer) | ObjectModel::Tag::Int16 asIntPointer reinterpretCastTo: AnyValue.

if: ObjectModel::PointerSize = 4sz then: {
    public function ObjectModel::boxChar32(value: Char32) => AnyValue := {
        value <= ObjectModel::Immediate::UInt::Max asChar32 ifTrue: {
            (value asUIntPointer << ObjectModel::Tag::Bits asUIntPointer) | ObjectModel::Tag::Char32 asUIntPointer reinterpretCastTo: AnyValue.
        } ifFalse: {
            let box := ObjectModel::allocateBoxForValueOfTypeWithSize(Char32, 4sz).
            (box + 1iptr reinterpretCastTo: Char32 pointer) store: value.
            box reinterpretCastTo: AnyValue
        }.
    }.

    public function ObjectModel::boxUInt32(value: UInt32) => AnyValue := {
        value <= ObjectModel::Immediate::UInt::Max asUInt32 ifTrue: {
            (value asUIntPointer << ObjectModel::Tag::Bits asUIntPointer) | ObjectModel::Tag::UInt32 asUIntPointer reinterpretCastTo: AnyValue.
        } ifFalse: {
            let box := ObjectModel::allocateBoxForValueOfTypeWithSize(UInt32, 4sz).
            (box + 1iptr reinterpretCastTo: UInt32 pointer) store: value.
            box reinterpretCastTo: AnyValue
        }.
    }.

    public function ObjectModel::boxInt32(value: Int32) => AnyValue := {
        (ObjectModel::Immediate::Int::Min asInt32 <= value) && (value <= ObjectModel::Immediate::Int::Max asInt32) ifTrue: {
            (value asIntPointer << ObjectModel::Tag::Bits asIntPointer) | ObjectModel::Tag::Int32 asIntPointer reinterpretCastTo: AnyValue.
        } ifFalse: {
            let box := ObjectModel::allocateBoxForValueOfTypeWithSize(Int32, 4sz).
            (box + 1iptr reinterpretCastTo: Int32 pointer) store: value.
            box reinterpretCastTo: AnyValue
        }.
    }.

    public function ObjectModel::boxFloat32(value: Float32) => AnyValue := {
        let box := ObjectModel::allocateBoxForValueOfTypeWithSize(Float32, 4sz).
        (box + 1iptr reinterpretCastTo: Float32 pointer) store: value.
        box reinterpretCastTo: AnyValue
    }.
} else: {
    public function ObjectModel::boxChar32(value: Char32) => AnyValue
        := (value asUIntPointer << ObjectModel::Tag::Bits asUIntPointer) | ObjectModel::Tag::Char32 asUIntPointer reinterpretCastTo: AnyValue.

    public function ObjectModel::boxUInt32(value: UInt32) => AnyValue
        := (value asUIntPointer << ObjectModel::Tag::Bits asUIntPointer) | ObjectModel::Tag::UInt32 asUIntPointer reinterpretCastTo: AnyValue.

    public function ObjectModel::boxInt32(value: Int32) => AnyValue
        := (value asIntPointer << ObjectModel::Tag::Bits asIntPointer) | ObjectModel::Tag::Int32 asIntPointer reinterpretCastTo: AnyValue.

    public function ObjectModel::boxFloat32(value: Float32) => AnyValue := {
        let ieeeValue := value asIEEEFloat32Encoding.
        (ieeeValue asUIntPointer << ObjectModel::Tag::Bits asUIntPointer asUIntPointer) | ObjectModel::Tag::Float32 asUIntPointer reinterpretCastTo: AnyValue.        
    }.
}.

public function ObjectModel::boxUInt64(value: UInt64) => AnyValue := {
    value <= ObjectModel::Immediate::UInt::Max asUInt64 ifTrue: {
        (value asUIntPointer << ObjectModel::Tag::Bits asUIntPointer) | ObjectModel::Tag::UInt64 asUIntPointer reinterpretCastTo: AnyValue.
    } ifFalse: {
        let box := ObjectModel::allocateBoxForValueOfTypeWithSize(UInt64, 8sz).
        (box + 1iptr reinterpretCastTo: UInt64 pointer) store: value.
        box reinterpretCastTo: AnyValue
    }.
}.

public function ObjectModel::boxInt64(value: Int64) => AnyValue := {
    (ObjectModel::Immediate::Int::Min asInt64 <= value) && (value <= ObjectModel::Immediate::Int::Max asInt64) ifTrue: {
        (value asIntPointer << ObjectModel::Tag::Bits asIntPointer) | ObjectModel::Tag::Int64 asIntPointer reinterpretCastTo: AnyValue.
    } ifFalse: {
        let box := ObjectModel::allocateBoxForValueOfTypeWithSize(Int64, 8sz).
        (box + 1iptr reinterpretCastTo: Int64 pointer) store: value.
        box reinterpretCastTo: AnyValue
    }.
}.

public function ObjectModel::boxFloat64(value: Float64) => AnyValue := {
    let box := ObjectModel::allocateBoxForValueOfTypeWithSize(Float64, 8sz).
    (box + 1iptr reinterpretCastTo: Float64 pointer) store: value.
    box reinterpretCastTo: AnyValue
}.

public function ObjectModel::boxPointer(pointerType: Type, value: UIntPointer) => AnyValue := {
    value = 0uptr ifTrue: {
        nil
    } ifFalse: {
        let box := ObjectModel::allocateBoxForValueOfTypeWithSize(pointerType, ObjectModel::PointerSize).
        (box + 1iptr reinterpretCastTo: UIntPointer pointer) store: value.
        box reinterpretCastTo: AnyValue
    }.
}.

## Unboxing methods.
public function ObjectModel::unboxChar8(value: Untyped) => Char8 := {
    let pointerValue := ObjectModel::getTuplePointerUIntValue(value).
    (pointerValue >> ObjectModel::Tag::Bits asUIntPointer) asChar8
}.

public function ObjectModel::unboxUInt8(value: Untyped) => UInt8 := {
    let pointerValue := ObjectModel::getTuplePointerUIntValue(value).
    (pointerValue >> ObjectModel::Tag::Bits asUIntPointer) asUInt8
}.

public function ObjectModel::unboxInt8(value: Untyped) => Int8 := {
    let pointerValue := ObjectModel::getTuplePointerIntValue(value).
    (pointerValue >> ObjectModel::Tag::Bits asIntPointer) asInt8
}.

public function ObjectModel::unboxBoolean(value: Untyped) => Boolean := {
    let pointerValue := ObjectModel::getTuplePointerUIntValue(value).
    pointerValue = ObjectModel::ImmediateTrivialConstant::True asUIntPointer
}.

public function ObjectModel::unboxChar16(value: Untyped) => Char16 := {
    let pointerValue := ObjectModel::getTuplePointerUIntValue(value).
    let tag := pointerValue & ObjectModel::Tag::Mask asUIntPointer.
    (pointerValue >> ObjectModel::Tag::Bits asUIntPointer) asChar16
}.

public function ObjectModel::unboxUInt16(value: Untyped) => UInt16 := {
    let pointerValue := ObjectModel::getTuplePointerUIntValue(value).
    let tag := pointerValue & ObjectModel::Tag::Mask asUIntPointer.
    (pointerValue >> ObjectModel::Tag::Bits asUIntPointer) asUInt16
}.

public function ObjectModel::unboxInt16(value: Untyped) => Int16 := {
    let pointerValue := ObjectModel::getTuplePointerIntValue(value).
    let tag := pointerValue & ObjectModel::Tag::Mask asIntPointer.
    (pointerValue >> ObjectModel::Tag::Bits asIntPointer) asInt16
}.

if: ObjectModel::PointerSize = 4sz then: {
    public function ObjectModel::unboxChar32(value: Untyped) => Char32 := {
        let pointerValue := ObjectModel::getTuplePointerUIntValue(value).
        let tag := pointerValue & ObjectModel::Tag::Mask asUIntPointer.
        (tag ~= 0uptr) || (pointerValue = 0uptr) ifTrue: {
            (pointerValue >> ObjectModel::Tag::Bits asUIntPointer) asChar32
        } ifFalse: {
            let objectHeader := pointerValue reinterpretCastTo: ObjectModel::TupleHeader pointer.
            (objectHeader + 1iptr reinterpretCastTo: Char32 pointer) load
        }.
    }.

    public function ObjectModel::unboxUInt32(value: Untyped) => UInt32 := {
        let pointerValue := ObjectModel::getTuplePointerUIntValue(value).
        let tag := pointerValue & ObjectModel::Tag::Mask asUIntPointer.
        (tag ~= 0uptr) || (pointerValue = 0uptr) ifTrue: {
            (pointerValue >> ObjectModel::Tag::Bits asUIntPointer) asUInt32
        } ifFalse: {
            let objectHeader := pointerValue reinterpretCastTo: ObjectModel::TupleHeader pointer.
            (objectHeader + 1iptr reinterpretCastTo: UInt32 pointer) load
        }.
    }.

    public function ObjectModel::unboxInt32(value: Untyped) => Int32 := {
        let pointerValue := ObjectModel::getTuplePointerIntValue(value).
        let tag := pointerValue & ObjectModel::Tag::Mask asIntPointer.
        (tag ~= 0uptr) || (pointerValue = 0uptr) ifTrue: {
            (pointerValue >> ObjectModel::Tag::Bits asIntPointer) asUInt32
        } ifFalse: {
            let objectHeader := pointerValue reinterpretCastTo: ObjectModel::TupleHeader pointer.
            (objectHeader + 1iptr reinterpretCastTo: Int32 pointer) load
        }.
    }.

    public function ObjectModel::unboxFloat32(value: Untyped) => Float32 := {
        let pointerValue := ObjectModel::getTuplePointerUIntValue(value).
        let tag := pointerValue & ObjectModel::Tag::Mask asUIntPointer.
        (tag ~= 0uptr) || (pointerValue = 0uptr) ifTrue: {
            (pointerValue >> ObjectModel::Tag::Bits asUIntPointer) asUInt32 asIEEEFloat32Decoded
        } ifFalse: {
            let objectHeader := pointerValue reinterpretCastTo: ObjectModel::TupleHeader pointer.
            (objectHeader + 1iptr reinterpretCastTo: Float32 pointer) load
        }.
    }.
} else: {
    public function ObjectModel::unboxChar32(value: Untyped) => Char32 := {
        let pointerValue := ObjectModel::getTuplePointerUIntValue(value).
        (pointerValue >> ObjectModel::Tag::Bits asUIntPointer) asChar32
    }.

    public function ObjectModel::unboxUInt32(value: Untyped) => UInt32 := {
        let pointerValue := ObjectModel::getTuplePointerUIntValue(value).
        (pointerValue >> ObjectModel::Tag::Bits asUIntPointer) asUInt32
    }.

    public function ObjectModel::unboxInt32(value: Untyped) => Int32 := {
        let pointerValue := ObjectModel::getTuplePointerIntValue(value).
        (pointerValue >> ObjectModel::Tag::Bits asIntPointer) asInt32
    }.

    public function ObjectModel::unboxFloat32(value: Untyped) => Float32 := {
        let pointerValue := ObjectModel::getTuplePointerUIntValue(value).
        (pointerValue >> ObjectModel::Tag::Bits asUIntPointer) asUInt32 asIEEEFloat32Decoded
    }.
}.

public function ObjectModel::unboxUInt64(value: Untyped) => UInt64 := {
    let pointerValue := ObjectModel::getTuplePointerUIntValue(value).
    let tag := pointerValue & ObjectModel::Tag::Mask asUIntPointer.
    (tag ~= 0uptr) || (pointerValue = 0uptr) ifTrue: {
        (pointerValue >> ObjectModel::Tag::Bits asUIntPointer) asUInt64
    } ifFalse: {
        let objectHeader := pointerValue reinterpretCastTo: ObjectModel::TupleHeader pointer.
        (objectHeader + 1iptr reinterpretCastTo: UInt64 pointer) load
    }.
}.

public function ObjectModel::unboxInt64(value: Untyped) => Int64 := {
    let pointerValue := ObjectModel::getTuplePointerIntValue(value).
    let tag := pointerValue & ObjectModel::Tag::Mask asIntPointer.
    (tag ~= 0iptr) || (pointerValue = 0iptr) ifTrue: {
        (pointerValue >> ObjectModel::Tag::Bits asIntPointer) asInt64
    } ifFalse: {
        let objectHeader := pointerValue reinterpretCastTo: ObjectModel::TupleHeader pointer.
        (objectHeader + 1iptr reinterpretCastTo: Int64 pointer) load
    }.
}.

public function ObjectModel::unboxFloat64(value: Untyped) => Float64 := {
    let pointerValue := ObjectModel::getTuplePointerUIntValue(value).
    let tag := pointerValue & ObjectModel::Tag::Mask asUIntPointer.
    (tag ~= 0uptr) || (pointerValue = 0uptr) ifTrue: {
        (pointerValue >> ObjectModel::Tag::Bits asUIntPointer) asUInt64 asIEEEFloat64Decoded
    } ifFalse: {
        let objectHeader := pointerValue reinterpretCastTo: ObjectModel::TupleHeader pointer.
        (objectHeader + 1iptr reinterpretCastTo: Float64 pointer) load
    }.
}.

public function ObjectModel::unboxPointer(value: Untyped) => UIntPointer := {
    Untyped::==(value, nil) ifTrue: {
        0uptr
    } ifFalse: {
        let valueType := RawTuple::type(value).
        let objectHeader := ObjectModel::getTuplePointerUIntValue(value) reinterpretCastTo: ObjectModel::TupleHeader pointer.

        valueType isPointerLikeType ifFalse: {
            return: (objectHeader + 1iptr reinterpretCastTo: UIntPointer)
        }.

        objectHeader _ isBytes ifTrue: {
            (objectHeader + 1iptr reinterpretCastTo: UIntPointer pointer) load
        } ifFalse: {
            let slotCount := objectHeader _ slotCount.
            let slots := objectHeader + 1iptr reinterpretCastTo: AnyValue pointer.
            error("TODO: Unbox object oriented pointer.").
        }
    }.
}.

public function ObjectModel::checkAndUnboxChar8(value: Untyped) => Char8 := {
    let pointerValue := ObjectModel::getTuplePointerUIntValue(value).
    let tag := pointerValue & ObjectModel::Tag::Mask asUIntPointer.
    tag = ObjectModel::Tag::Char8 asUIntPointer ifFalse: {
        error("Expected a Char8 value.").
    }.

    (pointerValue >> ObjectModel::Tag::Bits asUIntPointer) asChar8
}.

public function ObjectModel::checkAndUnboxUInt8(value: Untyped) => UInt8 := {
    let pointerValue := ObjectModel::getTuplePointerUIntValue(value).
    let tag := pointerValue & ObjectModel::Tag::Mask asUIntPointer.
    tag = ObjectModel::Tag::UInt8 asUIntPointer ifFalse: {
        error("Expected an UInt8 value.").
    }.

    (pointerValue >> ObjectModel::Tag::Bits asUIntPointer) asUInt8
}.

public function ObjectModel::checkAndUnboxInt8(value: Untyped) => Int8 := {
    let pointerValue := ObjectModel::getTuplePointerIntValue(value).
    let tag := pointerValue & ObjectModel::Tag::Mask asIntPointer.
    tag = ObjectModel::Tag::Int8 asIntPointer ifFalse: {
        error("Expected an Int8 value.").
    }.

    (pointerValue >> ObjectModel::Tag::Bits asIntPointer) asInt8
}.

public function ObjectModel::checkAndUnboxBoolean(value: Untyped) => Boolean := {
    let pointerValue := ObjectModel::getTuplePointerUIntValue(value).
    pointerValue = ObjectModel::ImmediateTrivialConstant::False asUIntPointer ifTrue: {
        return: false
    }.
    pointerValue = ObjectModel::ImmediateTrivialConstant::True asUIntPointer ifTrue: {
        return: true
    }.

    error("Expected a Boolean value.")
}.

public function ObjectModel::checkAndUnboxChar16(value: Untyped) => Char16 := {
    let pointerValue := ObjectModel::getTuplePointerUIntValue(value).
    let tag := pointerValue & ObjectModel::Tag::Mask asUIntPointer.
    tag = ObjectModel::Tag::Char16 asUIntPointer ifFalse: {
        error("Expected a Char16 value.").
    }.

    (pointerValue >> ObjectModel::Tag::Bits asUIntPointer) asChar16
}.

public function ObjectModel::checkAndUnboxUInt16(value: Untyped) => UInt16 := {
    let pointerValue := ObjectModel::getTuplePointerUIntValue(value).
    let tag := pointerValue & ObjectModel::Tag::Mask asUIntPointer.
    tag = ObjectModel::Tag::UInt16 asUIntPointer ifFalse: {
        error("Expected an UInt16 value.").
    }.

    (pointerValue >> ObjectModel::Tag::Bits asUIntPointer) asUInt16
}.

public function ObjectModel::checkAndUnboxInt16(value: Untyped) => Int16 := {
    let pointerValue := ObjectModel::getTuplePointerIntValue(value).
    let tag := pointerValue & ObjectModel::Tag::Mask asIntPointer.
    tag = ObjectModel::Tag::Int16 asIntPointer ifFalse: {
        error("Expected an Int16 value.").
    }.

    (pointerValue >> ObjectModel::Tag::Bits asIntPointer) asInt16
}.

if: ObjectModel::PointerSize = 4sz then: {
    public function ObjectModel::checkAndUnboxChar32(value: Untyped) => Char32 := {
        let pointerValue := ObjectModel::getTuplePointerUIntValue(value).
        let tag := pointerValue & ObjectModel::Tag::Mask asUIntPointer.
        tag = ObjectModel::Tag::Char32 asUIntPointer ifTrue: {
            (pointerValue >> ObjectModel::Tag::Bits asUIntPointer) asChar32
        } ifFalse: {
            pointerValue = 0uptr ifTrue: {
                error("Expected an Char32 boxed value instead of nil.").
            }.

            let objectHeader := pointerValue reinterpretCastTo: ObjectModel::TupleHeader pointer.
            let objectType := objectHeader _ typePointer reinterpretCastTo: Type.
            objectType ~~ Char32 ifTrue: {
                error("Expected an Char32 boxed value.").
            }.

            (objectHeader + 1iptr reinterpretCastTo: Char32 pointer) load
        }.
    }.

    public function ObjectModel::checkAndUnboxUInt32(value: Untyped) => UInt32 := {
        let pointerValue := ObjectModel::getTuplePointerUIntValue(value).
        let tag := pointerValue & ObjectModel::Tag::Mask asUIntPointer.
        tag = ObjectModel::Tag::UInt32 asUIntPointer ifTrue: {
            (pointerValue >> ObjectModel::Tag::Bits asUIntPointer) asUInt32
        } ifFalse: {
            pointerValue = 0uptr ifTrue: {
                error("Expected an UInt32 boxed value instead of nil.").
            }.

            let objectHeader := pointerValue reinterpretCastTo: ObjectModel::TupleHeader pointer.
            let objectType := objectHeader _ typePointer reinterpretCastTo: Type.
            objectType ~~ UInt32 ifTrue: {
                error("Expected an UInt32 boxed value.").
            }.

            (objectHeader + 1iptr reinterpretCastTo: UInt32 pointer) load
        }.
    }.

    public function ObjectModel::checkAndUnboxInt32(value: Untyped) => Int32 := {
        let pointerValue := ObjectModel::getTuplePointerIntValue(value).
        let tag := pointerValue & ObjectModel::Tag::Mask asIntPointer.
        tag = ObjectModel::Tag::Int32 asIntPointer ifTrue: {
            (pointerValue >> ObjectModel::Tag::Bits asIntPointer) asUInt32
        } ifFalse: {
            pointerValue = 0iptr ifTrue: {
                error("Expected an UInt32 value instead of nil.").
            }.

            let objectHeader := pointerValue reinterpretCastTo: ObjectModel::TupleHeader pointer.
            let objectType := objectHeader _ typePointer reinterpretCastTo: Type.
            objectType ~~ Int32 ifTrue: {
                error("Expected an Int32 boxed value.").
            }.

            (objectHeader + 1iptr reinterpretCastTo: Int32 pointer) load
        }.
    }.

    public function ObjectModel::checkAndUnboxFloat32(value: Untyped) => Float32 := {
        let pointerValue := ObjectModel::getTuplePointerUIntValue(value).
        let tag := pointerValue & ObjectModel::Tag::Mask asUIntPointer.
        tag = ObjectModel::Tag::Float32 asUIntPointer ifTrue: {
            (pointerValue >> ObjectModel::Tag::Bits asUIntPointer) asUInt32 asIEEEFloat32Decoded
        } ifFalse: {
            pointerValue = 0uptr ifTrue: {
                error("Expected a Float32 boxed value instead of nil.").
            }.

            let objectHeader := pointerValue reinterpretCastTo: ObjectModel::TupleHeader pointer.
            let objectType := objectHeader _ typePointer reinterpretCastTo: Type.
            objectType ~~ Float32 ifTrue: {
                error("Expected a Float32 boxed value.").
            }.

            (objectHeader + 1iptr reinterpretCastTo: Float32 pointer) load
        }.
    }.
} else: {
    public function ObjectModel::checkAndUnboxChar32(value: Untyped) => Char32 := {
        let pointerValue := ObjectModel::getTuplePointerUIntValue(value).
        let tag := pointerValue & ObjectModel::Tag::Mask asUIntPointer.
        tag = ObjectModel::Tag::Char32 asUIntPointer ifFalse: {
            error("Expected a Char32 value.").
        }.

        (pointerValue >> ObjectModel::Tag::Bits asUIntPointer) asChar32
    }.

    public function ObjectModel::checkAndUnboxUInt32(value: Untyped) => UInt32 := {
        let pointerValue := ObjectModel::getTuplePointerUIntValue(value).
        let tag := pointerValue & ObjectModel::Tag::Mask asUIntPointer.
        tag = ObjectModel::Tag::UInt32 asUIntPointer ifFalse: {
            error("Expected an UInt32 value.").
        }.

        (pointerValue >> ObjectModel::Tag::Bits asUIntPointer) asUInt32
    }.

    public function ObjectModel::checkAndUnboxInt32(value: Untyped) => Int32 := {
        let pointerValue := ObjectModel::getTuplePointerIntValue(value).
        let tag := pointerValue & ObjectModel::Tag::Mask asIntPointer.
        tag = ObjectModel::Tag::Int32 asIntPointer ifFalse: {
            error("Expected an Int32 boxed value.").
        }.

        (pointerValue >> ObjectModel::Tag::Bits asIntPointer) asInt32
    }.

    public function ObjectModel::checkAndUnboxFloat32(value: Untyped) => Float32 := {
        let pointerValue := ObjectModel::getTuplePointerUIntValue(value).
        let tag := pointerValue & ObjectModel::Tag::Mask asUIntPointer.
        tag = ObjectModel::Tag::Float32 asUIntPointer ifFalse: {
            error("Expected a Float32 value.").
        }.

        (pointerValue >> ObjectModel::Tag::Bits asUIntPointer) asUInt32 asIEEEFloat32Decoded
    }.
}.

public function ObjectModel::checkAndUnboxUInt64(value: Untyped) => UInt64 := {
    let pointerValue := ObjectModel::getTuplePointerUIntValue(value).
    let tag := pointerValue & ObjectModel::Tag::Mask asUIntPointer.
    tag = ObjectModel::Tag::UInt64 asUIntPointer ifTrue: {
        (pointerValue >> ObjectModel::Tag::Bits asUIntPointer) asUInt64
    } ifFalse: {
        pointerValue = 0uptr ifTrue: {
            error("Expected an UInt64 boxed value instead of nil.").
        }.

        let objectHeader := pointerValue reinterpretCastTo: ObjectModel::TupleHeader pointer.
        let objectType := objectHeader _ type.
        objectType ~~ UInt64 ifTrue: {
            error("Expected an UInt64 boxed value.").
        }.

        (objectHeader + 1iptr reinterpretCastTo: UInt64 pointer) load
    }.
}.

public function ObjectModel::checkAndUnboxInt64(value: Untyped) => Int64 := {
    let pointerValue := ObjectModel::getTuplePointerIntValue(value).
    let tag := pointerValue & ObjectModel::Tag::Mask asIntPointer.
    tag = ObjectModel::Tag::Int64 asIntPointer ifTrue: {
        (pointerValue >> ObjectModel::Tag::Bits asIntPointer) asInt64
    } ifFalse: {
        pointerValue = 0iptr ifTrue: {
            error("Expected an UInt32 value instead of nil.").
        }.

        let objectHeader := pointerValue reinterpretCastTo: ObjectModel::TupleHeader pointer.
        let objectType := objectHeader _ type.
        objectType ~~ Int64 ifTrue: {
            error("Expected an UInt32 boxed value.").
        }.

        (objectHeader + 1iptr reinterpretCastTo: Int64 pointer) load
    }.
}.

public function ObjectModel::checkAndUnboxFloat64(value: Untyped) => Float64 := {
    let pointerValue := ObjectModel::getTuplePointerUIntValue(value).
    let tag := pointerValue & ObjectModel::Tag::Mask asUIntPointer.
    tag = ObjectModel::Tag::Float64 asUIntPointer ifTrue: {
        (pointerValue >> ObjectModel::Tag::Bits asUIntPointer) asUInt64 asIEEEFloat64Decoded
    } ifFalse: {
        pointerValue = 0uptr ifTrue: {
            error("Expected a Float64 boxed value instead of nil.").
        }.

        let objectHeader := pointerValue reinterpretCastTo: ObjectModel::TupleHeader pointer.
        let objectType := objectHeader _ type.
        objectType ~~ Float64 ifTrue: {
            error("Expected a Float64 boxed value.").
        }.

        (objectHeader + 1iptr reinterpretCastTo: Float64 pointer) load
    }.
}.

public function ObjectModel::checkAndUnboxPointer(pointerType: PointerLikeType, value: Untyped) => UIntPointer := {
    Untyped::==(value, nil) ifTrue: {
        0uptr
    } ifFalse: {
        let valueType := RawTuple::type(value).
        let objectHeader := ObjectModel::getTuplePointerUIntValue(value) reinterpretCastTo: ObjectModel::TupleHeader pointer.

        valueType == pointerType ifFalse: {
            ## Am I a box for the requested base type?
            (valueType isDirectSubtypeOf: pointerType baseType) ifTrue: {
                return: (objectHeader + 1iptr reinterpretCastTo: UIntPointer)
            }.

            error("Expected a pointer with a specific type.").
        }.

        objectHeader _ isBytes ifTrue: {
            (objectHeader + 1iptr reinterpretCastTo: UIntPointer pointer) load
        } ifFalse: {
            let slotCount := objectHeader _ slotCount.
            let slots := objectHeader + 1iptr reinterpretCastTo: AnyValue pointer.
            error("TODO: Unbox object oriented pointer.").
        }.
    }.
}.

public function ObjectModel::coerceValue(expectedType: Type, value: Untyped) => Untyped := {
    let valueType := RawTuple::type(value).
    (valueType isDirectSubtypeOf: expectedType) ifTrue: (return: value).
    
    error("TODO: ObjectModel::coerceValue").
}.

public function ObjectModel::coerceNullableValue(expectedType: Type, value: Untyped) => Untyped := {
    Untyped::==(value, nil) ifTrue: (return: nil).

    ObjectModel::coerceValue(expectedType, value)
}.

public function ObjectModel::typecheckValue(expectedType: Type, value: Untyped) => Void := {
    let valueType := RawTuple::type(value).
    (valueType isDirectSubtypeOf: expectedType) ifTrue: (return: value).

    error("Value with unexpected type " -- valueType printString -- " instead of " -- expectedType printString).
}.

public function ObjectModel::typecheckNullableValue(expectedType: Type, value: Untyped) => Void := {
    Untyped::==(value, nil) ifTrue: (return: void).

    ObjectModel::typecheckValue(expectedType, value)
}.

public function ObjectModel::allocateCaptureVectorOfType(captureVectorType: SequenceTupleType) => AnySequenceTuple
    := captureVectorType basicAllocate.

public function ObjectModel::makeClosureWithCaptureVector(functionDefinition: FunctionDefinition, captureVector: AnySequenceTuple) => Function := {
    let result := Function basicAllocate.
    result
        captureVector: captureVector;
        definition: functionDefinition;
        __type__: (functionDefinition analyzedType ifNil: Function);
        yourself.
}.

public function ObjectModel::allocaGC(size: Size, elementType: Type) => Void pointer := {
    let result := sysmel_pal_gcalloc(size).
    memset(result, 0i8, size).
    result
}.


public function ObjectModel::fetchUncheckedEntryPointOrInterpreterTrampoline(function: Function, interpreterTrampoline: UIntPointer) => UIntPointer := {
    let result := function definition uncheckedEntryPoint asUIntPointer.
    result = 0uptr ifTrue: {
        interpreterTrampoline
    } ifFalse: {
        result
    }
}.

public function ObjectModel::fetchUncheckedEntryPointMatchingBoxDescriptorOrBoxingTrampoline(function: Function, boxDescriptor: UIntPointer, boxingTrampoline: UIntPointer) => UIntPointer := {
    let definition := function definition.
    let result := definition uncheckedEntryPoint asUIntPointer.
    (result = 0uptr) || (definition boxDescriptor ~= boxDescriptor) ifTrue: {
        boxingTrampoline
    } ifFalse: {
        result
    }
}.

public function ObjectModel::interpretFunctionWithArguments(function: Function, arguments: Array) => Untyped
    := function interpretWithArgument: arguments.

## Generate the trampolines via macro metaprogramming.
public global ObjectModel::DirectFunctionApplicationTrampolines := Array new: 17.
public global ObjectModel::CheckedFunctionApplicationTrampolines := Array new: 17.
public global ObjectModel::SendWithReceiverTypeTrampolines := Array new: 17.
public global ObjectModel::SendTrampolines := Array new: 16.

public struct ObjectModel::InlineCacheEntry definition: {
    public field selector => Symbol.
    public field type => Type.
    public field foundMethod => AnyValue.
}.

public global ObjectModel::PolymorphicInlineCache::Size := 4sz.
public global ObjectModel::PolymorphicInlineCache::SizeMask := 3sz.
public struct ObjectModel::PolymorphicInlineCache definition: {
    public field preSequence => UInt32.
    public field postSequence => UInt32.
    public field entries => ObjectModel::InlineCacheEntry[ObjectModel::PolymorphicInlineCache::Size].

    public inline method lookForSelector: (selector: Symbol) type: (type: Type) ::=> AnyValue := {
        let matchingEntryIndex mutable := ObjectModel::PolymorphicInlineCache::Size.
        let readStartSequence := preSequence. ## TODO: Use atomic load operations here.
        (entries[0sz] selector == selector) && (entries[0sz] type == type) ifTrue: (matchingEntryIndex := 0sz) ifFalse: (
        (entries[1sz] selector == selector) && (entries[1sz] type == type) ifTrue: (matchingEntryIndex := 1sz) ifFalse: (
        (entries[2sz] selector == selector) && (entries[2sz] type == type) ifTrue: (matchingEntryIndex := 2sz) ifFalse: (
        (entries[3sz] selector == selector) && (entries[3sz] type == type) ifTrue: (matchingEntryIndex := 3sz)))).

        matchingEntryIndex < ObjectModel::PolymorphicInlineCache::Size ifFalse: {
            return: nil
        }.

        let matchingMethod := entries[matchingEntryIndex] foundMethod.
        let readEndSequece := postSequence.

        readStartSequence = readEndSequece ifTrue: {
            matchingMethod
        } ifFalse: {
            nil
        }
    }.

    public inline method addEntry: (foundMethod) forSelector: (selector: Symbol) type: (type: Type) ::=> Void := {
        ## TODO: Hold a write mutex here.

        ## FIXME: Use atomic fetch and add here
        let entryIndex := preSequence asSize & ObjectModel::PolymorphicInlineCache::SizeMask asSize.
        preSequence := preSequence + 1u32.

        entries[entryIndex] selector: selector.
        entries[entryIndex] type: type.
        entries[entryIndex] foundMethod: foundMethod.

        ## FIXME: Use atomic fetch and add here
        postSequence := postSequence + 1u32.
    }.
}.

(0sz until: 17sz) macroDo: {:ArgumentCount |
    let argumentNames := (0sz until: ArgumentCount) collect: {:(Size)each | ("arg" -- each asString) asSymbol}.
    let argumentNodes := argumentNames collect: {:(Symbol)eachName | eachName asMacroArgumentWithType: Untyped asMacroLiteral}.
    let argumentIdentifiers := argumentNames collect: {:(Symbol)eachName | eachName asMacroIdentifier}.
    let applyDirectName := ("ObjectModel::applyDirect" -- ArgumentCount asString) asSymbol.
    let applyName := ("ObjectModel::apply" -- ArgumentCount asString) asSymbol.
    let checkedEntryPointArgumentTypes := (Array new: 1sz + ArgumentCount) atAllPut: Untyped; yourself.
    let checkedEntryPointPointerType := (checkedEntryPointArgumentTypes => Untyped) pointer.

    ``{
        public function `,(applyDirectName asMacroLiteral)(function: Function, `@argumentNodes) => Untyped := {
            let definition := function definition.
            definition ifNil: {
                error("Cannot apply direct function without definition.")
            }.
            
            function ensureIsReadyForEvaluation.

            let checkedEntryPoint := definition checkedEntryPoint asUIntPointer.
            checkedEntryPoint ~= 0uptr ifTrue: {
                let checkedEntryPointFunction := checkedEntryPoint reinterpretCastTo: `,(checkedEntryPointPointerType asMacroLiteral).
                return: checkedEntryPointFunction(function, `@argumentIdentifiers)
            }.

            function interpretWithArgument: (`@argumentIdentifiers,)
        }.
        ObjectModel::DirectFunctionApplicationTrampolines at: `,(ArgumentCount asMacroLiteral) put: `,(applyDirectName asMacroIdentifier).

        public function `,(applyName asMacroLiteral)(functional: AnyValue, `@argumentNodes) => Untyped := {
            ObjectModel::isFunction(functional) ifTrue: {
                let function := functional uncheckedDownCastTo: Function.
                function requiresArgumentExpansionDuringApplication ifFalse: {
                    let definition := function definition.
                    definition ifNotNil: {
                        function ensureIsReadyForEvaluation.
                        
                        let checkedEntryPoint := definition checkedEntryPoint asUIntPointer.
                        checkedEntryPoint ~= 0uptr ifTrue: {
                            let checkedEntryPointFunction := checkedEntryPoint reinterpretCastTo: `,(checkedEntryPointPointerType asMacroLiteral).
                            return: checkedEntryPointFunction(functional, `@argumentIdentifiers)
                        }.
                        
                        function interpretWithArgument: (`@argumentIdentifiers,)
                    }.
                }
            }.

            functional applyWithArguments: (`@argumentIdentifiers,)
        }.
        ObjectModel::CheckedFunctionApplicationTrampolines at: `,(ArgumentCount asMacroLiteral) put: `,(applyName asMacroIdentifier).
    } macroEvalHere
}.

public inline function ObjectModel::lookupMethodWithInlineCache(inlineCache: ObjectModel::PolymorphicInlineCache pointer, type: Type, selector: Symbol) => AnyValue := {
    inlineCache ifNil: {
        return: ((type ifNil: Untyped) lookupSelector: selector)
    }.

    let cachedEntry := inlineCache _ lookForSelector: selector type: type.
    cachedEntry ifNotNil: {
        return: cachedEntry
    }.

    let lookupResult := (type ifNil: Untyped) lookupSelector: selector.
    lookupResult ifNotNil: {
        inlineCache _ addEntry: lookupResult forSelector: selector type: type
    }.

    lookupResult
}.

public inline function ObjectModel::lookupValidMethodWithReceiverTypeAndInlineCache(inlineCache: ObjectModel::PolymorphicInlineCache pointer, receiver: Untyped, type: Type, selector: Symbol) => AnyValue := {
    ObjectModel::lookupMethodWithInlineCache(inlineCache, type, selector)
}.

public inline function ObjectModel::lookupValidMethodWithReceiverAndInlineCache(inlineCache: ObjectModel::PolymorphicInlineCache pointer, receiver: Untyped, selector: Symbol) => AnyValue
    := ObjectModel::lookupValidMethodWithReceiverTypeAndInlineCache(inlineCache, receiver, RawTuple::type(receiver), selector).
    
(0sz until: 16sz) macroDo: {:ArgumentCount |
    let argumentNames := (0sz until: ArgumentCount) collect: {:(Size)each | ("arg" -- each asString) asSymbol}.
    let argumentNodes := argumentNames collect: {:(Symbol)eachName | eachName asMacroArgumentWithType: Untyped asMacroLiteral}.
    let argumentIdentifiers := argumentNames collect: {:(Symbol)eachName | eachName asMacroIdentifier}.
    let applyName := ("ObjectModel::apply" -- (ArgumentCount  + 1sz) asString) asSymbol.
    let sendWithReceiverTypeName := ("ObjectModel::sendWithReceiverType" -- ArgumentCount asString) asSymbol.
    let sendName := ("ObjectModel::send" -- ArgumentCount asString) asSymbol.

    ``{
        public function `,(sendWithReceiverTypeName asMacroLiteral)(inlineCache: ObjectModel::PolymorphicInlineCache pointer, receiver: Untyped, receiverType: Type, selector: Symbol, `@argumentNodes) => Untyped := {
            let foundMethod := ObjectModel::lookupMethodWithInlineCache(inlineCache, receiverType, selector).
            foundMethod ifNotNil: {
                return: `,(applyName asMacroIdentifier)(foundMethod, receiver, `@argumentIdentifiers)
            }.

            if: (1sz = `,(ArgumentCount asMacroLiteral)) && (selector == #doesNotUnderstand:) then: {
                error("Message not understood")
            } else: {
                ObjectModel::sendWithReceiverType1(inlineCache, receiver, receiverType, #doesNotUnderstand:, Message basicAllocate
                    selector: selector;
                    arguments: (`@argumentIdentifiers,);
                    yourself)
            }
        }.
        ObjectModel::SendWithReceiverTypeTrampolines at: `,(ArgumentCount asMacroLiteral) put: `,(sendWithReceiverTypeName asMacroIdentifier).

        public function `,(sendName asMacroLiteral)(inlineCache: ObjectModel::PolymorphicInlineCache pointer, receiver: Untyped, selector: Symbol, `@argumentNodes) => Untyped
            := `,(sendWithReceiverTypeName asMacroIdentifier)(inlineCache, receiver, RawTuple::type(receiver), selector, `@argumentIdentifiers).

        ObjectModel::SendTrampolines at: `,(ArgumentCount asMacroLiteral) put: `,(sendName asMacroIdentifier).
    } macroEvalHere
}.
