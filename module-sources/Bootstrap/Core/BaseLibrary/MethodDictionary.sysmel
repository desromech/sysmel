MethodDictionary::new adoptDefinitionOf: {:: MethodDictionary | MethodDictionary new}.

MethodDictionary definition: {
    public final eager method capacity => Size
        := self storage size / 2sz.

    public final eager method scanFor: key ::=> IntPointer := {
        let storage := self __slotNamedAt__: #storage.
        storage ifNil: { return: -1iptr }.

        let capacity := storage size / 2sz.
        let naturalIndex := key identityHash % capacity.

        let i mutable := naturalIndex.
        while: (i < capacity) do: {
            let storageKey := storage __uncheckedSlotAt__: i*2sz.
            if: (key == storageKey) || (__hashtableEmptyElement__ == storageKey) then: {
                return: i asIntPointer
            }
        } continueWith: (i := i + 1sz).

        i := 0sz.
        while: (i < naturalIndex) do: {
            let storageKey := storage __uncheckedSlotAt__: i*2sz.
            if: (key == storageKey) || (__hashtableEmptyElement__ == storageKey) then: {
                return: i asIntPointer
            }
        } continueWith: (i := i + 1sz).

        -1iptr
    }.

    public eager method addNoCheckKey: key value: value ::=> Void := {
        let index := (self scanFor: key) asSize.
        storage at: index*2sz put: key.
        storage at: index*2sz + 1sz put: value.
    }.

    public eager method increaseCapacity => Void := {
        let oldCapacity := self capacity.
        let newCapacity := oldCapacity * 2sz max: 8sz.
        let oldStorage := storage.
        let oldStoragePairCount := oldCapacity*2sz.

        let newCapacityPairCount := newCapacity*2sz.
        storage := Array new: newCapacityPairCount.
        let i mutable := 0sz.
        while: (i < newCapacityPairCount) do: {
            storage at: i put: __hashtableEmptyElement__.
        } continueWith: (i := i + 2sz).

        i := 0sz.
        while: (i < oldStoragePairCount) do: {
            let oldKey := oldStorage at: i.
            __hashtableEmptyElement__ == oldKey ifFalse: {
                let oldValue := oldStorage at: i + 1sz.
                self addNoCheckKey: oldKey value: oldValue.
            }
        } continueWith: (i := i + 2sz)
    }.

    public eager method checkCapacityIncreaseCondition => Void := {
        let capacityThreshold := self capacity * 4sz / 5sz.
        self size >= capacityThreshold ifTrue: {
            self increaseCapacity
        }
    }.

    public final eager method at: key := {
        let index := self scanFor: key.
        index >= 0iptr ifTrue: {
            let methodIndex := index *2iptr + 1iptr.
            storage at: methodIndex asSize
        } ifFalse: {
            self error: "Key not found in method dictionary."
        }
    }.

    public final eager method at: key put: value ::=> Void := {
        let index mutable := self scanFor: key.
        index < 0iptr ifTrue: {
            self increaseCapacity.
            index := self scanFor: key.
        }.

        let methodIndex := index asSize *2sz.
        let isNewKey := (storage at: methodIndex) == __hashtableEmptyElement__.
        storage
            at: methodIndex asSize put: key;
            at: methodIndex asSize + 1sz put: value.

        isNewKey ifTrue: {
            size := size + 1sz.
            self checkCapacityIncreaseCondition
        }.
    }.

    public final eager method atOrNil: selector := {
        let index := self scanFor: selector.
        index >= 0iptr ifTrue: {
            let methodIndex := index asSize *2sz + 1sz.
            storage at: methodIndex asSize
        } ifFalse: {
            nil
        }
    }.
}.
