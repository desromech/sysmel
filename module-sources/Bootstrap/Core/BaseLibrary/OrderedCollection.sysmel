OrderedCollection::new adoptDefinitionOf: {:: OrderedCollection | OrderedCollection new}.

OrderedCollection definition: {
    public eager method capacity => Size
        := storage ifNil: 0sz ifNotNil: storage size.

    public eager method ensureCapacityForAtLeast: (additionalRequiredCapacity: Size) ::=> Void := {
        let requiredCapacity := size + additionalRequiredCapacity.
        requiredCapacity <= self capacity ifTrue: {return: void}.

        let newCapacity := requiredCapacity asLargerPowerOfTwo max: 4sz.
        let newStorage := Array basicAllocate: newCapacity.
        let currentSize := size.
        let i mutable := 0sz.
        while: (i < currentSize) do: {
            newStorage at: i put: (storage at: i)
        } continueWith: (i := i + 1sz).

        storage := newStorage.
    }.

    public eager method untypedAdd: (element: Untyped) ::=> Void := {
        self ensureCapacityForAtLeast: 1sz.
        storage untypedAt: size put: element.
        size := size + 1sz.
    }.

    public eager method identityIncludes: element ::=> Boolean := {
        let i mutable := 0sz.
        let size := self size.
        while: (i < size) do: {
            element == (storage at: i) ifTrue: {
                return: true
            }
        } continueWith: (i := i + 1sz).

        false
    }.

    public eager method add: element ::=> Void
        := self untypedAdd: element.

    public eager method addAll: (elements: Collection) ::=> Void := {
        self ensureCapacityForAtLeast: elements size.
        elements do: {:each :: Void |
            storage at: size put: each.
            size := size + 1sz
        }
    }.

    public override eager method asArray ::=> Array
        := storage isNil || (size = 0sz)
            ifTrue: #()
            ifFalse: (storage first: size).

    public method untypedAt: (index: Size) ::=> Untyped
        := storage untypedAt: index.

    public method removeAll => Void := {
        size := 0sz.
    }
}.
