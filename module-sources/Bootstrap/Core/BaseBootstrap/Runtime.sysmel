Function
    withSelector: #withEagerAnalysis addMethod: {:(Function)self :: Function |
        self ensureAnalysis.
        self
    }.

FunctionDefinition
    withSelector: #addFlags: addMethod: {:(FunctionDefinition)self :(Bitflags)flag :: Void |
        self flags: self flags | flag
    } withEagerAnalysis.

Function
    withSelector: #addFlags: addMethod: {:(Function)self :(Bitflags)flag :: Void |
        self flags: self flags | flag.
        let: #definition with: self definition.
        if: definition ~~ nil then: (definition addFlags: flag).
    } withEagerAnalysis.

Function
    withSelector: #makeMacro addMethod: {:(Function)self :: Function |
        self addFlags: FunctionFlags::Macro.
        self
    } withEagerAnalysis;
    withSelector: #makePure addMethod: {:(Function)self :: Function |
        self addFlags: FunctionFlags::Pure.
        self
    } withEagerAnalysis;
    withSelector: #makeFinal addMethod: {:(Function)self :: Function |
        self addFlags: FunctionFlags::Final.
        self
    } withEagerAnalysis;
    withSelector: #makeVirtual addMethod: {:(Function)self :: Function |
        self addFlags: FunctionFlags::Virtual.
        self
    } withEagerAnalysis;
    withSelector: #makeAbstract addMethod: {:(Function)self :: Function |
        self addFlags: FunctionFlags::Abstract.
        self
    } withEagerAnalysis;
    withSelector: #makeOverride addMethod: {:(Function)self :: Function |
        self addFlags: FunctionFlags::Override.
        self
    } withEagerAnalysis;
    withSelector: #makeStatic addMethod: {:(Function)self :: Function |
        self addFlags: FunctionFlags::Static.
        self
    } withEagerAnalysis;

    withSelector: #makeMemoized addMethod: {:(Function)self :: Function |
        self addFlags: FunctionFlags::Memoized.
        self
    } withEagerAnalysis;
    withSelector: #makeTemplate addMethod: {:(Function)self :: Function |
        self addFlags: FunctionFlags::Template.
        self
    } withEagerAnalysis;
    withSelector: #makeMemoizedTemplate addMethod: {:(Function)self :: Function |
        self addFlags: FunctionFlags::Memoized | FunctionFlags::Template.
        self
    } withEagerAnalysis;

    withSelector: #makeExternC addMethod: {:(Function)self :: Function |
        self addFlags: FunctionFlags::ExternC.
        self
    } withEagerAnalysis;
    withSelector: #makeDLLExport addMethod: {:(Function)self :: Function |
        self addFlags: FunctionFlags::DLLExport.
        self
    } withEagerAnalysis;
    withSelector: #makeDLLImport addMethod: {:(Function)self :: Function |
        self addFlags: FunctionFlags::DLLExport.
        self
    } withEagerAnalysis;

    withSelector: #makeInline addMethod: {:(Function)self :: Function |
        self addFlags: FunctionFlags::Inline.
        self
    } withEagerAnalysis;
    withSelector: #makeAlwaysInline addMethod: {:(Function)self :: Function |
        self addFlags: FunctionFlags::AlwaysInline.
        self
    } withEagerAnalysis;
    withSelector: #makeNeverInline addMethod: {:(Function)self :: Function |
        self addFlags: FunctionFlags::NeverInline.
        self
    } withEagerAnalysis.

ProgramEntity
    withSelector: #ensureAnalysis addMethod: {:(ProgramEntity)self :: Void |
        void
    } makeVirtual.

Type
    withSelector: #=> addMethod: {:(Type)self :(Type)resultType :: SimpleFunctionType |
        SimpleFunctionTypeTemplate((self,), 0bflgs, resultType)
    } makePure makeFinal withEagerAnalysis;
    withSelector: #computeLayout addMethod: {:(Type)self :: Void |
        void
    } makeVirtual;
    withSelector: #ensureLayoutIsComputed addMethod: {:(Type)self :: Void |
        if: self instanceAlignment = 0sz then: (self computeLayout).
        void
    } makeFinal;
    withSelector: #ensureAnalysis addMethod: {:(Type)self :: Void |
        void
    } makeOverride withEagerAnalysis;
    withSelector: #createBasicInitializeMethod addMethod: {:(Type)self :: Void |
        void
    } makeVirtual withEagerAnalysis;
    withSelector: #validBasicInitializeMethod addMethod: {:(Type)self :: Function |
        let: #method with: (self __slotNamedAt__: #basicInitializeMethod).
        if: method == nil then: {
            self createBasicInitializeMethod.
            self __slotNamedAt__: #basicInitializeMethod
        } else: {
            method
        }
    } makeFinal withEagerAnalysis;

    withSelector: #withSelector:replaceMethod: addMethod: {:(Type)self :selector :newMethod :: Void |
        ((self __slotNamedAt__: #methodDictionary) at: selector) adoptDefinitionOf: newMethod
    } withEagerAnalysis;
    withSelector: #withSelector:addOrReplaceMethod: addMethod: {:(Type)self :selector :newMethod :: Void |
        let: #methodDictionary with: self validMethodDictionary.
        let: #existent with: (methodDictionary atOrNil: selector).
        if: existent == nil then: {
            methodDictionary at: selector put: newMethod.
            self flushLookupSelector: selector
        } else: {
            existent adoptDefinitionOf: newMethod
        }
    } withEagerAnalysis.

ValueBox
    withSelector: #loadFrom:atOffset:withType: addMethod: {:(ValueBox)self :(Untyped)containerBase :(IntPointer)offset :(Type)valueType :: valueType |
        (RawTuple::slotAt:)(self, 0sz)
    } makeFinal withEagerAnalysis;
    withSelector: #store:in:atOffset:withType: addMethod: {:(ValueBox)self :(Untyped)value :(Untyped)containerBase :(IntPointer)offset :(Type)valueType :: Void |
        RawTuple::slotAt:put:(self, 0sz, value).
        void
    } makeFinal withEagerAnalysis.

TypeSlot
    withSelector: #loadFrom:atOffset:withType: addMethod: {:(TypeSlot)self :(Untyped)containerBase :(IntPointer)offset :(Type)valueType :: valueType |
        (RawTuple::slotAt:)(containerBase, (tuple: self slotNamedAt: #index))
    } makeFinal withEagerAnalysis;
    withSelector: #store:in:atOffset:withType: addMethod: {:(TypeSlot)self :(Untyped)value :(Untyped)containerBase :(IntPointer)offset :(Type)valueType :: Void |
        RawTuple::slotAt:put:(containerBase, (tuple: self slotNamedAt: #index), value).
        void
    } makeFinal withEagerAnalysis.

Type
    withSelector: #lookupLocalSelector: addMethod: {:(Type)self :(Symbol)selector :: AnyValue |
        let: #methodDictionary with: self methodDictionary.
        if: methodDictionary ~~ nil
            then: (methodDictionary atOrNil: selector)
            else: nil
    } makeFinal withEagerAnalysis;
    withSelector: #ensureAnalysisOfMethodWithSelector: addMethod: {:(Type)self :(Symbol)selector :: Void |
        (self methodDictionary at: selector) ensureAnalysis
    } withEagerAnalysis;
    withSelector: #>> addMethod: {:(Type)self :(Symbol)selector :: AnyValue |
        self lookupLocalSelector: selector
    } makeFinal withEagerAnalysis;
    withSelector: #lookupSelector: addMethod: {:(Type)self :(Symbol)selector :: AnyValue |
        let: #method with: (self lookupLocalSelector: selector).
        if: method ~~ nil
        then: method
        else: {
            let: #supertype with: self supertype.
            if: supertype ~~ nil
                then: (supertype lookupSelector: selector)
                else: (nil)
        }
    } makeFinal;
    ensureAnalysisOfMethodWithSelector: #lookupSelector:.

AnyValue
    basicInitializeMethod: {:(AnyValue)self :: Void | void } makeVirtual withEagerAnalysis;
    withSelector: #basicInitialize addMethod: AnyValue basicInitializeMethod;
    withSelector: #initialize addMethod: {:(AnyValue)self :: Void | } makeVirtual withEagerAnalysis;
    withSelector: #yourself addMethod: {:(AnyValue)self :: self __type__ |
        <primitive: #yourself>
        <targetDefinedPrimitive>
        self
    } makePure makeFinal withEagerAnalysis;

    withSelector: #postCopy addMethod: {:(AnyValue)self :: Void | } makeVirtual withEagerAnalysis;
    withSelector: #shallowCopy addMethod: {:(AnyValue)self :: self __type__ | RawTuple::shallowCopy(self) } makeFinal withEagerAnalysis;
    withSelector: #copy addMethod: {:(AnyValue)self :: self __type__ | self shallowCopy postCopy; yourself } withEagerAnalysis;

    withSelector: #doesNotUnderstand: addMethod: {:(AnyValue)self :(Message)message |
        error("doesNotUnderstand: " -- message selector printString)
    } withEagerAnalysis;

    withSelector: #isNil addMethod: {:(AnyValue)self :: Boolean | self == nil } makePure makeFinal withEagerAnalysis;
    withSelector: #isNotNil addMethod: {:(AnyValue)self :: Boolean | self ~~ nil } makePure makeFinal withEagerAnalysis;

    withSelector: #hash addMethod: {:(AnyValue)self :: Size | self identityHash } makeVirtual makePure withEagerAnalysis;
    withSelector: #= addMethod: {:(AnyValue)self :other :: Boolean | self == other } makeVirtual makePure withEagerAnalysis;
    withSelector: #~= addMethod: {:(AnyValue)self :other :: Boolean | (self = other) not } makeVirtual makePure withEagerAnalysis;
    withSelector: #recordBindingWithOwner:andName: addMethod: {:(AnyValue)self :(ProgramEntity)owner :(Symbol)name :: Void | void} makeVirtual withEagerAnalysis.

Object
    withSelector: #class addMethod: {:(Object)self :: self __type__ __type__ | self __type__ } makePure makeFinal withEagerAnalysis;
    withSelector: #species addMethod: {:(Object)self :: Class | self class } makeVirtual withEagerAnalysis;

    withSelector: #error: addMethod: {:(Object)self :(String)errorMessage :: Unwinds | error(errorMessage) } withEagerAnalysis;
    withSelector: #primitiveFailed addMethod: {:(Object)self :: Unwinds | error("Primitive failed") } withEagerAnalysis;
    withSelector: #assert: addMethod: {:(Object)self :(Boolean)condition :: Void |
        if: condition then: void else: error("Assertion failure.")
    } withEagerAnalysis;
    withSelector: #subclassResponsibility addMethod: {:(Object)self :: Unwinds | self error: self __type__ printString -- " Subclass responsibility." } withEagerAnalysis;
    withSelector: #shouldBeImplemented addMethod: {:(Object)self :: Unwinds | self error: self __type__ printString -- " should be implemented." } withEagerAnalysis;
    withSelector: #doesNotUnderstand: addMethod: {:(AnyValue)self :(Message)message |
        error((self __type__ printString -- " doesNotUnderstand: ") -- message selector printString)
    } makeVirtual withEagerAnalysis.

Type
    withSelector: #asCanonicalPendingInstanceType addMethod: {:(Type)self :: Type |
        AnyValue
    } makePure makeVirtual withEagerAnalysis;
    withSelector: #asCanonicalType addMethod: {:(Type)self :: Type |
        self
    } makePure makeVirtual withEagerAnalysis;
    withSelector: #asDecayedType addMethod: {:(Type)self :: Type |
        self
    } makePure makeVirtual withEagerAnalysis;
    withSelector: #decayReferenceLikeForReceiverType: addMethod: {:(Type)self :(ReferenceLikeType)reference :: Type |
        self
    } makePure makeVirtual withEagerAnalysis;
    withSelector: #asDecayedReceiverType addMethod: {:(Type)self :: Type |
        self
    } makePure makeVirtual withEagerAnalysis;
    withSelector: #isDirectSubtypeOf: addMethod: {:(Type)self :(Type)expectedParent :: Boolean |
        if: self == expectedParent
        then: true
        else: {
            let: #supertype with: self supertype.
            if: supertype ~~ nil
                then: (supertype isDirectSubtypeOf: expectedParent )
                else: false
        }
    } makePure;
    ensureAnalysisOfMethodWithSelector: #isDirectSubtypeOf:;
    withSelector: #isSubtypeOf: addMethod: {:(Type)self :(Type)expectedParent :: Boolean |
        if: self == expectedParent
        then: true
        else: {
            let: #supertype with: self supertype.
            if: supertype ~~ nil
                then: (supertype isSubtypeOf: expectedParent )
                else: false
        }
    } makePure;
    ensureAnalysisOfMethodWithSelector: #isSubtypeOf:.

Boolean __type__ withSelector: #asCanonicalType addMethod: {:(Type)self :: Type | Boolean } makePure makeOverride withEagerAnalysis.
Integer __type__ withSelector: #asCanonicalType addMethod: {:(Type)self :: Type | Integer } makePure makeOverride withEagerAnalysis.

AnyValue
    withSelector: #isKindOf: addMethod: {:(AnyValue)self :(Type)expectedType :: Boolean |
        self __type__ isSubtypeOf: expectedType
    } makePure makeFinal withEagerAnalysis;
    withSelector: #answersTo: addMethod: {:(AnyValue)self :(Symbol)selector :: Boolean |
        (self __type__ lookupSelector: selector) ~~ nil
    } makePure makeFinal withEagerAnalysis.

## Early new implementation
Type
    withSelector: #hasAnyFlag: addMethod: {:(Type)self :(Bitflags)flag :: Boolean |
        (self flags & flag) ~= 0bflgs
    } makeFinal withEagerAnalysis;
    withSelector: #isDynamic addMethod: {:(Type)self :: Boolean |
        self hasAnyFlag: TypeFlags::Dynamic.
    } makeFinal withEagerAnalysis;
    withSelector: #isBytes addMethod: {:(Type)self :: Boolean |
        self hasAnyFlag: TypeFlags::Bytes.
    } makeFinal withEagerAnalysis;
    withSelector: #isWeak addMethod: {:(Type)self :: Boolean |
        self hasAnyFlag: TypeFlags::Weak.
    } makeFinal withEagerAnalysis;
    withSelector: #isPointerLikeType addMethod: {:(Type)self :: Boolean |
        self hasAnyFlag: TypeFlags::PointerValue | TypeFlags::ReferenceValue.
    } makeFinal withEagerAnalysis;
    withSelector: #basicAllocate addMethod: {:(Type)self :: self |
        <primitive: #basicAllocate>
        let: #result with: (if: self isBytes
            then: RawTuple::byteNew(0sz)
            else: RawTuple::new(self totalSlotCount)).
        (RawTuple::type:)(result, self).
        if: self isWeak then: RawTuple::markWeak(result).
        result
    } makeVirtual withEagerAnalysis;
    withSelector: #basicNew addMethod: {:(Type)self :: self |
        <primitive: #basicNew>
        let: #result with: self basicAllocate.
        let: #basicInitializeMethod with: self validBasicInitializeMethod.
        if: basicInitializeMethod ~~ nil then: basicInitializeMethod(result).
        result
    } makeVirtual withEagerAnalysis;
    withSelector: #new addMethod: {:(Type)self :: self |
        <primitive: #new>
        self basicNew initialize; yourself
    } withEagerAnalysis;
    withSelector: #asReceiverType addMethod: {:(Type)self :: Type |
        self
    } makePure makeVirtual withEagerAnalysis;
    withSelector: #asResultType addMethod: {:(Type)self :: Type |
        self
    } makePure makeVirtual withEagerAnalysis;
    withSelector: #lookupLocalMacroSelector: addMethod: {:(Type)self :(Symbol)selector :: AnyValue |
        let: #methodDictionary with: self macroMethodDictionary.
        if: methodDictionary ~~ nil
            then: (methodDictionary atOrNil: selector)
            else: nil
    } makeFinal;
    withSelector: #lookupMacroSelector: addMethod: {:(Type)self :(Symbol)selector :: AnyValue |
        let: #method with: (self lookupLocalMacroSelector: selector).
        if: method ~~ nil
        then: method
        else: {
            let: #supertype with: self supertype.
            if: supertype ~~ nil
                then: (supertype lookupMacroSelector: selector)
                else: (nil)
        }
    } makeFinal;
    withSelector: #lookupLocalFallbackSelector: addMethod: {:(Type)self :(Symbol)selector :: AnyValue |
        let: #methodDictionary with: self fallbackMethodDictionary.
        if: methodDictionary ~~ nil
            then: (methodDictionary atOrNil: selector)
            else: nil
    } makeFinal;
    withSelector: #lookupFallbackSelector: addMethod: {:(Type)self :(Symbol)selector :: AnyValue |
        let: #method with: (self lookupLocalFallbackSelector: selector).
        if: method ~~ nil
        then: method
        else: {
            let: #supertype with: self supertype.
            if: supertype ~~ nil
                then: (supertype lookupFallbackSelector: selector)
                else: (nil)
        }
    } makeFinal.

ASTDownCastNode __type__
    withSelector: #makeForASTNode:targetType: addMethod: {:(ASTDownCastNode __type__)self :(ASTNode)astNode :(Type)targetType :: self |
        let: #sourcePosition with: astNode sourcePosition.

        self new
            sourcePosition: sourcePosition;
            analyzedType: targetType;
            typeExpression: (ASTLiteralNode new
                analyzedType: targetType __type__;
                sourcePosition: sourcePosition;
                value: targetType;
                yourself);
            valueExpression: astNode;
            yourself
    } withEagerAnalysis.

Untyped __type__
    withSelector: #coerceASTNode:into:withEnvironment: addMethod: {:(Type)self :(ASTNode)astNode :(Type)targetType :(AnalysisAndEvaluationEnvironment)environment :: ASTNode |
        if: self == targetType then: {
            astNode
        } else: {
            ASTDownCastNode makeForASTNode: astNode targetType: targetType
        }.
    } withEagerAnalysis.
    
TypeSlot
    withSelector: #hasAnyFlags: addMethod: {:(TypeSlot)self :(Bitflags)flags :: Boolean |
        (self flags & flags) ~= 0bflgs
    } withEagerAnalysis;
    withSelector: #isPublic addMethod: {:(TypeSlot)self :: Boolean |
        self hasAnyFlags: TypeSlotFlags::Public
    } withEagerAnalysis;
    withSelector: #isReadonly addMethod: {:(TypeSlot)self :: Boolean |
        self hasAnyFlags: TypeSlotFlags::ReadOnly
    } withEagerAnalysis;
    withSelector: #isNoRTTIExcluded addMethod: {:(TypeSlot)self :: Boolean |
        self hasAnyFlags: (TypeSlotFlags::NoRTTIExcluded | TypeSlotFlags::MinRTTIExcluded) | TypeSlotFlags::NoSourceDefinitionExcluded
    } withEagerAnalysis;
    withSelector: #isMinRTTIExcluded addMethod: {:(TypeSlot)self :: Boolean |
        self hasAnyFlags: TypeSlotFlags::MinRTTIExcluded | TypeSlotFlags::NoSourceDefinitionExcluded
    } withEagerAnalysis;
    withSelector: #isNoSourceDefinitionExcluded addMethod: {:(TypeSlot)self :: Boolean |
        self hasAnyFlags: TypeSlotFlags::NoSourceDefinitionExcluded
    } withEagerAnalysis;
    withSelector: #isBytecode addMethod: {:(TypeSlot)self :: Boolean |
        self hasAnyFlags: TypeSlotFlags::Bytecode
    } withEagerAnalysis;
    withSelector: #isDebugInformation addMethod: {:(TypeSlot)self :: Boolean |
        self hasAnyFlags: TypeSlotFlags::DebugInformation
    } withEagerAnalysis;
    withSelector: #isJitSpecific addMethod: {:(TypeSlot)self :: Boolean |
        self hasAnyFlags: TypeSlotFlags::JitSpecific
    } withEagerAnalysis;
    withSelector: #generateAccessorsOn: addMethod: {:(TypeSlot)typeSlot :(Type)type :: Void |
        if: typeSlot isPublic then: {
            let: #slotType with: typeSlot type.
            let: #getterName with: typeSlot name.
            let: #receiverType with: type asReceiverType.

            if: receiverType isPointerLikeType then: {
                ## Getter.
                let: #getterMethod with: ({:(receiverType)self :: slotType |
                    (RawTuple::refTypeSlotAt:)(self, typeSlot)
                } makePure makeFinal makeAlwaysInline recompileAndOptimize).

                if: type supertype isNotNil then: (if: (type supertype lookupSelector: getterName) isNotNil then: (getterMethod makeOverride)).
                type withSelector: getterName addMethod: getterMethod.

                ## Setter
                if: typeSlot isReadonly not then: {
                    let: #setterMethod with: ({:(receiverType)self :(slotType)value :: Void |
                        (RawTuple::refTypeSlotAt:put:)(self, typeSlot, value)
                    } makeFinal makeAlwaysInline recompileAndOptimize).

                    let: #setterName with: (typeSlot name asString -- ":") asSymbol.
                    if: type supertype isNotNil then: (if: (type supertype lookupSelector: setterName) isNotNil then: (setterMethod makeOverride)).

                    type withSelector: setterName addMethod: setterMethod.
                }
            } else: {
                ## Getter.
                let: #getterMethod with: ({:(receiverType)self :: slotType |
                    (RawTuple::typeSlotAt:)(self, typeSlot)
                } makePure makeFinal makeAlwaysInline recompileAndOptimize).

                if: type supertype isNotNil then: (if: (type supertype lookupSelector: getterName) isNotNil then: (getterMethod makeOverride)).
                type withSelector: getterName addMethod: getterMethod.

                ## Setter
                if: typeSlot isReadonly not then: {
                    let: #setterMethod with: ({:(receiverType)self :(slotType)value :: Void |
                        (RawTuple::typeSlotAt:put:)(self, typeSlot, value)
                    } makeFinal makeAlwaysInline recompileAndOptimize).
                    let: #setterName with: (typeSlot name asString -- ":") asSymbol.

                    if: type supertype isNotNil then: (if: (type supertype lookupSelector: setterName) isNotNil then: (setterMethod makeOverride)).
                    type withSelector: setterName addMethod: setterMethod.
                }
            }.
        }
    } withEagerAnalysis.

Array
    withSelector: #at: addMethod: {:(Array)self :(Size)index |
        self __slotAt__: index
    } makeVirtual makeFinal withEagerAnalysis;
    withSelector: #at:put: addMethod: {:(Array)self :(Size)index :value :: Void |
        self __slotAt__: index put: value
    } makeVirtual makeFinal withEagerAnalysis;
    withSelector: #untypedAt: addMethod: {:(Array)self :(Size)index :: Untyped |
        self __slotAt__: index
    } makeVirtual makeFinal withEagerAnalysis;
    withSelector: #untypedAt:put: addMethod: {:(Array)self :(Size)index :(Untyped)value :: Void |
        self __slotAt__: index put: value
    } makeVirtual makeFinal withEagerAnalysis;
    withSelector: #size addMethod: {:(Array)self :: Size |
        self __size__
    } makeVirtual makeFinal withEagerAnalysis;
    withSelector: #doWithIndex: addMethod: {:(Array)self :aBlock :: Void |
        let: #i mutableWith: 0sz.
        let: #size with: self size.

        while: i < size do: {
            aBlock(self at: i, i)
        } continueWith: (i := i + 1sz)
    } makeVirtual makeFinal.

Type
    withSelector: #coerceASTNode:into:withEnvironment: addMethod: {:(Type)self :(ASTNode)astNode :(Type)targetType :(AnalysisAndEvaluationEnvironment)environment :: ASTNode |
        if: (self isSubtypeOf: targetType)
        then: astNode
        else: {
            if: self isDynamic then: {
                ## TODO: Add a downcast node.
                ##astNode.
                ASTDownCastNode makeForASTNode: astNode targetType: targetType
            } else: {
                error((((astNode sourcePosition printString -- ": Cannot coerce node from type ") -- self printString) -- " into type ") -- targetType printString)
            }
        }
    } makeVirtual withEagerAnalysis;
    withSelector: #coerceASTNode:withEnvironment: addMethod: {:(Type)self :(ASTNode)astNode :(AnalysisAndEvaluationEnvironment)environment :: ASTNode |
        let: #sourceType with: astNode analyzedType.
        if: (if: sourceType ~~ nil then: sourceType ~= self else: false)
        then: (sourceType coerceASTNode: astNode into: self withEnvironment: environment)
        else: astNode
    } makeVirtual withEagerAnalysis;
    withSelector: #isReferenceLikeType addMethod: {:(Type)self :: Boolean | false } makeVirtual makePure withEagerAnalysis;
    withSelector: #isReferenceType addMethod: {:(Type)self :: Boolean | false } makeVirtual makePure withEagerAnalysis;
    withSelector: #isTemporaryReferenceType addMethod: {:(Type)self :: Boolean | false } makeVirtual makePure withEagerAnalysis;

    withSelector: #addFlags: addMethod: {:(Type)self :(Bitflags)flag :: Void |
        self flags: self flags | flag
    } withEagerAnalysis;

    withSelector: #makeNullable addMethod: {:(Type)self :: Type |
        self addFlags: TypeFlags::Nullable.
        self
    } withEagerAnalysis;
    withSelector: #isNullable addMethod: {:(Type)self :: Boolean |
        self hasAnyFlag: TypeFlags::Nullable.
    } withEagerAnalysis;

    withSelector: #makeBytes addMethod: {:(Type)self :: Type |
        self addFlags: TypeFlags::Bytes.
        self
    } withEagerAnalysis;

    withSelector: #makeWeak addMethod: {:(Type)self :: Type |
        self addFlags: TypeFlags::Weak.
        self
    } withEagerAnalysis;

    withSelector: #makeImmediate addMethod: {:(Type)self :: Type |
        self addFlags: TypeFlags::Immediate.
        self
    } withEagerAnalysis;
    withSelector: #isImmediate addMethod: {:(Type)self :: Boolean |
        self hasAnyFlag: TypeFlags::Immediate.
    } withEagerAnalysis;

    withSelector: #makeFinal addMethod: {:(Type)self :: Type |
        self addFlags: TypeFlags::Final.
        self
    } withEagerAnalysis;
    withSelector: #isFinal addMethod: {:(Type)self :: Boolean |
        self hasAnyFlag: TypeFlags::Final.
    } withEagerAnalysis;

    withSelector: #makeAbstract addMethod: {:(Type)self :: Type |
        self addFlags: TypeFlags::Abstract.
        self
    } withEagerAnalysis;
    withSelector: #isAbstract addMethod: {:(Type)self :: Boolean |
        self hasAnyFlag: TypeFlags::Abstract.
    } withEagerAnalysis;

    withSelector: #makeFunction addMethod: {:(Type)self :: Type |
        self addFlags: TypeFlags::Function.
        self
    } withEagerAnalysis;
    withSelector: #isFunction addMethod: {:(Type)self :: Boolean |
        self hasAnyFlag: TypeFlags::Function.
    } withEagerAnalysis;

    withSelector: #defaultValue addMethod: {:(Type)self :: self |
        if: self isNullable
            then: nil
            else: (self error: "A proper default value must be defined for " -- self printString).
    } makeVirtual withEagerAnalysis;

    withSelector: #validSlotDictionary addMethod: {:(Type)self :: MethodDictionary |
        if: self slotDictionary == nil then: (self slotDictionary: MethodDictionary new).
        self slotDictionary
    } withEagerAnalysis;
    withSelector: #addSlotToDictionary: addMethod: {:(Type)self :(TypeSlot)slot :: Void |
        let: #slotName with: slot name.
        if: slotName ~~ nil then: {
            self validSlotDictionary at: slotName put: slot
        }
    } withEagerAnalysis;
    withSelector: #validSupertypeTotalSlotCount addMethod: {:(Type)self :: Size |
        let: #supertype with: self supertype.
        if: supertype == nil then: 0sz else: supertype validTotalSlotCount.
    } makeFinal;
    withSelector: #validSlots addMethod: {:(Type)self :: Array |
        let: #pendingSlots with: self pendingSlots.
        if: pendingSlots ~~ nil then: {

            let: #pendingSlotsArray with: pendingSlots asArray.
            let: #localBaseIndex with: self slots size.
            let: #baseIndex with: self validSupertypeTotalSlotCount + localBaseIndex.

            pendingSlotsArray doWithIndex: {:pendingSlot :pendingSlotIndex :: Void |
                let: #localSlotIndex with: localBaseIndex + pendingSlotIndex.
                let: #slotIndex with: baseIndex + pendingSlotIndex.
                pendingSlot
                    localIndex: localSlotIndex;
                    index: slotIndex
            }.

            self slots: self slots -- pendingSlotsArray.
            self pendingSlots: nil
        }.

        if: self slots == nil then: (self slots: #()).
        self slots
    } makeFinal;
    withSelector: #validTotalSlotCount addMethod: {:(Type)self :: Size |
        let: #totalSlotCount with: self totalSlotCount.
        if: totalSlotCount == nil then: {
            self totalSlotCount: self validSupertypeTotalSlotCount + self validSlots size.
            self totalSlotCount
        } else: totalSlotCount
    } makeFinal withEagerAnalysis;
    withSelector: #registerSlotsInDictionary addMethod: {:(Type)self :: Void |
        let: #supertypeSlotCount with: self validSupertypeTotalSlotCount.

        self slots doWithIndex: {:(TypeSlot)slot :(Size)index :: Void |
            slot
                localIndex: index;
                index: supertypeSlotCount + index.
            self addSlotToDictionary: slot
        }
    } withEagerAnalysis;
    withSelector: #invalidateLayout addMethod: {:(Type)self  :: Void |
        self instanceSize: 0sz.
        self instanceAlignment: 0sz.
    } makeFinal withEagerAnalysis;
    withSelector: #addTypeSlot: addMethod: {:(Type)self :(TypeSlot)extraSlot :: Void |
        if: self totalSlotCount ~~ nil then: (self error: "Cannot add type slot when the total slot count has already been computed").
        if: self pendingSlots == nil then: (self pendingSlots: OrderedCollection new).

        self invalidateLayout.
        self pendingSlots add: extraSlot.
        self addSlotToDictionary: extraSlot.
        extraSlot owner: self.
        extraSlot generateAccessorsOn: self.
    } withEagerAnalysis;
    withSelector: #basicAllocate replaceMethod: {:(Type)self :: self |
        <primitive: #basicAllocate>
        let: #result with: (if: self isBytes
            then: RawTuple::byteNew(0sz)
            else: RawTuple::new(self validTotalSlotCount)).
        (RawTuple::type:)(result, self).
        if: self isWeak then: RawTuple::markWeak(result).
        result
    } makeVirtual withEagerAnalysis;
    withSelector: #basicAllocate: addMethod: {:(Type)self :(Size)variableSize :: self |
        let: #result with: (if: self isBytes
            then: RawTuple::byteNew(variableSize)
            else: RawTuple::new(self validTotalSlotCount + variableSize)).
        (RawTuple::type:)(result, self).
        if: self isWeak then: RawTuple::markWeak(result).
        result
    } makeVirtual withEagerAnalysis;
    withSelector: #basicNew: addMethod: {:(Type)self :(Size)variableSlotCount :: self |
        let: #result with: (self basicAllocate: variableSlotCount).
        let: #basicInitializeMethod with: self validBasicInitializeMethod.
        if: basicInitializeMethod ~~ nil then: basicInitializeMethod(result).
        result
    } makeVirtual withEagerAnalysis;
    withSelector: #new replaceMethod: {:(Type)self :: self |
        <primitive: #new>
        self basicNew initialize; yourself
    } makeVirtual withEagerAnalysis;
    withSelector: #new: addMethod: {:(Type)self :(Size)variableSlotCount :: self |
        (self basicNew: variableSlotCount) initialize; yourself
    } makeVirtual withEagerAnalysis;
    withSelector: #localSlotNamed: addMethod: {:(Type)self :(Symbol)name |
        let: #slotDictionary with: self slotDictionary.
        if: slotDictionary ~~ nil
            then: (slotDictionary atOrNil: name)
            else: nil
    };
    withSelector: #lookupSlot: addMethod: {:(Type)self :(Symbol)name |
        let: #slot with: (self localSlotNamed: name).
        if: slot ~~ nil
        then: slot
        else: {
            let: #supertype with: self supertype.
            if: supertype ~~ nil
                then: (supertype lookupSlot: name)
                else: (nil)
        }
    }.

ControlFlowEscapeType class
    withSelector: #coerceASTNode:into:withEnvironment: addMethod: {:(Type)self :(ASTNode)astNode :(Type)targetType :(AnalysisAndEvaluationEnvironment)environment :: ASTNode |
        astNode
    } makeOverride.

UndefinedObject class
    withSelector: #coerceASTNode:into:withEnvironment: addMethod: {:(Type)self :(ASTNode)astNode :(Type)targetType :(AnalysisAndEvaluationEnvironment)environment :: ASTNode |
        if: targetType isNullable
        then: astNode
        else: error("Cannot coerce nil into non-nullable type " -- targetType printString)
    } makeOverride.

ReferenceLikeType
    withSelector: #isReferenceLikeType addMethod: {:(ReferenceType)self :: Boolean | true } makeOverride makePure;
    withSelector: #asDecayedType addMethod: {:(ReferenceLikeType)self :: Type |
        self baseType asDecayedType
    } makePure makeOverride withEagerAnalysis;
    withSelector: #asDecayedReceiverType addMethod: {:(ReferenceLikeType)self :: Type |
        self baseType decayReferenceLikeForReceiverType: self
    } makePure makeOverride withEagerAnalysis;
    withSelector: #coerceASTNode:into:withEnvironment: addMethod: {:(ReferenceLikeType)self :(ASTNode)astNode :(Type)targetType :(AnalysisAndEvaluationEnvironment)environment :: ASTNode |
        if: (self isSubtypeOf: targetType)
        then: astNode
        else: {
            if: targetType isReferenceLikeType then: {
                error("TODO: Implement coercion between two reference types.")
            } else: {
                let: #sourcePosition with: astNode sourcePosition.
                let: #analyzerToken with: environment analyzerToken.
                let: #loadValueFunction with: self loadValueFunction.
                let: #baseType with: self baseType.

                targetType
                    coerceASTNode: (ASTFunctionApplicationNode new
                        sourcePosition: astNode sourcePosition;
                        functionExpression: (ASTLiteralNode new
                            value: loadValueFunction;
                            analyzedType: loadValueFunction __type__;
                            analyzerToken: analyzerToken;
                            yourself);
                        arguments: (astNode,);
                        analyzedType: self baseType;
                        analyzerToken: analyzerToken;
                        yourself)
                    withEnvironment: environment
            }
        }.
    } makeOverride withEagerAnalysis.

ReferenceType
    withSelector: #isReferenceType addMethod: {:(ReferenceType)self :: Boolean | true } makeOverride makePure;
    withSelector: #asCanonicalPendingInstanceType addMethod: {:(ReferenceType)self :: Type |
        let: #baseType with: self baseType.
        if: baseType ~~ nil
            then: (baseType asCanonicalPendingInstanceType refFor: self addressSpace)
            else: (AnyValue refFor: self addressSpace).
    } makePure makeOverride.

TemporaryReferenceType
    withSelector: #isTemporaryReferenceType addMethod: {:(TemporaryReferenceType)self :: Boolean | true } makeOverride makePure;
    withSelector: #asCanonicalPendingInstanceType addMethod: {:(TemporaryReferenceType)self :: Type |
        let: #baseType with: self baseType.
        if: baseType ~~ nil
            then: (baseType asCanonicalPendingInstanceType tempRefFor: self addressSpace)
            else: (AnyValue tempRefFor: self addressSpace).
    } makePure makeOverride.

Array ensureAnalysisOfMethodWithSelector: #doWithIndex:.

AnyValue
    withSelector: #isNil addMacroMethod: {:(MacroContext)macroContext :(ASTNode)self :: ASTMessageSendNode |
        ASTMessageSendNode new
            sourcePosition: macroContext sourcePosition;
            receiver: self;
            selector: (ASTLiteralNode new
                sourcePosition: macroContext sourcePosition;
                value: #==;
                yourself);
            arguments: (ASTLiteralNode new
                sourcePosition: macroContext sourcePosition;
                value: nil;
                yourself,);
            yourself
    } makeMacro;
    withSelector: #isNotNil addMacroMethod: {:(MacroContext)macroContext :(ASTNode)self :: ASTMessageSendNode |
        ASTMessageSendNode new
            sourcePosition: macroContext sourcePosition;
            receiver: self;
            selector: (ASTLiteralNode new
                sourcePosition: macroContext sourcePosition;
                value: #~~;
                yourself);
            arguments: (ASTLiteralNode new
                sourcePosition: macroContext sourcePosition;
                value: nil;
                yourself,);
            yourself
    } makeMacro;
    withSelector: #&& addMacroMethod: {:(MacroContext)macroContext :(ASTNode)self :(ASTNode)other :: ASTIfNode |
        ASTIfNode new
            sourcePosition: macroContext sourcePosition;
            conditionExpression: self;
            trueExpression: other;
            falseExpression: (ASTLiteralNode new
                sourcePosition: macroContext sourcePosition;
                value: false;
                yourself);
            yourself
    } makeMacro;
    withSelector: #|| addMacroMethod: {:(MacroContext)macroContext :(ASTNode)self :(ASTNode)other :: ASTIfNode |
        ASTIfNode new
            sourcePosition: macroContext sourcePosition;
            conditionExpression: self;
            trueExpression: (ASTLiteralNode new
                sourcePosition: macroContext sourcePosition;
                value: true;
                yourself);
            falseExpression: other;
            yourself
    } makeMacro;

    withSelector: #implicitCastTo: addMacroMethod: {:(MacroContext)macroContext :(ASTNode)self :(ASTNode)targetTypeExpression :: ASTCoerceValueNode |
        ASTCoerceValueNode new
            sourcePosition: macroContext sourcePosition;
            typeExpression: targetTypeExpression;
            valueExpression: self;
            yourself
    } makeMacro;
    withSelector: #downCastTo: addMacroMethod: {:(MacroContext)macroContext :(ASTNode)self :(ASTNode)targetTypeExpression :: ASTDownCastNode |
        ASTDownCastNode new
            sourcePosition: macroContext sourcePosition;
            typeExpression: targetTypeExpression;
            valueExpression: self;
            yourself
    } makeMacro;

    withSelector: #ifTrue: addMacroMethod: {:(MacroContext)macroContext :(ASTNode)self :(ASTNode)trueExpression :: ASTIfNode |
        ASTIfNode new
            sourcePosition: macroContext sourcePosition;
            conditionExpression: self;
            trueExpression: trueExpression;
            yourself
    } makeMacro;
    withSelector: #ifFalse: addMacroMethod: {:(MacroContext)macroContext :(ASTNode)self :(ASTNode)falseExpression :: ASTIfNode |
        ASTIfNode new
            sourcePosition: macroContext sourcePosition;
            conditionExpression: self;
            falseExpression: falseExpression;
            yourself
    } makeMacro;
    withSelector: #ifTrue:ifFalse: addMacroMethod: {:(MacroContext)macroContext :(ASTNode)self :(ASTNode)trueExpression :(ASTNode)falseExpression :: ASTIfNode |
        ASTIfNode new
            sourcePosition: macroContext sourcePosition;
            conditionExpression: self;
            trueExpression: trueExpression;
            falseExpression: falseExpression;
            yourself
    } makeMacro;
    withSelector: #ifFalse:ifTrue: addMacroMethod: {:(MacroContext)macroContext :(ASTNode)self :(ASTNode)falseExpression :(ASTNode)trueExpression :: ASTIfNode |
        ASTIfNode new
            sourcePosition: macroContext sourcePosition;
            conditionExpression: self;
            trueExpression: trueExpression;
            falseExpression: falseExpression;
            yourself
    } makeMacro;
    withSelector: #perform: addMacroMethod: {:(MacroContext)macroContext :(ASTNode)self :(ASTNode)selector :: ASTMessageSendNode |
        ASTMessageSendNode new
            sourcePosition: macroContext sourcePosition;
            receiver: self;
            selector: selector;
            arguments: Array new;
            isDynamic: true;
            yourself
    } makeMacro;
    withSelector: #perform:with: addMacroMethod: {:(MacroContext)macroContext :(ASTNode)self :(ASTNode)selector :(ASTNode)argument :: ASTMessageSendNode |
        ASTMessageSendNode new
            sourcePosition: macroContext sourcePosition;
            receiver: self;
            selector: selector;
            arguments: (Array with: argument);
            isDynamic: true;
            yourself
    } makeMacro;
    withSelector: #perform:with:with: addMacroMethod: {:(MacroContext)macroContext :(ASTNode)self :(ASTNode)selector :(ASTNode)firstArgument :(ASTNode)secondArgument :: ASTMessageSendNode |
        ASTMessageSendNode new
            sourcePosition: macroContext sourcePosition;
            receiver: self;
            selector: selector;
            arguments: (Array with: firstArgument with: secondArgument);
            isDynamic: true;
            yourself
    } makeMacro;
    withSelector: #perform:with:with:with: addMacroMethod: {:(MacroContext)macroContext :(ASTNode)self :(ASTNode)selector :(ASTNode)firstArgument :(ASTNode)secondArgument :(ASTNode)thirdArgument :: ASTMessageSendNode |
        ASTMessageSendNode new
            sourcePosition: macroContext sourcePosition;
            receiver: self;
            selector: selector;
            arguments: (Array with: firstArgument with: secondArgument with: thirdArgument);
            isDynamic: true;
            yourself
    } makeMacro;
    withSelector: #perform:with:with:with:with: addMacroMethod: {:(MacroContext)macroContext :(ASTNode)self :(ASTNode)selector :(ASTNode)firstArgument :(ASTNode)secondArgument :(ASTNode)thirdArgument :(ASTNode)fourthArgument :: ASTMessageSendNode |
        ASTMessageSendNode new
            sourcePosition: macroContext sourcePosition;
            receiver: self;
            selector: selector;
            arguments: (Array with: firstArgument with: secondArgument with: thirdArgument with: fourthArgument);
            isDynamic: true;
            yourself
    } makeMacro.

ASTNode
    withSelector: #postCopy addMethod: {:(ASTNode)self :: Void |
        (tuple: self withLookupStartingFrom: ASTNode supertype) postCopy.
        self analyzerToken: nil.
    } makeOverride.

Stream
    withSelector: #nextPut: addMethod: {:(Stream)self :element :: Void | 
        self subclassResponsibility
    } makeVirtual;
    withSelector: #nextPutAll: addMethod: {:(Stream)self :aCollection :: Void | 
        aCollection do: {:each :: Void | self nextPut: each}
    } makeVirtual;
    withSelector: #nextPutAllBytesOf: addMethod: {:(Stream)self :anObject :: Void | 
        let: #size mutableWith: RawTuple::byteSize(anObject).
        let: #i mutableWith: 0sz.
        while: i < size do: {
            self nextPut: (RawTuple::byteSlotAt:)(anObject, i)
        } continueWith: (i := i+ 1sz)
    } makeVirtual;
    withSelector: #print: addMethod: {:(Stream)self :value :: Void | 
        value printOn: self
    };
    withSelector: #store: addMethod: {:(Stream)self :value :: Void | 
        value storeOn: self
    };
    withSelector: #string: addMethod: {:(Stream)self :value :: Void | 
        value stringOn: self
    };
    withSelector: #fullPrint: addMethod: {:(Stream)self :value :: Void | 
        value fullPrintOn: self
    };
    withSelector: #cr addMethod: {:(Stream)self :: Void | 
        self nextPut: '\r'c8
    };
    withSelector: #lf addMethod: {:(Stream)self :: Void | 
        self nextPut: '\n'c8
    };
    withSelector: #nl addMethod: {:(Stream)self :: Void | 
        self nextPut: '\n'c8
    };
    withSelector: #tab addMethod: {:(Stream)self :: Void | 
        self nextPut: '\t'c8
    };
    withSelector: #space addMethod: {:(Stream)self :: Void | 
        self nextPut: ' 'c8
    }.

AnyValue
    withSelector: #asString addMethod: {:(AnyValue)self :: String | 
        let: #stream with: StringStream new.
        self stringOn: stream.
        stream asString.
    } makeVirtual;
    withSelector: #printString addMethod: {:(AnyValue)self :: String | 
        let: #stream with: StringStream new.
        self printOn: stream.
        stream asString.
    } makeVirtual;
    withSelector: #printOn: addMethod: {:(AnyValue)self :(Stream)stream :: Void |
        stream nextPutAll: "a " ; print: self __type__
    } makeVirtual;
    withSelector: #storeOn: addMethod: {:(AnyValue)self :(Stream)stream :: Void |
        self printOn: stream
    } makeVirtual;
    withSelector: #stringOn: addMethod: {:(AnyValue)self :(Stream)stream :: Void |
        self printOn: stream
    } makeVirtual;
    withSelector: #fullPrintString addMethod: {:(AnyValue)self :: String | 
        let: #stream with: StringStream new.
        self fullPrintOn: stream.
        stream asString.
    } makeVirtual;
    withSelector: #fullPrintOn: addMethod: {:(AnyValue)self :(Stream)stream :: Void |
        self printOn: stream
    } makeVirtual.

ProgramEntity
    withSelector: #printAnonymousNameOn: addMethod: {:(ProgramEntity)self :(Stream)stream :: Void |
        stream nextPutAll: "a "; string: self class name
    } makeVirtual;
    withSelector: #printOwnerOn: addMethod: {:(ProgramEntity)self :(Stream)stream :: Void |
        let: #owner with: self owner.
        if: owner ~~ nil then: {
            stream print: owner; space
        }.
    } makeVirtual;
    withSelector: #printOn: addMethod: {:(ProgramEntity)self :(Stream)stream :: Void |
        let: #name with: self name.
        self printOwnerOn: stream.
        if: name ~~ nil
            then: (stream string: name)
            else: (self printAnonymousNameOn: stream).
    } makeOverride.

Type
    withSelector: #coerceValue:intoType: addMethod: {:(Type)self :(Untyped)value :(Type)targetType :: Untyped |
        error((("Cannot coerce value " -- value printString) -- " into the expected target type ") -- targetType printString)
    };

    withSelector: #coerceValue: addMethod: {:(Type)self :(Untyped)value :: Untyped |
        let: #valueType with: RawTuple::type(value).
        if: (valueType isSubtypeOf: self) then: (value) else: {
            valueType coerceValue: value intoType: self
        }.
    } makeVirtual;
    withSelector: #printAnonymousNameOn: addMethod: {:(Type)self :(Stream)stream :: Void |
        stream nextPutAll: "a Type"
    } makeOverride.

Void class
    withSelector: #coerceASTNode:withEnvironment: addMethod: {:(Type)self :(ASTNode)astNode :(AnalysisAndEvaluationEnvironment)environment :: ASTNode |
        let: #sourceType with: astNode analyzedType.
        if: (if: sourceType ~~ nil then: (sourceType isDirectSubtypeOf: self) else: false)
        then: astNode
        else: (ASTFunctionApplicationNode new
            sourcePosition: astNode sourcePosition;
            analyzedType: Void;
            functionExpression: (ASTLiteralNode new
                sourcePosition: astNode sourcePosition;
                analyzedType: Void::fromAnyValue __type__;
                value: Void::fromAnyValue;
                yourself);
            arguments: (astNode,);
            yourself)
    } makeOverride withEagerAnalysis;
    withSelector: #coerceValue: addMethod: {:(Void class)self :value :: Void | void } makeOverride.
Void
    withSelector: #printString addMethod: {:(Void)self :: String | "void" } makeOverride;
    withSelector: #printOn: addMethod: {:(Void)self :(Stream)stream :: Void | stream nextPutAll: "void" } makeOverride.

UndefinedObject
    withSelector: #doesNotUnderstand: addMethod: {:(UndefinedObject)self :(Message)message |
        self error: message selector printString -- " was sent to nil."
    } makeOverride;

    withSelector: #printString addMethod: {:(UndefinedObject)self :: String | "nil" } makeOverride;
    withSelector: #printOn: addMethod: {:(UndefinedObject)self :(Stream)stream :: Void | stream nextPutAll: "nil" } makeOverride.

False
    withSelector: #printString addMethod: {:(False)self :: String | "false" } makeOverride;
    withSelector: #printOn: addMethod: {:(False)self :(Stream)stream :: Void | stream nextPutAll: "false" } makeOverride.

True
    withSelector: #printString addMethod: {:(True)self :: String | "true" } makeOverride;
    withSelector: #printOn: addMethod: {:(True)self :(Stream)stream :: Void | stream nextPutAll: "true" } makeOverride.

String
    withSelector: #stringOn: addMethod: {:(String)self :(Stream)stream :: Void |
        stream nextPutAllBytesOf: self
    } makeOverride;
    withSelector: #printOn: addMethod: {:(String)self :(Stream)stream :: Void |
        ## TODO: Implement this part properly.
        stream nextPut: '"'c8.
        stream nextPutAllBytesOf: self.
        stream nextPut: '"'c8.
    } makeOverride.

StringSymbol
    withSelector: #stringOn: addMethod: {:(StringSymbol)self :(Stream)stream :: Void |
        stream nextPutAllBytesOf: self
    } makeOverride;
    withSelector: #printOn: addMethod: {:(StringSymbol)self :(Stream)stream :: Void |
        ## TODO: Implement this part properly.
        stream nextPut: '#'c8; nextPutAllBytesOf: self
    } makeOverride;
    withSelector: #fullPrintOn: addMethod: {:(StringSymbol)self :(Stream)stream :: Void |
        ## TODO: Implement this part properly.
        stream nextPut: '#'c8; nextPutAllBytesOf: self
    } makeOverride.


Class
    withSelector: #withSelector:addClassMethod: addMethod: {:(Class)self :selector :method :: Void |
        self class withSelector: selector addMethod: method
    }.

FunctionDefinition
    withSelector: #hasPragmaNamed: addMethod: {:(FunctionDefinition)self :selector :: Boolean |
        let: #analyzedPragmas with: self analyzedPragmas.
        let: #definitionBodyNode with: self definitionBodyNode.
        if: analyzedPragmas ~~ nil
        then: (analyzedPragmas anySatisfy: {:(Pragma)pragma :: Boolean | selector == pragma selector })
        else: (
            if: definitionBodyNode ~~ nil
            then: (definitionBodyNode hasPragmaNamed: selector)
            else: false
        )
    }.

Function
    withSelector: #hasAnyFlag: addMethod: {:(Function)self :(Bitflags)flag :: Boolean |
        (self flags & flag) ~= 0bflgs
    } makeFinal makeAlwaysInline;
    withSelector: #hasAllFlags: addMethod: {:(Function)self :(Bitflags)flags :: Boolean |
        (self flags & flags) = flags
    } makeFinal makeAlwaysInline;
    withSelector: #isMacro addMethod: {:(Function)self :: Boolean |
        self hasAnyFlag: FunctionFlags::Macro
    } makeFinal makeAlwaysInline;
    withSelector: #isVariadic addMethod: {:(Function)self :: Boolean |
        self hasAnyFlag: FunctionFlags::Variadic
    } makeFinal makeAlwaysInline;
    withSelector: #isCorePrimitive addMethod: {:(Function)self :: Boolean |
        self hasAnyFlag: FunctionFlags::CorePrimitive
    } makeFinal makeAlwaysInline;
    withSelector: #isBootstrapPrimitive addMethod: {:(Function)self :: Boolean |
        self isNotNil && (self isCorePrimitive || self definition isNil)
    } makeFinal makeAlwaysInline;
    withSelector: #isPure addMethod: {:(Function)self :: Boolean |
        self hasAnyFlag: FunctionFlags::Pure
    } makeFinal makeAlwaysInline;
    withSelector: #isFinal addMethod: {:(Function)self :: Boolean |
        self hasAnyFlag: FunctionFlags::Final
    } makeFinal makeAlwaysInline;
    withSelector: #isVirtual addMethod: {:(Function)self :: Boolean |
        self hasAnyFlag: FunctionFlags::Virtual
    } makeFinal makeAlwaysInline;
    withSelector: #isAbstract addMethod: {:(Function)self :: Boolean |
        self hasAnyFlag: FunctionFlags::Abstract
    } makeFinal makeAlwaysInline;
    withSelector: #isOverride addMethod: {:(Function)self :: Boolean |
        self hasAnyFlag: FunctionFlags::Override
    } makeFinal makeAlwaysInline;
    withSelector: #isStatic addMethod: {:(Function)self :: Boolean |
        self hasAnyFlag: FunctionFlags::Static
    } makeFinal makeAlwaysInline;
    withSelector: #isMemoized addMethod: {:(Function)self :: Boolean |
        self hasAnyFlag: FunctionFlags::Memoized
    } makeFinal makeAlwaysInline;
    withSelector: #isTemplate addMethod: {:(Function)self :: Boolean |
        self hasAnyFlag: FunctionFlags::Template
    } makeFinal makeAlwaysInline;
    withSelector: #isMemoizedTemplate addMethod: {:(Function)self :: Boolean |
        self hasAllFlags: FunctionFlags::Memoized | FunctionFlags::Template
    } makeFinal makeAlwaysInline;
    withSelector: #isInline addMethod: {:(Function)self :: Boolean |
        self hasAnyFlag: FunctionFlags::Inline
    } makeFinal makeAlwaysInline;
    withSelector: #isAlwaysInline addMethod: {:(Function)self :: Boolean |
        self hasAnyFlag: FunctionFlags::AlwaysInline
    };
    withSelector: #isNeverInline addMethod: {:(Function)self :: Boolean |
        self hasAnyFlag: FunctionFlags::NeverInline
    };
    withSelector: #hasOverrideDispatch addMethod: {:(Function)self :: Boolean |
        self hasAnyFlag: FunctionFlags::Override
    } withEagerAnalysis;
    withSelector: #hasVirtualDispatch addMethod: {:(Function)self :: Boolean |
        self hasAnyFlag: (FunctionFlags::Virtual | FunctionFlags::Abstract) | FunctionFlags::Override
    } withEagerAnalysis;
    withSelector: #requiresArgumentExpansionDuringApplication addMethod: {:(Function)self :: Boolean |
        self hasAnyFlag: FunctionFlags::Memoized | FunctionFlags::Variadic
    } withEagerAnalysis;

    withSelector: #hasPragmaNamed: addMethod: {:(Function)self :selector :: Boolean |
        let: #definition with: self definition.
        if: definition == nil then: false else: (definition hasPragmaNamed: selector)
    };
    
    withSelector: #printOn: addMethod: {:(Function)self :(Stream)stream :: Void |
        let: #name with: self name.
        let: #definition with: self definition.
        let: #sourcePosition with: (if: definition ~~ nil then: definition sourcePosition else: nil).

        stream nextPutAll: "Function(".

        if: name ~~ nil then: {
            let: #owner with: self owner.
            if: owner ~~ nil then: (stream print: owner; nextPutAll: " >> ").
            
            stream print: name.
            if: sourcePosition ~~ nil then: (stream space).

        }.
        if: sourcePosition ~~ nil then: {
            stream nextPutAll: "at "; print: sourcePosition
        }.

        stream nextPut: ')'c8
    } makeOverride.

FunctionDefinition
    withSelector: #hasAnyFlag: addMethod: {:(FunctionDefinition)self :(Bitflags)flag :: Boolean |
        (self flags & flag) ~= 0bflgs
    };
    withSelector: #requiresArgumentExpansionDuringApplication addMethod: {:(FunctionDefinition)self :: Boolean |
        self hasAnyFlag: FunctionFlags::Memoized | FunctionFlags::Variadic
    }.

ValueBox
    withSelector: #with: addClassMethod: {:(ValueBox class)self :value :: self |
        self basicNew
            value: value;
            yourself
    };
    withSelector: #_ addMethod: {:(ValueBox)self | self value };
    withSelector: #_: addMethod: {:(ValueBox)self :newValue | self value: newValue. newValue };
    withSelector: #":=" addMethod: {:(ValueBox)self :newValue | self value: newValue. newValue }.

Collection
    withSelector: #isEmpty addMethod: {:(Collection)self :: Boolean |
        self size = 0sz
    };
    withSelector: #isNotEmpty addMethod: {:(Collection)self :: Boolean |
        self size ~= 0sz
    };
    withSelector: #size addMethod: {:(Collection)self :: Size |
        self subclassResponsibility
    } makeAbstract;

    withSelector: #do: addMethod: {:(Collection)self :aBlock :: Void |
        self subclassResponsibility
    } makeAbstract;

    withSelector: #doWithoutTombstones: addMethod: {:(Collection)self :aBlock :: Void |
        self do: {:each :: Void |
            if: __tombstone__ ~~ each then: aBlock(each)
        }
    };

    withSelector: #doWithIndex: addMethod: {:(Collection)self :aBlock :: Void |
        let: #i mutableWith: 0sz.
        self do: {:element :: Void |
            aBlock(element, i).
            i := 1sz + i
        }
    } makeVirtual;

    withSelector: #select: addMethod: {:(Collection)self :aBlock :: OrderedCollection |
        let: #result with: OrderedCollection new.
        self do: {:each :: Void |
            if: aBlock(each) then: (result add: each)
        }.
        result
    };
    withSelector: #reject: addMethod: {:(Collection)self :aBlock :: OrderedCollection |
        let: #result with: OrderedCollection new.
        self do: {:each :: Void |
            if: aBlock(each) not then: (result add: each)
        }.
        result
    };
    withSelector: #includes: addMethod: {:(Collection)self :element :: Boolean |
        self subclassResponsibility
    } makeAbstract;
    withSelector: #printOn: addMethod: {:(Collection)self :(Stream)stream :: Void |
        stream print: self class; nextPutAll: "(".
        self doWithIndex: {:element :(Size)index :: Void |
            if: index > 0sz then: (stream nextPutAll: ", ").
            stream print: element.
            void
        }.

        stream nextPutAll: ")"
    } makeOverride;
    withSelector: #fullPrintOn: addMethod: {:(Collection)self :(Stream)stream :: Void |
        stream print: self class; nextPutAll: "(".
        self doWithIndex: {:element :(Size)index :: Void |
            if: index > 0sz then: (stream nextPutAll: ", ").
            stream fullPrint: element.
            void
        }.

        stream nextPutAll: ")"
    } makeOverride;
    withSelector: #asArray addMethod: {:(Collection)self :: Array |
        let: #array with: (Array new: self size).
        self doWithIndex: {:element :(Size)index :: Void |
            array at: index put: element
        }.

        array
    } makeVirtual.

SequenceableCollection
    withSelector: #=> addMethod: {:(SequenceableCollection)self :(Type)resultType :: SimpleFunctionType |
        SimpleFunctionTypeTemplate(self asArray, 0bflgs, resultType)
    } makePure makeFinal.

Association
    withSelector: #key:value: addClassMethod: {:(Association class)self :key :value :: self |
        self new key: key; value: value; yourself
    };
    withSelector: #printOn: addMethod: {:(Association)self :(Stream)stream :: Void |
        stream print: self key; nextPutAll: " -> "; print: self value
    } makeOverride.

WeakValueAssociation
    withSelector: #new addClassMethod: {:(WeakValueAssociation class)self :: self |
        self basicNew: 1sz
    } makeOverride;
    withSelector: #key:value: addClassMethod: {:(WeakValueAssociation class)self :key :value :: self |
        self new key: key; value: value; yourself
    };
    withSelector: #value addMethod: {:(WeakValueAssociation)self :: Untyped |
        (RawTuple::slotAt:)(self, 1sz)
    };
    withSelector: #value: addMethod: {:(WeakValueAssociation)self :(Untyped)newValue :: Void |
        (RawTuple::slotAt:put:)(self, 1sz, newValue)
    }.

Object
    withSelector:#-> addMethod: {:(Object)self :value :: Association |
        Association key: self value: value
    }.

WeakValueAssociation
    withSelector: #value addMethod: {:(WeakValueAssociation)self |
        (RawTuple::slotAt:)(self, 1sz)
    } makePure; makeFinal;
    withSelector: #value: addMethod: {:(WeakValueAssociation)self :newValue :: Void |
        RawTuple::slotAt:put:(self, 1sz, newValue)
    } makePure; makeFinal;
    withSelector: #printOn: addMethod: {:(WeakValueAssociation)self :(Stream)stream :: Void |
        stream print: self key; nextPutAll: " -> "; print: self value
    } makeOverride.

Dictionary
    withSelector: #do: addMethod: {:(Dictionary)self :aBlock :: Void |
        let: #storage with: self storage.
        if: storage ~~ nil then: {
            storage do: {:element :: Void |
                if: element ~~ nil then: aBlock(element).
            }
        }
    } makeOverride;
    withSelector: #ensureStorage addMethod: {:(Dictionary)self :: Void |
        if: self storage == nil then: (self storage: (Array new: 16sz)).
    };
    withSelector: #at:ifAbsent: addMethod: {:(Dictionary)self :key :ifAbsentBlock |
        self ensureStorage.
        let: #entryIndex with: (self scanFor: key) asSize.
        let: #storage with: self storage.
        let: #entry with: (storage at: entryIndex).
        if: entry == nil then: {
            ifAbsentBlock()
        } else: {
            entry value
        }
    } makeVirtual;
    withSelector: #at:ifAbsentPut: addMethod: {:(Dictionary)self :key :ifAbsentBlock |
        self ensureStorage.
        let: #entryIndex with: (self scanFor: key) asSize.
        let: #storage with: self storage.
        let: #entry with: (storage at: entryIndex).
        if: entry == nil then: {
            let: #value with: ifAbsentBlock().
            self at: key put: value.
            value
        } else: {
            entry value
        }
    } makeVirtual;
    withSelector: #includesKey: addMethod: {:(Dictionary)self :(AnyValue)key :: Boolean |
        self ensureStorage.
        let: #entryIndex with: (self scanFor: key) asSize.
        let: #storage with: self storage.
        let: #entry with: (storage at: entryIndex).
        if: entry ~~ nil then: entry key = key else: false
    };
    withSelector: #at:ifPresent: addMethod: {:(Dictionary)self :key :ifPresentBlock :: Void |
        self ensureStorage.
        let: #entryIndex with: (self scanFor: key) asSize.
        let: #storage with: self storage.
        let: #entry with: (storage at: entryIndex).
        if: entry ~~ nil then: {
            ifPresentBlock(entry value)
        }
    }.

IdentityDictionary
    withSelector: #untypedIncludesKey: addMethod: {:(IdentityDictionary)self :(Untyped)key :: Boolean |
        self ensureStorage.
        let: #entryIndex with: (self scanFor: key) asSize.
        let: #storage with: self storage.
        let: #entry with: (storage at: entryIndex).
        if: entry ~~ nil then: (Untyped::==)((RawTuple::slotAt:)(entry, 0sz), key) else: false
    };
    withSelector: #untypedAt: addMethod: {:(IdentityDictionary)self :(Untyped)key |
        self at: key
    };
    withSelector: #untypedAtOrNil: addMethod: {:(IdentityDictionary)self :(Untyped)key |
        self atOrNil: key
    };
    withSelector: #untypedAt:put: addMethod: {:(IdentityDictionary)self :(Untyped)key :value :: Void |
        self at: key put: value.
    };
    withSelector: #untypedAt:ifAbsentPut: addMethod: {:(IdentityDictionary)self :(Untyped)key :ifAbsentBlock |
        self ensureStorage.
        let: #entryIndex with: (self scanFor: key) asSize.
        let: #storage with: self storage.
        let: #entry with: (storage at: entryIndex).
        if: entry == nil then: {
            let: #value with: ifAbsentBlock().
            self untypedAt: key put: value.
            value
        } else: {
            entry value
        }
    }.

Set
    withSelector: #do: addMethod: {:(Set)self :aBlock :: Void |
        let: #storage with: self storage.
        if: storage ~~ nil then: {
            storage do: {:element :: Void |
                if: __hashtableEmptyElement__ ~~ element then: aBlock(element).
            }
        }
    } makeOverride.

WeakSet
    withSelector: #do: addMethod: {:(WeakSet)self :aBlock :: Void |
        let: #storage with: self storage.
        if: storage ~~ nil then: {
            storage do: {:element :: Void |
                if: (__hashtableEmptyElement__ ~~ element) && (__tombstone__ ~~ element) then: aBlock(element).
            }
        }
    } makeOverride.

SequenceableCollection
    withSelector: #with: addClassMethod: {:(SequenceableCollection class)self :value :: self |
        (self new: 1sz)
            at: 0sz put: value;
            yourself
    };
    withSelector: #with:with: addClassMethod: {:(SequenceableCollection class)self :first :second :: self |
        (self new: 2sz)
            at: 0sz put: first;
            at: 1sz put: second;
            yourself
    };
    withSelector: #with:with:with: addClassMethod: {:(SequenceableCollection class)self :first :second :third :: self |
        (self new: 3sz)
            at: 0sz put: first;
            at: 1sz put: second;
            at: 2sz put: third;
            yourself
    };
    withSelector: #with:with:with:with: addClassMethod: {:(SequenceableCollection class)self :first :second :third :fourth :: self |
        (self new: 4sz)
            at: 0sz put: first;
            at: 1sz put: second;
            at: 2sz put: third;
            at: 3sz put: fourth;
            yourself
    };
    withSelector: #at: addMethod: {:(SequenceableCollection)self :(Size)index  |
        self subclassResponsibility
    } makeAbstract;
    withSelector: #at:put: addMethod: {:(SequenceableCollection)self :(Size)index :value :: Void |
        self subclassResponsibility
    } makeAbstract;
    withSelector: #atAllPut: addMethod: {:(SequenceableCollection)self :value :: Void |
        let: #i mutableWith: 0sz.
        let: #size with: self size.
        while: (i < size) do: (
            self at: i put: value
        ) continueWith: (i := i + 1sz)
    };
    withSelector: #anySatisfy: addMethod: {:(SequenceableCollection)self :aBlock :: Boolean |
        let: #i mutableWith: 0sz.
        let: #size with: self size.
        let: #hasFoundIt type: Boolean mutableWith: false.

        while: (if: hasFoundIt then: false else: i < self size) do: (
            hasFoundIt := aBlock(self at: i)
        ) continueWith: (i := i + 1sz).
        hasFoundIt
    } makeFinal;
    withSelector: #anySatisfyWithIndex: addMethod: {:(SequenceableCollection)self :aBlock :: Boolean |
        let: #i mutableWith: 0sz.
        let: #size with: self size.
        let: #hasFoundIt type: Boolean mutableWith: false.

        while: (if: hasFoundIt then: false else: i < self size) do: (
            hasFoundIt := aBlock(self at: i, i)
        ) continueWith: (i := i + 1sz).
        hasFoundIt
    } makeFinal;
    withSelector: #allSatisfy: addMethod: {:(SequenceableCollection)self :aBlock :: Boolean |
        let: #i mutableWith: 0sz.
        let: #size with: self size.
        let: #everythingIsFine type: Boolean mutableWith: true.

        while: (if: everythingIsFine then: i < self size else: false) do: (
            everythingIsFine := aBlock(self at: i)
        ) continueWith: (i := i + 1sz).
        everythingIsFine
    } makeFinal;
    withSelector: #allSatisfyWithIndex: addMethod: {:(SequenceableCollection)self :aBlock :: Boolean |
        let: #i mutableWith: 0sz.
        let: #size with: self size.
        let: #everythingIsFine type: Boolean mutableWith: true.

        while: (if: everythingIsFine then: i < self size else: false) do: (
            everythingIsFine := aBlock(self at: i, i)
        ) continueWith: (i := i + 1sz).
        everythingIsFine
    } makeFinal;
    withSelector: #indexOf: addMethod: {:(SequenceableCollection)self :value :: IntPointer |
        let: #i mutableWith: 0sz.
        let: #size with: self size.
        let: #hasFoundIt type: Boolean mutableWith: false.
        while: (i < size) do: (
            if: value = (self at: i) then: (return: i asIntPointer)
        ) continueWith: (i := i + 1sz).

        -1iptr
    };
    withSelector: #lastIndexOf: addMethod: {:(SequenceableCollection)self :value :: IntPointer |
        let: #i mutableWith: 0sz.
        let: #size with: self size.
        let: #bestFound mutableWith: -1iptr.
        while: (i < size) do: (
            if: value = (self at: i) then: (bestFound := i asIntPointer)
        ) continueWith: (i := i + 1sz).

        -1iptr
    };
    withSelector: #includes: addMethod: {:(SequenceableCollection)self :element :: Boolean |
        let: #i mutableWith: 0sz.
        let: #size with: self size.
        let: #hasFoundIt type: Boolean mutableWith: false.

        while: (if: hasFoundIt then: false else: i < self size) do: (
            hasFoundIt := (self at: i) = element
        ) continueWith: (i := i + 1sz).
        hasFoundIt
    } makeOverride makeFinal;
    withSelector: #collect: addMethod: {:(SequenceableCollection)self :aBlock :: self species |
        let: #i mutableWith: 0sz.
        let: #size with: self size.
        let: #result with: (self species new: size).

        self doWithIndex: {:each :(Size)index :: Void |
            result at: index put: aBlock(each)
        }.

        result
    } makeFinal;
    withSelector: #collect:as: addMethod: {:(SequenceableCollection)self :aBlock :(SequenceableCollection class)resultType :: resultType |
        let: #i mutableWith: 0sz.
        let: #size with: self size.
        let: #result with: (resultType new: size).

        self doWithIndex: {:each :(Size)index :: Void |
            result at: index put: aBlock(each)
        }.

        result
    } makeFinal;
    withSelector: #collectWithIndex: addMethod: {:(SequenceableCollection)self :aBlock :: self species |
        let: #i mutableWith: 0sz.
        let: #size with: self size.
        let: #result with: (self species new: size).

        self doWithIndex: {:each :(Size)index :: Void |
            result at: index put: aBlock(each, index)
        }.

        result
    } makeFinal;
    withSelector: #detect:ifFound:ifNone: addMethod: {:(SequenceableCollection)self :aPredicate :foundBlock :notFoundBlock |
        let: #i mutableWith: 0sz.
        let: #size with: self size.
        let: #hasFoundIt type: Boolean mutableWith: false.
        let: #foundElement type: AnyValue mutableWith: nil.

        while: (if: hasFoundIt then: false else: i < self size) do: {
            foundElement := self at: i.
            hasFoundIt := aPredicate(foundElement)
        } continueWith: (i := i + 1sz).

        if: hasFoundIt
            then: foundBlock(foundElement)
            else: notFoundBlock(notFoundBlock)
    };
    withSelector: #detect:ifNone: addMethod: {:(SequenceableCollection)self :aPredicate :notFoundBlock |
        self detect: aPredicate ifFound: {:element | element } ifNone: notFoundBlock
    };
    withSelector: #do: addMethod: {:(SequenceableCollection)self :aBlock :: Void |
        let: #i mutableWith: 0sz.

        while: i < self size do: (
            aBlock(self at: i)
        ) continueWith: (i := i + 1sz)
    } makeOverride;
    withSelector: #doWithIndex: addMethod: {:(SequenceableCollection)self :aBlock :: Void |
        let: #i mutableWith: 0sz.
        let: #size with: self size.

        while: i < self size do: {
            aBlock(self at: i, i)
        } continueWith: (i := i + 1sz)
    } makeOverride;
    withSelector: #pairsDo: addMethod: {:(SequenceableCollection)self :aBlock :: Void |
        let: #i mutableWith: 0sz.
        let: #size with: self size.

        while: i < self size do: {
            aBlock(self at: i, self at: i + 1sz)
        } continueWith: (i := i + 2sz)
    };
    withSelector: #reverseDo: addMethod: {:(SequenceableCollection)self :aBlock :: Void |
        let: #i mutableWith: 0sz.
        let: #size with: self size.

        while: i < self size do: (
            aBlock(self at: size - i - 1sz)
        ) continueWith: (i := i + 1sz)
    };
    withSelector: #-- addMethod: {:(SequenceableCollection)self :(SequenceableCollection)other :: self species |
        let: #size with: self size.
        let: #otherSize with: other size.
        let: #result with: (self species new: size + otherSize ).
        
        self doWithIndex: {:element :(Size)index :: Void |
            result at: index put: element
        }.

        other doWithIndex: {:element :(Size)index :: Void |
            result at: size + index put: element
        }.

        result
    } makeVirtual;
    withSelector: #replaceFrom:until:with: addMethod: {:(SequenceableCollection)self :(Size)start :(Size)stop :(SequenceableCollection)replacements :: Void |
        let: #i mutableWith: start.

        while: i < stop do: {
            self at: i put: (replacements at: i - start)
        } continueWith: (i := i + 1sz)
    };
    withSelector: #replaceAll:with: addMethod: {:(SequenceableCollection)self :oldObject :newObject :: Void |
        let: #i mutableWith: 0sz.
        let: #size with: self size.

        while: i < self size do: {
            if: (self at: i) = oldObject then: (self at: i put: newObject)
        } continueWith: (i := i + 1sz)
    };
    withSelector: #replaceAllWithDictionary: addMethod: {:(SequenceableCollection)self :(Dictionary)replacementDictionary :: Void |
        let: #i mutableWith: 0sz.
        let: #size with: self size.

        while: i < self size do: {
            replacementDictionary at: (self at: i) ifPresent: {:replacement :: Void |
                (self at: i put: replacement)
            }
        } continueWith: (i := i + 1sz)
    };
    withSelector: #first addMethod: {:(SequenceableCollection)self | self at: 0sz } makeFinal withEagerAnalysis;
    withSelector: #second addMethod: {:(SequenceableCollection)self | self at: 1sz } makeFinal withEagerAnalysis;
    withSelector: #third addMethod: {:(SequenceableCollection)self | self at: 2sz } makeFinal withEagerAnalysis;
    withSelector: #fourth addMethod: {:(SequenceableCollection)self | self at: 3sz } makeFinal withEagerAnalysis;
    withSelector: #fifth addMethod: {:(SequenceableCollection)self | self at: 4sz } makeFinal withEagerAnalysis;
    withSelector: #sixth addMethod: {:(SequenceableCollection)self | self at: 5sz } makeFinal withEagerAnalysis;
    withSelector: #seventh addMethod: {:(SequenceableCollection)self | self at: 6sz } makeFinal withEagerAnalysis;
    withSelector: #eighth addMethod: {:(SequenceableCollection)self | self at: 7sz } makeFinal withEagerAnalysis;
    withSelector: #ninth addMethod: {:(SequenceableCollection)self | self at: 8sz } makeFinal withEagerAnalysis;
    withSelector: #tenth addMethod: {:(SequenceableCollection)self | self at: 9sz } makeFinal withEagerAnalysis;

    withSelector: #last addMethod: {:(SequenceableCollection)self | self at: self size - 1sz } makeFinal withEagerAnalysis;
    withSelector: #nextToLast addMethod: {:(SequenceableCollection)self | self at: self size - 2sz } makeFinal withEagerAnalysis;

    withSelector: #copyFrom:until: addMethod: {:(SequenceableCollection)self :(Size)startIndex :(Size)endIndex :: self species |
        let: #resultSize with: (if: startIndex <= endIndex then: endIndex - startIndex else: 0sz).
        
        let: #result with: (self species new: resultSize).
        let: #i mutableWith: 0sz.
        while: i < resultSize do: (
            result at: i put: (self at: startIndex + i)
        ) continueWith: (i := i + 1sz).

        result
    };

    withSelector: #first: addMethod: {:(SequenceableCollection)self :(Size)elementsToKeep :: self species |
        let: #size with: self size.
        let: #resultSize with: (if: size < elementsToKeep then: size else: elementsToKeep).
        
        let: #result with: (self species new: resultSize).
        let: #i mutableWith: 0sz.
        while: i < resultSize do: (
            result at: i put: (self at: i)
        ) continueWith: (i := i + 1sz).

        result
    };
    withSelector: #allButFirst: addMethod: {:(SequenceableCollection)self :(Size)dropCount :: self species |
        let: #size with: self size.
        if: dropCount >= size then: (self species new: 0sz)
        else: {
            let: #resultSize with: size - dropCount.
            let: #result with: (self species new: resultSize).
            let: #i mutableWith: dropCount.
            while: i < size do: (
                result at: i - dropCount put: (self at: i)
            ) continueWith: (i := i + 1sz).
            result
        }
    };
    withSelector: #allButFirst addMethod: {:(SequenceableCollection)self :: self species |
        self allButFirst: 1sz
    };
    withSelector: #allButLast: addMethod: {:(SequenceableCollection)self :(Size)dropCount :: self species |
        let: #size with: self size.
        if: dropCount >= size then: (self species new: 0sz)
        else: {
            let: #resultSize with: size - dropCount.
            let: #result with: (self species new: resultSize).
            let: #i mutableWith: 0sz.
            while: i < resultSize do: (
                result at: i put: (self at: i)
            ) continueWith: (i := i + 1sz).
            result
        }
    };
    withSelector: #allButLast addMethod: {:(SequenceableCollection)self :: self species |
        self allButLast: 1sz
    };

    withSelector: #insertionSort:from:until: addMethod: {:(SequenceableCollection)self :lessThanComparison :(Size)startIndex :(Size)endIndex :: Void |
        ## Insertion sort algorithm from https://en.wikipedia.org/wiki/Insertion_sort [March 2023]
        let: #i mutableWith: startIndex + 1sz.
        let: #j mutableWith: 0sz.

        while: (i < endIndex) do: {
            let: #insertedElement with: (self at: i).
            j := i.
            while: (j > startIndex) && lessThanComparison(insertedElement, self at: j - 1sz) do: {
                self at: j put: (self at: j - 1sz)
            } continueWith: (j := j - 1sz).

            self at: j put: insertedElement.
        } continueWith: (i := i + 1sz)
    };
    withSelector: #partition:from:until: addMethod: {:(SequenceableCollection)self :lessThanComparison :(Size)startIndex :(Size)endIndex :: Size |
        let: #pivotIndex with: endIndex - 1sz.
        let: #pivot with: (self at: pivotIndex).

        let: #i mutableWith: startIndex.
        let: #j mutableWith: startIndex.
        while: (j < pivotIndex) do: {
            let: #element with: (self at: j).

            if: lessThanComparison(element, pivot) then: {
                if: i ~= j then: {
                    let: #temp with: (self at: i).
                    self at: i put: element.
                    self at: j put: temp.
                }.
                i := i + 1sz
            }
        } continueWith: (j := j + 1sz).

        let: #destElement with: (self at: i).
        self at: i put: pivot.
        self at: pivotIndex put: destElement.

        i
    };
    withSelector: #heapSort:from:until: addMethod: {:(SequenceableCollection)self :lessThanComparison :(Size)startIndex :(Size)endIndex :: Void |
        ## TODO: Implement this properly.
        self insertionSort: lessThanComparison from: startIndex until: endIndex
    };
    withSelector: #quickSort:from:until: addMethod: {:(SequenceableCollection)self :lessThanComparison :(Size)startIndex :(Size)endIndex :: Void |
        if: startIndex < endIndex then: {
            let: #partition with: (self partition: lessThanComparison from: startIndex until: endIndex).
            self quickSort: lessThanComparison from: startIndex until: partition.
            self quickSort: lessThanComparison from: partition + 1sz until: endIndex.
        }
    };
    withSelector: #introSort:from:until:maxDepth: addMethod: {:(SequenceableCollection)self :lessThanComparison :(Size)startIndex :(Size)endIndex :(Size)maxDepth :: Void |
        if: startIndex < endIndex then: {
            let: #rangeSize with: endIndex - startIndex.
            if: rangeSize <= 16sz then: {
                self insertionSort: lessThanComparison from: startIndex until: endIndex
            } else: {
                if: maxDepth = 0sz then: {
                    self heapSort: lessThanComparison from: startIndex until: endIndex
                } else: {
                    let: #partition with: (self partition: lessThanComparison from: startIndex until: endIndex).
                    self quickSort: lessThanComparison from: startIndex until: partition.
                    self quickSort: lessThanComparison from: partition + 1sz until: endIndex.
                }.
            }
        }
    };
    withSelector: #insertionSort: addMethod: {:(SequenceableCollection)self :lessThanComparison :: Void |
        self insertionSort: lessThanComparison from: 0sz until: self size
    };
    withSelector: #insertionSort addMethod: {:(SequenceableCollection)self :: Void |
        self sort: {:a :b :: Boolean | a < b }
    };
    withSelector: #heapSort: addMethod: {:(SequenceableCollection)self :lessThanComparison :: Void |
        self heapSort: lessThanComparison from: 0sz until: self size
    };
    withSelector: #heapSort addMethod: {:(SequenceableCollection)self :: Void |
        self sort: {:a :b :: Boolean | a < b }
    };
    withSelector: #quickSort: addMethod: {:(SequenceableCollection)self :lessThanComparison :: Void |
        self quickSort: lessThanComparison from: 0sz until: self size
    };
    withSelector: #quickSort addMethod: {:(SequenceableCollection)self :: Void |
        self sort: {:a :b :: Boolean | a < b }
    };
    withSelector: #sort: addMethod: {:(SequenceableCollection)self :lessThanComparison :: Void |
        self introSort: lessThanComparison from: 0sz until: self size maxDepth: 16sz
        ##self insertionSort: lessThanComparison from: 0sz until: self size
        ##self quickSort: lessThanComparison from: 0sz until: self size
        ##self heapSort: lessThanComparison from: 0sz until: self size
    };
    withSelector: #sort addMethod: {:(SequenceableCollection)self :: Void |
        self sort: {:a :b :: Boolean | a < b }
    };
    withSelector: #sorted: addMethod: {:(SequenceableCollection)self :lessThanComparison :: self __type__ |
        self copy sort: lessThanComparison; yourself
    };
    withSelector: #sorted addMethod: {:(SequenceableCollection)self :: self __type__ |
        self sorted: {:a :b :: Boolean | a < b }
    }.

OrderedCollection
    withSelector: #arrayType addClassMethod: {:(OrderedCollection class)self :: Array class |
        Array
    } makeVirtual;
    withSelector: #new: addClassMethod: {:(OrderedCollection class)self :(Size)initialSize :: self |
        self basicNew initializeWithSize: initialSize; yourself
    } makeOverride makeFinal;
    withSelector: #initialize addMethod: {:(OrderedCollection)self :: Void |
        self size: 0sz
    } makeOverride;
    withSelector: #initializeWithSize: addMethod: {:(OrderedCollection)self :(Size)initialSize :: Void |
        self size: initialSize.
        self storage: (self class arrayType new: initialSize).
    };
    withSelector: #capacity addMethod: {:(OrderedCollection)self :: Size |
        let: #storage with: self storage.
        if: storage == nil then: 0sz else: storage size
    };
    withSelector: #addAll: addMethod: {:(OrderedCollection)self :(Collection)elements |
        elements do: {:each :: Void |
            self add: each
        }
    };
    withSelector: #at: addMethod: {:(OrderedCollection)self :(Size)index |
        if: index < self size then: {
            self storage at: index
        } else: {
            error("Index out of bounds.")
        }
    } makeOverride;
    withSelector: #at:put: addMethod: {:(OrderedCollection)self :(Size)index :value :: Void |
        if: index < self size then: {
            self storage at: index put: value
        } else: {
            error("Index out of bounds.")
        }
    } makeOverride;
    withSelector: #removeAllThat: addMethod: {:(OrderedCollection)self :aPredicate :: Void |
        let: #size with: self size.
        let: #storage with: self storage.
        let: #newSize mutableWith: 0sz.
        let: #i mutableWith: 0sz.

        while: i < size do: {
            let: #element with: (storage at: i).
            (__tombstone__ == element) || aPredicate(element) ifFalse: {
                storage at: newSize put: element.
                newSize := newSize + 1sz
            }
        } continueWith: (i := i + 1sz).

        self size: newSize
    };
    withSelector: #removeAllOcurrencesOf: addMethod: {:(OrderedCollection)self :value :: Void |
        let: #size with: self size.
        let: #storage with: self storage.
        let: #newSize mutableWith: 0sz.
        let: #i mutableWith: 0sz.

        while: i < size do: {
            let: #element with: (storage at: i).
            (__tombstone__ == element) || (element = value) ifFalse: {
                storage at: newSize put: element.
                newSize := newSize + 1sz
            }
        } continueWith: (i := i + 1sz).

        self size: newSize
    }.

Dictionary
    withSelector: #new: addClassMethod: {:(Dictionary class)self :(Size)initialCapacity :: self |
        self basicNew initializeWithCapacity: initialCapacity; yourself
    } makeOverride makeFinal;
    withSelector: #initializeWithCapacity: addMethod: {:(Dictionary)self :(Size)initialCapacity :: Void |
        let: #requiredStorageCapacity with: initialCapacity * 130sz / 100sz.
        self storage: (Array new: requiredStorageCapacity).
    }.

WeakOrderedCollection
    withSelector: #arrayType addClassMethod: {:(OrderedCollection class)self :: Array class |
        WeakArray
    } makeOverride.
    
Array
    withSelector: #new: addClassMethod: {:(Array class)self :(Size)initialSize :: self |
        self basicNew: initialSize
    } makeOverride makeFinal;
    withSelector: #asArray addMethod: {:(Array)self :: Array | self } makeOverride;
    withSelector: #asArraySlice addMethod: {:(Array)self :: ArraySlice |
        ArraySlice basicNew
            elements: self;
            offset: 0sz;
            size: self size;
            yourself
    }.

ByteArray
    withSelector: #new: addClassMethod: {:(ByteArray class)self :(Size)initialSize :: self |
        self basicNew: initialSize
    } makeOverride makeFinal;
    withSelector: #at: addMethod: {:(ByteArray)self :(Size)index :: UInt8 |
        self __byteSlotAt__: index
    } makeOverride;
    withSelector: #at:put: addMethod: {:(ByteArray)self :(Size)index :(UInt8)value :: Void |
        self __byteSlotAt__: index put: value
    } makeOverride;
    withSelector: #size addMethod: {:(ByteArray)self :: Size |
        self __byteSize__
    } makeOverride;

    withSelector: #replaceBytesFrom:count:with:startingAt: addMethod: {:(ByteArray)self :(Size)startIndex :(Size)replacementSize :replacement :(Size)replacementOffset :: Void |
        self assert: (startIndex + replacementSize <= self size) && (replacementSize >= replacement __byteSize__).
        
        let: #i mutableWith: 0sz.
        while: (i < replacementSize) do: {
            self __byteSlotAt__: startIndex + i put: (replacement __byteSlotAt__: replacementOffset + i)
        } continueWith: (i := i + 1sz)
    };
    withSelector: #replaceBytesFrom:count:with: addMethod: {:(ByteArray)self :(Size)startIndex :(Size)replacementSize :replacement :: Void |
        self replaceBytesFrom: startIndex count: replacementSize with: replacement startingAt: 0sz
    };
    withSelector: #uint8At: addMethod: {:(ByteArray)self :(Size)index :: UInt8 |
        self at: index
    };
    withSelector: #uint8At:put: addMethod: {:(ByteArray)self :(Size)index :(UInt8)value :: Void |
        self at: index put: value
    };
    withSelector: #char8At: addMethod: {:(ByteArray)self :(Size)index :: Char8 |
        (self at: index) asChar8
    };
    withSelector: #char8At:put: addMethod: {:(ByteArray)self :(Size)index :(Char8)value :: Void |
        self uint8At: index put: value asUInt8
    };
    withSelector: #int8At: addMethod: {:(ByteArray)self :(Size)index :: Int8 |
        (self at: index) asInt8
    };
    withSelector: #int8At:put: addMethod: {:(ByteArray)self :(Size)index :(Int8)value :: Void |
        self uint8At: index put: value asUInt8
    };

    withSelector: #uint16At: addMethod: {:(ByteArray)self :(Size)index :: UInt16 |
        (self at: index) asUInt16
        | ((self at: index + 1sz) asUInt16 << 8u16)
    };
    withSelector: #uint16At:put: addMethod: {:(ByteArray)self :(Size)index :(UInt16)value :: Void |
        self
            at: index put: value asUInt8;
            at: index + 1sz put: (value >> 8u16) asUInt8
    };
    withSelector: #char16At: addMethod: {:(ByteArray)self :(Size)index :: Char16 |
        (self uint16At: index) asChar16
    };
    withSelector: #char16At:put: addMethod: {:(ByteArray)self :(Size)index :(Char16)value :: Void |
        self uint16At: index put: value asUInt16
    };
    withSelector: #int16At: addMethod: {:(ByteArray)self :(Size)index :: Int16 |
        (self uint16At: index) asInt16
    };
    withSelector: #int16At:put: addMethod: {:(ByteArray)self :(Size)index :(Int16)value :: Void |
        self uint16At: index put: value asUInt16
    };

    withSelector: #uint32At: addMethod: {:(ByteArray)self :(Size)index :: UInt32 |
        (((self at: index) asUInt32
        | ((self at: index + 1sz) asUInt32 << 8u32))
        | ((self at: index + 2sz) asUInt32 << 16u32))
        | ((self at: index + 3sz) asUInt32 << 24u32)
    };
    withSelector: #uint32At:put: addMethod: {:(ByteArray)self :(Size)index :(UInt32)value :: Void |
        self
            at: index put: value asUInt8;
            at: index + 1sz put: (value >> 8u32) asUInt8;
            at: index + 2sz put: (value >> 16u32) asUInt8;
            at: index + 3sz put: (value >> 24u32) asUInt8
    };
    withSelector: #char32At: addMethod: {:(ByteArray)self :(Size)index :: Char32 |
        (self uint32At: index) asChar32
    };
    withSelector: #char32At:put: addMethod: {:(ByteArray)self :(Size)index :(Char32)value :: Void |
        self uint32At: index put: value asUInt32
    };
    withSelector: #int32At: addMethod: {:(ByteArray)self :(Size)index :: Int32 |
        (self uint32At: index) asInt32
    };
    withSelector: #int32At:put: addMethod: {:(ByteArray)self :(Size)index :(Int32)value :: Void |
        self uint32At: index put: value asUInt32
    };

    withSelector: #uint64At: addMethod: {:(ByteArray)self :(Size)index :: UInt64 |
        (((((((self at: index) asUInt64
        | ((self at: index + 1sz) asUInt64 << 8u64))
        | ((self at: index + 2sz) asUInt64 << 16u64))
        | ((self at: index + 3sz) asUInt64 << 24u64))
        | ((self at: index + 4sz) asUInt64 << 32u64))
        | ((self at: index + 5sz) asUInt64 << 40u64))
        | ((self at: index + 6sz) asUInt64 << 48u64))
        | ((self at: index + 7sz) asUInt64 << 56u64)
    };
    withSelector: #uint64At:put: addMethod: {:(ByteArray)self :(Size)index :(UInt64) value :: Void |
        self
            at: index put: value asUInt8;
            at: index + 1sz put: (value >> 8u64) asUInt8;
            at: index + 2sz put: (value >> 16u64) asUInt8;
            at: index + 3sz put: (value >> 24u64) asUInt8;
            at: index + 4sz put: (value >> 32u64) asUInt8;
            at: index + 5sz put: (value >> 40u64) asUInt8;
            at: index + 6sz put: (value >> 48u64) asUInt8;
            at: index + 7sz put: (value >> 56u64) asUInt8
    };
    withSelector: #int64At: addMethod: {:(ByteArray)self :(Size)index :: Int64 |
        (self uint64At: index) asInt64
    };
    withSelector: #int64At:put: addMethod: {:(ByteArray)self :(Size)index :(Int64) value :: Void |
        self uint64At: index put: value asUInt64
    };

    withSelector: #float32At: addMethod: {:(ByteArray)self :(Size)index :: Float32 |
        (self uint32At: index) asIEEEFloat32Decoded
    };
    withSelector: #float32At:put: addMethod: {:(ByteArray)self :(Size)index :(Float32)value :: Void |
        self uint32At: index put: value asIEEEFloat32Encoding
    };

    withSelector: #float64At: addMethod: {:(ByteArray)self :(Size)index :: Float64 |
        (self uint64At: index) asIEEEFloat64Decoded
    };
    withSelector: #float64At:put: addMethod: {:(ByteArray)self :(Size)index :(Float64)value :: Void |
        self uint64At: index put: value asIEEEFloat64Encoding
    };

    withSelector: #printOn: addMethod: {:(ByteArray)self :(Stream)stream :: Void |
        stream nextPutAll: "#[".
        self doWithIndex: {:element :index :: Void |
            if: index > 0sz then: (stream nextPutAll: ". ").
            stream print: element.
            void
        }.

        stream nextPutAll: "]"
    } makeOverride.

String
    withSelector: #new: addClassMethod: {:(String class)self :(Size)initialSize :: self |
        self basicNew: initialSize
    } makeOverride makeFinal;
    withSelector: #at: addMethod: {:(String)self :(Size)index :: Char8 |
        (self __byteSlotAt__: index) asChar8
    } makeOverride;
    withSelector: #at:put: addMethod: {:(String)self :(Size)index :(Char8)value :: Void |
        self __byteSlotAt__: index put: value asUInt8
    } makeOverride;
    withSelector: #size addMethod: {:(String)self :: Size |
        self __byteSize__
    } makeOverride;
    withSelector: #replaceBytesFrom:count:with:startingAt: addMethod: {:(String)self :(Size)startIndex :(Size)replacementSize :replacement :(Size)replacementOffset :: Void |
        self assert: (startIndex + replacementSize <= self size) && (replacementSize >= replacement __byteSize__).
        
        let: #i mutableWith: 0sz.
        while: (i < replacementSize) do: {
            self __byteSlotAt__: startIndex + i put: (replacement __byteSlotAt__: replacementOffset + i)
        } continueWith: (i := i + 1sz)
    };
    withSelector: #replaceBytesFrom:count:with: addMethod: {:(String)self :(Size)startIndex :(Size)replacementSize :replacement :: Void |
        self replaceBytesFrom: startIndex count: replacementSize with: replacement startingAt: 0sz
    };
    withSelector: #padLeft:with: addMethod: {:(String)self :(Size)requiredLength :(Char8)paddingCharacter :: self species |
        let: #size with: self size.
        if: size >= requiredLength then: self
        else: {
            let: #paddingSize with: requiredLength - size.
            let: #result with: (self species new: requiredLength).

            let: #i mutableWith: 0sz.
            while: i < paddingSize do: (
                result at: i put: paddingCharacter
            ) continueWith: (i := i + 1sz).
            
            i := 0sz.
            while: i < size do: (
                result at: i + paddingSize put: (self at: i)
            ) continueWith: (i := i + 1sz).
            result
        }
    };
    withSelector: #padLeft: addMethod: {:(String)self :(Size)requiredLength :: self species |
        self padLeft: requiredLength with: ' 'c8
    }.

StringSymbol
    withSelector: #at: addMethod: {:(StringSymbol)self :(Size)index :: Char8 |
        (self __byteSlotAt__: index) asChar8
    };
    withSelector: #at:put: addMethod: {:(StringSymbol)self :(Size)index :(Char8)value :: Void |
        self __byteSlotAt__: index put: value asUInt8
    };
    withSelector: #size addMethod: {:(StringSymbol)self :: Size |
        self __byteSize__
    }.

ByteStream
    withSelector: #nextPutUInt16: addMethod: {:(ByteStream)self :(UInt16)value :: Void |
        self
            nextPut: value asUInt8;
            nextPut: (value >> 8u16) asUInt8
    };
    withSelector: #nextPutUInt32: addMethod: {:(ByteStream)self :(UInt32)value :: Void |
        self
            nextPut: value asUInt8;
            nextPut: (value >> 8u32) asUInt8;
            nextPut: (value >> 16u32) asUInt8;
            nextPut: (value >> 24u32) asUInt8
    };
    withSelector: #nextPutUInt64: addMethod: {:(ByteStream)self :(UInt64)value :: Void |
        self
            nextPut: value asUInt8;
            nextPut: (value >> 8u64) asUInt8;
            nextPut: (value >> 16u64) asUInt8;
            nextPut: (value >> 24u64) asUInt8;

            nextPut: (value >> 32u64) asUInt8;
            nextPut: (value >> 40u64) asUInt8;
            nextPut: (value >> 48u64) asUInt8;
            nextPut: (value >> 56u64) asUInt8
    }.

ArraySlice
    withSelector: #new: addClassMethod: {:(ArraySlice class)self :(Size)size :: self |
        self basicNew
            elements: (Array basicNew: size);
            offset: 0sz;
            size: size;
            yourself
    } makeOverride;
    withSelector: #at: addMethod: {:(ArraySlice)self :(Size)index |
        if: index < self size then: {
            self elements at: index + self offset
        } else: {
            error("Index out of bounds.")
        }
    } makeOverride;
    withSelector: #at:put: addMethod: {:(ArraySlice)self :(Size)index :value :: Void |
        if: index < self size then: {
            self elements at: index + self offset put: value
        } else: {
            error("Index out of bounds.")
        }
    } makeOverride.

MethodDictionary
    withSelector: #keysAndValuesDo: addMethod: {:(MethodDictionary)self :aBlock :: Void |
        let: #storage with: self storage.
        if: storage ~~ nil then: {
            self storage pairsDo: {:selector :method :: Void |
                if: selector ~~ __hashtableEmptyElement__ then: aBlock(selector, method)
            }
        }
    };
    withSelector: #do: addMethod: {:(MethodDictionary)self :aBlock :: Void |
        self keysAndValuesDo: {:selector :method :: Void |
            aBlock(Association key: selector value: method)
        }
    } makeOverride.

## Byte encoding
Type
    withSelector: #canEncodeValueInBytes addMethod: {:(Type)self :: Boolean | false } makeVirtual;
    withSelector: #encodeValue:inBytes:atOffset: addMethod: {:(Type)self :value :(ByteArray)bytes :(Size)offset :: Void |
        self subclassResponsibility
    } makeAbstract;
    withSelector: #encodeValueIn:atTypeSlot:inBytes:atOffset: addMethod: {:(Type)self :(Untyped)valueOwner :(TypeSlot)typeSlot :(ByteArray)bytes :(Size)offset :: Void |
        self encodeValue: (RawTuple::typeSlotAt:)(valueOwner, typeSlot) inBytes: bytes atOffset: offset
    } makeVirtual;
    withSelector: #canDecodeValueFromBytes addMethod: {:(Type)self :: Boolean | false } makeVirtual;
    withSelector: #decodeValueFromBytes:atOffset: addMethod: {:(Type)self :(ByteArray)bytes :(Size)offset :: self |
        self subclassResponsibility
    } makeAbstract;
    
    withSelector: #encodeValueAsByteArray: addMethod: {:(Type)self :value :: ByteArray |
        let: #result with: (ByteArray new: self alignedValueSize).
        self encodeValue: value inBytes: result atOffset: 0sz.
        result
    } makeVirtual;
    withSelector: #decodeValueFromByteArray: addMethod: {:(Type)self :(ByteArray)bytes :: self |
        self decodeValueFromBytes: bytes atOffset: 0sz
    } makeVirtual.

AnyValue
    withSelector: #sizeOfByteEncoding addMethod: {:self :: Size | self __type__ alignedValueSize } makeVirtual;
    withSelector: #canEncodeInBytes addMethod: {:self :: Boolean | self __type__ canEncodeValueInBytes } makeVirtual;
    withSelector: #offsetOfEncodedElementInByteStream: addMethod: {:self :(Size)offset :: Void | } makeVirtual;
    withSelector: #encodeInBytes:atOffset: addMethod: {:self :(ByteArray)bytes :(Size)offset :: Void |
        self __type__ encodeValue: self inBytes: bytes atOffset: offset
    } makeVirtual;
    withSelector: #encodedInByteArray addMethod: {:self :: ByteArray |
        let: #result with: (ByteArray new: self sizeOfByteEncoding).
        self encodeInBytes: result atOffset: 0sz.
        result
    } makeVirtual.

## Primitive numbers meta methods.
Char8 class
    withSelector: #canEncodeValueInBytes addMethod: {:(Char8 class)self :: Boolean | true } makeOverride;
    withSelector: #encodeValue:inBytes:atOffset: addMethod: {:(Char8 class)self :(Char8)value :(ByteArray)bytes :(Size)offset :: Void |
        bytes char8At: offset put: value
    } makeOverride;
    withSelector: #canDecodeValueFromBytes addMethod: {:(Char8 class)self :: Boolean | true } makeOverride;
    withSelector: #decodeValueFromBytes:atOffset: addMethod: {:(Char8 class)self :(ByteArray)bytes :(Size)offset :: Char8 |
        bytes char8At: offset
    } makeOverride;

    withSelector: #defaultValue addMethod: {:(Char8 class)self :: Char8 | 0c8 } makeOverride;
    withSelector: #zero addMethod: {:(Char8 class)self :: Char8 | 0c8 } makePure makeFinal;
    withSelector: #one addMethod: {:(Char8 class)self :: Char8 | 1c8 } makePure makeFinal.

UInt8 class
    withSelector: #canEncodeValueInBytes addMethod: {:(UInt8 class)self :: Boolean | true } makeOverride;
    withSelector: #encodeValue:inBytes:atOffset: addMethod: {:(UInt8 class)self :(UInt8)value :(ByteArray)bytes :(Size)offset :: Void |
        bytes uint8At: offset put: value
    } makeOverride;
    withSelector: #canDecodeValueFromBytes addMethod: {:(UInt8 class)self :: Boolean | true } makeOverride;
    withSelector: #decodeValueFromBytes:atOffset: addMethod: {:(UInt8 class)self :(ByteArray)bytes :(Size)offset :: UInt8 |
        bytes uint8At: offset
    } makeOverride;

    withSelector: #defaultValue addMethod: {:(UInt8 class)self :: UInt8 | 0u8 } makeOverride;
    withSelector: #zero addMethod: {:(UInt8 class)self :: UInt8 | 0u8 } makePure makeFinal;
    withSelector: #one addMethod: {:(UInt8 class)self :: UInt8 | 1u8 } makePure makeFinal.

Int8 class
    withSelector: #canEncodeValueInBytes addMethod: {:(Int8 class)self :: Boolean | true } makeOverride;
    withSelector: #encodeValue:inBytes:atOffset: addMethod: {:(Int8 class)self :(Int8)value :(ByteArray)bytes :(Size)offset :: Void |
        bytes int8At: offset put: value
    } makeOverride;
    withSelector: #canDecodeValueFromBytes addMethod: {:(Int8 class)self :: Boolean | true } makeOverride;
    withSelector: #decodeValueFromBytes:atOffset: addMethod: {:(Int8 class)self :(ByteArray)bytes :(Size)offset :: Int8 |
        bytes int8At: offset
    } makeOverride;

    withSelector: #defaultValue addMethod: {:(Int8 class)self :: Int8 | 0i8 } makeOverride;
    withSelector: #zero addMethod: {:(Int8 class)self :: Int8 | 0i8 } makePure makeFinal;
    withSelector: #one addMethod: {:(Int8 class)self :: Int8 | 1i8 } makePure makeFinal.

Char16 class
    withSelector: #canEncodeValueInBytes addMethod: {:(Char16 class)self :: Boolean | true } makeOverride;
    withSelector: #encodeValue:inBytes:atOffset: addMethod: {:(Char16 class)self :(Char16)value :(ByteArray)bytes :(Size)offset :: Void |
        bytes char16At: offset put: value
    } makeOverride;
    withSelector: #canDecodeValueFromBytes addMethod: {:(Char16 class)self :: Boolean | true } makeOverride;
    withSelector: #decodeValueFromBytes:atOffset: addMethod: {:(Char16 class)self :(ByteArray)bytes :(Size)offset :: Char16 |
        bytes char16At: offset
    } makeOverride;

    withSelector: #defaultValue addMethod: {:(Char16 class)self :: Char16 | 0c16 } makeOverride;
    withSelector: #zero addMethod: {:(Char16 class)self :: Char16 | 0c16 } makePure makeFinal;
    withSelector: #one addMethod: {:(Char16 class)self :: Char16 | 1c16 } makePure makeFinal.

UInt16 class
    withSelector: #canEncodeValueInBytes addMethod: {:(UInt16 class)self :: Boolean | true } makeOverride;
    withSelector: #encodeValue:inBytes:atOffset: addMethod: {:(UInt16 class)self :(UInt16)value :(ByteArray)bytes :(Size)offset :: Void |
        bytes uint16At: offset put: value
    } makeOverride;
    withSelector: #canDecodeValueFromBytes addMethod: {:(UInt16 class)self :: Boolean | true } makeOverride;
    withSelector: #decodeValueFromBytes:atOffset: addMethod: {:(UInt16 class)self :(ByteArray)bytes :(Size)offset :: UInt16 |
        bytes uint16At: offset
    } makeOverride;

    withSelector: #defaultValue addMethod: {:(UInt16 class)self :: UInt16 | 0u16 } makeOverride;
    withSelector: #zero addMethod: {:(UInt16 class)self :: UInt16 | 0u16 } makePure makeFinal;
    withSelector: #one addMethod: {:(UInt16 class)self :: UInt16 | 1u16 } makePure makeFinal.

Int16 class
    withSelector: #canEncodeValueInBytes addMethod: {:(Int16 class)self :: Boolean | true } makeOverride;
    withSelector: #encodeValue:inBytes:atOffset: addMethod: {:(Int16 class)self :(Int16)value :(ByteArray)bytes :(Size)offset :: Void |
        bytes int16At: offset put: value
    } makeOverride;
    withSelector: #canDecodeValueFromBytes addMethod: {:(Int16 class)self :: Boolean | true } makeOverride;
    withSelector: #decodeValueFromBytes:atOffset: addMethod: {:(Int16 class)self :(ByteArray)bytes :(Size)offset :: Int16 |
        bytes int16At: offset
    } makeOverride;

    withSelector: #defaultValue addMethod: {:(Int16 class)self :: Int16 | 0i16 } makeOverride;
    withSelector: #zero addMethod: {:(Int16 class)self :: Int16 | 0i16 } makePure makeFinal;
    withSelector: #one addMethod: {:(Int16 class)self :: Int16 | 1i16 } makePure makeFinal.

Char32 class
    withSelector: #canEncodeValueInBytes addMethod: {:(Char32 class)self :: Boolean | true } makeOverride;
    withSelector: #encodeValue:inBytes:atOffset: addMethod: {:(Char32 class)self :(Char32)value :(ByteArray)bytes :(Size)offset :: Void |
        bytes char32At: offset put: value
    } makeOverride;
    withSelector: #canDecodeValueFromBytes addMethod: {:(Char32 class)self :: Boolean | true } makeOverride;
    withSelector: #decodeValueFromBytes:atOffset: addMethod: {:(Char32 class)self :(ByteArray)bytes :(Size)offset :: Char32 |
        bytes char32At: offset
    } makeOverride;

    withSelector: #defaultValue addMethod: {:(Char32 class)self :: Char32 | 0c32 } makeOverride;
    withSelector: #zero addMethod: {:(Char32 class)self :: Char32 | 0c32 } makePure makeFinal;
    withSelector: #one addMethod: {:(Char32 class)self :: Char32 | 1c32 } makePure makeFinal.

Char32
    withSelector: #c8 addMethod: Char32 >> #asChar8;
    withSelector: #c16 addMethod: Char32 >> #asChar16;
    withSelector: #c32 addMethod: Char32 >> #asChar32.

UInt32 class
    withSelector: #canEncodeValueInBytes addMethod: {:(UInt32 class)self :: Boolean | true } makeOverride;
    withSelector: #encodeValue:inBytes:atOffset: addMethod: {:(UInt32 class)self :(UInt32)value :(ByteArray)bytes :(Size)offset :: Void |
        bytes uint32At: offset put: value
    } makeOverride;
    withSelector: #canDecodeValueFromBytes addMethod: {:(UInt32 class)self :: Boolean | true } makeOverride;
    withSelector: #decodeValueFromBytes:atOffset: addMethod: {:(UInt32 class)self :(ByteArray)bytes :(Size)offset :: UInt32 |
        bytes uint32At: offset
    } makeOverride;

    withSelector: #defaultValue addMethod: {:(UInt32 class)self :: UInt32 | 0u32 } makeOverride;
    withSelector: #zero addMethod: {:(UInt32 class)self :: UInt32 | 0u32 } makePure makeFinal;
    withSelector: #one addMethod: {:(UInt32 class)self :: UInt32 | 1u32 } makePure makeFinal.

Int32 class
    withSelector: #canEncodeValueInBytes addMethod: {:(Int32 class)self :: Boolean | true } makeOverride;
    withSelector: #encodeValue:inBytes:atOffset: addMethod: {:(Int32 class)self :(Int32)value :(ByteArray)bytes :(Size)offset :: Void |
        bytes int32At: offset put: value
    } makeOverride;
    withSelector: #canDecodeValueFromBytes addMethod: {:(Int32 class)self :: Boolean | true } makeOverride;
    withSelector: #decodeValueFromBytes:atOffset: addMethod: {:(Int32 class)self :(ByteArray)bytes :(Size)offset :: Int32 |
        bytes int32At: offset
    } makeOverride;

    withSelector: #defaultValue addMethod: {:(Int32 class)self :: Int32 | 0i32 } makeOverride;
    withSelector: #zero addMethod: {:(Int32 class)self :: Int32 | 0i32 } makePure makeFinal;
    withSelector: #one addMethod: {:(Int32 class)self :: Int32 | 1i32 } makePure makeFinal;
    withSelector: #minVal addMethod: {:(Int32 class)self :: Int32 | 16r80000000 i32 } makePure makeFinal;
    withSelector: #maxVal addMethod: {:(Int32 class)self :: Int32 | 16r7FFFFFFF i32 } makePure makeFinal.

Int64 class
    withSelector: #canEncodeValueInBytes addMethod: {:(Int64 class)self :: Boolean | true } makeOverride;
    withSelector: #encodeValue:inBytes:atOffset: addMethod: {:(Int64 class)self :(Int64)value :(ByteArray)bytes :(Size)offset :: Void |
        bytes int64At: offset put: value
    } makeOverride;
    withSelector: #canDecodeValueFromBytes addMethod: {:(Int64 class)self :: Boolean | true } makeOverride;
    withSelector: #decodeValueFromBytes:atOffset: addMethod: {:(Int64 class)self :(ByteArray)bytes :(Size)offset :: Int64 |
        bytes int64At: offset
    } makeOverride;

    withSelector: #defaultValue addMethod: {:(Int64 class)self :: Int64 | 0i64 } makeOverride;
    withSelector: #zero addMethod: {:(Int64 class)self :: Int64 | 0i64 } makePure makeFinal;
    withSelector: #one addMethod: {:(Int64 class)self :: Int64 | 1i64 } makePure makeFinal.

UInt64 class
    withSelector: #canEncodeValueInBytes addMethod: {:(UInt64 class)self :: Boolean | true } makeOverride;
    withSelector: #encodeValue:inBytes:atOffset: addMethod: {:(UInt64 class)self :(UInt64)value :(ByteArray)bytes :(Size)offset :: Void |
        bytes uint64At: offset put: value
    } makeOverride;
    withSelector: #canDecodeValueFromBytes addMethod: {:(UInt64 class)self :: Boolean | true } makeOverride;
    withSelector: #decodeValueFromBytes:atOffset: addMethod: {:(UInt64 class)self :(ByteArray)bytes :(Size)offset :: UInt64 |
        bytes uint64At: offset
    } makeOverride;

    withSelector: #defaultValue addMethod: {:(UInt64 class)self :: UInt64 | 0u64 } makeOverride;
    withSelector: #zero addMethod: {:(UInt64 class)self :: UInt64 | 0u64 } makePure makeFinal;
    withSelector: #one addMethod: {:(UInt64 class)self :: UInt64 | 1u64 } makePure makeFinal.

Float32 class
    withSelector: #canEncodeValueInBytes addMethod: {:(Float32 class)self :: Boolean | true } makeOverride;
    withSelector: #encodeValue:inBytes:atOffset: addMethod: {:(Float32 class)self :(Float32)value :(ByteArray)bytes :(Size)offset :: Void |
        bytes float32At: offset put: value
    } makeOverride;
    withSelector: #canDecodeValueFromBytes addMethod: {:(Float32 class)self :: Boolean | true } makeOverride;
    withSelector: #decodeValueFromBytes:atOffset: addMethod: {:(Float32 class)self :(ByteArray)bytes :(Size)offset :: Float32 |
        bytes float32At: offset
    } makeOverride;

    withSelector: #defaultValue addMethod: {:(Float32 class)self :: Float32 | 0.0f32 } makeOverride;
    withSelector: #zero addMethod: {:(Float32 class)self :: Float32 | 0.0f32 } makePure makeFinal;
    withSelector: #one addMethod: {:(Float32 class)self :: Float32 | 1.0f32 } makePure makeFinal.

Float64 class
    withSelector: #canEncodeValueInBytes addMethod: {:(Float64 class)self :: Boolean | true } makeOverride;
    withSelector: #encodeValue:inBytes:atOffset: addMethod: {:(Float64 class)self :(Float64)value :(ByteArray)bytes :(Size)offset :: Void |
        bytes float64At: offset put: value
    } makeOverride;
    withSelector: #canDecodeValueFromBytes addMethod: {:(Float64 class)self :: Boolean | true } makeOverride;
    withSelector: #decodeValueFromBytes:atOffset: addMethod: {:(Float64 class)self :(ByteArray)bytes :(Size)offset :: Float64 |
        bytes float64At: offset
    } makeOverride;

    withSelector: #defaultValue addMethod: {:(Float64 class)self :: Float64 | 0.0 } makeOverride;
    withSelector: #zero addMethod: {:(Float64 class)self :: Float64 | 0.0 } makePure makeFinal;
    withSelector: #one addMethod: {:(Float64 class)self :: Float64 | 1.0 } makePure makeFinal.

Integer class
    withSelector: #defaultValue addMethod: {:(Integer class)self :: Integer | 0 } makeOverride;
    withSelector: #zero addMethod: {:(Integer class)self :: Integer | 0 } makePure makeFinal;
    withSelector: #one addMethod: {:(Integer class)self :: Integer | 1 } makePure makeFinal.

Boolean class
    withSelector: #canEncodeValueInBytes addMethod: {:(Boolean class)self :: Boolean | true } makeOverride;
    withSelector: #encodeValue:inBytes:atOffset: addMethod: {:(Boolean class)self :(Boolean)value :(ByteArray)bytes :(Size)offset :: Void |
        bytes at: offset put: (if: value then: 1u8 else: 0u8)
    } makeOverride;
    withSelector: #canDecodeValueFromBytes addMethod: {:(Boolean class)self :: Boolean | true } makeOverride;
    withSelector: #decodeValueFromBytes:atOffset: addMethod: {:(Boolean class)self :(ByteArray)bytes :(Size)offset :: Boolean |
        (bytes at: offset) ~= 0u8
    } makeOverride;

    withSelector: #defaultValue addMethod: {:(Boolean class)self :: Boolean | false } makeOverride makePure makeFinal.

SequenceableCollection
    withSelector: #computeOffsetsOfEncodedElementsInByteStream addMethod: {:(SequenceableCollection)self :: Size |
        let: #offset mutableWith: 0sz.
        self do: {:each :: Void |
            each offsetOfEncodedElementInByteStream: offset.
            offset := offset + each sizeOfByteEncoding
        }.
        offset
    };
    withSelector: #encodedElementsInByteArray addMethod: {:(SequenceableCollection)self :: ByteArray |
        let: #result with: (ByteArray new: self computeOffsetsOfEncodedElementsInByteStream).
        let: #offset mutableWith: 0sz.
        self do: {:each :: Void |
            each encodeInBytes: result atOffset: offset.
            offset := offset + each sizeOfByteEncoding
        }.
        result
    }.

TypeSlot
    withSelector: #requiresBasicInitialization addMethod: {:(TypeSlot)self :: Boolean |
        let: #type with: self type.
        (self initialValueBlock ~~ nil) || ((type ~~ nil) && (type isNullable not))
    } withEagerAnalysis;
    withSelector: #initialValueExpression addMethod: {:(TypeSlot)self :: ASTNode |
        let: #initialValueBlock with: self initialValueBlock.
        if: initialValueBlock ~~ nil then: {
            error("Generate initialValueBlock application")
        } else: {
            let: #type with: self type.
            ASTLiteralNode new
                sourcePosition: self sourcePosition;
                value: (if: type ~~ nil then: type defaultValue else: nil);
                yourself
        }
    };
    withSelector: #validOffset addMethod: {:(TypeSlot)self :: Size |
        let: #owner with: self owner.
        if: owner ~~ nil then: ((owner downCastTo: Type) ensureLayoutIsComputed).
        self offset.
    };
    withSelector: #validReferenceType addMethod: {:(TypeSlot)self :: Type |
        if: self referenceType == nil then: (self referenceType: self type ref).
        self referenceType
    }.

Type
    withSelector: #validSlotsWithBasicInitialization addMethod: {:(Type)self :: Array |
        if: self slotsWithBasicInitialization == nil then: {
            let: #supertype with: self supertype.
            let: #result with: OrderedCollection new.
            if: supertype ~~ nil then: (result addAll: supertype validSlotsWithBasicInitialization).

            self validSlots do: {:(TypeSlot)typeSlot :: Void |
                if: typeSlot requiresBasicInitialization then: {
                    result add: typeSlot
                }.
            }.

            self slotsWithBasicInitialization: result asArray
        }.
        self slotsWithBasicInitialization
    };
    ensureAnalysisOfMethodWithSelector: #validSlotsWithBasicInitialization.

{
    let: #createBasicInitializeMethod with: {:(Type)self :: Void |
        let: #ReceiverType with: self asReceiverType.
        let: #slots with: self validSlotsWithBasicInitialization.
        let: #slotCount with: slots size.

        let: #makeTypeSlotNode with: {:(TypeSlot)eachSlot :: ASTNode |
            ASTTupleSlotNamedAtPutNode new
                sourcePosition: eachSlot sourcePosition;
                tupleExpression: (ASTIdentifierReferenceNode new
                    sourcePosition: eachSlot sourcePosition;
                    value: #self;
                    yourself);
                valueExpression: eachSlot initialValueExpression;
                boundSlot: eachSlot;
                yourself
            }.

        let: #defaultValueSlots with: (slots select: {:(TypeSlot)each :: Boolean | each initialValueBlock == nil}).
        let: #defaultValueSlotInitialization with: (ASTSequenceNode new
            expressions: (defaultValueSlots collect: makeTypeSlotNode) asArray;
            yourself).

        let: #initialValueSlots with: (slots select: {:(TypeSlot)each :: Boolean | each initialValueBlock ~~ nil}).
        let: #initialValueSlotInitialization with: (initialValueSlots collect: makeTypeSlotNode) asArray.

        let: #methodNode with: (ASTLambdaNode new
            arguments: (Array with: (ASTArgumentNode new
                isForAll: false;
                name: (ASTLiteralNode new
                    value: #self;
                    yourself);
                type: (ASTLiteralNode new
                    value: ReceiverType;
                    yourself);
                yourself));
            resultType: (ASTLiteralNode new
                value: Void;
                yourself);
            body: (ASTSequenceNode new
                expressions: (Array with: (ASTIfNode new
                    conditionExpression: (ASTFunctionApplicationNode new
                        functionExpression: (ASTLiteralNode new
                            value: ObjectModel::isLogical;
                            yourself);
                        arguments: #();
                        yourself);
                    trueExpression: defaultValueSlotInitialization;
                    yourself)) -- initialValueSlotInitialization;
                yourself);
            flags: (if: self supertype ~~ nil
                then: FunctionFlags::Override
                else: FunctionFlags::Virtual);
            hasLazyAnalysis: false;
            yourself).
        let: #methodFromAST with: (methodNode analyzeAndEvaluateWithEnvironment: Environment defaultForEvaluation).

        self basicInitializeMethod: methodFromAST.
        self withSelector: #basicInitialize addOrReplaceMethod: self basicInitializeMethod.
    } makeVirtual withEagerAnalysis.

    createBasicInitializeMethod(Object).
    createBasicInitializeMethod(Array).
    createBasicInitializeMethod(Environment).
    createBasicInitializeMethod(OrderedCollection).
    createBasicInitializeMethod(Function).
    createBasicInitializeMethod(FunctionDefinition).
    createBasicInitializeMethod(String).
    createBasicInitializeMethod(StringSymbol).
    createBasicInitializeMethod(SymbolArgumentBinding).
    createBasicInitializeMethod(SymbolCaptureBinding).
    createBasicInitializeMethod(SymbolLocalBinding).
    createBasicInitializeMethod(SimpleFunctionType).
    createBasicInitializeMethod(ASTArgumentNode).
    createBasicInitializeMethod(ASTIdentifierReferenceNode).
    createBasicInitializeMethod(ASTIfNode).
    createBasicInitializeMethod(ASTLambdaNode).
    createBasicInitializeMethod(ASTFunctionApplicationNode).
    createBasicInitializeMethod(ASTLocalDefinitionNode).
    createBasicInitializeMethod(ASTLiteralNode).
    createBasicInitializeMethod(ASTSequenceNode).
    createBasicInitializeMethod(ASTTupleSlotNamedAtPutNode).
    Type withSelector: #createBasicInitializeMethod replaceMethod: createBasicInitializeMethod
}.

Type
    withSelector: #validSubtypeList addMethod: {:(Type)self :: WeakOrderedCollection |
        if: self subtypes == nil then: (self subtypes: WeakOrderedCollection new).
        self subtypes
    };
    withSelector: #addSubtype: addMethod: {:(Type)self :(Type)aSubtype :: Void |
        let: #subtypes with: self validSubtypeList.
        if: (subtypes includes: aSubtype) not then: (subtypes add: aSubtype)
    };
    withSelector: #registerInSuperMetatype addMethod: {:(Type)self :: Void |
        ## By default do nothing
    } makeVirtual;
    withSelector: #registerInSupertype addMethod: {:(Type)self :: Void |
        let: #supertype with: self supertype.
        if: supertype ~~ nil then: (supertype addSubtype: self).
        self __type__ registerInSuperMetatype
    };
    withSelector: #withSupertypesDo: addMethod: {:(Type)self :aBlock :: Void |
        aBlock(self).
        let: #supertype with: self supertype.
        if: supertype ~~ nil then: (supertype withSupertypesDo: aBlock).
    };
    withSelector: #subtypesDo: addMethod: {:(Type)self :aBlock :: Void |
        let: #subtypes with: self subtypes.
        if: subtypes ~~ nil then: (subtypes doWithoutTombstones: aBlock)
    };
    withSelector: #withSubtypesDo: addMethod: {:(Type)self :aBlock :: Void |
        aBlock(self).
        self subtypesDo: aBlock.
    };
    withSelector: #allSubtypesDo: addMethod: {:(Type)self :aBlock :: Void |
        self subtypesDo: {:(Type)each :: Void |
            aBlock(each).
            each allSubtypesDo: aBlock
        }
    };
    withSelector: #withAllSubtypesDo: addMethod: {:(Type)self :aBlock :: Void |
        aBlock(self).
        self allSubtypesDo: aBlock
    };

    withSelector: #allSubtypes addMethod: {:(Type)self :: OrderedCollection |
        let: #result with: OrderedCollection new.
        self allSubtypesDo: {:(Type)each :: Void |
            result add: each
        }.
        result
    };
    withSelector: #withAllSubtypes addMethod: {:(Type)self :: OrderedCollection |
        let: #result with: OrderedCollection new.
        self withAllSubtypesDo: {:(Type)each :: Void |
            result add: each
        }.
        result
    };

    withSelector: #selectorsDo: addMethod: {:(Type)self :aBlock :: Void |
        let: #methodDictionary with: self methodDictionary.
        if: methodDictionary ~~ nil then: (methodDictionary keysAndValuesDo: {:key :value |
            aBlock(key)
        })
    };
    withSelector: #selectors addMethod: {:(Type)self :: Array |
        let: #selectors with: OrderedCollection new.

        self selectorsDo: {:each :: Void |
            selectors add: each
        }.

        selectors asArray
    };
    withSelector: #allMethodsDo: addMethod: {:(Type)self :aBlock :: Void |
        let: #dictionaryIterationBlock with: {:selector :method :: Void |
            aBlock(method)
        }.

        let: #macroMethodDictionary with: self macroMethodDictionary.
        if: macroMethodDictionary ~~ nil then: (macroMethodDictionary keysAndValuesDo: dictionaryIterationBlock).

        let: #methodDictionary with: self methodDictionary.
        if: methodDictionary ~~ nil then: (methodDictionary keysAndValuesDo: dictionaryIterationBlock).

        let: #fallbackMethodDictionary with: self fallbackMethodDictionary.
        if: fallbackMethodDictionary ~~ nil then: (fallbackMethodDictionary keysAndValuesDo: dictionaryIterationBlock).
    };
    withSelector: #allInstancesDo: addMethod: {:(Type)self :aBlock :: Void |
        let: #instance mutableWith: RawTuple::firstInstanceWithType(self).
        while: instance ~~ nil do: (
            aBlock(instance)
        ) continueWith: (instance := RawTuple::nextInstanceWithSameType(instance))
    };
    withSelector: #allInstances addMethod: {:(Type)self :: Array |
        let: #instance mutableWith: RawTuple::firstInstanceWithType(self).
        let: #result with: OrderedCollection new.
        while: instance ~~ nil do: (
            result add: instance
        ) continueWith: (instance := RawTuple::nextInstanceWithSameType(instance)).

        result asArray
    };
    withSelector: #allSlotsDo: addMethod: {:(Type)self :(TypeSlot => Void)aBlock :: Void |
        let: #supertype with: self supertype.
        if: supertype ~~ nil then: (supertype allSlotsDo: aBlock).
        self validSlots do: aBlock
    }.

Metatype
    withSelector: #registerInSuperMetatype addMethod: {:(Type)self :: Void |
        self registerInSupertype
    } makeOverride.

## Construct the subtype links
BootstrapEnv::IntrinsicTypes do: {:(Type)each :: Void |
    each registerInSupertype 
}.

TypeSlot
    withSelector: #named:type:flags: addClassMethod: {:(TypeSlot class)self :name :(Type)type :(Size)flags :: self |
        self new
            name: name;
            type: type;
            flags: flags;
            localIndex: 0sz;
            index: 0sz;
            yourself
    };
    withSelector: #named:type:flags:initialValueBlock: addClassMethod: {:(TypeSlot class)self :name :(Type)type :(Size)flags :(AnyValue)initialValueBlock :: self |
        self new
            name: name;
            type: type;
            flags: flags;
            localIndex: 0sz;
            index: 0sz;
            initialValueBlock: initialValueBlock;
            yourself
    };
    withSelector: #named:type: addClassMethod: {:(TypeSlot class)self :name :(Type)type :: self |
        self named: name type: type flags: TypeSlotFlags::None
    };
    withSelector: #named:flags: addClassMethod: {:(TypeSlot class)self :name :(Size)flags :: self |
        self named: name type: AnyValue flags: flags
    };
    withSelector: #named:flags:initialValueBlock: addClassMethod: {:(TypeSlot class)self :name :(Size)flags :(AnyValue)initialValueBlock :: self |
        self named: name type: AnyValue flags: flags initialValueBlock: initialValueBlock
    };
    withSelector: #named: addClassMethod: {:(TypeSlot class)self :name :(Type)type :: self |
        self publicNamed: name type: AnyValue
    };
    withSelector: #publicNamed:type: addClassMethod: {:(TypeSlot class)self :name :(Type)type :: self |
        self named: name type: type flags: TypeSlotFlags::Public
    };
    withSelector: #publicNamed: addClassMethod: {:(TypeSlot class)self :name :(Type)type :: self |
        self publicNamed: name type: AnyValue
    }.

Type
    withSelector: #generatePublicAccessors addMethod: {:(Type)self :: Void |
        let: #baseSlotIndex with: self validSupertypeTotalSlotCount.
        self slots doWithIndex: {:slot :index :: Void |
            let: #slotIndex with: baseSlotIndex + index.
            slot localIndex: index.
            slot index: slotIndex.
            slot generateAccessorsOn: self
        }.
    } makeVirtual.

Metatype
    withSelector: #printOn: addMethod: {:(Metatype)self :(Stream)stream :: Void |
        let: #thisType with: self thisType.
        if: thisType ~~ nil
        then: (stream print: thisType; nextPutAll: " __type__")
        else: (stream nextPutAll: "a "; print: self __type__)
    } makeOverride.

Metaclass
    withSelector: #thisClass addMethod: {:(Metaclass)self :: Type | self thisType };
    withSelector: #thisClass: addMethod: {:(Metaclass)self :(Type)thisClass :: Void | self thisType: thisClass };
    withSelector: #printOn: addMethod: {:(Metaclass)self :(Stream)stream :: Void |
        let: #thisClass with: self thisClass.
        if: thisClass ~~ nil
        then: (stream print: thisClass; nextPutAll: " class")
        else: (stream nextPutAll: "a "; print: self __type__)
    } makeOverride.

Type
    withSelector: #refFor: addMethod: {:(Type)self :addressSpace :: ReferenceType |
        ReferenceTypeTemplate(self, addressSpace)
    } makeVirtual makePure;
    withSelector: #ref addMethod: {:(Type)self :: ReferenceType |
        self refFor: nil
    } makeVirtual makePure;
    withSelector: #refForFunction addMethod: {:(Type)self :: ReferenceType |
        self refFor: nil
    } makePure;
    withSelector: #tempRefFor: addMethod: {:(Type)self :addressSpace :: ReferenceLikeType |
        TemporaryReferenceTypeTemplate(self, addressSpace)
    } makeVirtual makePure;
    withSelector: #tempRef addMethod: {:(Type)self :: ReferenceLikeType |
        self tempRefFor: nil
    } makeVirtual makePure;
    withSelector: #pointerFor: addMethod: {:(Type)self :addressSpace :: PointerType |
        PointerTypeTemplate(self, addressSpace)
    } makePure;
    withSelector: #pointer addMethod: {:(Type)self :: PointerType |
        self pointerFor: nil
    } makePure;
    withSelector: #const addMethod: {:(Type)self :: Type |
        self
    } makePure;
    withSelector: #restrict addMethod: {:(Type)self :: Type |
        self
    } makePure.

ReferenceType
    withSelector: #printOn: addMethod: {:(ReferenceType)self :(Stream)stream :: Void |
        stream print: self baseType.
        if: self addressSpace == nil then: {
            stream nextPutAll: " ref"
        } else: {
            stream nextPutAll: " refFor: "; print: self addressSpace
        }.
    } makeOverride;
    withSelector: #refFor: addMethod: {:(ReferenceType)self :addressSpace :: ReferenceType |
        self baseType refFor: addressSpace
    } makeOverride makePure;
    withSelector: #ref addMethod: {:(ReferenceType)self :: ReferenceType |
        self
    } makeOverride makePure;
    withSelector: #tempRefFor: addMethod: {:(ReferenceType)self :addressSpace :: ReferenceLikeType |
        self baseType refFor: addressSpace
    } makeOverride makePure;
    withSelector: #tempRef addMethod: {:(ReferenceType)self :: ReferenceLikeType |
        self baseType ref
    } makeOverride makePure.

TemporaryReferenceType
    withSelector: #printOn: addMethod: {:(ReferenceType)self :(Stream)stream :: Void |
        stream print: self baseType.
        if: self addressSpace == nil then: {
            stream nextPutAll: " tempRef"
        } else: {
            stream nextPutAll: " tempRefFor: "; print: self addressSpace
        }.
    } makeOverride;
    withSelector: #tempRefFor: addMethod: {:(ReferenceType)self :addressSpace :: ReferenceLikeType |
        self baseType refFor: addressSpace
    } makeOverride makePure;
    withSelector: #tempRef addMethod: {:(ReferenceType)self :: ReferenceLikeType |
        self
    } makeOverride makePure.

PointerType
    withSelector: #printOn: addMethod: {:(PointerType)self :(Stream)stream :: Void |
        stream print: self baseType.
        if: self addressSpace == nil then: {
            stream nextPutAll: " pointer"
        } else: {
            stream nextPutAll: " pointerFor: "; print: self addressSpace
        }.
    } makeOverride.

Type
    withSelector: #canonicalTypeForApplicationArgumentWithIndex: addMethod: {:(Type)self :(Size)index :: Type | AnyValue } makeVirtual.

FunctionType
    withSelector: #canonicalResultType addMethod: {:(FunctionType)self :: Type |
        self subclassResponsibility
    } makeVirtual;
    withSelector: #hasFunctionFlags: addMethod: {:(FunctionType)self :(Bitflags)flag :: Boolean |
        (self functionFlags & flag) = flag
    };
    withSelector: #isVariadic addMethod: {:(FunctionType)self :: Boolean |
        self hasFunctionFlags: FunctionFlags::Variadic
    };
    withSelector: #isMemoized addMethod: {:(FunctionType)self :: Boolean |
        self hasFunctionFlags: FunctionFlags::Memoized
    };
    withSelector: #isTemplate addMethod: {:(FunctionType)self :: Boolean |
        self hasFunctionFlags: FunctionFlags::Template
    };
    withSelector: #isMemoizedTemplate addMethod: {:(FunctionType)self :: Boolean |
        self hasFunctionFlags: FunctionFlags::Memoized | FunctionFlags::Template
    }.

DependentFunctionType
    withSelector: #canonicalResultType addMethod: {:(DependentFunctionType)self :: Type |
        ## FIXME: Implement this properly.
        AnyValue
    } makeOverride;
    withSelector: #canonicalTypeForApplicationArgumentWithIndex: addMethod: {:(DependentFunctionType)self :(Size)index :: Type |
        ## FIXME: Implement this properly.
        AnyValue
    } makeOverride;
    withSelector: #printOn: addMethod: {:(DependentFunctionType)self :(Stream)stream :: Void |
        stream nextPutAll: "DependentFunctionType at "; print: self sourcePosition
    } makeOverride.

SimpleFunctionType
    withSelector: #canonicalTypeForApplicationArgumentWithIndex: addMethod: {:(SimpleFunctionType)self :(Size)index :: Type |
        if: index < self argumentTypes size
        then: (self argumentTypes at: index)
        else: Untyped
    } makeOverride;
    withSelector: #canonicalResultType addMethod: {:(SimpleFunctionType)self :: Type |
        let: #resultType with: self resultType.
        if: resultType == nil then: Untyped else: resultType.
    } makeOverride;
    withSelector: #printOn: addMethod: {:(SimpleFunctionType)self :(Stream)stream :: Void |
        stream nextPut: '('c8.
        self argumentTypes doWithIndex: {:(Type)argumentType :(Size)index :: Void |
            index > 0sz ifTrue: (stream nextPutAll: ", ").
            stream print: argumentType
        }.
        self isVariadic ifTrue: {
            self argumentTypes isNotEmpty
                ifTrue: (stream nextPutAll: ", ...")
                ifFalse: (stream nextPutAll: "...")
        }.
        stream nextPutAll: ") => "; print: self resultType.
    } makeOverride.

## Primitive values printString and primitive function types
(
    UInt8,Int8,Char8,
    UInt16,Int16,Char16,
    UInt32,Int32,Char32,
    UInt64,Int64,
    Float32,Float64,
    Integer
) do: {:SelfType :: Void |
    let: #unaryFunctionType with: SelfType => SelfType.
    let: #binaryFunctionType with: (SelfType, SelfType) => SelfType.
    let: #binaryComparisonFunctionType with: (SelfType, SelfType) => Boolean.

    ## Unary selectors
    #(
        negated bitInvert
    ) do: {:selector :: Void |
        let: #method with: (SelfType >> selector).
        if: method ~~ nil then: (method __type__: unaryFunctionType)
    }.

    ## Binary selectors.
    #(
        + - * / %
        | & ^ << >>
    ) do: {:selector :: Void |
        let: #method with: (SelfType >> selector).
        if: method ~~ nil then: (method __type__: binaryFunctionType)
    }.

    ## Comparisons
    #(
        = ~= < <= >= >
    ) do: {:selector :: Void |
        (SelfType >> selector) __type__: binaryComparisonFunctionType
    }.

    SelfType
        withSelector: #printOn: addMethod: {:(SelfType)self :(Stream)stream :: Void |
            stream nextPutAll: self printString
        } makeOverride makeFinal recompileAndOptimize.

    let: #setConversionTypeFunction with: {:method :targetType :: Void |
        if: method ~~ nil then: (method __type__: (SelfType => targetType))
    }.

    setConversionTypeFunction((SelfType >> #asChar8), Char8).
    setConversionTypeFunction((SelfType >> #asUInt8), UInt8).
    setConversionTypeFunction((SelfType >> #asInt8), Int8).

    setConversionTypeFunction((SelfType >> #asChar16), Char16).
    setConversionTypeFunction((SelfType >> #asUInt16), UInt16).
    setConversionTypeFunction((SelfType >> #asInt16), Int16).

    setConversionTypeFunction((SelfType >> #asChar32), Char32).
    setConversionTypeFunction((SelfType >> #asUInt32), UInt32).
    setConversionTypeFunction((SelfType >> #asInt32), Int32).

    setConversionTypeFunction((SelfType >> #asUInt64), UInt64).
    setConversionTypeFunction((SelfType >> #asInt64), Int64).

    setConversionTypeFunction((SelfType >> #asSize), Size).
    setConversionTypeFunction((SelfType >> #asIntPointer), IntPointer).
    setConversionTypeFunction((SelfType >> #asUIntPointer), UIntPointer).

    setConversionTypeFunction((SelfType >> #asFloat32), Float32).
    setConversionTypeFunction((SelfType >> #asFloat64), Float64).
}.

(Integer >> #i8) __type__: (Integer => Int8).
(Integer >> #u8) __type__: (Integer => UInt8).
(Integer >> #c8) __type__: (Integer => Char8).
(Integer >> #i16) __type__: (Integer => Int16).
(Integer >> #u16) __type__: (Integer => UInt16).
(Integer >> #c16) __type__: (Integer => Char16).
(Integer >> #i32) __type__: (Integer => Int32).
(Integer >> #u32) __type__: (Integer => UInt32).
(Integer >> #c32) __type__: (Integer => Char32).
(Integer >> #i64) __type__: (Integer => Int64).
(Integer >> #u64) __type__: (Integer => UInt64).
##(Integer >> #f32) __type__: (Integer => Float32).
##(Integer >> #f64) __type__: (Integer => Float64).

(Float32 >> #sqrt) __type__: (Float32 => Float32).
(Float32 >> #asIEEEFloat32Encoding) __type__: (Float32 => UInt32).
(UInt32 >> #asIEEEFloat32Decoded) __type__: (UInt32 => Float32).

(Float64 >> #sqrt) __type__: (Float32 => Float32).
(Float64 >> #asIEEEFloat64Encoding) __type__: (Float64 => UInt64).
(UInt64 >> #asIEEEFloat64Decoded) __type__: (UInt64 => Float64).

let: #UInt32HashBitCount with: 32u32 - 4u32.
let: #UInt32HashBitMask with: (1u32 << UInt32HashBitCount) - 1u32.
let: #UInt64HashBitCount with: 64u64 - 4u64.
let: #UInt64HashBitMask with: (1u64 << UInt64HashBitCount) - 1u64.

UInt32
    withSelector: #hashMultiply addMethod: {:(UInt32)self :: UInt32 |
        (self * 1103515245u32) & UInt32HashBitMask
    } makePure makeFinal withEagerAnalysis;
    withSelector: #hashConcatenate: addMethod: {:(UInt32)self :(UInt32)next :: UInt32 |
        (self hashMultiply + next) & UInt32HashBitMask
    } makePure makeFinal withEagerAnalysis.

UInt64
    withSelector: #hashMultiply addMethod: {:(UInt64)self :: UInt64 |
        (self * 1103515245u64) & UInt64HashBitMask
    } makePure makeFinal withEagerAnalysis;
    withSelector: #hashConcatenate: addMethod: {:(UInt64)self :(UInt64)next :: UInt64 |
        (self hashMultiply + next) & UInt64HashBitMask
    } makePure makeFinal withEagerAnalysis.

FunctionDefinition
    withSelector: #validAnnotations addMethod: {:(FunctionDefinition)self :: Dictionary |
        let: #annotations with: self annotations.
        if: annotations == nil then: {
            self annotations: Dictionary new.
            self annotations
        } else: {
            annotations
        }
    };
    withSelector: #annotationAt:put: addMethod: {:(FunctionDefinition)self :key :value :: Void |
        self validAnnotations at: key put: value.
    };
    withSelector: #annotationAt:ifAbsent: addMethod: {:(FunctionDefinition)self :key :ifAbsentBlock |
        let: #annotations with: self annotations.
        if: annotations == nil then: {
            ifAbsentBlock()
        } else: {
            annotations at: key ifAbsent: ifAbsentBlock
        }
    };
    withSelector: #annotationAt:ifAbsentPut: addMethod: {:(FunctionDefinition)self :key :ifAbsentBlock |
        self validAnnotations at: key ifAbsentPut: ifAbsentBlock.
    };
    withSelector: #annotationAtOrNil: addMethod: {:(FunctionDefinition)self :key |
        let: #annotations with: self annotations.
        if: annotations == nil then: nil else: (annotations atOrNil: key)
    };
    withSelector: #importWithSymbol: addMethod: {:(FunctionDefinition)self :(Symbol)symbol :: Void |
        (self annotationAt: #importedSymbols ifAbsentPut: {| OrderedCollection new }) add: symbol
    };
    withSelector: #importedSymbols addMethod: {:(FunctionDefinition)self :: SequenceableCollection |
        self annotationAt: #importedSymbols ifAbsent: {| #() }.
    }.

Function
    withSelector: #validAnnotations addMethod: {:(Function)self :: Dictionary |
        let: #annotations with: self annotations.
        if: annotations == nil then: {
            self annotations: Dictionary new.
            self annotations
        } else: {
            annotations
        }
    };
    withSelector: #annotationAt:put: addMethod: {:(Function)self :key :value :: Void |
        self validAnnotations at: key put: value.
    };
    withSelector: #annotationAt:ifAbsent: addMethod: {:(Function)self :key :ifAbsentBlock |
        let: #annotations with: self annotations.
        if: annotations == nil then: {
            ifAbsentBlock()
        } else: {
            annotations at: key ifAbsent: ifAbsentBlock
        }
    };
    withSelector: #annotationAt:ifAbsentPut: addMethod: {:(Function)self :key :ifAbsentBlock |
        self validAnnotations at: key ifAbsentPut: ifAbsentBlock.
    };
    withSelector: #annotationAtOrNil: addMethod: {:(Function)self :key |
        let: #annotations with: self annotations.
        if: annotations == nil then: nil else: (annotations atOrNil: key)
    };
    withSelector: #importWithSymbol: addMethod: {:(Function)self :(Symbol)symbol :: Void |
        self definition importWithSymbol: symbol
    };
    withSelector: #exportWithSymbol: addMethod: {:(Function)self :(Symbol)symbol :: Void |
        (self annotationAt: #exportedSymbols ifAbsentPut: {| OrderedCollection new }) add: symbol
    };
    withSelector: #exportedSymbols addMethod: {:(Function)self :: SequenceableCollection |
        self annotationAt: #exportedSymbols ifAbsent: {| #() }.
    };
    withSelector: #timeToRunInNanoseconds addMethod: {:(Function)self :: Int64 |
        let: #startTime with: Time::Timestamp::nanosecondsNow().
        self().
        let: #endTime with: Time::Timestamp::nanosecondsNow().
        endTime - startTime
    };
    withSelector: #timeToRunInMicroseconds addMethod: {:(Function)self :: Int64 |
        let: #startTime with: Time::Timestamp::microsecondsNow().
        self().
        let: #endTime with: Time::Timestamp::microsecondsNow().
        endTime - startTime
    };
    withSelector: #printTimeToRunInMicrosecondsWithTitle: addMethod: {:(Function)self :(String)title |
        printLine(title, "...").
        let: #startTime with: Time::Timestamp::microsecondsNow().
        let: #result with: self().
        let: #endTime with: Time::Timestamp::microsecondsNow().
        printLine(title, " took ", (endTime - startTime) asFloat32 * 0.001f32,  " ms").
        result
    }.

SourcePosition
    withSelector: #printOn: addMethod: {:(SourcePosition)self :(Stream)stream :: Void |
        let: #sourceCode with: self sourceCode.

        stream
            nextPutAll: (sourceCode directory FileSystem::joinPath: sourceCode name);
            nextPut: ':'c8;
            print: self startLine;
            nextPut: '.'c8;
            print: self startColumn;
            nextPut: '-'c8;
            print: self endLine;
            nextPut: '.'c8;
            print: self endColumn
    } makeOverride.

GeneratedSymbol
    withSelector: #printOn: addMethod: {:(GeneratedSymbol)self :(Stream)stream :: Void |
        stream print: self class; nextPut: '('c8; print: self value; nextPut: ')'c8
    } makeOverride;
    withSelector: #fullPrintOn: addMethod: {:(GeneratedSymbol)self :(Stream)stream :: Void |
        stream print: self class; nextPut: '('c8; print: self value; nextPut: ')'c8
    } makeOverride.


Metatype
    withSelector: #asCanonicalPendingInstanceType addMethod: {:(Metatype)self :: Type |
        let: #thisType with: self thisType.
        if: thisType ~~ nil then: thisType else: Type.
    } makePure makeOverride withEagerAnalysis.

Metatype __type__
    withSelector: #getOrCreateDependentApplicationValueForNode: addMethod: {:(Metatype __type__)self :(ASTNode)astNode | Type } makeVirtual.

Metaclass
    withSelector: #asCanonicalPendingInstanceType addMethod: {:(Metaclass)self :: Type |
        let: #thisType with: self thisType.
        if: thisType ~~ nil then: thisType else: Class.
    } makePure makeOverride withEagerAnalysis.

Metaclass class
    withSelector: #asCanonicalPendingInstanceType addMethod: {:(Metaclass class)self :: Type | Class } makeOverride withEagerAnalysis;
    withSelector: #getOrCreateDependentApplicationValueForNode: addMethod: {:(Metaclass class)self :(ASTNode)astNode |
        Class
    }.

Class
    withSelector: #subclassWithClassSlots: addMethod: {:(Class)self :(Array)classSlots :: Class |
        let: #metaclass with: Metaclass basicNew.
        let: #metaclassSuper with: self class.
        metaclass
            flags: TypeFlags::MetatypeRequiredFlags;
            supertype: metaclassSuper;
            slots: classSlots;
            totalSlotCount: metaclassSuper validTotalSlotCount + classSlots size;
            registerSlotsInDictionary;
            generatePublicAccessors;
            createBasicInitializeMethod.
        
        let: #class with: metaclass basicNew.
        class
            flags: TypeFlags::ClassDefaultFlags;
            supertype: self;
            slots: ();
            totalSlotCount: nil;
            registerInSupertype.
        metaclass thisClass: class.
        class
    };
    withSelector: #subclassWithClassSlots:slots: addMethod: {:(Class)self :(Array)classSlots :(Array)instanceSlots :: Class |
        (self subclassWithClassSlots: classSlots)
            slots: instanceSlots;
            totalSlotCount: self validTotalSlotCount + instanceSlots size;
            registerSlotsInDictionary;
            generatePublicAccessors;
            createBasicInitializeMethod;
            yourself
    };
    withSelector: #subclass:classSlots:slots: addMethod: {:(Class)self :(StringSymbol)name :(Array)classSlots :(Array)instanceSlots :: Class |
        let: #class with: (self subclassWithClassSlots: classSlots slots: instanceSlots).
        class name: name.
        class
    };
    withSelector: #subclass:slots: addMethod: {:(Class)self :(StringSymbol)name :(Array)instanceSlots :: Class |
        self subclass: name classSlots: () slots: instanceSlots
    }.


UInt32
    withSelector: #min: addMethod: {:(UInt32)a :(UInt32)b :: UInt32 |
        if: a <= b then: a else: b
    };
    withSelector: #max: addMethod: {:(UInt32)a :(UInt32)b :: UInt32 |
        if: a >= b then: a else: b
    };
    withSelector: #alignedTo: addMethod: {:(UInt32)value :(UInt32)alignment :: UInt32 |
        ((value + alignment) - 1u32) & alignment negated.
    };
    withSelector: #log2Floor addMethod: {:(UInt32)value :: UInt32 |
        value highBit - 1u32
    };
    withSelector: #log2Ceiling addMethod: {:(UInt32)value :: UInt32 |
        (value - 1u32) log2Floor + 1u32
    };
    withSelector: #asLargerPowerOfTwo addMethod: {:(UInt32)value :: UInt32 |
        1u32 << value log2Ceiling
    }.

Int32
    withSelector: #abs addMethod: {:(Int32)a :: Int32 |
        if: a >= 0i32 then: a else: a negated
    };
    withSelector: #min: addMethod: {:(Int32)a :(Int32)b :: Int32 |
        if: a <= b then: a else: b
    };
    withSelector: #max: addMethod: {:(Int32)a :(Int32)b :: Int32 |
        if: a >= b then: a else: b
    };
    withSelector: #alignedTo: addMethod: {:(Int32)value :(Int32)alignment :: Int32 |
        ((value + alignment) - 1i32) & alignment negated.
    }.

UInt64
    withSelector: #min: addMethod: {:(UInt64)a :(UInt64)b :: UInt64 |
        if: a <= b then: a else: b
    };
    withSelector: #max: addMethod: {:(UInt64)a :(UInt64)b :: UInt64 |
        if: a >= b then: a else: b
    };
    withSelector: #alignedTo: addMethod: {:(UInt64)value :(UInt64)alignment :: UInt64 |
        ((value + alignment) - 1u64) & alignment negated.
    };
    withSelector: #log2Floor addMethod: {:(UInt64)value :: UInt64 |
        value highBit - 1u64
    };
    withSelector: #log2Ceiling addMethod: {:(UInt64)value :: UInt64 |
        (value - 1u64) log2Floor + 1u64
    };
    withSelector: #asLargerPowerOfTwo addMethod: {:(UInt64)value :: UInt64 |
        1u64 << value log2Ceiling
    }.

Int64
    withSelector: #abs addMethod: {:(Int64)a :: Int64 |
        if: a >= 0i64 then: a else: a negated
    };
    withSelector: #min: addMethod: {:(Int64)a :(Int64)b :: Int64 |
        if: a <= b then: a else: b
    };
    withSelector: #max: addMethod: {:(Int64)a :(Int64)b :: Int64 |
        if: a >= b then: a else: b
    };
    withSelector: #alignedTo: addMethod: {:(Int64)value :(Int64)alignment :: Int64 |
        ((value + alignment) - 1i64) & alignment negated.
    }.

TypeSlot
    withSelector: #size addMethod: {:(TypeSlot)self :: Size |
        self type valueSize
    } makeFinal;
    withSelector: #alignment addMethod: {:(TypeSlot)self :: Size |
        self type valueAlignment
    } makeFinal.

Type
    withSelector: #computeLayout replaceMethod: {:(Type)self :: Void |
        self instanceSize: 0sz.
        self instanceAlignment: 1sz.

        let: #supertype with: self supertype.
        if: supertype ~~ nil then: {
            self instanceSize: supertype validInstanceSize.
            self instanceAlignment: (supertype validInstanceAlignment max: 1sz).
        }.

        self validSlots do: {:(TypeSlot)eachSlot :: Void |
            let: #slotSize with: eachSlot size.
            let: #slotAlignment with: eachSlot alignment.

            let: #slotOffset with: (self instanceSize alignedTo: slotAlignment).
            eachSlot offset: slotOffset.

            self instanceAlignment: (self instanceAlignment max: slotAlignment).
            self instanceSize: slotOffset + slotSize.
        }.

        self instanceSize: (self instanceSize alignedTo: self instanceAlignment).
    } makeVirtual;
    withSelector: #validInstanceSize addMethod: {:(Type)self :: Size |
        if: self instanceAlignment = 0sz then: (self ensureLayoutIsComputed).
        self instanceSize
    } makeFinal;
    withSelector: #validInstanceAlignment addMethod: {:(Type)self :: Size |
        if: self instanceAlignment = 0sz then: (self ensureLayoutIsComputed).
        self instanceAlignment
    } makeFinal;
    withSelector: #valueAlignment addMethod: {:(Type)self :: Size |
        UIntPointer instanceAlignment
    } makeVirtual;
    withSelector: #valueSize addMethod: {:(Type)self :: Size |
        UIntPointer instanceSize
    } makeVirtual;
    withSelector: #alignedValueSize addMethod: {:(Type)self :: Size |
        self valueSize alignedTo: self valueAlignment
    } makeFinal;
    withSelector: #isGarbageCollectedPointerType addMethod: {:(Type)self :: Boolean | true } makeVirtual;
    withSelector: #isValueType addMethod: {:(Type)self :: Boolean | false } makeVirtual;
    withSelector: #isPrimitiveNumberType addMethod: {:(Type)self :: Boolean | false } makeVirtual;
    withSelector: #isPrimitiveCharacterType addMethod: {:(Type)self :: Boolean | false } makeVirtual;
    withSelector: #isPrimitiveFloatType addMethod: {:(Type)self :: Boolean | false } makeVirtual;
    withSelector: #isPrimitiveIntegerType addMethod: {:(Type)self :: Boolean | false } makeVirtual;
    withSelector: #isPrimitiveUnsignedIntegerType addMethod: {:(Type)self :: Boolean | false } makeVirtual;
    withSelector: #isPrimitiveSignedIntegerType addMethod: {:(Type)self :: Boolean | false } makeVirtual;
    withSelector: #isPrimitiveVectorType addMethod: {:(Type)self :: Boolean | false } makeVirtual.

PrimitiveNumber __type__ withSelector: #isPrimitiveNumberType addMethod: {:(Type)self :: Boolean | true } makeOverride.
PrimitiveCharacter __type__ withSelector: #isPrimitiveCharacterType addMethod: {:(Type)self :: Boolean | true } makeOverride.
PrimitiveFloat __type__ withSelector: #isPrimitiveFloatType addMethod: {:(Type)self :: Boolean | true } makeOverride.
PrimitiveInteger __type__ withSelector: #isPrimitiveIntegerType addMethod: {:(Type)self :: Boolean | true } makeOverride.
PrimitiveSignedInteger __type__ withSelector: #isPrimitiveSignedIntegerType addMethod: {:(Type)self :: Boolean | true } makeOverride.
PrimitiveUnsignedInteger __type__ withSelector: #isPrimitiveUnsignedIntegerType addMethod: {:(Type)self :: Boolean | true } makeOverride.

Type
    validInstanceAlignment;
    validInstanceSize;
    withSelector: #basicAllocate replaceMethod: {:(Type)self :: self |
        <primitive: #basicAllocate>
        (RawTuple::basicAllocateWithType:instanceSize:alignment:slotCount:variableSize:isBytes:isWeak:)(
            self, self validInstanceSize, self validInstanceAlignment, self validTotalSlotCount, 0sz,
            self isBytes, self isWeak
        )
    } makeVirtual withEagerAnalysis;
    withSelector: #basicAllocate: replaceMethod: {:(Type)self :(Size)variableSize :: self |
        (RawTuple::basicAllocateWithType:instanceSize:alignment:slotCount:variableSize:isBytes:isWeak:)(
            self, self validInstanceSize, self validInstanceAlignment, self validTotalSlotCount, variableSize,
            self isBytes, self isWeak
        )
    } makeVirtual withEagerAnalysis;
    withSelector: #ensureAnalysis replaceMethod: {:(Type)self :: Void |
        (tuple: self withLookupStartingFrom: Type supertype) ensureAnalysis.
        self validSlots.
        self validBasicInitializeMethod.
        self ensureLayoutIsComputed.
    } makeVirtual withEagerAnalysis.

PointerLikeType
    withSelector: #computeLayout addMethod: {:(PointerLikeType)self :: Void |
        self instanceSize: UIntPointer valueSize.
        self instanceAlignment: UIntPointer valueAlignment.
    } makeOverride;
    withSelector: #withStorage: addMethod: {:(PointerLikeType)self :storage :: self |
        let: #result with: (RawTuple::new(1sz)).
        (RawTuple::slotAt:put:)(result, 0sz, storage).
        (RawTuple::type:)(result, self).
        result
    };
    withSelector: #withBoxForValue: addMethod: {:(PointerLikeType)self :(Untyped)value :: Untyped |
        self withStorage: (ValueBox with: value)
    };
    withSelector: #untypedWithStorage: addMethod: {:(PointerLikeType)self :storage :: Untyped |
        let: #result with: (RawTuple::new(1sz)).
        (RawTuple::slotAt:put:)(result, 0sz, storage).
        (RawTuple::type:)(result, self).
        result
    };
    withSelector: #untypedWithBoxForValue: addMethod: {:(PointerLikeType)self :(Untyped)value :: Untyped |
        self untypedWithStorage: (ValueBox with: value)
    }.

ValueType
    withSelector: #asReceiverType addMethod: {:(Type)self :: Type | self ref } makePure makeOverride;
    withSelector: #asResultType addMethod: {:(Type)self :: Type | self tempRef } makePure makeOverride;
    withSelector: #valueSize addMethod: {:(ValueType)self :: Size |
        self validInstanceSize
    } makeOverride;
    withSelector: #valueAlignment addMethod: {:(ValueType)self :: Size |
        self validInstanceAlignment
    } makeOverride;
    withSelector: #isGarbageCollectedPointerType addMethod: {:(Type)self :: Boolean | false } makeOverride;
    withSelector: #isValueType addMethod: {:(Type)self :: Boolean | true } makeOverride;
    withSelector: #decayReferenceLikeForReceiverType: addMethod: {:(Type)self :(ReferenceLikeType)reference :: Type | reference } makeOverride.

PrimitiveValueType
    withSelector: #asReceiverType addMethod: {:(Type)self :: Type | self } makePure makeOverride;
    withSelector: #asResultType addMethod: {:(Type)self :: Type | self } makePure makeOverride;
    withSelector: #decayReferenceLikeForReceiverType: addMethod: {:(Type)self :(ReferenceLikeType)reference :: Type | self } makeOverride.

Environment
    withSelector: #setSymbol:value: addMethod: {:(Environment)self :(Symbol)symbol :value :: value __type__ |
        self setSymbol: symbol bindingWithValue: value.
        value recordBindingWithOwner: self andName: symbol.
        value
    };
    withSelector: #setPublicSymbol:value: addMethod: {:(Environment)self :(Symbol)symbol :value :: value __type__ |
        self setSymbol: symbol value: value
    };
    withSelector: #withSelector:addMacroMethod: addMethod: {:(Environment)self :(Symbol)symbol :method :: Void |
        self setSymbol: symbol value: method
    };
    withSelector: #withSelector:addMethod: addMethod: {:(Environment)self :(Symbol)symbol :method :: Void |
        self setSymbol: symbol value: method
    };
    withSelector: #withSelector:addFallbackMethod: addMethod: {:(Environment)self :(Symbol)symbol :method :: Void |
        self setSymbol: symbol value: method
    }.

BootstrapEnv::IntrinsicTypes do: {:(Type)each :: Void |
    each ensureAnalysis
}.
