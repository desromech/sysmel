public class FixedArrayType superclass: ValueType; definition: {
    public field elementType => Type.
    public field size => Size.

    public method initializeWithElementType: (initialElementType: Type) size: (initialSize: Size) ::=> Void := {
        elementType := initialElementType.
        size := initialSize.

        self
            supertype: AnyValue;
            slots: #();
            totalSlotCount: 0sz;
            generatePublicAccessors;
            createBasicInitializeMethod.
    }.

    public override method generatePublicAccessors => Void := {
        let ReceiverType := self asReceiverType.
        let elementType := self elementType.
        let elementReferenceType := elementType ref.
        let size := self size.

        self
            withSelector: #at: addMethod: {:(ReceiverType)self :(Size)index :: elementType |
                <primitive: #FixedArray::at:>
                if: index >= size then: error("Index is out of bounds.").

                (RawTuple::refSlotAt:)(self, index)
            } makeFinal recompileAndOptimize;
            withSelector: #"[]:" addMethod: {:(ReceiverType)self :(Size)index :: elementReferenceType |
                <primitive: #FixedArray::refAt:>
                if: index >= size then: error("Index is out of bounds.").
                error("TODO: Implement reference at").
            } makeFinal recompileAndOptimize;
            withSelector: #at:put: addMethod: {:(ReceiverType)self :(Size)index :(elementType)value :: Void |
                <primitive: #FixedArray::at:put:>
                if: index >= size then: error("Index is out of bounds.").

                (RawTuple::refSlotAt:put:)(self, index, value)
            } makeFinal recompileAndOptimize.
    }.

    public override method printOn: (stream: Stream) ::=> Void := {
        stream print: elementType; nextPut: '['c8; print: size; nextPut: ']'c8
    }.

    public override method basicAllocate => self := {
        let result := RawTuple::new(size).
        (RawTuple::type:)(result, self).
        result
    }.

    public override method createBasicInitializeMethod => Void := {
        let elementCount := self size.
        let defaultValue := elementType defaultValue.
        let ReceiverType := self asReceiverType.
        basicInitializeMethod := {:(ReceiverType)self :: Void |
            <primitive: #zeroInitialization>
            if: ObjectModel::isLogical() then: {
                let i mutable := 0sz.
                while: (i < elementCount) do: (
                    ##(RawTuple::refSlotAt:put:)(self, i, defaultValue)
                    (RawTuple::slotAt:put:)(self, i, defaultValue)
                ) continueWith: (i := i + 1sz)
            }
        } makeOverride makeFinal recompileAndOptimize
    }.

    public override method defaultValue => self
        := self basicNew.

    public override method computeLayout => Void := {
        instanceSize := 0sz.
        instanceAlignment := 1sz.

        instanceSize := elementType valueSize * size.
        instanceAlignment := elementType valueAlignment.
    }.

    public override method canEncodeValueInBytes => Boolean
        := elementType canEncodeValueInBytes.

    public override method encodeValue: (value: self) inBytes: (bytes: ByteArray) atOffset: (offset: Size) ::=> Void := {
        let i mutable := 0sz.
        let elementOffset mutable := offset.
        let elementSize := elementType alignedValueSize.
        while: (i < size) do: (
            elementType encodeValue: (RawTuple::slotAt:)(value, i) inBytes: bytes atOffset: elementOffset 
        ) continueWith: {
            i := i + 1sz.
            elementOffset := elementOffset + elementSize
        }.
    }.

    public override method canDecodeValueFromBytes => Boolean
        := elementType canDecodeValueFromBytes.

    public override method decodeValueFromBytes: (bytes: ByteArray) atOffset: (offset: Size) ::=> self := {
        let result := self basicAllocate.
        let i mutable := 0sz.
        let elementOffset mutable := offset.
        let elementSize := elementType alignedValueSize.
        while: (i < size) do: (
            (RawTuple::slotAt:put:)(result, i, elementType decodeValueFromBytes: bytes atOffset: elementOffset)
        ) continueWith: {
            i := i + 1sz.
            elementOffset := elementOffset + elementSize
        }.

        result
    }.
}.

public template FixedArrayTypeTemplate(elementType: Type, size: Size) => FixedArrayType := {
    let result := FixedArrayType basicNew.
    __templateResult__ value: result.
    result
        initializeWithElementType: elementType size: size;
        yourself.
}.

Type extend: {
    public pure final method fixedArray: (size: Size) ::=> FixedArrayType
        := FixedArrayTypeTemplate(self, size).

    public pure final method fixedArray ::=> FixedArrayType
        := self fixedArray: 0sz.

    public pure final method[size: Size] ::=> FixedArrayType
        := self fixedArray: size.

    public pure final method[] ::=> FixedArrayType
        := self fixedArray: 0sz.
}.
