## We use these for the different implementations of Size
error __type__: (SimpleFunctionTypeTemplate((String,), false, Unwinds)).
    
{
    let: #binaryFunctionType with: SimpleFunctionTypeTemplate((UInt32, UInt32), false, UInt32).
    let: #equalityComparisonFunctionType with: SimpleFunctionTypeTemplate((UInt32, AnyValue), false, Boolean).
    let: #comparisonFunctionType with: SimpleFunctionTypeTemplate((UInt32, UInt32), false, Boolean).

    UInt32::+ __type__: binaryFunctionType.
    UInt32::- __type__: binaryFunctionType.
    UInt32::* __type__: binaryFunctionType.
    UInt32::/ __type__: binaryFunctionType.
    UInt32::% __type__: binaryFunctionType.

    UInt32::& __type__: binaryFunctionType.
    UInt32::| __type__: binaryFunctionType.
    UInt32::<< __type__: binaryFunctionType.
    UInt32::>> __type__: binaryFunctionType.

    UInt32::= __type__: equalityComparisonFunctionType.
    UInt32::~= __type__: equalityComparisonFunctionType.
    UInt32::< __type__: comparisonFunctionType.
    UInt32::<= __type__: comparisonFunctionType.
    UInt32::>= __type__: comparisonFunctionType.
    UInt32::> __type__: comparisonFunctionType.
}.

{
    let: #binaryFunctionType with: SimpleFunctionTypeTemplate((UInt64, UInt64), false, UInt64).
    let: #equalityComparisonFunctionType with: SimpleFunctionTypeTemplate((UInt64, AnyValue), false, Boolean).
    let: #comparisonFunctionType with: SimpleFunctionTypeTemplate((UInt64, UInt64), false, Boolean).

    UInt64::+ __type__: binaryFunctionType.
    UInt64::- __type__: binaryFunctionType.
    UInt64::* __type__: binaryFunctionType.
    UInt64::/ __type__: binaryFunctionType.
    UInt64::% __type__: binaryFunctionType.

    UInt64::& __type__: binaryFunctionType.
    UInt64::| __type__: binaryFunctionType.
    UInt64::<< __type__: binaryFunctionType.
    UInt64::>> __type__: binaryFunctionType.

    UInt64::= __type__: equalityComparisonFunctionType.
    UInt64::~= __type__: equalityComparisonFunctionType.
    UInt64::< __type__: comparisonFunctionType.
    UInt64::<= __type__: comparisonFunctionType.
    UInt64::>= __type__: comparisonFunctionType.
    UInt64::> __type__: comparisonFunctionType.
}.

Function
    withSelector: #withEagerAnalysis addMethod: {:(Function)self :: Function |
        self ensureAnalysis.
        self
    };
    withSelector: #addFlags: addMethod: {:(Function)self :(Bitflags)flag :: Void |
        self flags: self flags | flag
    } withEagerAnalysis;
    withSelector: #makeMacro addMethod: {:(Function)self :: Function |
        self addFlags: FunctionFlags::Macro.
        self
    } withEagerAnalysis;
    withSelector: #makePure addMethod: {:(Function)self :: Function |
        self addFlags: FunctionFlags::Pure.
        self
    } withEagerAnalysis;
    withSelector: #makeFinal addMethod: {:(Function)self :: Function |
        self addFlags: FunctionFlags::Final.
        self
    } withEagerAnalysis;
    withSelector: #makeVirtual addMethod: {:(Function)self :: Function |
        self addFlags: FunctionFlags::Virtual.
        self
    } withEagerAnalysis;
    withSelector: #makeAbstract addMethod: {:(Function)self :: Function |
        self addFlags: FunctionFlags::Abstract.
        self
    } withEagerAnalysis;
    withSelector: #makeOverride addMethod: {:(Function)self :: Function |
        self addFlags: FunctionFlags::Override.
        self
    } withEagerAnalysis;
    withSelector: #makeStatic addMethod: {:(Function)self :: Function |
        self addFlags: FunctionFlags::Static.
        self
    } withEagerAnalysis;

    withSelector: #makeMemoized addMethod: {:(Function)self :: Function |
        self addFlags: FunctionFlags::Memoized.
        self
    } withEagerAnalysis;
    withSelector: #makeTemplate addMethod: {:(Function)self :: Function |
        self addFlags: FunctionFlags::Template.
        self
    } withEagerAnalysis.

Type
    withSelector: #=> addMethod: {:(Type)self :(Type)resultType :: SimpleFunctionType |
        SimpleFunctionTypeTemplate((self,), false, resultType)
    } makePure makeFinal withEagerAnalysis.

ValueBox
    withSelector: #loadFrom:atOffset:withType: addMethod: {:(ValueBox)self :(Untyped)containerBase :(IntPointer)offset :(Type)valueType :: valueType |
        (RawTuple::slotAt:)(self, 0sz)
    } makeFinal withEagerAnalysis;
    withSelector: #store:in:atOffset:withType: addMethod: {:(ValueBox)self :(Untyped)value :(Untyped)containerBase :(IntPointer)offset :(Type)valueType :: Void |
        RawTuple::slotAt:put:(self, 0sz, value).
        void
    } makeFinal withEagerAnalysis.

TypeSlot
    withSelector: #loadFrom:atOffset:withType: addMethod: {:(TypeSlot)self :(Untyped)containerBase :(IntPointer)offset :(Type)valueType :: valueType |
        (RawTuple::slotAt:)(containerBase, (tuple: self slotNamedAt: #index))
    } makeFinal withEagerAnalysis;
    withSelector: #store:in:atOffset:withType: addMethod: {:(TypeSlot)self :(Untyped)value :(Untyped)containerBase :(IntPointer)offset :(Type)valueType :: Void |
        RawTuple::slotAt:put:(containerBase, (tuple: self slotNamedAt: #index), value).
        void
    } makeFinal withEagerAnalysis.

AnyValue
    withSelector: #basicInitialize addMethod: {:(AnyValue)self :: Void | self __type__ basicInitializeInstance: self } withEagerAnalysis;
    withSelector: #initialize addMethod: {:(AnyValue)self :: Void | } withEagerAnalysis;
    withSelector: #yourself addMethod: {:(AnyValue)self :: self __type__ |
        <primitive: #yourself>
        self
    } makePure makeFinal withEagerAnalysis;

    withSelector: #postCopy addMethod: {:(AnyValue)self :: Void | } withEagerAnalysis;
    withSelector: #shallowCopy addMethod: {:(AnyValue)self :: self __type__ | RawTuple::shallowCopy(self) } makeFinal withEagerAnalysis;
    withSelector: #copy addMethod: {:(AnyValue)self :: self __type__ | self shallowCopy postCopy; yourself } withEagerAnalysis;

    withSelector: #doesNotUnderstand: addMethod: {:(AnyValue)self :(Message)message |
        error("doesNotUnderstand: " -- message selector printString)
    } withEagerAnalysis;

    withSelector: #isNil addMethod: {:(AnyValue)self :: Boolean | self == nil } makePure makeFinal withEagerAnalysis;
    withSelector: #isNotNil addMethod: {:(AnyValue)self :: Boolean | self ~~ nil } makePure makeFinal withEagerAnalysis;

    withSelector: #= addMethod: {:(AnyValue)self :other :: Boolean | self == other } makePure withEagerAnalysis;
    withSelector: #~= addMethod: {:(AnyValue)self :other :: Boolean | self ~~ other } makePure withEagerAnalysis.

Object
    withSelector: #class addMethod: {:(Object)self :: self __type__ __type__ | self __type__ } makePure makeFinal withEagerAnalysis;
    withSelector: #species addMethod: {:(Object)self :: Class | self class } withEagerAnalysis;

    withSelector: #error: addMethod: {:(Object)self :(String)errorMessage :: Unwinds | error(errorMessage) } withEagerAnalysis;
    withSelector: #assert: addMethod: {:(Object)self :(Boolean)condition :: Void |
        if: condition then: void else: error("Assertion failure.")
    } withEagerAnalysis;
    withSelector: #subclassResponsibility addMethod: {:(Object)self :: Unwinds | self error: self __type__ printString -- " Subclass responsibility." } withEagerAnalysis;
    withSelector: #doesNotUnderstand: addMethod: {:(AnyValue)self :(Message)message |
        error((self class printString -- " doesNotUnderstand: ") -- message selector printString)
    } withEagerAnalysis.

Type
    withSelector: #isSubtypeOf: addMethod: {:(Type)self :(Type)expectedParent :: Boolean |
        if: self == expectedParent
        then: true
        else: {
            let: #supertype with: self supertype.
            if: supertype ~~ nil
                then: (supertype isSubtypeOf: expectedParent )
                else: false
        }
    } makePure withEagerAnalysis.

AnyValue
    withSelector: #isKindOf: addMethod: {:(AnyValue)self :(Type)expectedType :: Boolean |
        self __type__ isSubtypeOf: expectedType
    } makePure makeFinal withEagerAnalysis.

## Early new implementation
Type
    withSelector: #hasFlag: addMethod: {:(Type)self :(Bitflags)flag :: Boolean |
        (self flags & flag) ~= 0bflgs
    } withEagerAnalysis;
    withSelector: #isDynamic addMethod: {:(Type)self :: Boolean |
        self hasFlag: TypeFlags::Dynamic.
    } withEagerAnalysis;
    withSelector: #isBytes addMethod: {:(Type)self :: Boolean |
        self hasFlag: TypeFlags::Bytes.
    } withEagerAnalysis;
    withSelector: #isWeak addMethod: {:(Type)self :: Boolean |
        self hasFlag: TypeFlags::Weak.
    } withEagerAnalysis;
    withSelector: #basicAllocate addMethod: {:(Type)self :: self |
        let: #result with: (if: self isBytes
            then: RawTuple::byteNew(0sz)
            else: RawTuple::new(self totalSlotCount)).
        (RawTuple::type:)(result, self).
        if: self isWeak then: RawTuple::markWeak(result).
        result
    } withEagerAnalysis;
    withSelector: #basicNew addMethod: {:(Type)self :: self |
        self basicAllocate
    } withEagerAnalysis;
    withSelector: #basicInitializeInstance: addMethod: {:(TypeSlot)self :(AnyValue)instance :: Void |
    } withEagerAnalysis;
    withSelector: #new addMethod: {:(Type)self :: self |
        self basicNew initialize; yourself
    } withEagerAnalysis.

ASTDownCastNode __type__
    withSelector: #makeForASTNode:targetType: addMethod: {:(ASTDownCastNode __type__)self :(ASTNode)astNode :(Type)targetType :: self |
        let: #sourcePosition with: astNode sourcePosition.

        self new
            sourcePosition: sourcePosition;
            analyzedType: targetType;
            typeExpression: (ASTLiteralNode new
                analyzedType: targetType __type__;
                sourcePosition: sourcePosition;
                value: targetType;
                yourself);
            valueExpression: astNode;
            yourself
    } withEagerAnalysis.

Untyped __type__
    withSelector: #coerceASTNode:into:withEnvironment: addMethod: {:(Type)self :(ASTNode)astNode :(Type)targetType :(AnalysisAndEvaluationEnvironment)environment :: ASTNode |
        if: self == targetType then: {
            astNode
        } else: {
            ASTDownCastNode makeForASTNode: astNode targetType: targetType
        }.
    } withEagerAnalysis.
    
TypeSlot
    withSelector: #hasFlag: addMethod: {:(TypeSlot)self :(Size)flag :: Boolean |
        (self flags & flag) ~= 0bflgs
    } withEagerAnalysis;
    withSelector: #isPublic addMethod: {:(TypeSlot)self :: Boolean |
        self hasFlag: TypeSlotFlags::Public
    } withEagerAnalysis;
    withSelector: #isReadonly addMethod: {:(TypeSlot)self :: Boolean |
        self hasFlag: TypeSlotFlags::ReadOnly
    } withEagerAnalysis;
    withSelector: #generateAccessorsOn: addMethod: {:(TypeSlot)typeSlot :(Type)type :: Void |
        if: typeSlot isPublic then: {
            let: #slotType with: typeSlot type.
            let: #getterName with: typeSlot name.
            let: #setterName with: (typeSlot name asString -- ":") asSymbol.

            ## Getter.
            type withSelector: getterName addMethod: {:(type)self :: slotType |
                ## TODO: Perform direct access via the AST node.
                (RawTuple::slotAt:)(self, typeSlot index)
            } makePure makeFinal recompileAndOptimize.

            ## Setter
            if: typeSlot isReadonly not then: {
                type withSelector: setterName addMethod: {:(type)self :(slotType)value :: Void |
                    RawTuple::slotAt:put:(self, typeSlot index, value)
                } makeFinal recompileAndOptimize.
            }
        }
    } withEagerAnalysis.

Array
    withSelector: #at: addMethod: {:(Array)self :(Size)index |
        self __slotAt__: index
    } withEagerAnalysis;
    withSelector: #at:put: addMethod: {:(Array)self :(Size)index :value :: Void |
        self __slotAt__: index put: value
    } withEagerAnalysis;
    withSelector: #size addMethod: {:(Array)self :: Size |
        self __size__
    } withEagerAnalysis.

Type
    withSelector: #coerceASTNode:into:withEnvironment: addMethod: {:(Type)self :(ASTNode)astNode :(Type)targetType :(AnalysisAndEvaluationEnvironment)environment :: ASTNode |
        if: (self isSubtypeOf: targetType)
        then: astNode
        else: {
            if: self isDynamic then: {
                ## TODO: Add a downcast node.
                ##astNode.
                ASTDownCastNode makeForASTNode: astNode targetType: targetType
            } else: {
                error((("Cannot coerce node from type " -- self printString) -- " into type ") -- targetType printString)
            }
        }
    } withEagerAnalysis;
    withSelector: #coerceASTNode:withEnvironment: addMethod: {:(Type)self :(ASTNode)astNode :(AnalysisAndEvaluationEnvironment)environment :: ASTNode |
        let: #sourceType with: astNode analyzedType.
        if: (if: sourceType ~~ nil then: sourceType ~= self else: false)
        then: (sourceType coerceASTNode: astNode into: self withEnvironment: environment)
        else: astNode
    } withEagerAnalysis;
    withSelector: #isReferenceType addMethod: {:(Type)self :: Boolean | false } makePure withEagerAnalysis;

    withSelector: #addFlags: addMethod: {:(Type)self :(Bitflags)flag :: Void |
        self flags: self flags | flag
    } withEagerAnalysis;

    withSelector: #makeNullable addMethod: {:(Type)self :: Type |
        self addFlags: TypeFlags::Nullable.
        self
    } withEagerAnalysis;
    withSelector: #isNullable addMethod: {:(Type)self :: Boolean |
        self hasFlag: TypeFlags::Nullable.
    } withEagerAnalysis;

    withSelector: #makeBytes addMethod: {:(Type)self :: Type |
        self addFlags: TypeFlags::Bytes.
        self
    } withEagerAnalysis;

    withSelector: #makeWeak addMethod: {:(Type)self :: Type |
        self addFlags: TypeFlags::Weak.
        self
    } withEagerAnalysis;

    withSelector: #makeImmediate addMethod: {:(Type)self :: Type |
        self addFlags: TypeFlags::Immediate.
        self
    } withEagerAnalysis;
    withSelector: #isImmediate addMethod: {:(Type)self :: Boolean |
        self hasFlag: TypeFlags::Immediate.
    } withEagerAnalysis;

    withSelector: #makeFinal addMethod: {:(Type)self :: Type |
        self addFlags: TypeFlags::Final.
        self
    } withEagerAnalysis;
    withSelector: #isFinal addMethod: {:(Type)self :: Boolean |
        self hasFlag: TypeFlags::Final.
    } withEagerAnalysis;

    withSelector: #makeAbstract addMethod: {:(Type)self :: Type |
        self addFlags: TypeFlags::Abstract.
        self
    } withEagerAnalysis;
    withSelector: #isAbstract addMethod: {:(Type)self :: Boolean |
        self hasFlag: TypeFlags::Abstract.
    } withEagerAnalysis;

    withSelector: #defaultValue addMethod: {:(Type)self :: self |
        if: self isNullable
            then: nil
            else: (self error: "A proper default value must be defined for " -- self printString).
    } withEagerAnalysis;

    withSelector: #validSlotDictionary addMethod: {:(Type)self :: MethodDictionary |
        if: self slotDictionary == nil then: (self slotDictionary: MethodDictionary new).
        self slotDictionary
    } withEagerAnalysis;
    withSelector: #addSlotToDictionary: addMethod: {:(Type)self :(TypeSlot)slot :: Void |
        let: #slotName with: slot name.
        if: slotName ~~ nil then: {
            self validSlotDictionary at: slotName put: slot
        }
    } withEagerAnalysis;
    withSelector: #validSupertypeTotalSlotCount addMethod: {:(Type)self :: Size |
        let: #supertype with: self supertype.
        if: supertype == nil then: 0sz else: supertype validTotalSlotCount.
    };
    withSelector: #validSlots addMethod: {:(Type)self :: Array |
        let: #pendingSlots with: self pendingSlots.
        if: pendingSlots ~~ nil then: {

            let: #pendingSlotsArray with: pendingSlots asArray.
            let: #localBaseIndex with: self slots size.
            let: #baseIndex with: self validSupertypeTotalSlotCount + localBaseIndex.

            pendingSlotsArray doWithIndex: {:pendingSlot :pendingSlotIndex :: Void |
                let: #localSlotIndex with: localBaseIndex + pendingSlotIndex.
                let: #slotIndex with: baseIndex + pendingSlotIndex.
                pendingSlot
                    localIndex: localSlotIndex;
                    index: slotIndex
            }.

            self slots: self slots -- pendingSlotsArray.
            self pendingSlots: nil
        }.

        if: self slots == nil then: (self slots: #()).
        self slots
    };
    withSelector: #validTotalSlotCount addMethod: {:(Type)self :: Size |
        let: #totalSlotCount with: self totalSlotCount.
        if: totalSlotCount == nil then: {
            self totalSlotCount: self validSupertypeTotalSlotCount + self validSlots size.
            self totalSlotCount
        } else: totalSlotCount
    } withEagerAnalysis;
    withSelector: #registerSlotsInDictionary addMethod: {:(Type)self :: Void |
        let: #supertypeSlotCount with: self validSupertypeTotalSlotCount.

        self slots doWithIndex: {:(TypeSlot)slot :(Size)index :: Void |
            slot
                localIndex: index;
                index: supertypeSlotCount + index.
            self addSlotToDictionary: slot
        }
    } withEagerAnalysis;
    withSelector: #invalidateLayout addMethod: {:(Type)self  :: Void |
        self instanceSize: 0sz.
        self instanceAlignment: 0sz.
    } withEagerAnalysis;
    withSelector: #addTypeSlot: addMethod: {:(Type)self :(TypeSlot)extraSlot :: Void |
        if: self totalSlotCount ~~ nil then: (self error: "Cannot add type slot when the total slot count has already been computed").
        if: self pendingSlots == nil then: (self pendingSlots: ArrayList new).

        self invalidateLayout.
        self pendingSlots add: extraSlot.
        self addSlotToDictionary: extraSlot.
        extraSlot generateAccessorsOn: self.
    } withEagerAnalysis;
    withSelector: #basicAllocate addMethod: {:(Type)self :: self |
        let: #result with: (if: self isBytes
            then: RawTuple::byteNew(0sz)
            else: RawTuple::new(self validTotalSlotCount)).
        (RawTuple::type:)(result, self).
        if: self isWeak then: RawTuple::markWeak(result).
        result
    } withEagerAnalysis;
    withSelector: #basicAllocate: addMethod: {:(Type)self :(Size)variableSize :: self |
        let: #result with: (if: self isBytes
            then: RawTuple::byteNew(variableSize)
            else: RawTuple::new(self validTotalSlotCount + variableSize)).
        (RawTuple::type:)(result, self).
        result
    } withEagerAnalysis;
    withSelector: #basicNew addMethod: {:(Type)self :: self |
        self basicAllocate basicInitialize; yourself
    } withEagerAnalysis;
    withSelector: #basicNew: addMethod: {:(Type)self :(Size)variableSlotCount :: self |
        (self basicAllocate: variableSlotCount) basicInitialize; yourself
    } withEagerAnalysis;
    withSelector: #new addMethod: {:(Type)self :: self |
        self basicNew initialize; yourself
    } withEagerAnalysis;
    withSelector: #new: addMethod: {:(Type)self :(Size)variableSlotCount :: self |
        (self basicNew: variableSlotCount) initialize; yourself
    } withEagerAnalysis;
    withSelector: #>> addMethod: {:(Type)self :(Symbol)selector |
        let: #methodDictionary with: self methodDictionary.
        if: methodDictionary ~~ nil
            then: (methodDictionary atOrNil: selector)
            else: nil
    };
    withSelector: #lookupSelector: addMethod: {:(Type)self :(Symbol)selector |
        let: #method with: self >> selector.
        if: method ~~ nil
        then: method
        else: {
            let: #supertype with: self supertype.
            if: supertype ~~ nil
                then: (supertype lookupSelector: selector)
                else: (nil)
        }
    };
    withSelector: #localSlotNamed: addMethod: {:(Type)self :(Symbol)name |
        let: #slotDictionary with: self slotDictionary.
        if: slotDictionary ~~ nil
            then: (slotDictionary atOrNil: name)
            else: nil
    };
    withSelector: #lookupSlot: addMethod: {:(Type)self :(Symbol)name |
        let: #slot with: (self localSlotNamed: name).
        if: slot ~~ nil
        then: slot
        else: {
            let: #supertype with: self supertype.
            if: supertype ~~ nil
                then: (supertype lookupSlot: name)
                else: (nil)
        }
    }.

ControlFlowEscapeType class
    withSelector: #coerceASTNode:into:withEnvironment: addMethod: {:(Type)self :(ASTNode)astNode :(Type)targetType :(AnalysisAndEvaluationEnvironment)environment :: ASTNode |
        astNode
    }.

UndefinedObject class
    withSelector: #coerceASTNode:into:withEnvironment: addMethod: {:(Type)self :(ASTNode)astNode :(Type)targetType :(AnalysisAndEvaluationEnvironment)environment :: ASTNode |
        if: targetType isNullable
        then: astNode
        else: error("Cannot coerce nil into non-nullable type " -- targetType printString)
    }.

ReferenceType
    withSelector: #isReferenceType addMethod: {:(ReferenceType)self :: Boolean | true } makePure;
    withSelector: #coerceASTNode:into:withEnvironment: addMethod: {:(ReferenceType)self :(ASTNode)astNode :(Type)targetType :(AnalysisAndEvaluationEnvironment)environment :: ASTNode |

        if: targetType isReferenceType then: {
            error("TODO: Implement coercion between two reference types.")
        } else: {
            let: #sourcePosition with: astNode sourcePosition.
            let: #analyzerToken with: environment analyzerToken.
            let: #loadValueFunction with: self loadValueFunction.
            let: #baseType with: self baseType.

            targetType
                coerceASTNode: (ASTFunctionApplicationNode new
                    sourcePosition: astNode sourcePosition;
                    functionExpression: (ASTLiteralNode new
                        value: loadValueFunction;
                        analyzedType: loadValueFunction __type__;
                        analyzerToken: analyzerToken;
                        yourself);
                    arguments: (astNode,);
                    analyzedType: self baseType;
                    analyzerToken: analyzerToken;
                    yourself)
                withEnvironment: environment
        }.
    }.

AnyValue
    withSelector: #isNil addMacroMethod: {:(MacroContext)macroContext :(ASTNode)self :: ASTMessageSendNode |
        ASTMessageSendNode new
            sourcePosition: macroContext sourcePosition;
            receiver: self;
            selector: (ASTLiteralNode new
                sourcePosition: macroContext sourcePosition;
                value: #==;
                yourself);
            arguments: (ASTLiteralNode new
                sourcePosition: macroContext sourcePosition;
                value: nil;
                yourself,);
            yourself
    } makeMacro;
    withSelector: #isNotNil addMacroMethod: {:(MacroContext)macroContext :(ASTNode)self :: ASTMessageSendNode |
        ASTMessageSendNode new
            sourcePosition: macroContext sourcePosition;
            receiver: self;
            selector: (ASTLiteralNode new
                sourcePosition: macroContext sourcePosition;
                value: #~~;
                yourself);
            arguments: (ASTLiteralNode new
                sourcePosition: macroContext sourcePosition;
                value: nil;
                yourself,);
            yourself
    } makeMacro;
    withSelector: #&& addMacroMethod: {:(MacroContext)macroContext :(ASTNode)self :(ASTNode)other :: ASTIfNode |
        ASTIfNode new
            sourcePosition: macroContext sourcePosition;
            conditionExpression: self;
            trueExpression: other;
            falseExpression: (ASTLiteralNode new
                sourcePosition: macroContext sourcePosition;
                value: false;
                yourself);
            yourself
    } makeMacro;
    withSelector: #|| addMacroMethod: {:(MacroContext)macroContext :(ASTNode)self :(ASTNode)other :: ASTIfNode |
        ASTIfNode new
            sourcePosition: macroContext sourcePosition;
            conditionExpression: self;
            trueExpression: (ASTLiteralNode new
                sourcePosition: macroContext sourcePosition;
                value: true;
                yourself);
            falseExpression: other;
            yourself
    } makeMacro;

    withSelector: #implicitCastTo: addMacroMethod: {:(MacroContext)macroContext :(ASTNode)self :(ASTNode)targetTypeExpression :: ASTCoerceValueNode |
        ASTCoerceValueNode new
            sourcePosition: macroContext sourcePosition;
            typeExpression: targetTypeExpression;
            valueExpression: self;
            yourself
    } makeMacro;
    withSelector: #downCastTo: addMacroMethod: {:(MacroContext)macroContext :(ASTNode)self :(ASTNode)targetTypeExpression :: ASTDownCastNode |
        ASTDownCastNode new
            sourcePosition: macroContext sourcePosition;
            typeExpression: targetTypeExpression;
            valueExpression: self;
            yourself
    } makeMacro;

    withSelector: #ifTrue: addMacroMethod: {:(MacroContext)macroContext :(ASTNode)self :(ASTNode)trueExpression :: ASTIfNode |
        ASTIfNode new
            sourcePosition: macroContext sourcePosition;
            conditionExpression: self;
            trueExpression: trueExpression;
            yourself
    } makeMacro;
    withSelector: #ifFalse: addMacroMethod: {:(MacroContext)macroContext :(ASTNode)self :(ASTNode)falseExpression :: ASTIfNode |
        ASTIfNode new
            sourcePosition: macroContext sourcePosition;
            conditionExpression: self;
            falseExpression: falseExpression;
            yourself
    } makeMacro;
    withSelector: #ifTrue:ifFalse: addMacroMethod: {:(MacroContext)macroContext :(ASTNode)self :(ASTNode)trueExpression :(ASTNode)falseExpression :: ASTIfNode |
        ASTIfNode new
            sourcePosition: macroContext sourcePosition;
            conditionExpression: self;
            trueExpression: trueExpression;
            falseExpression: falseExpression;
            yourself
    } makeMacro;
    withSelector: #ifFalse:ifTrue: addMacroMethod: {:(MacroContext)macroContext :(ASTNode)self :(ASTNode)falseExpression :(ASTNode)trueExpression :: ASTIfNode |
        ASTIfNode new
            sourcePosition: macroContext sourcePosition;
            conditionExpression: self;
            trueExpression: trueExpression;
            falseExpression: falseExpression;
            yourself
    } makeMacro;
    withSelector: #perform: addMacroMethod: {:(MacroContext)macroContext :(ASTNode)self :(ASTNode)selector :: ASTMessageSendNode |
        ASTMessageSendNode new
            sourcePosition: macroContext sourcePosition;
            receiver: self;
            selector: selector;
            arguments: Array new;
            isDynamic: true;
            yourself
    } makeMacro;
    withSelector: #perform:with: addMacroMethod: {:(MacroContext)macroContext :(ASTNode)self :(ASTNode)selector :(ASTNode)argument :: ASTMessageSendNode |
        ASTMessageSendNode new
            sourcePosition: macroContext sourcePosition;
            receiver: self;
            selector: selector;
            arguments: (Array with: argument);
            isDynamic: true;
            yourself
    } makeMacro;
    withSelector: #perform:with:with: addMacroMethod: {:(MacroContext)macroContext :(ASTNode)self :(ASTNode)selector :(ASTNode)firstArgument :(ASTNode)secondArgument :: ASTMessageSendNode |
        ASTMessageSendNode new
            sourcePosition: macroContext sourcePosition;
            receiver: self;
            selector: selector;
            arguments: (Array with: firstArgument with: secondArgument);
            isDynamic: true;
            yourself
    } makeMacro;
    withSelector: #perform:with:with:with: addMacroMethod: {:(MacroContext)macroContext :(ASTNode)self :(ASTNode)selector :(ASTNode)firstArgument :(ASTNode)secondArgument :(ASTNode)thirdArgument :: ASTMessageSendNode |
        ASTMessageSendNode new
            sourcePosition: macroContext sourcePosition;
            receiver: self;
            selector: selector;
            arguments: (Array with: firstArgument with: secondArgument with: thirdArgument);
            isDynamic: true;
            yourself
    } makeMacro;
    withSelector: #perform:with:with:with:with: addMacroMethod: {:(MacroContext)macroContext :(ASTNode)self :(ASTNode)selector :(ASTNode)firstArgument :(ASTNode)secondArgument :(ASTNode)thirdArgument :(ASTNode)fourthArgument :: ASTMessageSendNode |
        ASTMessageSendNode new
            sourcePosition: macroContext sourcePosition;
            receiver: self;
            selector: selector;
            arguments: (Array with: firstArgument with: secondArgument with: thirdArgument with: fourthArgument);
            isDynamic: true;
            yourself
    } makeMacro.

ASTNode
    withSelector: #postCopy addMethod: {:(ASTNode)self :: Void |
        (tuple: self withLookupStartingFrom: ASTNode supertype) postCopy.
        self analyzerToken: nil.
    }.

AnyReference
    withSelector: #doesNotUnderstand: addFallbackMethod: {:(MacroContext)macroContext :(ASTNode)self :(ASTMessageSendNode)messageSend :: ASTNode |
        messageSend copy
            receiver: (ASTFunctionApplicationNode new
                sourcePosition: self sourcePosition;
                functionExpression: (ASTLiteralNode new
                    sourcePosition: self sourcePosition;
                    value: self analyzedType loadValueFunction;
                    yourself);
                arguments: (self,);
                yourself);
            yourself
    } makeMacro.

Stream
    withSelector: #nextPut: addMethod: {:(Stream)self :element :: Void | 
        self subclassResponsibility
    };
    withSelector: #nextPutAll: addMethod: {:(Stream)self :aCollection :: Void | 
        aCollection do: {:each :: Void | self nextPut: each}
    };
    withSelector: #print: addMethod: {:(Stream)self :value :: Void | 
        value printOn: self
    };
    withSelector: #fullPrint: addMethod: {:(Stream)self :value :: Void | 
        value fullPrintOn: self
    };
    withSelector: #cr addMethod: {:(Stream)self :: Void | 
        self nextPut: '\r'
    };
    withSelector: #lf addMethod: {:(Stream)self :: Void | 
        self nextPut: '\n'
    };
    withSelector: #nl addMethod: {:(Stream)self :: Void | 
        self nextPut: '\n'
    };
    withSelector: #tab addMethod: {:(Stream)self :: Void | 
        self nextPut: '\t'
    };
    withSelector: #space addMethod: {:(Stream)self :: Void | 
        self nextPut: ' '
    }.

AnyValue
    withSelector: #printString addMethod: {:(AnyValue)self :: String | 
        let: #stream with: StringStream new.
        self printOn: stream.
        stream asString.
    };
    withSelector: #printOn: addMethod: {:(AnyValue)self :(Stream)stream :: Void |
        stream nextPutAll: "a " ; print: self __type__
    };
    withSelector: #fullPrintString addMethod: {:(AnyValue)self :: String | 
        let: #stream with: StringStream new.
        self fullPrintOn: stream.
        stream asString.
    };
    withSelector: #fullPrintOn: addMethod: {:(AnyValue)self :(Stream)stream :: Void |
        self printOn: stream
    }.

Type
    withSelector: #printOn: addMethod: {:(Type)self :(Stream)stream :: Void |
        let: #name with: self name.
        if: name ~~ nil
            then: (stream nextPutAll: name)
            else: (stream nextPutAll: "a Type")
    }.

Void class
    withSelector: #coerceValue: addMethod: {:(Void class)self :value :: Void | void }.
Void
    withSelector: #printString addMethod: {:(Void)self :: String | "void" };
    withSelector: #printOn: addMethod: {:(Void)self :(Stream)stream :: Void | stream nextPutAll: "void" }.

UndefinedObject
    withSelector: #doesNotUnderstand: addMethod: {:(UndefinedObject)self :(Message)message |
        self error: message selector printString -- " was sent to nil."
    };

    withSelector: #printString addMethod: {:(UndefinedObject)self :: String | "nil" };
    withSelector: #printOn: addMethod: {:(UndefinedObject)self :(Stream)stream :: Void | stream nextPutAll: "nil" }.

False
    withSelector: #printString addMethod: {:(False)self :: String | "false" };
    withSelector: #printOn: addMethod: {:(False)self :(Stream)stream :: Void | stream nextPutAll: "false" }.

True
    withSelector: #printString addMethod: {:(True)self :: String | "true" };
    withSelector: #printOn: addMethod: {:(True)self :(Stream)stream :: Void | stream nextPutAll: "true" }.

String
    withSelector: #printOn: addMethod: {:(String)self :(Stream)stream :: Void |
        ## TODO: Implement this part properly.
        stream nextPut: '"'.
        stream nextPutAll: self.
        stream nextPut: '"'.
    }.

StringSymbol
    withSelector: #printOn: addMethod: {:(StringSymbol)self :(Stream)stream :: Void |
        ## TODO: Implement this part properly.
        stream nextPut: '#'; nextPutAll: self
    };
    withSelector: #fullPrintOn: addMethod: {:(StringSymbol)self :(Stream)stream :: Void |
        ## TODO: Implement this part properly.
        stream nextPut: '#'; nextPutAll: self
    }.


Class
    withSelector: #withSelector:addClassMethod: addMethod: {:(Class)self :selector :method :: Void |
        self class withSelector: selector addMethod: method
    }.

FunctionDefinition
    withSelector: #hasPragmaNamed: addMethod: {:(FunctionDefinition)self :selector :: Boolean |
        let: #analyzedPragmas with: self analyzedPragmas.
        let: #definitionBodyNode with: self definitionBodyNode.
        if: analyzedPragmas ~~ nil
        then: (analyzedPragmas anySatisfy: {:(Pragma)pragma :: Boolean | selector == pragma selector })
        else: (
            if: definitionBodyNode ~~ nil
            then: (definitionBodyNode hasPragmaNamed: selector)
            else: false
        )
    }.

Function
    withSelector: #hasFlag: addMethod: {:(Function)self :(Bitflags)flag :: Boolean |
        (self flags & flag) ~= 0bflgs
    };
    withSelector: #isMacro addMethod: {:(Function)self :: Boolean |
        self hasFlag: FunctionFlags::Macro
    };
    
    withSelector: #isVariadic addMethod: {:(Function)self :: Boolean |
        self hasFlag: FunctionFlags::Variadic
    };
    withSelector: #isCorePrimitive addMethod: {:(Function)self :: Boolean |
        self hasFlag: FunctionFlags::CorePrimitive
    };

    withSelector: #isPure addMethod: {:(Function)self :: Boolean |
        self hasFlag: FunctionFlags::Pure
    };
    withSelector: #isFinal addMethod: {:(Function)self :: Boolean |
        self hasFlag: FunctionFlags::Final
    };
    withSelector: #isVirtual addMethod: {:(Function)self :: Boolean |
        self hasFlag: FunctionFlags::Virtual
    };
    withSelector: #isAbstract addMethod: {:(Function)self :: Boolean |
        self hasFlag: FunctionFlags::Abstract
    };
    withSelector: #isOverride addMethod: {:(Function)self :: Boolean |
        self hasFlag: FunctionFlags::Override
    };
    withSelector: #isStatic addMethod: {:(Function)self :: Boolean |
        self hasFlag: FunctionFlags::Static
    };

    withSelector: #hasPragmaNamed: addMethod: {:(Function)self :selector :: Boolean |
        let: #definition with: self definition.
        if: definition == nil then: false else: (definition hasPragmaNamed: selector)
    };
    
    withSelector: #printOn: addMethod: {:(Function)self :(Stream)stream :: Void |
        let: #name with: self name.
        let: #definition with: self definition.
        let: #sourcePosition with: (if: definition ~~ nil then: definition sourcePosition else: nil).

        stream nextPutAll: "Function(".

        if: name ~~ nil then: {
            let: #owner with: self owner.
            if: owner ~~ nil then: (stream print: owner; nextPutAll: " >> ").
            
            stream print: name.
            if: sourcePosition ~~ nil then: (stream space).

        }.
        if: sourcePosition ~~ nil then: {
            stream nextPutAll: "at "; print: sourcePosition
        }.

        stream nextPut: ')'
    }.

ValueBox
    withSelector: #with: addClassMethod: {:(ValueBox class)self :value :: self |
        self basicNew
            value: value;
            yourself
    };
    withSelector: #_ addMethod: {:(ValueBox)self | self value };
    withSelector: #_: addMethod: {:(ValueBox)self :newValue | self value: newValue. newValue };
    withSelector: #":=" addMethod: {:(ValueBox)self :newValue | self value: newValue. newValue }.

Collection
    withSelector: #isEmpty addMethod: {:(Collection)self :: Boolean |
        self size = 0sz
    };
    withSelector: #isNotEmpty addMethod: {:(Collection)self :: Boolean |
        self size ~= 0sz
    };
    withSelector: #size addMethod: {:(Collection)self :: Size |
        self subclassResponsibility
    } makeAbstract;

    withSelector: #do: addMethod: {:(Collection)self :aBlock :: Void |
        self subclassResponsibility
    } makeAbstract;

    withSelector: #doWithoutTombstones: addMethod: {:(Collection)self :aBlock :: Void |
        self do: {:each :: Void |
            if: __tombstone__ ~~ each then: aBlock(each)
        }
    };

    withSelector: #doWithIndex: addMethod: {:(Collection)self :aBlock :: Void |
        let: #i mutableWith: 0sz.
        self do: {:element :: Void |
            aBlock(element, i).
            i := 1sz + i
        }
    };

    withSelector: #select: addMethod: {:(Collection)self :aBlock :: Collection |
        let: #result with: ArrayList new.
        self do: {:each :: Void |
            if: aBlock(each) then: (result add: each)
        }.
        result
    };
    withSelector: #reject: addMethod: {:(Collection)self :aBlock :: Collection |
        let: #result with: ArrayList new.
        self do: {:each :: Void |
            if: aBlock(each) not then: (result add: each)
        }.
        result
    };

    withSelector: #printOn: addMethod: {:(Collection)self :(Stream)stream :: Void |
        stream print: self class; nextPutAll: "(".
        self doWithIndex: {:element :(Size)index :: Void |
            if: index > 0sz then: (stream nextPutAll: ", ").
            stream print: element.
            void
        }.

        stream nextPutAll: ")"
    };
    withSelector: #fullPrintOn: addMethod: {:(Collection)self :(Stream)stream :: Void |
        stream print: self class; nextPutAll: "(".
        self doWithIndex: {:element :(Size)index :: Void |
            if: index > 0sz then: (stream nextPutAll: ", ").
            stream fullPrint: element.
            void
        }.

        stream nextPutAll: ")"
    };
    withSelector: #asArray addMethod: {:(Collection)self :: Array |
        let: #array with: (Array new: self size).
        self doWithIndex: {:element :(Size)index :: Void |
            array at: index put: element
        }.

        array
    }.

SequenceableCollection
    withSelector: #=> addMethod: {:(SequenceableCollection)self :(Type)resultType :: SimpleFunctionType |
        SimpleFunctionTypeTemplate(self asArray, false, resultType)
    } makePure makeFinal.

Association
    withSelector: #key:value: addClassMethod: {:(Association class)self :key :value :: self |
        self new key: key; value: value; yourself
    };
    withSelector: #printOn: addMethod: {:(Association)self :(Stream)stream :: Void |
        stream print: self key; nextPutAll: " -> "; print: self value
    }.
Object
    withSelector:#-> addMethod: {:(Object)self :value :: Association |
        Association key: self value: value
    }.

WeakValueAssociation
    withSelector: #value addMethod: {:(WeakValueAssociation)self |
        (RawTuple::slotAt:)(self, 1sz)
    } makePure; makeFinal;
    withSelector: #value: addMethod: {:(WeakValueAssociation)self :newValue :: Void |
        RawTuple::slotAt:put:(self, 1sz, newValue)
    } makePure; makeFinal;
    withSelector: #printOn: addMethod: {:(WeakValueAssociation)self :(Stream)stream :: Void |
        stream print: self key; nextPutAll: " -> "; print: self value
    }.

Dictionary
    withSelector: #do: addMethod: {:(Dictionary)self :aBlock :: Void |
        let: #storage with: self storage.
        if: storage ~~ nil then: {
            storage do: {:element :: Void |
                if: element ~~ nil then: aBlock(element).
            }
        }
    };
    withSelector: #ensureStorage addMethod: {:(Dictionary)self :: Void |
        if: self storage == nil then: (self storage: (Array new: 16sz)).
    };
    withSelector: #at:ifAbsent: addMethod: {:(Dictionary)self :key :ifAbsentBlock |
        self ensureStorage.
        let: #entryIndex with: (self scanFor: key) asSize.
        let: #storage with: self storage.
        let: #entry with: (storage at: entryIndex).
        if: entry == nil then: {
            ifAbsentBlock()
        } else: {
            entry value
        }
    };
    withSelector: #at:ifAbsentPut: addMethod: {:(Dictionary)self :key :ifAbsentBlock |
        self ensureStorage.
        let: #entryIndex with: (self scanFor: key) asSize.
        let: #storage with: self storage.
        let: #entry with: (storage at: entryIndex).
        if: entry == nil then: {
            let: #value with: ifAbsentBlock().
            self at: key put: value.
            value
        } else: {
            entry value
        }
    };
    withSelector: #at:ifPresent: addMethod: {:(Dictionary)self :key :ifPresentBlock :: Void |
        self ensureStorage.
        let: #entryIndex with: (self scanFor: key) asSize.
        let: #storage with: self storage.
        let: #entry with: (storage at: entryIndex).
        if: entry ~~ nil then: {
            ifPresentBlock(entry value)
        }
    }.

Set
    withSelector: #do: addMethod: {:(Set)self :aBlock :: Void |
        let: #storage with: self storage.
        if: storage ~~ nil then: {
            storage do: {:element :: Void |
                if: __hashtableEmptyElement__ ~~ element then: aBlock(element).
            }
        }
    }.

WeakSet
    withSelector: #do: addMethod: {:(WeakSet)self :aBlock :: Void |
        let: #storage with: self storage.
        if: storage ~~ nil then: {
            storage do: {:element :: Void |
                if: (__hashtableEmptyElement__ ~~ element) && (__tombstone__ ~~ element) then: aBlock(element).
            }
        }
    }.

SequenceableCollection
    withSelector: #with: addClassMethod: {:(SequenceableCollection class)self :value :: self |
        (self new: 1sz)
            at: 0sz put: value;
            yourself
    };
    withSelector: #with:with: addClassMethod: {:(SequenceableCollection class)self :first :second :: self |
        (self new: 2sz)
            at: 0sz put: first;
            at: 1sz put: second;
            yourself
    };
    withSelector: #with:with:with: addClassMethod: {:(SequenceableCollection class)self :first :second :third :: self |
        (self new: 3sz)
            at: 0sz put: first;
            at: 1sz put: second;
            at: 2sz put: third;
            yourself
    };
    withSelector: #with:with:with:with: addClassMethod: {:(SequenceableCollection class)self :first :second :third :fourth :: self |
        (self new: 4sz)
            at: 0sz put: first;
            at: 1sz put: second;
            at: 2sz put: third;
            at: 3sz put: fourth;
            yourself
    };
    withSelector: #at: addMethod: {:(SequenceableCollection)self :(Size)index  |
        self subclassResponsibility
    } makeAbstract;
    withSelector: #at:put: addMethod: {:(SequenceableCollection)self :(Size)index :value :: Void |
        self subclassResponsibility
    } makeAbstract;
    withSelector: #atAllPut: addMethod: {:(SequenceableCollection)self :value :: Void |
        let: #i mutableWith: 0sz.
        let: #size with: self size.
        while: (i < size) do: (
            self at: i put: value
        ) continueWith: (i := i + 1sz)
    };
    withSelector: #anySatisfy: addMethod: {:(SequenceableCollection)self :aBlock :: Boolean |
        let: #i mutableWith: 0sz.
        let: #size with: self size.
        let: #hasFoundIt type: Boolean mutableWith: false.

        while: (if: hasFoundIt then: false else: i < self size) do: (
            hasFoundIt := aBlock(self at: i)
        ) continueWith: (i := i + 1sz).
        hasFoundIt
    } makeFinal;
    withSelector: #allSatisfy: addMethod: {:(SequenceableCollection)self :aBlock :: Boolean |
        let: #i mutableWith: 0sz.
        let: #size with: self size.
        let: #everythingIsFine type: Boolean mutableWith: true.

        while: (if: everythingIsFine then: i < self size else: false) do: (
            everythingIsFine := aBlock(self at: i)
        ) continueWith: (i := i + 1sz).
        everythingIsFine
    } makeFinal;
    withSelector: #indexOf: addMethod: {:(SequenceableCollection)self :value :: IntPointer |
        let: #i mutableWith: 0sz.
        let: #size with: self size.
        let: #hasFoundIt type: Boolean mutableWith: false.
        while: (i < size) do: (
            if: value = (self at: i) then: (return: i asIntPointer)
        ) continueWith: (i := i + 1sz).

        -1iptr
    };
    withSelector: #includes: addMethod: {:(SequenceableCollection)self :element :: Boolean |
        let: #i mutableWith: 0sz.
        let: #size with: self size.
        let: #hasFoundIt type: Boolean mutableWith: false.

        while: (if: hasFoundIt then: false else: i < self size) do: (
            hasFoundIt := (self at: i) = element
        ) continueWith: (i := i + 1sz).
        hasFoundIt
    } makeFinal;
    withSelector: #collect: addMethod: {:(SequenceableCollection)self :aBlock :: self species |
        let: #i mutableWith: 0sz.
        let: #size with: self size.
        let: #result with: (self species new: size).

        while: i < self size do: {
            result at: i put: aBlock(self at: i)
        } continueWith: (i := i + 1sz).

        result
    } makeFinal;
    withSelector: #collect:as: addMethod: {:(SequenceableCollection)self :aBlock :(SequenceableCollection class)resultType :: resultType |
        let: #i mutableWith: 0sz.
        let: #size with: self size.
        let: #result with: (resultType new: size).

        while: i < self size do: {
            result at: i put: aBlock(self at: i)
        } continueWith: (i := i + 1sz).

        result
    } makeFinal;
    withSelector: #collectWithIndex: addMethod: {:(SequenceableCollection)self :aBlock :: self species |
        let: #i mutableWith: 0sz.
        let: #size with: self size.
        let: #result with: (self species new: size).

        while: i < self size do: {
            result at: i put: aBlock(self at: i, i)
        } continueWith: (i := i + 1sz).

        result
    } makeFinal;
    withSelector: #detect:ifFound:ifNone: addMethod: {:(SequenceableCollection)self :aPredicate :foundBlock :notFoundBlock |
        let: #i mutableWith: 0sz.
        let: #size with: self size.
        let: #hasFoundIt type: Boolean mutableWith: false.
        let: #foundElement type: AnyValue mutableWith: nil.

        while: (if: hasFoundIt then: false else: i < self size) do: {
            foundElement := self at: i.
            hasFoundIt := aPredicate(foundElement)
        } continueWith: (i := i + 1sz).

        if: hasFoundIt
            then: foundBlock(foundElement)
            else: notFoundBlock(notFoundBlock)
    };
    withSelector: #detect:ifNone: addMethod: {:(SequenceableCollection)self :aPredicate :notFoundBlock |
        self detect: aPredicate ifFound: {:element | element } ifNone: notFoundBlock
    };
    withSelector: #do: addMethod: {:(SequenceableCollection)self :aBlock :: Void |
        let: #i mutableWith: 0sz.
        let: #size with: self size.

        while: i < self size do: (
            aBlock(self at: i)
        ) continueWith: (i := i + 1sz)
    };
    withSelector: #doWithIndex: addMethod: {:(SequenceableCollection)self :aBlock :: Void |
        let: #i mutableWith: 0sz.
        let: #size with: self size.

        while: i < self size do: {
            aBlock(self at: i, i)
        } continueWith: (i := i + 1sz)
    };
    withSelector: #pairsDo: addMethod: {:(SequenceableCollection)self :aBlock :: Void |
        let: #i mutableWith: 0sz.
        let: #size with: self size.

        while: i < self size do: {
            aBlock(self at: i, self at: i + 1sz)
        } continueWith: (i := i + 2sz)
    };
    withSelector: #-- addMethod: {:(SequenceableCollection)self :(SequenceableCollection)other :: self species |
        let: #size with: self size.
        let: #otherSize with: other size.
        let: #result with: (self species new: size + otherSize ).
        
        self doWithIndex: {:element :(Size)index :: Void |
            result at: index put: element
        }.

        other doWithIndex: {:element :(Size)index :: Void |
            result at: size + index put: element
        }.

        result
    };
    withSelector: #replaceFrom:until:with: addMethod: {:(SequenceableCollection)self :(Size)start :(Size)stop :(SequenceableCollection)replacements :: Void |
        let: #i mutableWith: start.

        while: i < stop do: {
            self at: i put: (replacements at: i - start)
        } continueWith: (i := i + 1sz)
    };
    withSelector: #replaceAll:with: addMethod: {:(SequenceableCollection)self :oldObject :newObject :: Void |
        let: #i mutableWith: 0sz.
        let: #size with: self size.

        while: i < self size do: {
            if: (self at: i) = oldObject then: (self at: i put: newObject)
        } continueWith: (i := i + 1sz)
    };
    withSelector: #replaceAllWithDictionary: addMethod: {:(SequenceableCollection)self :(Dictionary)replacementDictionary :: Void |
        let: #i mutableWith: 0sz.
        let: #size with: self size.

        while: i < self size do: {
            replacementDictionary at: (self at: i) ifPresent: {:replacement :: Void |
                (self at: i put: replacement)
            }
        } continueWith: (i := i + 1sz)
    };
    withSelector: #first addMethod: {:(SequenceableCollection)self | self at: 0sz } makeFinal;
    withSelector: #second addMethod: {:(SequenceableCollection)self | self at: 1sz } makeFinal;
    withSelector: #third addMethod: {:(SequenceableCollection)self | self at: 2sz } makeFinal;
    withSelector: #fourth addMethod: {:(SequenceableCollection)self | self at: 3sz } makeFinal;
    withSelector: #fifth addMethod: {:(SequenceableCollection)self | self at: 4sz } makeFinal;
    withSelector: #sixth addMethod: {:(SequenceableCollection)self | self at: 5sz } makeFinal;
    withSelector: #seventh addMethod: {:(SequenceableCollection)self | self at: 6sz } makeFinal;
    withSelector: #eighth addMethod: {:(SequenceableCollection)self | self at: 7sz } makeFinal;
    withSelector: #ninth addMethod: {:(SequenceableCollection)self | self at: 8sz } makeFinal;
    withSelector: #tenth addMethod: {:(SequenceableCollection)self | self at: 9sz } makeFinal;

    withSelector: #last addMethod: {:(SequenceableCollection)self | self at: self size - 1sz } makeFinal;

    withSelector: #first: addMethod: {:(SequenceableCollection)self :(Size)elementsToKeep :: self species |
        let: #size with: self size.
        let: #resultSize with: (if: size < elementsToKeep then: size else: size).
        
        let: #result with: (self species new: resultSize).
        let: #i mutableWith: 0sz.
        while: i < resultSize do: (
            result at: i put: (self at: i)
        ) continueWith: (i := i + 1sz).
    };
    withSelector: #allButFirst: addMethod: {:(SequenceableCollection)self :(Size)dropCount :: self species |
        let: #size with: self size.
        if: dropCount >= size then: (self species new: 0sz)
        else: {
            let: #resultSize with: size - dropCount.
            let: #result with: (self species new: resultSize).
            let: #i mutableWith: dropCount.
            while: i < size do: (
                result at: i - dropCount put: (self at: i)
            ) continueWith: (i := i + 1sz).
            result
        }
    };
    withSelector: #allButFirst addMethod: {:(SequenceableCollection)self :: self species |
        self allButFirst: 1sz
    };

    withSelector: #insertionSort:from:until: addMethod: {:(SequenceableCollection)self :lessThanComparison :(Size)startIndex :(Size)endIndex :: Void |
        ## Insertion sort algorithm from https://en.wikipedia.org/wiki/Insertion_sort [March 2023]
        let: #i mutableWith: startIndex + 1sz.
        let: #j mutableWith: 0sz.

        while: (i < endIndex) do: {
            let: #insertedElement with: (self at: i).
            j := i.
            while: (j > startIndex) && lessThanComparison(insertedElement, self at: j - 1sz) do: {
                self at: j put: (self at: j - 1sz)
            } continueWith: (j := j - 1sz).

            self at: j put: insertedElement.
        } continueWith: (i := i + 1sz)
    };
    withSelector: #partition:from:until: addMethod: {:(SequenceableCollection)self :lessThanComparison :(Size)startIndex :(Size)endIndex :: Size |
        let: #pivotIndex with: endIndex - 1sz.
        let: #pivot with: (self at: pivotIndex).

        let: #i mutableWith: startIndex.
        let: #j mutableWith: startIndex.
        while: (j < pivotIndex) do: {
            let: #element with: (self at: j).

            if: lessThanComparison(element, pivot) then: {
                if: i ~= j then: {
                    let: #temp with: (self at: i).
                    self at: i put: element.
                    self at: j put: temp.
                }.
                i := i + 1sz
            }
        } continueWith: (j := j + 1sz).

        let: #destElement with: (self at: i).
        self at: i put: pivot.
        self at: pivotIndex put: destElement.

        i
    };
    withSelector: #heapSort:from:until: addMethod: {:(SequenceableCollection)self :lessThanComparison :(Size)startIndex :(Size)endIndex :: Void |
        ## TODO: Implement this properly.
        self insertionSort: lessThanComparison from: startIndex until: endIndex
    };
    withSelector: #quickSort:from:until: addMethod: {:(SequenceableCollection)self :lessThanComparison :(Size)startIndex :(Size)endIndex :: Void |
        if: startIndex < endIndex then: {
            let: #partition with: (self partition: lessThanComparison from: startIndex until: endIndex).
            self quickSort: lessThanComparison from: startIndex until: partition.
            self quickSort: lessThanComparison from: partition + 1sz until: endIndex.
        }
    };
    withSelector: #introSort:from:until:maxDepth: addMethod: {:(SequenceableCollection)self :lessThanComparison :(Size)startIndex :(Size)endIndex :(Size)maxDepth :: Void |
        if: startIndex < endIndex then: {
            let: #rangeSize with: endIndex - startIndex.
            if: rangeSize <= 16sz then: {
                self insertionSort: lessThanComparison from: startIndex until: endIndex
            } else: {
                if: maxDepth = 0sz then: {
                    self heapSort: lessThanComparison from: startIndex until: endIndex
                } else: {
                    let: #partition with: (self partition: lessThanComparison from: startIndex until: endIndex).
                    self quickSort: lessThanComparison from: startIndex until: partition.
                    self quickSort: lessThanComparison from: partition + 1sz until: endIndex.
                }.
            }
        }
    };
    withSelector: #insertionSort: addMethod: {:(SequenceableCollection)self :lessThanComparison :: Void |
        self insertionSort: lessThanComparison from: 0sz until: self size
    };
    withSelector: #insertionSort addMethod: {:(SequenceableCollection)self :: Void |
        self sort: {:a :b :: Boolean | a < b }
    };
    withSelector: #heapSort: addMethod: {:(SequenceableCollection)self :lessThanComparison :: Void |
        self heapSort: lessThanComparison from: 0sz until: self size
    };
    withSelector: #heapSort addMethod: {:(SequenceableCollection)self :: Void |
        self sort: {:a :b :: Boolean | a < b }
    };
    withSelector: #quickSort: addMethod: {:(SequenceableCollection)self :lessThanComparison :: Void |
        self quickSort: lessThanComparison from: 0sz until: self size
    };
    withSelector: #quickSort addMethod: {:(SequenceableCollection)self :: Void |
        self sort: {:a :b :: Boolean | a < b }
    };
    withSelector: #sort: addMethod: {:(SequenceableCollection)self :lessThanComparison :: Void |
        self introSort: lessThanComparison from: 0sz until: self size maxDepth: 16sz
        ##self insertionSort: lessThanComparison from: 0sz until: self size
        ##self quickSort: lessThanComparison from: 0sz until: self size
        ##self heapSort: lessThanComparison from: 0sz until: self size
    };
    withSelector: #sort addMethod: {:(SequenceableCollection)self :: Void |
        self sort: {:a :b :: Boolean | a < b }
    };
    withSelector: #sorted: addMethod: {:(SequenceableCollection)self :lessThanComparison :: self __type__ |
        self copy sort: lessThanComparison; yourself
    };
    withSelector: #sorted addMethod: {:(SequenceableCollection)self :: self __type__ |
        self sorted: {:a :b :: Boolean | a < b }
    }.

ArrayList
    withSelector: #arrayType addClassMethod: {:(ArrayList class)self :: Array class |
        Array
    };
    withSelector: #new: addClassMethod: {:(ArrayList class)self :(Size)initialSize :: self |
        self basicNew initializeWithSize: initialSize; yourself
    } makeFinal;
    withSelector: #initialize addMethod: {:(ArrayList)self :: Void |
        self size: 0sz
    };
    withSelector: #initializeWithSize: addMethod: {:(ArrayList)self :(Size)initialSize :: Void |
        self size: initialSize.
        self storage: (self class arrayType new: initialSize).
    };
    withSelector: #addAll: addMethod: {:(ArrayList)self :(Collection)elements |
        elements do: {:each :: Void |
            self add: each
        }
    };
    withSelector: #at: addMethod: {:(ArrayList)self :(Size)index |
        if: index < self size then: {
            self storage at: index
        } else: {
            error("Index out of bounds.")
        }
    };
    withSelector: #at:put: addMethod: {:(ArrayList)self :(Size)index :value :: Void |
        if: index < self size then: {
            self storage at: index put: value
        } else: {
            error("Index out of bounds.")
        }
    };
    withSelector: #removeAllThat: addMethod: {:(ArrayList)self :aPredicate :: Void |
        let: #size with: self size.
        let: #storage with: self storage.
        let: #newSize mutableWith: 0sz.
        let: #i mutableWith: 0sz.

        while: i < size do: {
            let: #element with: (storage at: i).
            (__tombstone__ == element) || aPredicate(element) ifFalse: {
                storage at: newSize put: element.
                newSize := newSize + 1sz
            }
        } continueWith: (i := i + 1sz).

        self size: newSize
    };
    withSelector: #removeAllOcurrencesOf: addMethod: {:(ArrayList)self :value :: Void |
        let: #size with: self size.
        let: #storage with: self storage.
        let: #newSize mutableWith: 0sz.
        let: #i mutableWith: 0sz.

        while: i < size do: {
            let: #element with: (storage at: i).
            (__tombstone__ == element) || (element = value) ifFalse: {
                storage at: newSize put: element.
                newSize := newSize + 1sz
            }
        } continueWith: (i := i + 1sz).

        self size: newSize
    }.

WeakArrayList
    withSelector: #arrayType addClassMethod: {:(ArrayList class)self :: Array class |
        WeakArray
    }.
    
StringStream
    withSelector: #initialize addMethod: {:(StringStream)self :: Void |
        self size: 0
    }.

Array
    withSelector: #new: addClassMethod: {:(Array class)self :(Size)initialSize :: self |
        self basicNew: initialSize
    } makeFinal;
    withSelector: #asArray addMethod: {:(Array)self :: Array | self };
    withSelector: #asArraySlice addMethod: {:(Array)self :: ArraySlice |
        ArraySlice basicNew
            elements: self;
            offset: 0sz;
            size: self size;
            yourself
    }.

ByteArray
    withSelector: #new: addClassMethod: {:(ByteArray class)self :(Size)initialSize :: self |
        self basicNew: initialSize
    } makeFinal;
    withSelector: #at: addMethod: {:(ByteArray)self :(Size)index :: UInt8 |
        self __slotAt__: index
    };
    withSelector: #at:put: addMethod: {:(ByteArray)self :(Size)index :(UInt8)value :: Void |
        self __slotAt__: index put: value
    };
    withSelector: #size addMethod: {:(ByteArray)self :: Size |
        self __byteSize__
    };

    withSelector: #uint8At: addMethod: {:(ByteArray)self :(Size)index :: UInt8 |
        self at: index
    };
    withSelector: #uint8At:put: addMethod: {:(ByteArray)self :(Size)index :(UInt8)value :: Void |
        self at: index put: value
    };
    withSelector: #char8At: addMethod: {:(ByteArray)self :(Size)index :: Char8 |
        (self at: index) asChar8
    };
    withSelector: #char8At:put: addMethod: {:(ByteArray)self :(Size)index :(Char8)value :: Void |
        self uint8At: index put: value asUInt8
    };
    withSelector: #int8At: addMethod: {:(ByteArray)self :(Size)index :: Int8 |
        (self at: index) asInt8
    };
    withSelector: #int8At:put: addMethod: {:(ByteArray)self :(Size)index :(Int8)value :: Void |
        self uint8At: index put: value asUInt8
    };

    withSelector: #uint16At: addMethod: {:(ByteArray)self :(Size)index :: UInt16 |
        (self at: index) asUInt16
        | ((self at: index + 1sz) asUInt16 << 8u16)
    };
    withSelector: #uint16At:put: addMethod: {:(ByteArray)self :(Size)index :(UInt16)value :: Void |
        self
            at: index put: value asUInt8;
            at: index + 1sz put: (value >> 8u16) asUInt8
    };
    withSelector: #char16At: addMethod: {:(ByteArray)self :(Size)index :: Char16 |
        (self uint16At: index) asChar16
    };
    withSelector: #char16At:put: addMethod: {:(ByteArray)self :(Size)index :(Char16)value :: Void |
        self uint16At: index put: value asUInt16
    };
    withSelector: #int16At: addMethod: {:(ByteArray)self :(Size)index :: Int16 |
        (self uint16At: index) asInt16
    };
    withSelector: #int16At:put: addMethod: {:(ByteArray)self :(Size)index :(Int16)value :: Void |
        self uint16At: index put: value asUInt16
    };

    withSelector: #uint32At: addMethod: {:(ByteArray)self :(Size)index :: UInt32 |
        (((self at: index) asUInt32
        | ((self at: index + 1sz) asUInt32 << 8u32))
        | ((self at: index + 2sz) asUInt32 << 16u32))
        | ((self at: index + 3sz) asUInt32 << 24u32)
    };
    withSelector: #uint32At:put: addMethod: {:(ByteArray)self :(Size)index :(UInt32)value :: Void |
        self
            at: index put: value asUInt8;
            at: index + 1sz put: (value >> 8u32) asUInt8;
            at: index + 2sz put: (value >> 16u32) asUInt8;
            at: index + 3sz put: (value >> 24u32) asUInt8
    };
    withSelector: #char32At: addMethod: {:(ByteArray)self :(Size)index :: Char32 |
        (self uint32At: index) asChar32
    };
    withSelector: #char32At:put: addMethod: {:(ByteArray)self :(Size)index :(Char32)value :: Void |
        self uint32At: index put: value asUInt32
    };
    withSelector: #int32At: addMethod: {:(ByteArray)self :(Size)index :: Int32 |
        (self uint32At: index) asInt32
    };
    withSelector: #int32At:put: addMethod: {:(ByteArray)self :(Size)index :(Int32)value :: Void |
        self uint32At: index put: value asUInt32
    };

    withSelector: #uint64At: addMethod: {:(ByteArray)self :(Size)index :: UInt64 |
        (((((((self at: index) asUInt64
        | ((self at: index + 1sz) asUInt64 << 8u64))
        | ((self at: index + 2sz) asUInt64 << 16u64))
        | ((self at: index + 3sz) asUInt64 << 24u64))
        | ((self at: index + 4sz) asUInt64 << 32u64))
        | ((self at: index + 5sz) asUInt64 << 40u64))
        | ((self at: index + 6sz) asUInt64 << 48u64))
        | ((self at: index + 7sz) asUInt64 << 56u64)
    };
    withSelector: #uint64At:put: addMethod: {:(ByteArray)self :(Size)index :(UInt64) value :: Void |
        self
            at: index put: value asUInt8;
            at: index + 1sz put: (value >> 8u64) asUInt8;
            at: index + 2sz put: (value >> 16u64) asUInt8;
            at: index + 3sz put: (value >> 24u64) asUInt8;
            at: index + 4sz put: (value >> 32u64) asUInt8;
            at: index + 5sz put: (value >> 40u64) asUInt8;
            at: index + 6sz put: (value >> 48u64) asUInt8;
            at: index + 7sz put: (value >> 56u64) asUInt8
    };
    withSelector: #int64At: addMethod: {:(ByteArray)self :(Size)index :: Int64 |
        (self uint64At: index) asInt64
    };
    withSelector: #int64At:put: addMethod: {:(ByteArray)self :(Size)index :(Int64) value :: Void |
        self uint64At: index put: value asUInt64
    };

    withSelector: #float32At: addMethod: {:(ByteArray)self :(Size)index :: Float32 |
        (self uint32At: index) asIEEEFloat32Decoded
    };
    withSelector: #float32At:put: addMethod: {:(ByteArray)self :(Size)index :(Float32)value :: Void |
        self uint32At: index put: value asIEEEFloat32Encoding
    };

    withSelector: #float64At: addMethod: {:(ByteArray)self :(Size)index :: Float64 |
        (self uint64At: index) asIEEEFloat64Decoded
    };
    withSelector: #float64At:put: addMethod: {:(ByteArray)self :(Size)index :(Float64)value :: Void |
        self uint64At: index put: value asIEEEFloat64Encoding
    };

    withSelector: #printOn: addMethod: {:(ByteArray)self :(Stream)stream :: Void |
        stream nextPutAll: "#[".
        self doWithIndex: {:element :index :: Void |
            if: index > 0sz then: (stream nextPutAll: ". ").
            stream print: element.
            void
        }.

        stream nextPutAll: "]"
    }.

String
    withSelector: #new: addClassMethod: {:(String class)self :(Size)initialSize :: self |
        self basicNew: initialSize
    } makeFinal;
    withSelector: #at: addMethod: {:(String)self :(Size)index :: Char8 |
        (self __slotAt__: index) asChar8
    };
    withSelector: #at:put: addMethod: {:(String)self :(Size)index :(Char8)value :: Void |
        self __slotAt__: index put: value
    };
    withSelector: #size addMethod: {:(String)self :: Size |
        self __byteSize__
    };
    withSelector: #padLeft:with: addMethod: {:(String)self :(Size)requiredLength :(Char8)paddingCharacter :: self species |
        let: #size with: self size.
        if: size >= requiredLength then: self
        else: {
            let: #paddingSize with: requiredLength - size.
            let: #result with: (self species new: requiredLength).

            let: #i mutableWith: 0sz.
            while: i < paddingSize do: (
                result at: i put: paddingCharacter
            ) continueWith: (i := i + 1sz).
            
            i := 0sz.
            while: i < size do: (
                result at: i + paddingSize put: (self at: i)
            ) continueWith: (i := i + 1sz).
            result
        }
    };
    withSelector: #padLeft: addMethod: {:(String)self :(Size)requiredLength :: self species |
        self padLeft: requiredLength with: ' 'asChar8
    }.

ArraySlice
    withSelector: #new: addClassMethod: {:(ArraySlice class)self :(Size)size :: self |
        self basicNew
            elements: (Array basicNew: size);
            offset: 0sz;
            size: size;
            yourself
    };
    withSelector: #at: addMethod: {:(ArraySlice)self :(Size)index |
        if: index < self size then: {
            self elements at: index + self offset
        } else: {
            error("Index out of bounds.")
        }
    };
    withSelector: #at:put: addMethod: {:(ArraySlice)self :(Size)index :value :: Void |
        if: index < self size then: {
            self elements at: index + self offset put: value
        } else: {
            error("Index out of bounds.")
        }
    }.

MethodDictionary
    withSelector: #keysAndValuesDo: addMethod: {:(MethodDictionary)self :aBlock :: Void |
        let: #storage with: self storage.
        if: storage ~~ nil then: {
            self storage pairsDo: {:selector :method :: Void |
                if: selector ~~ __hashtableEmptyElement__ then: aBlock(selector, method)
            }
        }
    };
    withSelector: #do: addMethod: {:(MethodDictionary)self :aBlock :: Void |
        self keysAndValuesDo: {:selector :method :: Void |
            aBlock(Association key: selector value: method)
        }
    }.

## Byte encoding
Type
    withSelector: #canEncodeValueInBytes addMethod: {:(Type)self :: Boolean | false };
    withSelector: #encodeValue:inBytes:atOffset: addMethod: {:(Type)self :value :(ByteArray)bytes :(Size)offset :: Void |
        self subclassResponsibility
    };
    withSelector: #canDecodeValueFromBytes addMethod: {:(Type)self :: Boolean | false };
    withSelector: #decodeValueFromBytes:atOffset: addMethod: {:(Type)self :(ByteArray)bytes :(Size)offset :: self |
        self subclassResponsibility
    };
    
    withSelector: #encodeValueAsByteArray: addMethod: {:(Type)self :value :: ByteArray |
        let result := ByteArray new: self alignedValueSize.
        self encodeValue: value inBytes: result atOffset: 0sz.
        result
    };
    withSelector: #decodeValueFromByteArray: addMethod: {:(Type)self :(ByteArray)bytes :: self |
        self decodeValueFromBytes: bytes atOffset: 0sz
    }.

AnyValue
    withSelector: #sizeOfByteEncoding addMethod: {:self :: Size | self __type__ alignedValueSize };
    withSelector: #canEncodeInBytes addMethod: {:self :: Boolean | self __type__ canEncodeValueInBytes };
    withSelector: #offsetOfEncodedElementInByteStream: addMethod: {:self :(Size)offset :: Void | };
    withSelector: #encodeInBytes:atOffset: addMethod: {:self :(ByteArray)bytes :(Size)offset :: Void |
        self __type__ encodeValue: self inBytes: bytes atOffset: offset
    };
    withSelector: #encodedInByteArray addMethod: {:self :: ByteArray |
        let result := ByteArray new: self sizeOfByteEncoding.
        self encodeInBytes: result atOffset: 0sz.
        result
    }.

## Primitive numbers meta methods.
Char8 class
    withSelector: #canEncodeValueInBytes addMethod: {:(Char8 class)self :: Boolean | true };
    withSelector: #encodeValue:inBytes:atOffset: addMethod: {:(Char8 class)self :(Char8)value :(ByteArray)bytes :(Size)offset :: Void |
        bytes char8At: offset put: value
    };
    withSelector: #canDecodeValueFromBytes addMethod: {:(Char8 class)self :: Boolean | true };
    withSelector: #decodeValueFromBytes:atOffset: addMethod: {:(Char8 class)self :(ByteArray)bytes :(Size)offset :: Char8 |
        bytes char8At: offset
    };

    withSelector: #defaultValue addMethod: {:(Char8 class)self :: Char8 | 0c8 };
    withSelector: #zero addMethod: {:(Char8 class)self :: Char8 | 0c8 };
    withSelector: #one addMethod: {:(Char8 class)self :: Char8 | 1c8 }.

UInt8 class
    withSelector: #canEncodeValueInBytes addMethod: {:(UInt8 class)self :: Boolean | true };
    withSelector: #encodeValue:inBytes:atOffset: addMethod: {:(UInt8 class)self :(UInt8)value :(ByteArray)bytes :(Size)offset :: Void |
        bytes uint8At: offset put: value
    };
    withSelector: #canDecodeValueFromBytes addMethod: {:(UInt8 class)self :: Boolean | true };
    withSelector: #decodeValueFromBytes:atOffset: addMethod: {:(UInt8 class)self :(ByteArray)bytes :(Size)offset :: UInt8 |
        bytes uint8At: offset
    };

    withSelector: #defaultValue addMethod: {:(UInt8 class)self :: UInt8 | 0u8 };
    withSelector: #zero addMethod: {:(UInt8 class)self :: UInt8 | 0u8 };
    withSelector: #one addMethod: {:(UInt8 class)self :: UInt8 | 1u8 }.

Int8 class
    withSelector: #canEncodeValueInBytes addMethod: {:(Int8 class)self :: Boolean | true };
    withSelector: #encodeValue:inBytes:atOffset: addMethod: {:(Int8 class)self :(Int8)value :(ByteArray)bytes :(Size)offset :: Void |
        bytes int8At: offset put: value
    };
    withSelector: #canDecodeValueFromBytes addMethod: {:(Int8 class)self :: Boolean | true };
    withSelector: #decodeValueFromBytes:atOffset: addMethod: {:(Int8 class)self :(ByteArray)bytes :(Size)offset :: Int8 |
        bytes int8At: offset
    };

    withSelector: #defaultValue addMethod: {:(Int8 class)self :: Int8 | 0i8 };
    withSelector: #zero addMethod: {:(Int8 class)self :: Int8 | 0i8 };
    withSelector: #one addMethod: {:(Int8 class)self :: Int8 | 1i8 }.

Char16 class
    withSelector: #canEncodeValueInBytes addMethod: {:(Char16 class)self :: Boolean | true };
    withSelector: #encodeValue:inBytes:atOffset: addMethod: {:(Char16 class)self :(Char16)value :(ByteArray)bytes :(Size)offset :: Void |
        bytes char16At: offset put: value
    };
    withSelector: #canDecodeValueFromBytes addMethod: {:(Char16 class)self :: Boolean | true };
    withSelector: #decodeValueFromBytes:atOffset: addMethod: {:(Char16 class)self :(ByteArray)bytes :(Size)offset :: Char16 |
        bytes char16At: offset
    };

    withSelector: #defaultValue addMethod: {:(Char16 class)self :: Char16 | 0c16 };
    withSelector: #zero addMethod: {:(Char16 class)self :: Char16 | 0c16 };
    withSelector: #one addMethod: {:(Char16 class)self :: Char16 | 1c16 }.

UInt16 class
    withSelector: #canEncodeValueInBytes addMethod: {:(UInt16 class)self :: Boolean | true };
    withSelector: #encodeValue:inBytes:atOffset: addMethod: {:(UInt16 class)self :(UInt16)value :(ByteArray)bytes :(Size)offset :: Void |
        bytes uint16At: offset put: value
    };
    withSelector: #canDecodeValueFromBytes addMethod: {:(UInt16 class)self :: Boolean | true };
    withSelector: #decodeValueFromBytes:atOffset: addMethod: {:(UInt16 class)self :(ByteArray)bytes :(Size)offset :: UInt16 |
        bytes uint16At: offset
    };

    withSelector: #defaultValue addMethod: {:(UInt16 class)self :: UInt16 | 0u16 };
    withSelector: #zero addMethod: {:(UInt16 class)self :: UInt16 | 0u16 };
    withSelector: #one addMethod: {:(UInt16 class)self :: UInt16 | 1u16 }.

Int16 class
    withSelector: #canEncodeValueInBytes addMethod: {:(Int16 class)self :: Boolean | true };
    withSelector: #encodeValue:inBytes:atOffset: addMethod: {:(Int16 class)self :(Int16)value :(ByteArray)bytes :(Size)offset :: Void |
        bytes int16At: offset put: value
    };
    withSelector: #canDecodeValueFromBytes addMethod: {:(Int16 class)self :: Boolean | true };
    withSelector: #decodeValueFromBytes:atOffset: addMethod: {:(Int16 class)self :(ByteArray)bytes :(Size)offset :: Int16 |
        bytes int16At: offset
    };

    withSelector: #defaultValue addMethod: {:(Int16 class)self :: Int16 | 0i16 };
    withSelector: #zero addMethod: {:(Int16 class)self :: Int16 | 0i16 };
    withSelector: #one addMethod: {:(Int16 class)self :: Int16 | 1i16 }.

Char32 class
    withSelector: #canEncodeValueInBytes addMethod: {:(Char32 class)self :: Boolean | true };
    withSelector: #encodeValue:inBytes:atOffset: addMethod: {:(Char32 class)self :(Char32)value :(ByteArray)bytes :(Size)offset :: Void |
        bytes char32At: offset put: value
    };
    withSelector: #canDecodeValueFromBytes addMethod: {:(Char32 class)self :: Boolean | true };
    withSelector: #decodeValueFromBytes:atOffset: addMethod: {:(Char32 class)self :(ByteArray)bytes :(Size)offset :: Char32 |
        bytes char32At: offset
    };

    withSelector: #defaultValue addMethod: {:(Char32 class)self :: Char32 | 0c32 };
    withSelector: #zero addMethod: {:(Char32 class)self :: Char32 | 0c32 };
    withSelector: #one addMethod: {:(Char32 class)self :: Char32 | 1c32 }.

UInt32 class
    withSelector: #canEncodeValueInBytes addMethod: {:(UInt32 class)self :: Boolean | true };
    withSelector: #encodeValue:inBytes:atOffset: addMethod: {:(UInt32 class)self :(UInt32)value :(ByteArray)bytes :(Size)offset :: Void |
        bytes uint32At: offset put: value
    };
    withSelector: #canDecodeValueFromBytes addMethod: {:(UInt32 class)self :: Boolean | true };
    withSelector: #decodeValueFromBytes:atOffset: addMethod: {:(UInt32 class)self :(ByteArray)bytes :(Size)offset :: UInt32 |
        bytes uint32At: offset
    };

    withSelector: #defaultValue addMethod: {:(UInt32 class)self :: UInt32 | 0u32 };
    withSelector: #zero addMethod: {:(UInt32 class)self :: UInt32 | 0u32 };
    withSelector: #one addMethod: {:(UInt32 class)self :: UInt32 | 1u32 }.

Int32 class
    withSelector: #canEncodeValueInBytes addMethod: {:(Int32 class)self :: Boolean | true };
    withSelector: #encodeValue:inBytes:atOffset: addMethod: {:(Int32 class)self :(Int32)value :(ByteArray)bytes :(Size)offset :: Void |
        bytes int32At: offset put: value
    };
    withSelector: #canDecodeValueFromBytes addMethod: {:(Int32 class)self :: Boolean | true };
    withSelector: #decodeValueFromBytes:atOffset: addMethod: {:(Int32 class)self :(ByteArray)bytes :(Size)offset :: Int32 |
        bytes int32At: offset
    };

    withSelector: #defaultValue addMethod: {:(Int32 class)self :: Int32 | 0i32 };
    withSelector: #zero addMethod: {:(Int32 class)self :: Int32 | 0i32 };
    withSelector: #one addMethod: {:(Int32 class)self :: Int32 | 1i32 }.

Int64 class
    withSelector: #canEncodeValueInBytes addMethod: {:(Int64 class)self :: Boolean | true };
    withSelector: #encodeValue:inBytes:atOffset: addMethod: {:(Int64 class)self :(Int64)value :(ByteArray)bytes :(Size)offset :: Void |
        bytes int64At: offset put: value
    };
    withSelector: #canDecodeValueFromBytes addMethod: {:(Int64 class)self :: Boolean | true };
    withSelector: #decodeValueFromBytes:atOffset: addMethod: {:(Int64 class)self :(ByteArray)bytes :(Size)offset :: Int64 |
        bytes int64At: offset
    };

    withSelector: #defaultValue addMethod: {:(Int64 class)self :: Int64 | 0i64 };
    withSelector: #zero addMethod: {:(Int64 class)self :: Int64 | 0i64 };
    withSelector: #one addMethod: {:(Int64 class)self :: Int64 | 1i64 }.

UInt64 class
    withSelector: #canEncodeValueInBytes addMethod: {:(UInt64 class)self :: Boolean | true };
    withSelector: #encodeValue:inBytes:atOffset: addMethod: {:(UInt64 class)self :(UInt64)value :(ByteArray)bytes :(Size)offset :: Void |
        bytes uint64At: offset put: value
    };
    withSelector: #canDecodeValueFromBytes addMethod: {:(UInt64 class)self :: Boolean | true };
    withSelector: #decodeValueFromBytes:atOffset: addMethod: {:(UInt64 class)self :(ByteArray)bytes :(Size)offset :: UInt64 |
        bytes uint64At: offset
    };

    withSelector: #defaultValue addMethod: {:(UInt64 class)self :: UInt64 | 0u64 };
    withSelector: #zero addMethod: {:(UInt64 class)self :: UInt64 | 0u64 };
    withSelector: #one addMethod: {:(UInt64 class)self :: UInt64 | 1u64 }.

Float32 class
    withSelector: #canEncodeValueInBytes addMethod: {:(Float32 class)self :: Boolean | true };
    withSelector: #encodeValue:inBytes:atOffset: addMethod: {:(Float32 class)self :(Float32)value :(ByteArray)bytes :(Size)offset :: Void |
        bytes float32At: offset put: value
    };
    withSelector: #canDecodeValueFromBytes addMethod: {:(Float32 class)self :: Boolean | true };
    withSelector: #decodeValueFromBytes:atOffset: addMethod: {:(Float32 class)self :(ByteArray)bytes :(Size)offset :: Float32 |
        bytes float32At: offset
    };

    withSelector: #defaultValue addMethod: {:(Float32 class)self :: Float32 | 0.0f32 };
    withSelector: #zero addMethod: {:(Float32 class)self :: Float32 | 0.0f32 };
    withSelector: #one addMethod: {:(Float32 class)self :: Float32 | 1.0f32 }.

Float64 class
    withSelector: #canEncodeValueInBytes addMethod: {:(Float64 class)self :: Boolean | true };
    withSelector: #encodeValue:inBytes:atOffset: addMethod: {:(Float64 class)self :(Float64)value :(ByteArray)bytes :(Size)offset :: Void |
        bytes float64At: offset put: value
    };
    withSelector: #canDecodeValueFromBytes addMethod: {:(Float64 class)self :: Boolean | true };
    withSelector: #decodeValueFromBytes:atOffset: addMethod: {:(Float64 class)self :(ByteArray)bytes :(Size)offset :: Float64 |
        bytes float64At: offset
    };

    withSelector: #defaultValue addMethod: {:(Float64 class)self :: Float64 | 0.0 };
    withSelector: #zero addMethod: {:(Float64 class)self :: Float64 | 0.0 };
    withSelector: #one addMethod: {:(Float64 class)self :: Float64 | 1.0 }.

Boolean class
    withSelector: #canEncodeValueInBytes addMethod: {:(Boolean class)self :: Boolean | true };
    withSelector: #encodeValue:inBytes:atOffset: addMethod: {:(Boolean class)self :(Boolean)value :(ByteArray)bytes :(Size)offset :: Void |
        bytes at: offset put: (if: value then: 1u8 else: 0u8)
    };
    withSelector: #canDecodeValueFromBytes addMethod: {:(Boolean class)self :: Boolean | true };
    withSelector: #decodeValueFromBytes:atOffset: addMethod: {:(Boolean class)self :(ByteArray)bytes :(Size)offset :: Boolean |
        (bytes at: offset) ~= 0u8
    };

    withSelector: #defaultValue addMethod: {:(Boolean class)self :: Boolean | false }.

SequenceableCollection
    withSelector: #computeOffsetsOfEncodedElementsInByteStream addMethod: {:(SequenceableCollection)self :: Size |
        let: #offset mutableWith: 0sz.
        self do: {:each :: Void |
            each offsetOfEncodedElementInByteStream: offset.
            offset := offset + each sizeOfByteEncoding
        }.
        offset
    };
    withSelector: #encodedElementsInByteArray addMethod: {:(SequenceableCollection)self :: ByteArray |
        let: #result with: (ByteArray new: self computeOffsetsOfEncodedElementsInByteStream).
        let: #offset mutableWith: 0sz.
        self do: {:each :: Void |
            each encodeInBytes: result atOffset: offset.
            offset := offset + each sizeOfByteEncoding
        }.
        result
    }.

TypeSlot
    withSelector: #requiresBasicInitialization addMethod: {:(TypeSlot)self :: Boolean |
        let: #type with: self type.
        (self initialValueBlock ~~ nil) || ((type ~~ nil) && (type isNullable not))
    } withEagerAnalysis;
    withSelector: #basicInitializeInstance: addMethod: {:(TypeSlot)self :(AnyValue)instance :: Void |
        let: #initialValueBlock with: self initialValueBlock.
        if: initialValueBlock ~~ nil then: {
            let: #initialValue with: initialValueBlock(instance).
            (RawTuple::slotAt:put:)(instance, self index, initialValue)
        } else: {
            let: #type with: self type.
            if: type ~~ nil then: {
                (RawTuple::slotAt:put:)(instance, self index, type defaultValue)
            }.
        }
    } withEagerAnalysis.

Type
    withSelector: #validSlotsWithBasicInitialization addMethod: {:(Type)self :: Array |
        if: self slotsWithBasicInitialization == nil then: {
            let: #supertype with: self supertype.
            let: #result with: ArrayList new.
            if: supertype ~~ nil then: (result addAll: supertype validSlotsWithBasicInitialization).

            self validSlots do: {:(TypeSlot)typeSlot :: Void |
                if: typeSlot requiresBasicInitialization then: {
                    result add: typeSlot
                }.
            }.

            self slotsWithBasicInitialization: result asArray
        }.
        self slotsWithBasicInitialization
    }.

Array validSlotsWithBasicInitialization.
ArrayList validSlotsWithBasicInitialization.

Type
    withSelector: #basicInitializeInstance: addMethod: {:(Type)self :(AnyValue)instance :: Void |
        let: #validSlots with: self validSlotsWithBasicInitialization.
        let: #slotCount with: validSlots size.
        let: #i mutableWith: 0sz.
        while: (i < slotCount) do: (
            (validSlots at: i) basicInitializeInstance: instance
        ) continueWith: (i := i + 1sz)
    } withEagerAnalysis;
    withSelector: #validSubtypeList addMethod: {:(Type)self :: WeakArrayList |
        if: self subtypes == nil then: (self subtypes: WeakArrayList new).
        self subtypes
    };
    withSelector: #addSubtype: addMethod: {:(Type)self :(Type)aSubtype :: Void |
        let: #subtypes with: self validSubtypeList.
        if: (subtypes includes: aSubtype) not then: (subtypes add: aSubtype)
    };
    withSelector: #registerInSuperMetatype addMethod: {:(Type)self :: Void |
        ## By default do nothing
    };
    withSelector: #registerInSupertype addMethod: {:(Type)self :: Void |
        let: #supertype with: self supertype.
        if: supertype ~~ nil then: (supertype addSubtype: self).
        self __type__ registerInSuperMetatype
    };
    withSelector: #subtypesDo: addMethod: {:(Type)self :aBlock :: Void |
        let: #subtypes with: self subtypes.
        if: subtypes ~~ nil then: (subtypes doWithoutTombstones: aBlock)
    };
    withSelector: #withSubtypesDo: addMethod: {:(Type)self :aBlock :: Void |
        aBlock(self).
        self subtypesDo: aBlock.
    };
    withSelector: #allSubtypesDo: addMethod: {:(Type)self :aBlock :: Void |
        self subtypesDo: {:(Type)each :: Void |
            aBlock(each).
            each allSubtypesDo: aBlock
        }
    };
    withSelector: #withAllSubtypesDo: addMethod: {:(Type)self :aBlock :: Void |
        aBlock(self).
        self allSubtypesDo: aBlock
    };

    withSelector: #allSubtypes addMethod: {:(Type)self :: ArrayList |
        let: #result with: ArrayList new.
        self allSubtypesDo: {:(Type)each :: Void |
            result add: each
        }.
        result
    };
    withSelector: #withAllSubtypes addMethod: {:(Type)self :: ArrayList |
        let: #result with: ArrayList new.
        self withAllSubtypesDo: {:(Type)each :: Void |
            result add: each
        }.
        result
    };

    withSelector: #selectorsDo: addMethod: {:(Type)self :aBlock :: Void |
        let: #methodDictionary with: self methodDictionary.
        if: methodDictionary ~~ nil then: (methodDictionary keysAndValuesDo: {:key :value |
            aBlock(key)
        })
    };
    withSelector: #selectors addMethod: {:(Type)self :: Array |
        let: #selectors with: ArrayList new.

        self selectorsDo: {:each :: Void |
            selectors add: each
        }.

        selectors asArray
    };
    withSelector: #allMethodsDo: addMethod: {:(Type)self :aBlock :: Void |
        let: #dictionaryIterationBlock with: {:selector :method :: Void |
            aBlock(method)
        }.

        let: #macroMethodDictionary with: self macroMethodDictionary.
        if: macroMethodDictionary ~~ nil then: (macroMethodDictionary keysAndValuesDo: dictionaryIterationBlock).

        let: #methodDictionary with: self methodDictionary.
        if: methodDictionary ~~ nil then: (methodDictionary keysAndValuesDo: dictionaryIterationBlock).

        let: #fallbackMethodDictionary with: self fallbackMethodDictionary.
        if: fallbackMethodDictionary ~~ nil then: (fallbackMethodDictionary keysAndValuesDo: dictionaryIterationBlock).
    };
    withSelector: #allInstancesDo: addMethod: {:(Type)self :aBlock :: Void |
        let: #instance mutableWith: RawTuple::firstInstanceWithType(self).
        while: instance ~~ nil do: (
            aBlock(instance)
        ) continueWith: (instance := RawTuple::nextInstanceWithSameType(instance))
    };
    withSelector: #allInstances addMethod: {:(Type)self :: Array |
        let: #instance mutableWith: RawTuple::firstInstanceWithType(self).
        let: #result with: ArrayList new.
        while: instance ~~ nil do: (
            result add: instance
        ) continueWith: (instance := RawTuple::nextInstanceWithSameType(instance)).

        result asArray
    };
    withSelector: #allSlotsDo: addMethod: {:(Type)self :(TypeSlot => Void)aBlock :: Void |
        let: #supertype with: self supertype.
        if: supertype ~~ nil then: (supertype allSlotsDo: aBlock).
        self validSlots do: aBlock
    }.

Metatype
    withSelector: #registerInSuperMetatype addMethod: {:(Type)self :: Void |
        self registerInSupertype
    }.

## Construct the subtype links
BootstrapEnv::IntrinsicTypes do: {:(Type)each :: Void |
    each registerInSupertype
}.

TypeSlot
    withSelector: #named:type:flags: addClassMethod: {:(TypeSlot class)self :name :(Type)type :(Size)flags :: self |
        self new
            name: name;
            type: type;
            flags: flags;
            localIndex: 0sz;
            index: 0sz;
            yourself
    };
    withSelector: #named:type:flags:initialValueBlock: addClassMethod: {:(TypeSlot class)self :name :(Type)type :(Size)flags :(AnyValue)initialValueBlock :: self |
        self new
            name: name;
            type: type;
            flags: flags;
            localIndex: 0sz;
            index: 0sz;
            initialValueBlock: initialValueBlock;
            yourself
    };
    withSelector: #named:type: addClassMethod: {:(TypeSlot class)self :name :(Type)type :: self |
        self named: name type: type flags: TypeSlotFlags::None
    };
    withSelector: #named:flags: addClassMethod: {:(TypeSlot class)self :name :(Size)flags :: self |
        self named: name type: AnyValue flags: flags
    };
    withSelector: #named:flags:initialValueBlock: addClassMethod: {:(TypeSlot class)self :name :(Size)flags :(AnyValue)initialValueBlock :: self |
        self named: name type: AnyValue flags: flags initialValueBlock: initialValueBlock
    };
    withSelector: #named: addClassMethod: {:(TypeSlot class)self :name :(Type)type :: self |
        self publicNamed: name type: AnyValue
    };
    withSelector: #publicNamed:type: addClassMethod: {:(TypeSlot class)self :name :(Type)type :: self |
        self named: name type: type flags: TypeSlotFlags::Public
    };
    withSelector: #publicNamed: addClassMethod: {:(TypeSlot class)self :name :(Type)type :: self |
        self publicNamed: name type: AnyValue
    }.

Type
    withSelector: #generatePublicAccessors addMethod: {:(Type)self :: Void |
        let: #baseSlotIndex with: self validSupertypeTotalSlotCount.
        self slots doWithIndex: {:slot :index :: Void |
            let: #slotIndex with: baseSlotIndex + index.
            slot localIndex: index.
            slot index: slotIndex.
            slot generateAccessorsOn: self
        }.
    }.

Metatype
    withSelector: #printOn: addMethod: {:(Metatype)self :(Stream)stream :: Void |
        let: #thisType with: self thisType.
        if: thisType ~~ nil
        then: (stream print: thisType; nextPutAll: " __type__")
        else: (stream nextPutAll: "a "; print: self __type__)
    }.

Metaclass
    withSelector: #thisClass addMethod: {:(Metaclass)self :: Type | self thisType };
    withSelector: #thisClass: addMethod: {:(Metaclass)self :(Type)thisClass :: Void | self thisType: thisClass };
    withSelector: #printOn: addMethod: {:(Metaclass)self :(Stream)stream :: Void |
        let: #thisClass with: self thisClass.
        if: thisClass ~~ nil
        then: (stream print: thisClass; nextPutAll: " class")
        else: (stream nextPutAll: "a "; print: self __type__)
    }.

Type
    withSelector: #refFor: addMethod: {:(Type)self :addressSpace :: ReferenceType |
        ReferenceTypeTemplate(self, addressSpace)
    } makePure;
    withSelector: #ref addMethod: {:(Type)self :: ReferenceType |
        self refFor: AnyValue
    } makePure;
    withSelector: #pointerFor: addMethod: {:(Type)self :addressSpace :: ReferenceType |
        PointerTypeTemplate(self, addressSpace)
    } makePure;
    withSelector: #pointer addMethod: {:(Type)self :addressSpace :: ReferenceType |
        self pointerFor: AnyValue
    } makePure.

ReferenceType
    withSelector: #printOn: addMethod: {:(ReferenceType)self :(Stream)stream :: Void |
        stream print: self baseType.
        if: self addressSpace == nil then: {
            stream nextPutAll: " ref"
        } else: {
            stream nextPutAll: " refFor: "; print: self addressSpace
        }.
    }.

PointerType
    withSelector: #printOn: addMethod: {:(ReferenceType)self :(Stream)stream :: Void |
        stream print: self baseType.
        if: self addressSpace == nil then: {
            stream nextPutAll: " pointer"
        } else: {
            stream nextPutAll: " pointerFor: "; print: self addressSpace
        }.
    }.

DependentFunctionType
    withSelector: #printOn: addMethod: {:(DependentFunctionType)self :(Stream)stream :: Void |
        stream nextPutAll: "DependentFunctionType at "; print: self sourcePosition
    }.

SimpleFunctionType
    withSelector: #printOn: addMethod: {:(SimpleFunctionType)self :(Stream)stream :: Void |
        stream nextPut: '('.
        self argumentTypes doWithIndex: {:(Type)argumentType :(Size)index :: Void |
            index > 0sz ifTrue: (stream nextPutAll: ", ").
            stream print: argumentType
        }.
        self isVariadic ifTrue: {
            self argumentTypes isNotEmpty
                ifTrue: (stream nextPutAll: ", ...")
                ifFalse: (stream nextPutAll: "...")
        }.
        stream nextPutAll: ") => "; print: self resultType.
    }.

## Primitive values printString and primitive function types
(
    UInt8,Int8,Char8,
    UInt16,Int16,Char16,
    UInt32,Int32,Char32,
    UInt64,Int64,
    Float32,Float64,
    Integer
) do: {:SelfType :: Void |
    let: #unaryFunctionType with: SelfType => SelfType.
    let: #binaryFunctionType with: (SelfType, SelfType) => SelfType.
    let: #equalityFunctionType with: (SelfType, AnyValue) => Boolean.
    let: #binaryComparisonFunctionType with: (SelfType, SelfType) => Boolean.

    ## Unary selectors
    #(
        negated bitInvert
    ) do: {:selector :: Void |
        let: #method with: (SelfType >> selector).
        if: method ~~ nil then: (method __type__: unaryFunctionType)
    }.

    ## Binary selectors.
    #(
        + - * / %
        | & ^ << >>
    ) do: {:selector :: Void |
        let: #method with: (SelfType >> selector).
        if: method ~~ nil then: (method __type__: binaryFunctionType)
    }.

    ## Equality
    #(
        = ~=
    ) do: {:selector :: Void |
        (SelfType >> selector) __type__: equalityFunctionType
    }.

    ## Comparisons
    #(
        < <= >= >
    ) do: {:selector :: Void |
        (SelfType >> selector) __type__: binaryComparisonFunctionType
    }.

    SelfType
        withSelector: #printOn: addMethod: {:(SelfType)self :(Stream)stream :: Void |
            stream nextPutAll: self printString
        } makeFinal recompileAndOptimize.

    let: #setConversionTypeFunction with: {:method :targetType :: Void |
        if: method ~~ nil then: (method __type__: (SelfType => targetType))
    }.

    setConversionTypeFunction((SelfType >> #asChar8), Char8).
    setConversionTypeFunction((SelfType >> #asUInt8), UInt8).
    setConversionTypeFunction((SelfType >> #asInt8), Int8).

    setConversionTypeFunction((SelfType >> #asChar16), Char16).
    setConversionTypeFunction((SelfType >> #asUInt16), UInt16).
    setConversionTypeFunction((SelfType >> #asInt16), Int16).

    setConversionTypeFunction((SelfType >> #asChar32), Char32).
    setConversionTypeFunction((SelfType >> #asUInt32), UInt32).
    setConversionTypeFunction((SelfType >> #asInt32), Int32).

    setConversionTypeFunction((SelfType >> #asUInt64), UInt64).
    setConversionTypeFunction((SelfType >> #asInt64), Int64).

    setConversionTypeFunction((SelfType >> #asFloat32), Float32).
    setConversionTypeFunction((SelfType >> #asFloat64), Float64).
}.

(Integer >> #i8) __type__: (Integer => Int8).
(Integer >> #u8) __type__: (Integer => UInt8).
(Integer >> #c8) __type__: (Integer => Char8).
(Integer >> #i16) __type__: (Integer => Int16).
(Integer >> #u16) __type__: (Integer => UInt16).
(Integer >> #c16) __type__: (Integer => Char16).
(Integer >> #i32) __type__: (Integer => Int32).
(Integer >> #u32) __type__: (Integer => UInt32).
(Integer >> #c32) __type__: (Integer => Char32).
(Integer >> #i64) __type__: (Integer => Int64).
(Integer >> #u64) __type__: (Integer => UInt64).
##(Integer >> #f32) __type__: (Integer => Float32).
##(Integer >> #f64) __type__: (Integer => Float64).

(Float32 >> #sqrt) __type__: (Float32 => Float32).
(Float32 >> #asIEEEFloat32Encoding) __type__: (Float32 => UInt32).
(UInt32 >> #asIEEEFloat32Decoded) __type__: (UInt32 => Float32).

(Float64 >> #sqrt) __type__: (Float32 => Float32).
(Float64 >> #asIEEEFloat64Encoding) __type__: (Float64 => UInt64).
(UInt64 >> #asIEEEFloat64Decoded) __type__: (UInt64 => Float64).

Function
    withSelector: #timeToRunInNanoseconds addMethod: {:(Function)self :: Int64 |
        let: #startTime with: Time::Timestamp::nanosecondsNow().
        self().
        let: #endTime with: Time::Timestamp::nanosecondsNow().
        endTime - startTime
    };
    withSelector: #timeToRunInMicroseconds addMethod: {:(Function)self :: Int64 |
        let: #startTime with: Time::Timestamp::microsecondsNow().
        self().
        let: #endTime with: Time::Timestamp::microsecondsNow().
        endTime - startTime
    };
    withSelector: #printTimeToRunInMicrosecondsWithTitle: addMethod: {:(Function)self :(String)title |
        let: #startTime with: Time::Timestamp::microsecondsNow().
        let: #result with: self().
        let: #endTime with: Time::Timestamp::microsecondsNow().
        printLine(title, " ", (endTime - startTime) asFloat32 * 0.001f32,  " ms").
        result
    }.

SourcePosition
    withSelector: #printOn: addMethod: {:(SourcePosition)self :(Stream)stream :: Void |
        let: #sourceCode with: self sourceCode.

        stream
            nextPutAll: (sourceCode directory FileSystem::joinPath: sourceCode name);
            nextPut: ':';
            print: self startLine;
            nextPut: '.';
            print: self startColumn;
            nextPut: '-';
            print: self endLine;
            nextPut: '.';
            print: self endColumn
    }.

GeneratedSymbol
    withSelector: #printOn: addMethod: {:(GeneratedSymbol)self :(Stream)stream :: Void |
        stream print: self class; nextPut: '('; print: self value; nextPut: ')'
    };
    withSelector: #fullPrintOn: addMethod: {:(GeneratedSymbol)self :(Stream)stream :: Void |
        stream print: self class; nextPut: '('; print: self value; nextPut: ')'
    }.

Metaclass class
    withSelector: #getOrCreateDependentApplicationValueForNode: addMethod: {:(Metaclass class)self :(ASTNode)astNode |
        Class
    }.

Class
    withSelector: #subclassWithClassSlots: addMethod: {:(Class)self :(Array)classSlots :: Class |
        let: #metaclass with: Metaclass basicNew.
        let: #metaclassSuper with: self class.
        metaclass
            flags: TypeFlags::MetatypeRequiredFlags;
            supertype: metaclassSuper;
            slots: classSlots;
            totalSlotCount: metaclassSuper validTotalSlotCount + classSlots size;
            registerSlotsInDictionary;
            generatePublicAccessors.
        
        let: #class with: metaclass basicNew.
        class
            flags: TypeFlags::ClassDefaultFlags;
            supertype: self;
            slots: ();
            totalSlotCount: nil;
            registerInSupertype.
        metaclass thisClass: class.
        class
    };
    withSelector: #subclassWithClassSlots:slots: addMethod: {:(Class)self :(Array)classSlots :(Array)instanceSlots :: Class |
        (self subclassWithClassSlots: classSlots)
            slots: instanceSlots;
            totalSlotCount: self validTotalSlotCount + instanceSlots size;
            registerSlotsInDictionary;
            generatePublicAccessors;
            yourself
    };
    withSelector: #subclass:classSlots:slots: addMethod: {:(Class)self :(StringSymbol)name :(Array)classSlots :(Array)instanceSlots :: Class |
        let: #class with: (self subclassWithClassSlots: classSlots slots: instanceSlots).
        class name: name.
        class
    };
    withSelector: #subclass:slots: addMethod: {:(Class)self :(StringSymbol)name :(Array)instanceSlots :: Class |
        self subclass: name classSlots: () slots: instanceSlots
    }.

Size
    withSelector: #min: addMethod: {:(Size)a :(Size)b :: Size |
        if: a <= b then: a else: b
    };
    withSelector: #max: addMethod: {:(Size)a :(Size)b :: Size |
        if: a >= b then: a else: b
    };
    withSelector: #alignedTo: addMethod: {:(Size)value :(Size)alignment :: Size |
        ((value + alignment) - 1sz) & alignment negated.
    }.

TypeSlot
    withSelector: #size addMethod: {:(TypeSlot)self :: Size |
        self type valueSize
    };
    withSelector: #alignment addMethod: {:(TypeSlot)self :: Size |
        self type valueAlignment
    }.

Type
    withSelector: #ensureLayoutIsComputed addMethod: {:(Type)self :: Void |
        if: self instanceAlignment = 0sz then: (self computeLayout)
    };
    withSelector: #computeLayout addMethod: {:(Type)self :: Void |
        self instanceSize: 0sz.
        self instanceAlignment: 1sz.

        let: #supertype with: self supertype.
        if: supertype ~~ nil then: {
            self instanceSize: supertype validInstanceSize.
            self instanceAlignment: (supertype validInstanceAlignment max: 1sz).
        }.

        self validSlots do: {:(TypeSlot)eachSlot :: Void |
            let: #slotSize with: eachSlot size.
            let: #slotAlignment with: eachSlot alignment.

            let: #slotOffset with: (self instanceSize alignedTo: slotAlignment).
            eachSlot offset: slotOffset.

            self instanceAlignment: (self instanceAlignment max: slotAlignment).
            self instanceSize: slotOffset + slotSize.
        }.

        self instanceSize: (self instanceSize alignedTo: self instanceAlignment).
    };
    withSelector: #validInstanceSize addMethod: {:(Type)self :: Size |
        if: self instanceAlignment = 0sz then: (self ensureLayoutIsComputed).
        self instanceSize
    };
    withSelector: #validInstanceAlignment addMethod: {:(Type)self :: Size |
        if: self instanceAlignment = 0sz then: (self ensureLayoutIsComputed).
        self instanceAlignment
    };
    withSelector: #valueAlignment addMethod: {:(Type)self :: Size |
        UIntPointer instanceAlignment
    };
    withSelector: #valueSize addMethod: {:(Type)self :: Size |
        UIntPointer instanceSize
    };
    withSelector: #alignedValueSize addMethod: {:(Type)self :: Size |
        self valueSize alignedTo: self valueAlignment
    }.

ValueType
    withSelector: #valueSize addMethod: {:(ValueType)self :: Size |
        self validInstanceSize
    };
    withSelector: #valueAlignment addMethod: {:(ValueType)self :: Size |
        self validInstanceAlignment
    }.

Environment
    withSelector: #setSymbol:value: addMethod: {:(Environment)self :(Symbol)selector :value :: value __type__ | self setSymbol: selector bindingWithValue: value. value };
    withSelector: #setPublicSymbol:value: addMethod: {:(Environment)self :(Symbol)selector :value :: value __type__ | self setSymbol: selector bindingWithValue: value. value };
    withSelector: #withSelector:addMethod: addMethod: {:(Environment)self :(Symbol)selector :method :: Void | self setSymbol: selector bindingWithValue: method }.
