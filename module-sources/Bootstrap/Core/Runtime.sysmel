## We use these for the different implementations of Size
error __type__: (SimpleFunctionTypeTemplate((String,), false, Unwinds)).
    
{
    let: #binaryFunctionType with: SimpleFunctionTypeTemplate((UInt32, UInt32), false, UInt32).
    let: #equalityComparisonFunctionType with: SimpleFunctionTypeTemplate((UInt32, AnyValue), false, Boolean).
    let: #comparisonFunctionType with: SimpleFunctionTypeTemplate((UInt32, UInt32), false, Boolean).

    UInt32::+ __type__: binaryFunctionType.
    UInt32::- __type__: binaryFunctionType.
    UInt32::* __type__: binaryFunctionType.
    UInt32::/ __type__: binaryFunctionType.
    UInt32::% __type__: binaryFunctionType.

    UInt32::& __type__: binaryFunctionType.
    UInt32::| __type__: binaryFunctionType.
    UInt32::<< __type__: binaryFunctionType.
    UInt32::>> __type__: binaryFunctionType.

    UInt32::= __type__: equalityComparisonFunctionType.
    UInt32::~= __type__: equalityComparisonFunctionType.
    UInt32::< __type__: comparisonFunctionType.
    UInt32::<= __type__: comparisonFunctionType.
    UInt32::>= __type__: comparisonFunctionType.
    UInt32::> __type__: comparisonFunctionType.
}.

{
    let: #binaryFunctionType with: SimpleFunctionTypeTemplate((UInt64, UInt64), false, UInt64).
    let: #equalityComparisonFunctionType with: SimpleFunctionTypeTemplate((UInt64, AnyValue), false, Boolean).
    let: #comparisonFunctionType with: SimpleFunctionTypeTemplate((UInt64, UInt64), false, Boolean).

    UInt64::+ __type__: binaryFunctionType.
    UInt64::- __type__: binaryFunctionType.
    UInt64::* __type__: binaryFunctionType.
    UInt64::/ __type__: binaryFunctionType.
    UInt64::% __type__: binaryFunctionType.

    UInt64::& __type__: binaryFunctionType.
    UInt64::| __type__: binaryFunctionType.
    UInt64::<< __type__: binaryFunctionType.
    UInt64::>> __type__: binaryFunctionType.

    UInt64::= __type__: equalityComparisonFunctionType.
    UInt64::~= __type__: equalityComparisonFunctionType.
    UInt64::< __type__: comparisonFunctionType.
    UInt64::<= __type__: comparisonFunctionType.
    UInt64::>= __type__: comparisonFunctionType.
    UInt64::> __type__: comparisonFunctionType.
}.

Function
    withSelector: #addFlags: addMethod: {:(Function)self :(Bitflags)flag :: Void |
        self flags: self flags | flag
    };
    withSelector: #makeMacro addMethod: {:(Function)self :: Function |
        self addFlags: FunctionFlags::Macro.
        self
    };
    withSelector: #makePure addMethod: {:(Function)self :: Function |
        self addFlags: FunctionFlags::Pure.
        self
    };
    withSelector: #makeFinal addMethod: {:(Function)self :: Function |
        self addFlags: FunctionFlags::Final.
        self
    };
    withSelector: #makeVirtual addMethod: {:(Function)self :: Function |
        self addFlags: FunctionFlags::Virtual.
        self
    };
    withSelector: #makeAbstract addMethod: {:(Function)self :: Function |
        self addFlags: FunctionFlags::Abstract.
        self
    };
    withSelector: #makeOverride addMethod: {:(Function)self :: Function |
        self addFlags: FunctionFlags::Override.
        self
    };
    withSelector: #makeStatic addMethod: {:(Function)self :: Function |
        self addFlags: FunctionFlags::Static.
        self
    };

    withSelector: #makeMemoized addMethod: {:(Function)self :: Function |
        self addFlags: FunctionFlags::Memoized.
        self
    };
    withSelector: #makeTemplate addMethod: {:(Function)self :: Function |
        self addFlags: FunctionFlags::Template.
        self
    }.

Type
    withSelector: #=> addMethod: {:(Type)self :(Type)resultType :: SimpleFunctionType |
        SimpleFunctionTypeTemplate((self,), false, resultType)
    } makePure makeFinal.

ValueBox
    withSelector: #loadAtOffset:withType: addMethod: {:(ValueBox)self :(IntPointer)offset :(Type)valueType :: valueType |
        (RawTuple::slotAt:)(self, 0sz)
    } makeFinal;
    withSelector: #store:atOffset:withType: addMethod: {:(ValueBox)self :value :(IntPointer)offset :(Type)valueType :: Void |
        RawTuple::slotAt:put:(self, 0sz, value).
        void
    } makeFinal.

AnyValue
    withSelector: #initialize addMethod: {:(AnyValue)self :: Void | };
    withSelector: #yourself addMethod: {:(AnyValue)self :: self __type__ |
        <primitive: #yourself>
        self
    } makePure makeFinal;

    withSelector: #postCopy addMethod: {:(AnyValue)self :: Void | };
    withSelector: #shallowCopy addMethod: {:(AnyValue)self :: self __type__ | RawTuple::shallowCopy(self) } makeFinal;
    withSelector: #copy addMethod: {:(AnyValue)self :: self __type__ | self shallowCopy postCopy; yourself };

    withSelector: #doesNotUnderstand: addMethod: {:(AnyValue)self :(Message)message |
        error("doesNotUnderstand: " -- message selector printString)
    };

    withSelector: #isNil addMethod: {:(AnyValue)self :: Boolean | self == nil } makePure makeFinal;
    withSelector: #isNotNil addMethod: {:(AnyValue)self :: Boolean | self ~~ nil } makePure makeFinal;

    withSelector: #= addMethod: {:(AnyValue)self :other :: Boolean | self == other } makePure;
    withSelector: #~= addMethod: {:(AnyValue)self :other :: Boolean | self ~~ other } makePure.

Object
    withSelector: #class addMethod: {:(Object)self :: self __type__ __type__ | self __type__ } makePure makeFinal;
    withSelector: #species addMethod: {:(Object)self :: Class | self class };

    withSelector: #error: addMethod: {:(Object)self :(String)errorMessage :: Unwinds | error(errorMessage) };
    withSelector: #assert: addMethod: {:(Object)self :(Boolean)condition :: Void |
        if: condition then: void else: error("Assertion failure.")
    };
    withSelector: #subclassResponsibility addMethod: {:(Object)self :: Unwinds | self error: self __type__ printString -- " Subclass responsibility." };
    withSelector: #doesNotUnderstand: addMethod: {:(AnyValue)self :(Message)message |
        error((self class printString -- " doesNotUnderstand: ") -- message selector printString)
    }.

Type
    withSelector: #isSubtypeOf: addMethod: {:(Type)self :(Type)expectedParent :: Boolean |
        if: self == expectedParent
        then: true
        else: {
            let: #supertype with: self supertype.
            if: supertype ~~ nil
                then: (supertype isSubtypeOf: expectedParent )
                else: false
        }
    } makePure.

AnyValue
    withSelector: #isKindOf: addMethod: {:(AnyValue)self :(Type)expectedType :: Boolean |
        self __type__ isSubtypeOf: expectedType
    } makePure makeFinal.

Untyped __type__
    withSelector: #coerceASTNode:into:withEnvironment: addMethod: {:(Type)self :(ASTNode)astNode :(Type)targetType :(AnalysisAndEvaluationEnvironment)environment :: ASTNode |
        ## TODO: Add a downcast node.
        astNode
    }.
    
Type
    withSelector: #hasFlag: addMethod: {:(Type)self :(Bitflags)flag :: Boolean |
        (self flags & flag) ~= 0bflgs
    };
    withSelector: #isDynamic addMethod: {:(Type)self :: Boolean |
        self hasFlag: TypeFlags::Dynamic.
    };

    withSelector: #coerceASTNode:into:withEnvironment: addMethod: {:(Type)self :(ASTNode)astNode :(Type)targetType :(AnalysisAndEvaluationEnvironment)environment :: ASTNode |
        if: (self isSubtypeOf: targetType)
        then: astNode
        else: {
            if: self isDynamic then: astNode else: {
                error((("Cannot coerce node from type " -- self printString) -- " into type ") -- targetType printString)
            }
        }
    };
    withSelector: #coerceASTNode:withEnvironment: addMethod: {:(Type)self :(ASTNode)astNode :(AnalysisAndEvaluationEnvironment)environment :: ASTNode |
        let: #sourceType with: astNode analyzedType.
        if: (if: sourceType ~~ nil then: sourceType ~= self else: false)
        then: (sourceType coerceASTNode: astNode into: self withEnvironment: environment)
        else: astNode
    };
    withSelector: #isReferenceType addMethod: {:(Type)self :: Boolean | false } makePure;

    withSelector: #addFlags: addMethod: {:(Type)self :(Bitflags)flag :: Void |
        self flags: self flags | flag
    };

    withSelector: #makeNullable addMethod: {:(Type)self :: Type |
        self addFlags: TypeFlags::Nullable.
        self
    };
    withSelector: #isNullable addMethod: {:(Type)self :: Boolean |
        self hasFlag: TypeFlags::Nullable.
    };

    withSelector: #makeBytes addMethod: {:(Type)self :: Type |
        self addFlags: TypeFlags::Bytes.
        self
    };
    withSelector: #isBytes addMethod: {:(Type)self :: Boolean |
        self hasFlag: TypeFlags::Bytes.
    };

    withSelector: #makeWeak addMethod: {:(Type)self :: Type |
        self addFlags: TypeFlags::Weak.
        self
    };
    withSelector: #isWeak addMethod: {:(Type)self :: Boolean |
        self hasFlag: TypeFlags::Weak.
    };

    withSelector: #makeImmediate addMethod: {:(Type)self :: Type |
        self addFlags: TypeFlags::Immediate.
        self
    };
    withSelector: #isImmediate addMethod: {:(Type)self :: Boolean |
        self hasFlag: TypeFlags::Immediate.
    };

    withSelector: #makeFinal addMethod: {:(Type)self :: Type |
        self addFlags: TypeFlags::Final.
        self
    };
    withSelector: #isFinal addMethod: {:(Type)self :: Boolean |
        self hasFlag: TypeFlags::Final.
    };

    withSelector: #makeAbstract addMethod: {:(Type)self :: Type |
        self addFlags: TypeFlags::Abstract.
        self
    };
    withSelector: #isAbstract addMethod: {:(Type)self :: Boolean |
        self hasFlag: TypeFlags::Abstract.
    };

    withSelector: #addTypeSlot: addMethod: {:(Type)self :(TypeSlot)extraSlot :: Void |
        if: self totalSlotCount ~~ nil then: (self error: "Cannot add type slot when the total slot count has already been computed").
        if: self pendingSlots == nil then: (self pendingSlots: ArrayList new).
        self pendingSlots add: extraSlot
    };
    withSelector: #validSlots addMethod: {:(Type)self |
        let: #pendingSlots with: self pendingSlots.
        if: pendingSlots ~~ nil then: {

            let: #pendingSlotsArray with: pendingSlots asArray.
            let: #baseIndex with: self validSupertypeTotalSlotCount + self slots size.

            pendingSlotsArray doWithIndex: {:pendingSlot :pendingSlotIndex :: Void |
                let: #slotIndex with: baseIndex + pendingSlotIndex.
                pendingSlot generateAccessorsOn: self withIndex: slotIndex
            }.

            self slots: self slots -- pendingSlotsArray.
            self pendingSlots: nil
        }.
        
        self slots
    };
    withSelector: #validSupertypeTotalSlotCount addMethod: {:(Type)self :: Size |
        let: #supertype with: self supertype.
        if: supertype == nil then: 0sz else: supertype validTotalSlotCount.
    };
    withSelector: #validTotalSlotCount addMethod: {:(Type)self :: Size |
        let: #totalSlotCount with: self totalSlotCount.
        if: totalSlotCount == nil then: {
            self totalSlotCount: self validSupertypeTotalSlotCount + self validSlots size.
            self totalSlotCount
        } else: totalSlotCount
    };
    withSelector: #basicAllocate addMethod: {:(Type)self :: self |
        let: #result with: (if: self isBytes
            then: RawTuple::byteNew(0sz)
            else: RawTuple::new(self validTotalSlotCount)).
        (RawTuple::type:)(result, self).
        if: self isWeak then: RawTuple::markWeak(result).
        result
    };
    withSelector: #basicAllocate: addMethod: {:(Type)self :(Size)variableSize :: self |
        let: #result with: (if: self isBytes
            then: RawTuple::byteNew(variableSize)
            else: RawTuple::new(self validTotalSlotCount + variableSize)).
        (RawTuple::type:)(result, self).
        result
    };
    withSelector: #basicNew addMethod: {:(Type)self :: self |
        self basicAllocate
    };
    withSelector: #basicNew: addMethod: {:(Type)self :(Size)variableSlotCount :: self |
        self basicAllocate: variableSlotCount
    };
    withSelector: #new addMethod: {:(Type)self :: self |
        self basicNew initialize; yourself
    };
    withSelector: #>> addMethod: {:(Type)self :selector |
        let: #methodDictionary with: self methodDictionary.
        if: methodDictionary ~~ nil
            then: (methodDictionary atOrNil: selector)
            else: nil
    };
    withSelector: #lookupSelector: addMethod: {:(Type)self :selector |
        let: #method with: self >> selector.
        if: method ~~ nil
        then: method
        else: {
            let: #supertype with: self supertype.
            if: supertype ~~ nil
                then: (supertype lookupSelector: selector)
                else: (nil)
        }
    }.

ControlFlowEscapeType class
    withSelector: #coerceASTNode:into:withEnvironment: addMethod: {:(Type)self :(ASTNode)astNode :(Type)targetType :(AnalysisAndEvaluationEnvironment)environment :: ASTNode |
        astNode
    }.

UndefinedObject class
    withSelector: #coerceASTNode:into:withEnvironment: addMethod: {:(Type)self :(ASTNode)astNode :(Type)targetType :(AnalysisAndEvaluationEnvironment)environment :: ASTNode |
        if: targetType isNullable
        then: astNode
        else: error("Cannot coerce nil into non-nullable type " -- targetType printString)
    }.

ReferenceType
    withSelector: #isReferenceType addMethod: {:(Type)self :: Boolean | true } makePure;
    withSelector: #coerceASTNode:into:withEnvironment: addMethod: {:(Type)self :(ASTNode)astNode :(Type)targetType :(AnalysisAndEvaluationEnvironment)environment :: ASTNode |

        if: targetType isReferenceType then: {
            error("TODO: Implement coercion between two reference types.")
        } else: {
            let: #sourcePosition with: astNode sourcePosition.
            let: #analyzerToken with: environment analyzerToken.
            let: #loadValueFunction with: self loadValueFunction.
            let: #baseType with: self baseType.

            targetType
                coerceASTNode: (ASTFunctionApplicationNode new
                    sourcePosition: astNode sourcePosition;
                    functionExpression: (ASTLiteralNode new
                        value: loadValueFunction;
                        analyzedType: loadValueFunction __type__;
                        analyzerToken: analyzerToken;
                        yourself);
                    arguments: (astNode,);
                    analyzedType: self baseType;
                    analyzerToken: analyzerToken;
                    yourself)
                withEnvironment: environment
        }.
    }.

AnyValue
    withSelector: #isNil addMacroMethod: {:(MacroContext)macroContext :(ASTNode)self :: ASTMessageSendNode |
        ASTMessageSendNode new
            sourcePosition: macroContext sourcePosition;
            receiver: self;
            selector: (ASTLiteralNode new
                sourcePosition: macroContext sourcePosition;
                value: #==;
                yourself);
            arguments: (ASTLiteralNode new
                sourcePosition: macroContext sourcePosition;
                value: nil;
                yourself,);
            yourself
    } makeMacro;
    withSelector: #isNotNil addMacroMethod: {:(MacroContext)macroContext :(ASTNode)self :: ASTMessageSendNode |
        ASTMessageSendNode new
            sourcePosition: macroContext sourcePosition;
            receiver: self;
            selector: (ASTLiteralNode new
                sourcePosition: macroContext sourcePosition;
                value: #~~;
                yourself);
            arguments: (ASTLiteralNode new
                sourcePosition: macroContext sourcePosition;
                value: nil;
                yourself,);
            yourself
    } makeMacro;
    withSelector: #&& addMacroMethod: {:(MacroContext)macroContext :(ASTNode)self :(ASTNode)other :: ASTIfNode |
        ASTIfNode new
            sourcePosition: macroContext sourcePosition;
            conditionExpression: self;
            trueExpression: other;
            falseExpression: (ASTLiteralNode new
                sourcePosition: macroContext sourcePosition;
                value: false;
                yourself);
            yourself
    } makeMacro;
    withSelector: #|| addMacroMethod: {:(MacroContext)macroContext :(ASTNode)self :(ASTNode)other :: ASTIfNode |
        ASTIfNode new
            sourcePosition: macroContext sourcePosition;
            conditionExpression: self;
            trueExpression: (ASTLiteralNode new
                sourcePosition: macroContext sourcePosition;
                value: true;
                yourself);
            falseExpression: other;
            yourself
    } makeMacro;

    withSelector: #ifTrue: addMacroMethod: {:(MacroContext)macroContext :(ASTNode)self :(ASTNode)trueExpression :: ASTIfNode |
        ASTIfNode new
            sourcePosition: macroContext sourcePosition;
            conditionExpression: self;
            trueExpression: trueExpression;
            yourself
    } makeMacro;
    withSelector: #ifFalse: addMacroMethod: {:(MacroContext)macroContext :(ASTNode)self :(ASTNode)falseExpression :: ASTIfNode |
        ASTIfNode new
            sourcePosition: macroContext sourcePosition;
            conditionExpression: self;
            falseExpression: falseExpression;
            yourself
    } makeMacro;
    withSelector: #ifTrue:ifFalse: addMacroMethod: {:(MacroContext)macroContext :(ASTNode)self :(ASTNode)trueExpression :(ASTNode)falseExpression :: ASTIfNode |
        ASTIfNode new
            sourcePosition: macroContext sourcePosition;
            conditionExpression: self;
            trueExpression: trueExpression;
            falseExpression: falseExpression;
            yourself
    } makeMacro;
    withSelector: #ifFalse:ifTrue: addMacroMethod: {:(MacroContext)macroContext :(ASTNode)self :(ASTNode)falseExpression :(ASTNode)trueExpression :: ASTIfNode |
        ASTIfNode new
            sourcePosition: macroContext sourcePosition;
            conditionExpression: self;
            trueExpression: trueExpression;
            falseExpression: falseExpression;
            yourself
    } makeMacro;
    withSelector: #perform: addMacroMethod: {:(MacroContext)macroContext :(ASTNode)self :(ASTNode)selector :: ASTMessageSendNode |
        ASTMessageSendNode new
            sourcePosition: macroContext sourcePosition;
            receiver: self;
            selector: selector;
            arguments: Array new;
            yourself
    } makeMacro;
    withSelector: #perform:with: addMacroMethod: {:(MacroContext)macroContext :(ASTNode)self :(ASTNode)selector :(ASTNode)argument :: ASTMessageSendNode |
        ASTMessageSendNode new
            sourcePosition: macroContext sourcePosition;
            receiver: self;
            selector: selector;
            arguments: (Array with: argument);
            yourself
    } makeMacro;
    withSelector: #perform:with:with: addMacroMethod: {:(MacroContext)macroContext :(ASTNode)self :(ASTNode)selector :(ASTNode)firstArgument :(ASTNode)secondArgument :: ASTMessageSendNode |
        ASTMessageSendNode new
            sourcePosition: macroContext sourcePosition;
            receiver: self;
            selector: selector;
            arguments: (Array with: firstArgument with: secondArgument);
            yourself
    } makeMacro;
    withSelector: #perform:with:with:with: addMacroMethod: {:(MacroContext)macroContext :(ASTNode)self :(ASTNode)selector :(ASTNode)firstArgument :(ASTNode)secondArgument :(ASTNode)thirdArgument :: ASTMessageSendNode |
        ASTMessageSendNode new
            sourcePosition: macroContext sourcePosition;
            receiver: self;
            selector: selector;
            arguments: (Array with: firstArgument with: secondArgument with: thirdArgument);
            yourself
    } makeMacro;
    withSelector: #perform:with:with:with:with: addMacroMethod: {:(MacroContext)macroContext :(ASTNode)self :(ASTNode)selector :(ASTNode)firstArgument :(ASTNode)secondArgument :(ASTNode)thirdArgument :(ASTNode)fourthArgument :: ASTMessageSendNode |
        ASTMessageSendNode new
            sourcePosition: macroContext sourcePosition;
            receiver: self;
            selector: selector;
            arguments: (Array with: firstArgument with: secondArgument with: thirdArgument with: fourthArgument);
            yourself
    } makeMacro.

ASTNode
    withSelector: #postCopy addMethod: {:(ASTNode)self :: Void |
        (object: self withLookupStartingFrom: ASTNode supertype) postCopy.
        self analyzerToken: nil.
    }.

AnyReference
    withSelector: #doesNotUnderstand: addMacroMethod: {:(MacroContext)macroContext :(ASTNode)self :(ASTMessageSendNode)messageSend :: ASTNode |
        messageSend copy
            receiver: (ASTFunctionApplicationNode new
                sourcePosition: self sourcePosition;
                functionExpression: (ASTLiteralNode new
                    sourcePosition: self sourcePosition;
                    value: self analyzedType loadValueFunction;
                    yourself);
                arguments: (self,);
                yourself);
            yourself
    } makeMacro.

Stream
    withSelector: #print: addMethod: {:(Stream)self :value :: Void | 
        value printOn: self
    };
    withSelector: #fullPrint: addMethod: {:(Stream)self :value :: Void | 
        value fullPrintOn: self
    };
    withSelector: #cr addMethod: {:(Stream)self :: Void | 
        self nextPut: '\r'
    };
    withSelector: #lf addMethod: {:(Stream)self :: Void | 
        self nextPut: '\n'
    };
    withSelector: #nl addMethod: {:(Stream)self :: Void | 
        self nextPut: '\n'
    };
    withSelector: #tab addMethod: {:(Stream)self :: Void | 
        self nextPut: '\t'
    };
    withSelector: #space addMethod: {:(Stream)self :: Void | 
        self nextPut: ' '
    }.

AnyValue
    withSelector: #printString addMethod: {:(AnyValue)self :: String | 
        let: #stream with: StringStream new.
        self printOn: stream.
        stream asString.
    };
    withSelector: #printOn: addMethod: {:(AnyValue)self :(Stream)stream :: Void |
        stream nextPutAll: "a " ; print: self __type__
    };
    withSelector: #fullPrintString addMethod: {:(AnyValue)self :: String | 
        let: #stream with: StringStream new.
        self fullPrintOn: stream.
        stream asString.
    };
    withSelector: #fullPrintOn: addMethod: {:(AnyValue)self :(Stream)stream :: Void |
        self printOn: stream
    }.

Type
    withSelector: #printOn: addMethod: {:(Type)self :(Stream)stream :: Void |
        let: #name with: self name.
        if: name ~~ nil
            then: (stream nextPutAll: name)
            else: (stream nextPutAll: "a Type")
    }.

Void class
    withSelector: #coerceValue: addMethod: {:(Void class)self :value :: Void | void }.
Void
    withSelector: #printString addMethod: {:(Void)self :: String | "void" };
    withSelector: #printOn: addMethod: {:(Void)self :(Stream)stream :: Void | stream nextPutAll: "void" }.

UndefinedObject
    withSelector: #printString addMethod: {:(UndefinedObject)self :: String | "nil" };
    withSelector: #printOn: addMethod: {:(UndefinedObject)self :(Stream)stream :: Void | stream nextPutAll: "nil" }.

False
    withSelector: #printString addMethod: {:(False)self :: String | "false" };
    withSelector: #printOn: addMethod: {:(False)self :(Stream)stream :: Void | stream nextPutAll: "false" }.

True
    withSelector: #printString addMethod: {:(True)self :: String | "true" };
    withSelector: #printOn: addMethod: {:(True)self :(Stream)stream :: Void | stream nextPutAll: "true" }.

String
    withSelector: #printOn: addMethod: {:(String)self :(Stream)stream :: Void |
        ## TODO: Implement this part properly.
        stream nextPut: '"'.
        stream nextPutAll: self.
        stream nextPut: '"'.
    }.

StringSymbol
    withSelector: #printOn: addMethod: {:(StringSymbol)self :(Stream)stream :: Void |
        ## TODO: Implement this part properly.
        stream nextPut: '#'; nextPutAll: self
    };
    withSelector: #fullPrintOn: addMethod: {:(StringSymbol)self :(Stream)stream :: Void |
        ## TODO: Implement this part properly.
        stream nextPut: '#'; nextPutAll: self
    }.


Class
    withSelector: #withSelector:addClassMethod: addMethod: {:(Class)self :selector :method :: Void |
        self class withSelector: selector addMethod: method
    }.

FunctionDefinition
    withSelector: #hasPragmaNamed: addMethod: {:(FunctionDefinition)self :selector :: Boolean |
        let: #analyzedPragmas with: self analyzedPragmas.
        let: #definitionBodyNode with: self definitionBodyNode.
        if: analyzedPragmas ~~ nil
        then: (analyzedPragmas anySatisfy: {:(Pragma)pragma :: Boolean | selector == pragma selector })
        else: (
            if: definitionBodyNode ~~ nil
            then: (definitionBodyNode hasPragmaNamed: selector)
            else: false
        )
    }.

Function
    withSelector: #hasFlag: addMethod: {:(Function)self :(Bitflags)flag :: Boolean |
        (self flags & flag) ~= 0bflgs
    };
    withSelector: #isMacro addMethod: {:(Function)self :: Boolean |
        self hasFlag: FunctionFlags::Macro
    };
    
    withSelector: #isVariadic addMethod: {:(Function)self :: Boolean |
        self hasFlag: FunctionFlags::Variadic
    };
    withSelector: #isCorePrimitive addMethod: {:(Function)self :: Boolean |
        self hasFlag: FunctionFlags::CorePrimitive
    };

    withSelector: #isPure addMethod: {:(Function)self :: Boolean |
        self hasFlag: FunctionFlags::Pure
    };
    withSelector: #isFinal addMethod: {:(Function)self :: Boolean |
        self hasFlag: FunctionFlags::Final
    };
    withSelector: #isVirtual addMethod: {:(Function)self :: Boolean |
        self hasFlag: FunctionFlags::Virtual
    };
    withSelector: #isAbstract addMethod: {:(Function)self :: Boolean |
        self hasFlag: FunctionFlags::Abstract
    };
    withSelector: #isOverride addMethod: {:(Function)self :: Boolean |
        self hasFlag: FunctionFlags::Override
    };
    withSelector: #isStatic addMethod: {:(Function)self :: Boolean |
        self hasFlag: FunctionFlags::Static
    };

    withSelector: #hasPragmaNamed: addMethod: {:(Function)self :selector :: Boolean |
        let: #definition with: self definition.
        if: definition == nil then: false else: (definition hasPragmaNamed: selector)
    };
    
    withSelector: #printOn: addMethod: {:(Function)self :(Stream)stream :: Void |
        let: #name with: self name.
        let: #definition with: self definition.
        let: #sourcePosition with: (if: definition ~~ nil then: definition sourcePosition else: nil).

        stream nextPutAll: "Function(".

        if: name ~~ nil then: {
            let: #owner with: self owner.
            if: owner ~~ nil then: (stream print: owner; nextPutAll: " >> ").
            
            stream print: name.
            if: sourcePosition ~~ nil then: (stream space).

        }.
        if: sourcePosition ~~ nil then: {
            stream nextPutAll: "at "; print: sourcePosition
        }.

        stream nextPut: ')'
    }.

ValueBox
    withSelector: #with: addClassMethod: {:(ValueBox class)self :value :: self |
        self basicNew
            value: value;
            yourself
    };
    withSelector: #_ addMethod: {:(ValueBox)self | self value };
    withSelector: #_: addMethod: {:(ValueBox)self :newValue | self value: newValue. newValue };
    withSelector: #":=" addMethod: {:(ValueBox)self :newValue | self value: newValue. newValue }.

Collection
    withSelector: #isEmpty addMethod: {:(Collection)self :: Boolean |
        self size = 0sz
    };
    withSelector: #isNotEmpty addMethod: {:(Collection)self :: Boolean |
        self size ~= 0sz
    };
    withSelector: #size addMethod: {:(Collection)self :: Size |
        self subclassResponsibility
    } makeAbstract;

    withSelector: #do: addMethod: {:(Collection)self :aBlock :: Void |
        self subclassResponsibility
    } makeAbstract;

    withSelector: #doWithoutTombstones: addMethod: {:(Collection)self :aBlock :: Void |
        self do: {:each :: Void |
            if: __tombstone__ ~~ each then: aBlock(each)
        }
    };

    withSelector: #doWithIndex: addMethod: {:(Collection)self :aBlock :: Void |
        let: #i mutableWith: 0sz.
        self do: {:element :: Void |
            aBlock(element, i).
            i := 1sz + i
        }
    };

    withSelector: #printOn: addMethod: {:(Collection)self :(Stream)stream :: Void |
        stream print: self class; nextPutAll: "(".
        self doWithIndex: {:element :(Size)index :: Void |
            if: index > 0sz then: (stream nextPutAll: ", ").
            stream print: element.
            void
        }.

        stream nextPutAll: ")"
    };
    withSelector: #fullPrintOn: addMethod: {:(Collection)self :(Stream)stream :: Void |
        stream print: self class; nextPutAll: "(".
        self doWithIndex: {:element :(Size)index :: Void |
            if: index > 0sz then: (stream nextPutAll: ", ").
            stream fullPrint: element.
            void
        }.

        stream nextPutAll: ")"
    };
    withSelector: #asArray addMethod: {:(SequenceableCollection)self :: Array |
        let: #array with: (Array new: self size).
        self doWithIndex: {:element :(Size)index :: Void |
            array at: index put: element
        }.

        array
    }.

SequenceableCollection
    withSelector: #=> addMethod: {:(SequenceableCollection)self :(Type)resultType :: SimpleFunctionType |
        SimpleFunctionTypeTemplate(self asArray, false, resultType)
    } makePure makeFinal.

Association
    withSelector: #key:value: addClassMethod: {:(Association class)self :key :value :: self |
        self new key: key; value: value; yourself
    };
    withSelector: #printOn: addMethod: {:(Association)self :(Stream)stream :: Void |
        stream print: self key; nextPutAll: " -> "; print: self value
    }.
Object
    withSelector:#-> addMethod: {:(Object)self :value :: Association |
        Association key: self value: value
    }.

WeakValueAssociation
    withSelector: #value addMethod: {:(WeakValueAssociation)self |
        (RawTuple::slotAt:)(self, 1sz)
    } makePure; makeFinal;
    withSelector: #value: addMethod: {:(WeakValueAssociation)self :newValue :: Void |
        RawTuple::slotAt:put:(self, 1sz, newValue)
    } makePure; makeFinal;
    withSelector: #printOn: addMethod: {:(WeakValueAssociation)self :(Stream)stream :: Void |
        stream print: self key; nextPutAll: " -> "; print: self value
    }.

Dictionary
    withSelector: #do: addMethod: {:(Dictionary)self :aBlock :: Void |
        let: #storage with: self storage.
        if: storage ~~ nil then: {
            storage do: {:element :: Void |
                if: element ~~ nil then: aBlock(element).
            }
        }
    };
    withSelector: #ensureStorage addMethod: {:(Dictionary)self :: Void |
        if: self storage == nil then: (self storage: (Array new: 16sz)).
    };
    withSelector: #at:ifAbsentPut: addMethod: {:(Dictionary)self :key :ifAbsentBlock |
        self ensureStorage.
        let: #entryIndex with: (self scanFor: key) asSize.
        let: #storage with: self storage.
        let: #entry with: (storage at: entryIndex).
        if: entry == nil then: {
            let: #value with: ifAbsentBlock().
            self at: key put: value.
            value
        } else: {
            entry value
        }
    }.

Set
    withSelector: #do: addMethod: {:(Set)self :aBlock :: Void |
        let: #storage with: self storage.
        if: storage ~~ nil then: {
            storage do: {:element :: Void |
                if: __hashtableEmptyElement__ ~~ element then: aBlock(element).
            }
        }
    }.

WeakSet
    withSelector: #do: addMethod: {:(WeakSet)self :aBlock :: Void |
        let: #storage with: self storage.
        if: storage ~~ nil then: {
            storage do: {:element :: Void |
                if: (__hashtableEmptyElement__ ~~ element) && (__tombstone__ ~~ element) then: aBlock(element).
            }
        }
    }.

SequenceableCollection
    withSelector: #with: addClassMethod: {:(SequenceableCollection class)self :value :: self |
        (self new: 1sz)
            at: 0sz put: value;
            yourself
    };
    withSelector: #with:with: addClassMethod: {:(SequenceableCollection class)self :first :second :: self |
        (self new: 2sz)
            at: 0sz put: first;
            at: 1sz put: second;
            yourself
    };
    withSelector: #with:with:with: addClassMethod: {:(SequenceableCollection class)self :first :second :third :: self |
        (self new: 3sz)
            at: 0sz put: first;
            at: 1sz put: second;
            at: 2sz put: third;
            yourself
    };
    withSelector: #with:with:with:with: addClassMethod: {:(SequenceableCollection class)self :first :second :third :fourth :: self |
        (self new: 4sz)
            at: 0sz put: first;
            at: 1sz put: second;
            at: 2sz put: third;
            at: 3sz put: fourth;
            yourself
    };
    withSelector: #at: addMethod: {:(Collection)self :(Size)index  |
        self subclassResponsibility
    } makeAbstract;
    withSelector: #at:put: addMethod: {:(Collection)self :(Size)index :value  |
        self subclassResponsibility
    } makeAbstract;
    withSelector: #anySatisfy: addMethod: {:(SequenceableCollection)self :aBlock :: Boolean |
        let: #i mutableWith: 0sz.
        let: #size with: self size.
        let: #hasFoundIt type: Boolean mutableWith: false.

        while: (if: hasFoundIt then: false else: i < self size) do: (
            hasFoundIt := aBlock(self at: i)
        ) continueWith: (i := i + 1sz).
        hasFoundIt
    } makeFinal;
    withSelector: #allSatisfy: addMethod: {:(SequenceableCollection)self :aBlock :: Boolean |
        let: #i mutableWith: 0sz.
        let: #size with: self size.
        let: #everythingIsFine type: Boolean mutableWith: true.

        while: (if: everythingIsFine then: i < self size else: false) do: (
            everythingIsFine := aBlock(self at: i)
        ) continueWith: (i := i + 1sz).
        everythingIsFine
    } makeFinal;
    withSelector: #includes: addMethod: {:(SequenceableCollection)self :element :: Boolean |
        let: #i mutableWith: 0sz.
        let: #size with: self size.
        let: #hasFoundIt type: Boolean mutableWith: false.

        while: (if: hasFoundIt then: false else: i < self size) do: (
            hasFoundIt := (self at: i) = element
        ) continueWith: (i := i + 1sz).
        hasFoundIt
    } makeFinal;
    withSelector: #collect: addMethod: {:(SequenceableCollection)self :aBlock :: self species |
        let: #i mutableWith: 0sz.
        let: #size with: self size.
        let: #result with: (self species new: size).

        while: i < self size do: {
            result at: i put: aBlock(self at: i)
        } continueWith: (i := i + 1sz).

        result
    } makeFinal;
    withSelector: #collect:as: addMethod: {:(SequenceableCollection)self :aBlock :(SequenceableCollection class)resultType :: resultType |
        let: #i mutableWith: 0sz.
        let: #size with: self size.
        let: #result with: (resultType new: size).

        while: i < self size do: {
            result at: i put: aBlock(self at: i)
        } continueWith: (i := i + 1sz).

        result
    } makeFinal;
    withSelector: #collectWithIndex: addMethod: {:(SequenceableCollection)self :aBlock :: self species |
        let: #i mutableWith: 0sz.
        let: #size with: self size.
        let: #result with: (self species new: size).

        while: i < self size do: {
            result at: i put: aBlock(self at: i, i)
        } continueWith: (i := i + 1sz).

        result
    } makeFinal;
    withSelector: #detect:ifFound:ifNone: addMethod: {:(SequenceableCollection)self :aPredicate :foundBlock :notFoundBlock |
        let: #i mutableWith: 0sz.
        let: #size with: self size.
        let: #hasFoundIt type: Boolean mutableWith: false.
        let: #foundElement type: AnyValue mutableWith: nil.

        while: (if: hasFoundIt then: false else: i < self size) do: {
            foundElement := self at: i.
            hasFoundIt := aPredicate(foundElement)
        } continueWith: (i := i + 1sz).

        if: hasFoundIt
            then: foundBlock(foundElement)
            else: notFoundBlock(notFoundBlock)
    };
    withSelector: #detect:ifNone: addMethod: {:(SequenceableCollection)self :aPredicate :notFoundBlock |
        self detect: aPredicate ifFound: {:element | element } ifNone: notFoundBlock
    };
    withSelector: #do: addMethod: {:(SequenceableCollection)self :aBlock :: Void |
        let: #i mutableWith: 0sz.
        let: #size with: self size.

        while: i < self size do: (
            aBlock(self at: i)
        ) continueWith: (i := i + 1sz)
    };
    withSelector: #doWithIndex: addMethod: {:(SequenceableCollection)self :aBlock :: Void |
        let: #i mutableWith: 0sz.
        let: #size with: self size.

        while: i < self size do: {
            aBlock(self at: i, i)
        } continueWith: (i := i + 1sz)
    };
    withSelector: #pairsDo: addMethod: {:(SequenceableCollection)self :aBlock :: Void |
        let: #i mutableWith: 0sz.
        let: #size with: self size.

        while: i < self size do: {
            aBlock(self at: i, self at: i + 1sz)
        } continueWith: (i := i + 2sz)
    };
    withSelector: #-- addMethod: {:(SequenceableCollection)self :(SequenceableCollection)other :: self species |
        let: #size with: self size.
        let: #otherSize with: other size.
        let: #result with: (self species new: size + otherSize ).
        
        self doWithIndex: {:element :(Size)index :: Void |
            result at: index put: element
        }.

        other doWithIndex: {:element :(Size)index :: Void |
            result at: size + index put: element
        }.

        result
    };
    withSelector: #replaceAll:with: addMethod: {:(SequenceableCollection)self :oldObject :newObject :: Void |
        let: #i mutableWith: 0sz.
        let: #size with: self size.

        while: i < self size do: {
            if: (self at: i) = oldObject then: (self at: i put: newObject)
        } continueWith: (i := i + 1sz)
    };
    withSelector: #replaceAllWithDictionary: addMethod: {:(SequenceableCollection)self :(Dictionary)replacementDictionary :: Void |
        let: #i mutableWith: 0sz.
        let: #size with: self size.

        while: i < self size do: {
            replacementDictionary at: (self at: i) ifPresent: {:replacement :: Void |
                (self at: i put: replacement)
            }
        } continueWith: (i := i + 1sz)
    };
    withSelector: #first addMethod: {:(SequenceableCollection)self | self at: 0sz } makeFinal;
    withSelector: #second addMethod: {:(SequenceableCollection)self | self at: 1sz } makeFinal;
    withSelector: #third addMethod: {:(SequenceableCollection)self | self at: 2sz } makeFinal;
    withSelector: #fourth addMethod: {:(SequenceableCollection)self | self at: 3sz } makeFinal;
    withSelector: #fifth addMethod: {:(SequenceableCollection)self | self at: 4sz } makeFinal;
    withSelector: #sixth addMethod: {:(SequenceableCollection)self | self at: 5sz } makeFinal;
    withSelector: #seventh addMethod: {:(SequenceableCollection)self | self at: 6sz } makeFinal;
    withSelector: #eighth addMethod: {:(SequenceableCollection)self | self at: 7sz } makeFinal;
    withSelector: #ninth addMethod: {:(SequenceableCollection)self | self at: 8sz } makeFinal;
    withSelector: #tenth addMethod: {:(SequenceableCollection)self | self at: 9sz } makeFinal;

    withSelector: #last addMethod: {:(SequenceableCollection)self | self at: self size - 1sz } makeFinal;

    withSelector: #insertionSort:from:until: addMethod: {:(SequenceableCollection)self :lessThanComparison :(Size)startIndex :(Size)endIndex :: Void |
        ## Insertion sort algorithm from https://en.wikipedia.org/wiki/Insertion_sort [March 2023]
        let: #i mutableWith: startIndex + 1sz.
        let: #j mutableWith: 0sz.

        while: (i < endIndex) do: {
            let: #insertedElement with: (self at: i).
            j := i.
            while: (j > startIndex) && lessThanComparison(insertedElement, self at: j - 1sz) do: {
                self at: j put: (self at: j - 1sz)
            } continueWith: (j := j - 1sz).

            self at: j put: insertedElement.
        } continueWith: (i := i + 1sz)
    };
    withSelector: #partition:from:until: addMethod: {:(SequenceableCollection)self :lessThanComparison :(Size)startIndex :(Size)endIndex :: Size |
        let: #pivotIndex with: endIndex - 1sz.
        let: #pivot with: (self at: pivotIndex).

        let: #i mutableWith: startIndex.
        let: #j mutableWith: startIndex.
        while: (j < pivotIndex) do: {
            let: #element with: (self at: j).

            if: lessThanComparison(element, pivot) then: {
                if: i ~= j then: {
                    let: #temp with: (self at: i).
                    self at: i put: element.
                    self at: j put: temp.
                }.
                i := i + 1sz
            }
        } continueWith: (j := j + 1sz).

        let: #destElement with: (self at: i).
        self at: i put: pivot.
        self at: pivotIndex put: destElement.

        i
    };
    withSelector: #heapSort:from:until: addMethod: {:(SequenceableCollection)self :lessThanComparison :(Size)startIndex :(Size)endIndex :: Void |
        ## TODO: Implement this properly.
        self insertionSort: lessThanComparison from: startIndex until: endIndex
    };
    withSelector: #quickSort:from:until: addMethod: {:(SequenceableCollection)self :lessThanComparison :(Size)startIndex :(Size)endIndex :: Void |
        if: startIndex < endIndex then: {
            let: #partition with: (self partition: lessThanComparison from: startIndex until: endIndex).
            self quickSort: lessThanComparison from: startIndex until: partition.
            self quickSort: lessThanComparison from: partition + 1sz until: endIndex.
        }
    };
    withSelector: #introSort:from:until:maxDepth: addMethod: {:(SequenceableCollection)self :lessThanComparison :(Size)startIndex :(Size)endIndex :(Size)maxDepth :: Void |
        if: startIndex < endIndex then: {
            let: #rangeSize with: endIndex - startIndex.
            if: rangeSize <= 16sz then: {
                self insertionSort: lessThanComparison from: startIndex until: endIndex
            } else: {
                if: maxDepth = 0sz then: {
                    self heapSort: lessThanComparison from: startIndex until: endIndex
                } else: {
                    let: #partition with: (self partition: lessThanComparison from: startIndex until: endIndex).
                    self quickSort: lessThanComparison from: startIndex until: partition.
                    self quickSort: lessThanComparison from: partition + 1sz until: endIndex.
                }.
            }
        }
    };
    withSelector: #insertionSort: addMethod: {:(SequenceableCollection)self :lessThanComparison :: Void |
        self insertionSort: lessThanComparison from: 0sz until: self size
    };
    withSelector: #insertionSort addMethod: {:(SequenceableCollection)self :: Void |
        self sort: {:a :b :: Boolean | a < b }
    };
    withSelector: #heapSort: addMethod: {:(SequenceableCollection)self :lessThanComparison :: Void |
        self heapSort: lessThanComparison from: 0sz until: self size
    };
    withSelector: #heapSort addMethod: {:(SequenceableCollection)self :: Void |
        self sort: {:a :b :: Boolean | a < b }
    };
    withSelector: #quickSort: addMethod: {:(SequenceableCollection)self :lessThanComparison :: Void |
        self quickSort: lessThanComparison from: 0sz until: self size
    };
    withSelector: #quickSort addMethod: {:(SequenceableCollection)self :: Void |
        self sort: {:a :b :: Boolean | a < b }
    };
    withSelector: #sort: addMethod: {:(SequenceableCollection)self :lessThanComparison :: Void |
        self introSort: lessThanComparison from: 0sz until: self size maxDepth: 16sz
        ##self insertionSort: lessThanComparison from: 0sz until: self size
        ##self quickSort: lessThanComparison from: 0sz until: self size
        ##self heapSort: lessThanComparison from: 0sz until: self size
    };
    withSelector: #sort addMethod: {:(SequenceableCollection)self :: Void |
        self sort: {:a :b :: Boolean | a < b }
    };
    withSelector: #sorted: addMethod: {:(SequenceableCollection)self :lessThanComparison :: self __type__ |
        self copy sort: lessThanComparison; yourself
    };
    withSelector: #sorted addMethod: {:(SequenceableCollection)self :: self __type__ |
        self sorted: {:a :b :: Boolean | a < b }
    }.

ArrayList
    withSelector: #arrayType addClassMethod: {:(ArrayList class)self :: Array class |
        Array
    };
    withSelector: #new: addClassMethod: {:(ArrayList class)self :(Size)initialSize :: self |
        self basicNew initializeWithSize: initialSize; yourself
    } makeFinal;
    withSelector: #initialize addMethod: {:(ArrayList)self :: Void |
        self size: 0sz
    };
    withSelector: #initializeWithSize: addMethod: {:(ArrayList)self :(Size)initialSize :: Void |
        self size: initialSize.
        self storage: (self class arrayType new: initialSize).
    };
    withSelector: #at: addMethod: {:(ArrayList)self :(Size)index |
        if: index < self size then: {
            self storage at: index
        } else: {
            error("Index out of bounds.")
        }
    };
    withSelector: #at:put: addMethod: {:(ArrayList)self :(Size)index :value :: Void |
        if: index < self size then: {
            self storage at: index put: value
        } else: {
            error("Index out of bounds.")
        }
    };
    withSelector: #removeAllThat: addMethod: {:(ArrayList)self :aPredicate :: Void |
        let: #size with: self size.
        let: #storage with: self storage.
        let: #newSize mutableWith: 0sz.
        let: #i mutableWith: 0sz.

        while: i < size do: {
            let: #element with: (storage at: i).
            (__tombstone__ == element) || aPredicate(element) ifFalse: {
                storage at: newSize put: element.
                newSize := newSize + 1sz
            }
        } continueWith: (i := i + 1sz).

        self size: newSize
    };
    withSelector: #removeAllOcurrencesOf: addMethod: {:(ArrayList)self :value :: Void |
        let: #size with: self size.
        let: #storage with: self storage.
        let: #newSize mutableWith: 0sz.
        let: #i mutableWith: 0sz.

        while: i < size do: {
            let: #element with: (storage at: i).
            (__tombstone__ == element) || (element = value) ifFalse: {
                storage at: newSize put: element.
                newSize := newSize + 1sz
            }
        } continueWith: (i := i + 1sz).

        self size: newSize
    }.

WeakArrayList
    withSelector: #arrayType addClassMethod: {:(ArrayList class)self :: Array class |
        WeakArray
    }.
    
StringStream
    withSelector: #initialize addMethod: {:(StringStream)self :: Void |
        self size: 0
    }.

Array
    withSelector: #new: addClassMethod: {:(Array class)self :(Size)initialSize :: self |
        self basicNew: initialSize
    } makeFinal;
    withSelector: #at: addMethod: {:(Array)self :(Size)index |
        self __slotAt__: index
    };
    withSelector: #at:put: addMethod: {:(Array)self :(Size)index :value :: Void |
        self __slotAt__: index put: value
    };
    withSelector: #size addMethod: {:(Array)self :: Size |
        self __size__
    };
    withSelector: #asArray addMethod: {:(Array)self :: Array | self };
    withSelector: #asArraySlice addMethod: {:(Array)self :: ArraySlice |
        ArraySlice basicNew
            elements: self;
            offset: 0sz;
            size: self size;
            yourself
    }.

ByteArray
    withSelector: #new: addClassMethod: {:(ByteArray class)self :(Size)initialSize :: self |
        self basicNew: initialSize
    } makeFinal;
    withSelector: #at: addMethod: {:(ByteArray)self :(Size)index |
        self __slotAt__: index
    };
    withSelector: #at:put: addMethod: {:(ByteArray)self :(Size)index :value :: Void |
        self __slotAt__: index put: value
    };
    withSelector: #size addMethod: {:(ByteArray)self :: Size |
        self __byteSize__
    };
    withSelector: #printOn: addMethod: {:(ByteArray)self :(Stream)stream :: Void |
        stream nextPutAll: "#[".
        self doWithIndex: {:element :index :: Void |
            if: index > 0sz then: (stream nextPutAll: ". ").
            stream print: element.
            void
        }.

        stream nextPutAll: "]"
    }.

String
    withSelector: #new: addClassMethod: {:(String class)self :(Size)initialSize :: self |
        self basicNew: initialSize
    } makeFinal;
    withSelector: #at: addMethod: {:(String)self :(Size)index :: Char8 |
        (self __slotAt__: index) asChar8
    };
    withSelector: #at:put: addMethod: {:(String)self :(Size)index :(Char8)value :: Void |
        self __slotAt__: index put: value
    };
    withSelector: #size addMethod: {:(String)self :: Size |
        self __byteSize__
    };
    withSelector: #padLeft:with: addMethod: {:(String)self :(Size)requiredLength :(Char8)paddingCharacter :: self species |
        let: #size with: self size.
        if: size >= requiredLength then: self
        else: {
            let: #paddingSize with: requiredLength - size.
            let: #result with: (self species new: requiredLength).

            let: #i mutableWith: 0sz.
            while: i < paddingSize do: (
                result at: i put: paddingCharacter
            ) continueWith: (i := i + 1sz).
            
            i := 0sz.
            while: i < size do: (
                result at: i + paddingSize put: (self at: i)
            ) continueWith: (i := i + 1sz).
            result
        }
    };
    withSelector: #padLeft: addMethod: {:(String)self :(Size)requiredLength :: self species |
        self padLeft: requiredLength with: ' 'asChar8
    }.

ArraySlice
    withSelector: #new: addClassMethod: {:(ArraySlice class)self :(Size)size :: self |
        self basicNew
            elements: (Array basicNew: size);
            offset: 0sz;
            size: size;
            yourself
    };
    withSelector: #at: addMethod: {:(ArraySlice)self :(Size)index |
        if: index < self size then: {
            self elements at: index + self offset
        } else: {
            error("Index out of bounds.")
        }
    };
    withSelector: #at:put: addMethod: {:(ArraySlice)self :(Size)index :value :: Void |
        if: index < self size then: {
            self elements at: index + self offset put: value
        } else: {
            error("Index out of bounds.")
        }
    }.

MethodDictionary
    withSelector: #keysAndValuesDo: addMethod: {:(MethodDictionary)self :aBlock :: Void |
        let: #storage with: self storage.
        if: storage ~~ nil then: {
            self storage pairsDo: {:selector :method :: Void |
                if: selector ~~ __hashtableEmptyElement__ then: aBlock(selector, method)
            }
        }
    };
    withSelector: #do: addMethod: {:(MethodDictionary)self :aBlock :: Void |
        self keysAndValuesDo: {:selector :method :: Void |
            aBlock(Association key: selector value: method)
        }
    }.

Type
    withSelector: #validSubtypeList addMethod: {:(Type)self :: WeakArrayList |
        if: self subtypes == nil then: (self subtypes: WeakArrayList new).
        self subtypes
    };
    withSelector: #addSubtype: addMethod: {:(Type)self :(Type)aSubtype :: Void |
        let: #subtypes with: self validSubtypeList.
        if: (subtypes includes: aSubtype) not then: (subtypes add: aSubtype)
    };
    withSelector: #registerInSuperMetatype addMethod: {:(Type)self :: Void |
        ## By default do nothing
    };
    withSelector: #registerInSupertype addMethod: {:(Type)self :: Void |
        let: #supertype with: self supertype.
        if: supertype ~~ nil then: (supertype addSubtype: self).
        self __type__ registerInSuperMetatype
    };
    withSelector: #subtypesDo: addMethod: {:(Type)self :aBlock :: Void |
        let: #subtypes with: self subtypes.
        if: subtypes ~~ nil then: (subtypes doWithoutTombstones: aBlock)
    };
    withSelector: #withSubtypesDo: addMethod: {:(Type)self :aBlock :: Void |
        aBlock(self).
        self subtypesDo: aBlock.
    };
    withSelector: #allSubtypesDo: addMethod: {:(Type)self :aBlock :: Void |
        self subtypesDo: {:(Type)each :: Void |
            aBlock(each).
            each allSubtypesDo: aBlock
        }
    };
    withSelector: #withAllSubtypesDo: addMethod: {:(Type)self :aBlock :: Void |
        aBlock(self).
        self allSubtypesDo: aBlock
    };

    withSelector: #allSubtypes addMethod: {:(Type)self :: ArrayList |
        let: #result with: ArrayList new.
        self allSubtypesDo: {:(Type)each :: Void |
            result add: each
        }.
        result
    };
    withSelector: #withAllSubtypes addMethod: {:(Type)self :: ArrayList |
        let: #result with: ArrayList new.
        self withAllSubtypesDo: {:(Type)each :: Void |
            result add: each
        }.
        result
    };

    withSelector: #selectorsDo: addMethod: {:(Type)self :aBlock :: Void |
        let: #methodDictionary with: self methodDictionary.
        if: methodDictionary ~~ nil then: (methodDictionary keysAndValuesDo: {:key :value |
            aBlock(key)
        })
    };
    withSelector: #selectors addMethod: {:(Type)self :: Array |
        let: #selectors with: ArrayList new.

        self selectorsDo: {:each :: Void |
            selectors add: each
        }.

        selectors asArray
    };
    withSelector: #allMethodsDo: addMethod: {:(Type)self :aBlock :: Void |
        let: #dictionaryIterationBlock with: {:selector :method :: Void |
            aBlock(method)
        }.

        let: #macroMethodDictionary with: self macroMethodDictionary.
        if: macroMethodDictionary ~~ nil then: (macroMethodDictionary keysAndValuesDo: dictionaryIterationBlock).

        let: #methodDictionary with: self methodDictionary.
        if: methodDictionary ~~ nil then: (methodDictionary keysAndValuesDo: dictionaryIterationBlock).

        let: #fallbackMethodDictionary with: self fallbackMethodDictionary.
        if: fallbackMethodDictionary ~~ nil then: (fallbackMethodDictionary keysAndValuesDo: dictionaryIterationBlock).
    };
    withSelector: #allInstancesDo: addMethod: {:(Type)self :aBlock :: Void |
        let: #instance mutableWith: RawTuple::firstInstanceWithType(self).
        while: instance ~~ nil do: (
            aBlock(instance)
        ) continueWith: (instance := RawTuple::nextInstanceWithSameType(instance))
    };
    withSelector: #allInstances addMethod: {:(Type)self :: Array |
        let: #instance mutableWith: RawTuple::firstInstanceWithType(self).
        let: #result with: ArrayList new.
        while: instance ~~ nil do: (
            result add: instance
        ) continueWith: (instance := RawTuple::nextInstanceWithSameType(instance)).

        result asArray
    }.

Metatype
    withSelector: #registerInSuperMetatype addMethod: {:(Type)self :: Void |
        self registerInSupertype
    }.

## Construct the subtype links
BootstrapEnv::IntrinsicTypes do: {:(Type)each :: Void |
    each registerInSupertype
}.

TypeSlot
    withSelector: #named:type:flags: addClassMethod: {:(TypeSlot class)self :name :(Type)type :(Size)flags :: self |
        self new
            name: name;
            type: type;
            flags: flags;
            yourself
    };
    withSelector: #named:type: addClassMethod: {:(TypeSlot class)self :name :(Type)type :: self |
        self named: name type: type flags: TypeSlotFlags::None
    };
    withSelector: #named:flags: addClassMethod: {:(TypeSlot class)self :name :(Size)flags :: self |
        self named: name type: AnyValue flags: flags
    };
    withSelector: #named: addClassMethod: {:(TypeSlot class)self :name :(Type)type :: self |
        self publicNamed: name type: AnyValue
    };
    withSelector: #publicNamed:type: addClassMethod: {:(TypeSlot class)self :name :(Type)type :: self |
        self named: name type: type flags: TypeSlotFlags::Public
    };
    withSelector: #publicNamed: addClassMethod: {:(TypeSlot class)self :name :(Type)type :: self |
        self publicNamed: name type: AnyValue
    };

    withSelector: #hasFlag: addMethod: {:(TypeSlot)self :(Size)flag :: Boolean |
        (self flags & flag) ~= 0bflgs
    };
    withSelector: #isPublic addMethod: {:(TypeSlot)self :: Boolean |
        self hasFlag: TypeSlotFlags::Public
    };
    withSelector: #isReadonly addMethod: {:(TypeSlot)self :: Boolean |
        self hasFlag: TypeSlotFlags::ReadOnly
    };
    withSelector: #generateAccessorsOn:withIndex: addMethod: {:(TypeSlot)self :(Type)type :(Size)slotIndex :: Void |
        if: self isPublic then: {
            let: #slotType with: self type.
            let: #getterName with: self name.
            let: #setterName with: (self name asString -- ":") asSymbol.

            ## Getter.
            type withSelector: getterName addMethod: {:(type)self :: slotType |
                (RawTuple::slotAt:)(self, slotIndex)
            } makePure makeFinal recompileAndOptimize.

            ## Setter
            if: self isReadonly not then: {
                type withSelector: setterName addMethod: {:(type)self :(slotType)value :: Void |
                    RawTuple::slotAt:put:(self, slotIndex, value)
                } makeFinal recompileAndOptimize.
            }
        }
    }.

Type
    withSelector: #generatePublicAccessors addMethod: {:(Type)self :: Void |
        let: #baseSlotIndex with: self validSupertypeTotalSlotCount.
        self slots doWithIndex: {:slot :index :: Void |
            let: #slotIndex with: baseSlotIndex + index.
            slot generateAccessorsOn: self withIndex: slotIndex
        }.
    }.

Metatype
    withSelector: #printOn: addMethod: {:(Metatype)self :(Stream)stream :: Void |
        let: #thisType with: self thisType.
        if: thisType ~~ nil
        then: (stream print: thisType; nextPutAll: " __type__")
        else: (stream nextPutAll: "a "; print: self __type__)
    }.

Metaclass
    withSelector: #thisClass addMethod: {:(Metaclass)self :: Type | self thisType };
    withSelector: #thisClass: addMethod: {:(Metaclass)self :(Type)thisClass :: Void | self thisType: thisClass };
    withSelector: #printOn: addMethod: {:(Metaclass)self :(Stream)stream :: Void |
        let: #thisClass with: self thisClass.
        if: thisClass ~~ nil
        then: (stream print: thisClass; nextPutAll: " class")
        else: (stream nextPutAll: "a "; print: self __type__)
    }.

Type
    withSelector: #refFor: addMethod: {:(Type)self :addressSpace :: ReferenceType |
        ReferenceTypeTemplate(self, addressSpace)
    } makePure;
    withSelector: #ref addMethod: {:(Type)self :: ReferenceType |
        self refFor: AnyValue
    } makePure;
    withSelector: #pointerFor: addMethod: {:(Type)self :addressSpace :: ReferenceType |
        PointerTypeTemplate(self, addressSpace)
    } makePure;
    withSelector: #pointer addMethod: {:(Type)self :addressSpace :: ReferenceType |
        self pointerFor: AnyValue
    } makePure.

ReferenceType
    withSelector: #printOn: addMethod: {:(Type)self :(Stream)stream :: Void |
        stream print: self baseType.
        if: self addressSpace == nil then: {
            stream nextPutAll: " ref"
        } else: {
            stream nextPutAll: " refFor: "; print: self addressSpace
        }.
    }.

PointerType
    withSelector: #printOn: addMethod: {:(Type)self :(Stream)stream :: Void |
        stream print: self baseType.
        if: self addressSpace == nil then: {
            stream nextPutAll: " pointer"
        } else: {
            stream nextPutAll: " pointerFor: "; print: self addressSpace
        }.
    }.

DependentFunctionType
    withSelector: #printOn: addMethod: {:(Type)self :(Stream)stream :: Void |
        stream nextPutAll: "DependentFunctionType at "; print: self sourcePosition
    }.

SimpleFunctionType
    withSelector: #printOn: addMethod: {:(Type)self :(Stream)stream :: Void |
        stream nextPut: '('.
        self argumentTypes doWithIndex: {:(Type)argumentType :(Size)index :: Void |
            index > 0sz ifTrue: (stream nextPutAll: ", ").
            stream print: argumentType
        }.
        self isVariadic ifTrue: {
            self argumentTypes isNotEmpty
                ifTrue: (stream nextPutAll: ", ...")
                ifFalse: (stream nextPutAll: "...")
        }.
        stream nextPutAll: ") => "; print: self resultType.
    }.

## Primitive values printString and primitive function types
(
    UInt8,Int8,Char8,
    UInt16,Int16,Char16,
    UInt32,Int32,Char32,
    UInt64,Int64,
    Float32,Float64,
    Integer
) do: {:SelfType :: Void |
    let: #unaryFunctionType with: SelfType => SelfType.
    let: #binaryFunctionType with: (SelfType, SelfType) => SelfType.
    let: #equalityFunctionType with: (SelfType, AnyValue) => Boolean.
    let: #binaryComparisonFunctionType with: (SelfType, SelfType) => Boolean.

    ## Unary selectors
    #(
        negated bitInvert
    ) do: {:selector :: Void |
        let: #method with: (SelfType >> selector).
        if: method ~~ nil then: (method __type__: unaryFunctionType)
    }.

    ## Binary selectors.
    #(
        + - * / %
        | & ^ << >>
    ) do: {:selector :: Void |
        let: #method with: (SelfType >> selector).
        if: method ~~ nil then: (method __type__: binaryFunctionType)
    }.

    ## Equality
    #(
        = ~=
    ) do: {:selector :: Void |
        (SelfType >> selector) __type__: equalityFunctionType
    }.

    ## Comparisons
    #(
        < <= >= >
    ) do: {:selector :: Void |
        (SelfType >> selector) __type__: binaryComparisonFunctionType
    }.

    SelfType
        withSelector: #printOn: addMethod: {:(SelfType)self :(Stream)stream :: Void |
            stream nextPutAll: self printString
        } makeFinal recompileAndOptimize
}.

(Integer >> #i8) __type__: (Integer => Int8).
(Integer >> #u8) __type__: (Integer => UInt8).
(Integer >> #c8) __type__: (Integer => Char8).
(Integer >> #i16) __type__: (Integer => Int16).
(Integer >> #u16) __type__: (Integer => UInt16).
(Integer >> #c16) __type__: (Integer => Char16).
(Integer >> #i32) __type__: (Integer => Int32).
(Integer >> #u32) __type__: (Integer => UInt32).
(Integer >> #c32) __type__: (Integer => Char32).
(Integer >> #i64) __type__: (Integer => Int64).
(Integer >> #u64) __type__: (Integer => UInt64).
##(Integer >> #f32) __type__: (Integer => Float32).
##(Integer >> #f64) __type__: (Integer => Float64).

(Float32 >> #sqrt) __type__: (Float32 => Float32).
(Float64 >> #sqrt) __type__: (Float32 => Float32).


Function
    withSelector: #timeToRunInNanoseconds addMethod: {:(Function)self :: Int64 |
        let: #startTime with: Time::Timestamp::nanosecondsNow().
        self().
        let: #endTime with: Time::Timestamp::nanosecondsNow().
        endTime - startTime
    };
    withSelector: #timeToRunInMicroseconds addMethod: {:(Function)self :: Int64 |
        let: #startTime with: Time::Timestamp::microsecondsNow().
        self().
        let: #endTime with: Time::Timestamp::microsecondsNow().
        endTime - startTime
    };
    withSelector: #printTimeToRunInMicrosecondsWithTitle: addMethod: {:(Function)self :(String)title |
        let: #startTime with: Time::Timestamp::microsecondsNow().
        let: #result with: self().
        let: #endTime with: Time::Timestamp::microsecondsNow().
        printLine(title, " ", (endTime - startTime) asFloat32 * 0.001f32,  " ms").
        result
    }.

SourcePosition
    withSelector: #printOn: addMethod: {:(SourcePosition)self :(Stream)stream :: Void |
        let: #sourceCode with: self sourceCode.

        stream
            nextPutAll: (sourceCode directory FileSystem::joinPath: sourceCode name);
            nextPut: ':';
            print: self startLine;
            nextPut: '.';
            print: self startColumn;
            nextPut: '-';
            print: self endLine;
            nextPut: '.';
            print: self endColumn
    }.

GeneratedSymbol
    withSelector: #printOn: addMethod: {:(GeneratedSymbol)self :(Stream)stream :: Void |
        stream print: self class; nextPut: '('; print: self value; nextPut: ')'
    };
    withSelector: #fullPrintOn: addMethod: {:(GeneratedSymbol)self :(Stream)stream :: Void |
        stream print: self class; nextPut: '('; print: self value; nextPut: ')'
    }.

Metaclass class
    withSelector: #getOrCreateDependentApplicationValueForNode: addMethod: {:(Metaclass class)self :(ASTNode)astNode |
        Class
    }.

Class
    withSelector: #subclassWithClassSlots: addMethod: {:(Class)self :(Array)classSlots :: Class |
        let: #metaclass with: Metaclass basicNew.
        let: #metaclassSuper with: self class.
        metaclass
            flags: TypeFlags::MetatypeRequiredFlags;
            supertype: metaclassSuper;
            slots: classSlots;
            totalSlotCount: metaclassSuper validTotalSlotCount + classSlots size;
            generatePublicAccessors.
        
        let: #class with: metaclass basicNew.
        class
            flags: TypeFlags::ClassDefaultFlags;
            supertype: self;
            slots: ();
            totalSlotCount: nil;
            registerInSupertype.
        metaclass thisClass: class.
        class
    };
    withSelector: #subclassWithClassSlots:slots: addMethod: {:(Class)self :(Array)classSlots :(Array)instanceSlots :: Class |
        (self subclassWithClassSlots: classSlots)
            slots: instanceSlots;
            totalSlotCount: self validTotalSlotCount + instanceSlots size;
            generatePublicAccessors;
            yourself
    };
    withSelector: #subclass:classSlots:slots: addMethod: {:(Class)self :(StringSymbol)name :(Array)classSlots :(Array)instanceSlots :: Class |
        let: #class with: (self subclassWithClassSlots: classSlots slots: instanceSlots).
        class name: name.
        class
    };
    withSelector: #subclass:slots: addMethod: {:(Class)self :(StringSymbol)name :(Array)instanceSlots :: Class |
        self subclass: name classSlots: () slots: instanceSlots
    }.

Environment
    withSelector: #setSymbol:value: addMethod: {:(Environment)self :(Symbol)selector :value :: value __type__ | self setSymbol: selector bindingWithValue: value. value };
    withSelector: #setPublicSymbol:value: addMethod: {:(Environment)self :(Symbol)selector :value :: value __type__ | self setSymbol: selector bindingWithValue: value. value };
    withSelector: #withSelector:addMethod: addMethod: {:(Environment)self :(Symbol)selector :method :: Void | self setSymbol: selector bindingWithValue: method }.
