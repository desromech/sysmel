FunctionDefinition
    withSelector: #asFunctionWithCaptureVector: addMethod: {:(FunctionDefinition)self :(Array)captureVector :: Function |
        Function new
            flags: self flags;
            argumentCount: self argumentCount;
            definition: self;
            yourself
    };
    withSelector: #asFunction addMethod: {:(FunctionDefinition)self :: Function |
        self asFunctionWithCaptureVector: #()
    }.

let opcodeExtraImplicitOperandCountDictionay := #{
    FunctionBytecode::Opcode::Call : 2sz.
    FunctionBytecode::Opcode::Send : 3sz.
    FunctionBytecode::Opcode::SendWithLookup : 4sz.

    FunctionBytecode::Opcode::MakeArrayWithElements : 1sz.
    FunctionBytecode::Opcode::MakeByteArrayWithElements : 1sz.
    FunctionBytecode::Opcode::MakeClosureWithCaptures : 1sz.
    FunctionBytecode::Opcode::MakeDictionaryWithElements : 1sz.
    FunctionBytecode::Opcode::MakeTupleWithElements : 1sz
}.

let computeOperandCountForOpcode := {:(UInt8)opcode :: Size |
    if: opcode >= FunctionBytecode::Opcode::FirstVariable then: {
        let standardOpcode := opcode & 16rF0 u8.
        let opcodeVariantNumber := opcode & 16r0F u8.
        (opcodeVariantNumber asSize) + (opcodeExtraImplicitOperandCountDictionay at: standardOpcode)
    } else: {
        (opcode >> 4u8) asSize
    }
}.

let opcodeNameDictionary := #{
    FunctionBytecode::Opcode::Nop : #nop.
    FunctionBytecode::Opcode::Trap : #trap.

    FunctionBytecode::Opcode::Return : #return.
    FunctionBytecode::Opcode::Jump : #jump.

    FunctionBytecode::Opcode::Alloca : #alloca.
    FunctionBytecode::Opcode::Move : #move.
    FunctionBytecode::Opcode::Load : #load.
    FunctionBytecode::Opcode::Store : #store.
    FunctionBytecode::Opcode::JumpIfTrue : #jumpIfTrue.
    FunctionBytecode::Opcode::JumpIfFalse : #jumpIfFalse.

    FunctionBytecode::Opcode::AllocaWithValue : #allocaWithValue.
    FunctionBytecode::Opcode::CoerceValue : #coerceValue.
    FunctionBytecode::Opcode::MakeAssociation : #makeAssociation.
    FunctionBytecode::Opcode::MakeClosureWithVector : #makeClosureWithVector.

    FunctionBytecode::Opcode::Call : #call.
    FunctionBytecode::Opcode::Send : #send.
    FunctionBytecode::Opcode::SendWithLookup : #sendWithLookup.

    FunctionBytecode::Opcode::MakeArrayWithElements : #makeArrayWithElements.
    FunctionBytecode::Opcode::MakeByteArrayWithElements : #makeByteArrayWithElements.
    FunctionBytecode::Opcode::MakeClosureWithCaptures : #makeClosureWithCaptures.
    FunctionBytecode::Opcode::MakeDictionaryWithElements : #makeDictionaryWithElements.
    FunctionBytecode::Opcode::MakeTupleWithElements : #makeTupleWithElements.
}.

let operandVectorNameDictionary := #{
    FunctionBytecode::OperandVectorName::Arguments : #arguments.
    FunctionBytecode::OperandVectorName::Captures : #captures.
    FunctionBytecode::OperandVectorName::Literal : #literal.
    FunctionBytecode::OperandVectorName::Local : #local.
}.

let isBranchOpcode := {:(UInt8)opcode :: Boolean |
    ((opcode = FunctionBytecode::Opcode::Jump) ||
    (opcode = FunctionBytecode::Opcode::JumpIfTrue)) ||
    (opcode = FunctionBytecode::Opcode::JumpIfFalse)
}.

FunctionBytecode
    withSelector: #decodedInstructionsDo: addMethod: {:(FunctionBytecode)self :aBlock :: Void |
        let instructions := self instructions.
        let instructionsSize := instructions size.
        let pc mutable := 0sz.

        while: pc < instructionsSize do: {
            let instructionPC := pc.
            let opcode := instructions at: pc.
            pc := pc + 1sz.

            let operandCount := computeOperandCountForOpcode(opcode).
            let operands := Array new: operandCount.
            let i mutable := 0sz.
            while: (i < operandCount) do: {
                let lowByte := (instructions at: pc).
                let highByte := (instructions at: pc + 1sz).
                let operandIndex := ((lowByte asUInt16) | (highByte asUInt16 << 8u16)) asInt16.
                operands at: i put: operandIndex.
                pc := pc + 2sz
            } continueWith: (i := i + 1sz).

            let nextPC := pc.
            aBlock(opcode, operands, instructionPC, nextPC).
        }.
    };
    withSelector: #printOpcodeMnemonic:on: addMethod: {:(FunctionBytecode)self :(UInt8)opcode :(Stream)stream :: Void |
        if: opcode >= FunctionBytecode::Opcode::Call then: {
            let standardOpcode := opcode & 16rF0 u8.
            let opcodeVariantNumber := opcode & 16r0F u8.
            stream nextPutAll: (opcodeNameDictionary at: opcode); print: opcodeVariantNumber.
        } else: {
            stream nextPutAll: (opcodeNameDictionary at: opcode).
        }
    } makeFinal;
    withSelector: #fullPrintOn: addMethod: {:(FunctionBytecode)self :(Stream)stream :: Void |
        stream print: self class; nl;
            nextPutAll: "argumentCount: "; print: self argumentCount; nl;
            nextPutAll: "captureVectorSize: "; print: self captureVectorSize; nl;
            nextPutAll: "localVectorSize: "; print: self localVectorSize; nl;
            nextPutAll: "literalVector: "; print: self literalVector; nl;
            nextPutAll: "instructions: ["; nl.

        self decodedInstructionsDo: {:(UInt8)opcode :(Array)operands :(Size)pc :(Size)nextPC :: Void |
            stream nextPutAll: " "; nextPutAll: (pc printString padLeft: 4sz with: '0'asChar8); nextPutAll: " | ".
            self printOpcodeMnemonic: opcode on: stream.
            
            let isBranchInstruction := isBranchOpcode(opcode).
            operands doWithIndex: {:(Int16)each :(Size)operandIndex :: Void |
                stream nextPut: ' '.
                if: isBranchInstruction && ((operandIndex + 1sz) = operands size) then: {
                    stream print: each; nextPut: '|'; nextPutAll: ((nextPC asIntPointer + each asIntPointer) printString padLeft: 4 with: '0')
                } else: {
                    let operandVector := each & FunctionBytecode::OperandVectorName::BitMask.
                    let operandIndex := each >> FunctionBytecode::OperandVectorName::Bits.
                    stream nextPutAll: (operandVectorNameDictionary at: operandVector); nextPut: ':'; print: operandIndex.
                    if: operandVector = FunctionBytecode::OperandVectorName::Literal
                        then: (stream nextPut: ':'; print: (self literalVector at: operandIndex asSize)).
                }.
            }.
            stream nl.
        }.

        stream nextPutAll: "]"; nl
    };
    withSelector: #asFunctionDefinition addMethod: {:(FunctionBytecode)self :: FunctionDefinition |
        FunctionDefinition new
            flags: 0sz;
            argumentCount: self argumentCount;
            bytecode: self;
            yourself
    };
    withSelector: #asFunction addMethod: {:(FunctionBytecode)self :: Function |
        self asFunctionDefinition asFunction
    }.
