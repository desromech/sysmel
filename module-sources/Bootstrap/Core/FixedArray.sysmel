public class FixedArrayType superclass: ValueType; definition: {
    public field elementType => Type.
    public field size => Size.

    public method initializeWithElementType: (initialElementType: Type) size: (initialSize: Size) ::=> Void := {
        elementType := initialElementType.
        size := initialSize.

        self
            supertype: AnyValue;
            slots: #();
            totalSlotCount: 0sz;
            generatePublicAccessors.
    }.

    public method generatePublicAccessors => Void := {
        let SelfType := self.
        let elementType := self elementType.
        let size := self size.

        self
            withSelector: #at: addMethod: {:(SelfType)self :(Size)index :: elementType |
                if: index >= size then: error("Index is out of bounds.").

                (RawTuple::slotAt:)(self, index)
            } makeFinal recompileAndOptimize;
            withSelector: #at:put: addMethod: {:(SelfType)self :(Size)index :(elementType)value :: Void |
                if: index >= size then: error("Index is out of bounds.").

                (RawTuple::slotAt:put:)(self, index, value)
            } makeFinal recompileAndOptimize.
    }.

    public method printOn: (stream: Stream) ::=> Void := {
        stream print: elementType; nextPut: '['; print: size; nextPut: ']'
    }.

    public method basicAllocate => self := {
        let result := RawTuple::new(size).
        (RawTuple::type:)(result, self).
        result
    }.

    public method basicInitializeInstance: instance ::=> Void := {
        let i mutable := 0sz.
        while: (i < size) do: (
            (RawTuple::slotAt:put:)(instance, i, elementType defaultValue)
        ) continueWith: (i := i + 1sz)
    }.

    public method defaultValue => self
        := self basicNew.

    public method computeLayout => Void := {
        instanceSize := 0sz.
        instanceAlignment := 1sz.

        instanceSize := elementType valueSize * size.
        instanceAlignment := elementType valueAlignment.
    }.

    public method canEncodeValueInBytes => Boolean
        := elementType canEncodeValueInBytes.

    public method encodeValue: (value: self) inBytes: (bytes: ByteArray) atOffset: (offset: Size) ::=> Void := {
        let i mutable := 0sz.
        let elementOffset mutable := offset.
        let elementSize := elementType alignedValueSize.
        while: (i < size) do: (
            elementType encodeValue: (RawTuple::slotAt:)(value, i) inBytes: bytes atOffset: elementOffset 
        ) continueWith: {
            i := i + 1sz.
            elementOffset := elementOffset + elementSize
        }.
    }.

    public method canDecodeValueFromBytes => Boolean
        := elementType canDecodeValueFromBytes.

    public method decodeValueFromBytes: (bytes: ByteArray) atOffset: (offset: Size) ::=> self := {
        let result := self basicAllocate.
        let i mutable := 0sz.
        let elementOffset mutable := offset.
        let elementSize := elementType alignedValueSize.
        while: (i < size) do: (
            (RawTuple::slotAt:put:)(result, i, elementType decodeValueFromBytes: bytes atOffset: elementOffset)
        ) continueWith: {
            i := i + 1sz.
            elementOffset := elementOffset + elementSize
        }.

        result
    }.
}.

public global FixedArrayTypeTemplate := {:(WeakValueAssociation)templateResult :(Type)elementType :(Size)size :: FixedArrayType |
    let result := FixedArrayType basicNew.
    templateResult value: result.
    result
        initializeWithElementType: elementType size: size;
        yourself.
} makeMemoized makeTemplate.

Type extend: {
    public pure final method fixedArray: (size: Size) ::=> FixedArrayType
        := FixedArrayTypeTemplate(self, size).

    public pure final method fixedArray ::=> FixedArrayType
        := self fixedArray: 0sz.

    public pure final method[size: Size] ::=> FixedArrayType
        := self fixedArray: size.

    public pure final method[] ::=> FixedArrayType
        := self fixedArray: 0sz.
}.
