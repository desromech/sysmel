public final class MIRLinearScanRegisterAllocator superclass: MIRRegisterAllocator; definition: {
    protected field integerRegisterFile => MIRRegisterAllocationFile.
    protected field floatRegisterFile => MIRRegisterAllocationFile.
    protected field vectorRegisterFile => MIRRegisterAllocationFile.
    protected field functionArguments => Array.

    public override method allocateRegistersIn: (function: MIRFunction) withTarget: (target: MIRCompilationTarget) ::=> Void := {
        compilationTarget := target.

        integerRegisterFile := MIRRegisterAllocationFile for: target allocableIntegerRegisters.
        vectorRegisterFile := MIRRegisterAllocationFile for: target allocableVectorRegisters.
        target usesVectorRegistersForFloatOperations ifTrue: {
            floatRegisterFile := vectorRegisterFile
        } ifFalse: {
            floatRegisterFile := MIRRegisterAllocationFile for: target allocableFloatRegisters.
        }.

        ## Precolor the the arguments.
        functionArguments := function arguments.
        functionArguments do: {:(MIRArgumentValue)eachArgument :: Void |
            eachArgument passingRegister ifNotNil: {
                self spillIfNeededAndAllocateRegister: eachArgument passingRegister withResultValue: eachArgument.
            }.
        }.

        function computeLiveIntervals.
        function basicBlocksDo: {:(MIRBasicBlock)basicBlock :: Void |
            self allocateRegistersInBasicBlock: basicBlock
        }.

        function touchedCallPreservedRegisters: (function callingConvention integerCallPreservedRegisters select: {:(MIRPhysicalLocation)register | integerRegisterFile usesRegister: register }) asArray
    }.

    public method allocateRegistersInBasicBlock: (basicBlock: MIRBasicBlock) ::=> Void := {
        basicBlock instructionsDo: {:(MIRInstruction)instruction :: Void |
            self allocateInstructionRegisters: instruction
        }
    }.

    public method allocateInstructionRegisters: (instruction: MIRInstruction) ::=> Void := {
        self beginValueAtIndex: instruction index.
        instruction isDebug ifTrue: {
            instruction operands first markMemoryCopyRequired.
            return: void.
        }.

        instruction resetRegisterAllocation.
        instruction operation computeRegisterConstraintsOf: instruction with: self.
        instruction usesCapture ifTrue: {
            ## FIXME: Add a proper temporary for the capture vector.
            functionArguments first markMemoryCopyRequired.
            instruction captureVectorPointerRegister: integerRegisterFile allocateForCaptureVector
        }.
    }.

    public method beginValueAtIndex: (deadPoint: UInt32) ::=> Void := {
        integerRegisterFile beginValueAtIndex: deadPoint.
        floatRegisterFile ifNotNil: (floatRegisterFile beginValueAtIndex: deadPoint).
        vectorRegisterFile ifNotNil: (vectorRegisterFile beginValueAtIndex: deadPoint).
    }.

    public override method allocateRegisterForInstructionResult: (instruction: MIRInstruction) ::=> Void := {
        instruction hasValidType ifTrue: {
            instruction resultRegister: (instruction physicalLocationClass allocateRegisterForResultValue: instruction with: self).
        }
    }.

    public override method allocateRegister8ForInstructionResult: (instruction: MIRInstruction) ::=> Void := {
        instruction hasValidType ifTrue: {
            instruction resultRegister: (self allocateIntegerRegister8ForResultValue: instruction).
        }
    }.

    public override method allocateRegister: (register: MIRPhysicalLocation) forInstructionResult: (instruction: MIRInstruction) ::=> Void := {
        instruction resultRegister: register.
        self spillIfNeededAndAllocateRegister: register withResultValue: instruction.
    }.

    public override method allocateRegister: (register: MIRPhysicalLocation) forInstructionResultPointer: (instruction: MIRInstruction) ::=> Void := {
        instruction resultRegister: (MIRPhysicalLocationRegisterWithPointer new register: register; yourself).
        instruction markMemoryCopyRequired.
        self spillIfNeededAndAllocateRegister: register withValuePointer: instruction.
    }.

    public override method allocateRegister: (register: MIRPhysicalLocation) forInstruction: (instruction: MIRInstruction) operandAt: (operandIndex: Size) ::=> Void := {
        instruction operandRegisters at: operandIndex put: register.
        self spillIfNeededAndAllocateRegister: register withValue: (instruction operands at: operandIndex)
    }.

    public override method allocateRegister: (register: MIRPhysicalLocation) forInstruction: (instruction: MIRInstruction) operandPointerAt: (operandIndex: Size) ::=> Void := {
        let operand => MIRLocalValue := instruction operands at: operandIndex.
        operand markMemoryCopyRequired.
        instruction operandRegisters at: operandIndex put: (MIRPhysicalLocationRegisterWithPointer new register: register; yourself).
        self spillIfNeededAndAllocateRegister: register withValuePointer: operand
    }.

    public override method allocateCloberredRegister: (register: MIRPhysicalLocation) forInstructionResultPointer: (instruction: MIRInstruction) ::=> Void := {
        instruction resultRegister: (MIRPhysicalLocationRegisterWithPointer new register: register; yourself).
        instruction markMemoryCopyRequired.
        self spillIfNeededAndAllocateRegister: register withValuePointer: nil.
    }.

    public override method allocateCloberredRegister: (register: MIRPhysicalLocation) forInstruction: (instruction: MIRInstruction) operandAt: (operandIndex: Size) ::=> Void := {
        instruction operandRegisters at: operandIndex put: register.
        self spillIfNeededAndAllocateRegister: register withValue: nil
    }.

    public override method allocateCloberredRegister: (register: MIRPhysicalLocation) forInstruction: (instruction: MIRInstruction) operandPointerAt: (operandIndex: Size) ::=> Void := {
        instruction operandRegisters at: operandIndex put: (MIRPhysicalLocationRegisterWithPointer new register: register; yourself).
        let operand => MIRValue := instruction operands at: operandIndex.
        operand markMemoryCopyRequired.
        self spillIfNeededAndAllocateRegister: register withValuePointer: nil
    }.

    public override method allocateRegister: (register: MIRPhysicalLocation) forInstruction: (instruction: MIRInstruction) scratchAt: (scratchIndex: Size) ::=> Void := {
        instruction scratchRegisters at: scratchIndex put: register.
        self spillIfNeededAndAllocateRegister: register withValue: nil
    }.

    public override method allocateRegisterForInstruction: (instruction: MIRInstruction) operandAt: (operandIndex: Size) ::=> Void := {
        let operand => MIRValue := instruction operands at: operandIndex.
        instruction operandRegisters at: operandIndex put: (self allocateRegisterForOperand: operand).
    }.
    
    public override method allocateRegister8ForInstruction: (instruction: MIRInstruction) operandAt: (operandIndex: Size) ::=> Void := {
        let operand => MIRValue  := instruction operands at: operandIndex.
        instruction operandRegisters at: operandIndex put: (self allocateRegister8ForOperand: operand).
    }.

    public method allocateRegisterForOperand: (operand: MIRValue) ::=> MIRPhysicalLocation := {
        operand physicalLocationClass allocateRegisterForValue: operand with: self
    }.

    public method allocateRegister8ForOperand: (operand: MIRValue) ::=> MIRPhysicalLocation
        := self allocateIntegerRegister8ForValue: operand.

    public override method allocateIntegerRegisterForValue: (value: MIRValue) ::=> MIRPhysicalLocation
        := integerRegisterFile allocateForValue: value.

    public override method allocateIntegerRegisterForResultValue: (value: MIRLocalValue) ::=> MIRPhysicalLocation
        := integerRegisterFile allocateForResultValue: value.

    public override method allocateIntegerRegister8ForValue: (value: MIRValue) ::=> MIRPhysicalLocation
        := integerRegisterFile allocateForByteValue: value.

    public override method allocateIntegerRegister8ForResultValue: (value: MIRValue) ::=> MIRPhysicalLocation
        := integerRegisterFile allocateForByteResultValue: value.

    public override method spillIntegerRegistersExceptFor: (registers: Array) ::=> Void := {
        integerRegisterFile spillRegistersIfNeededExceptFor: registers
    }.

    public override method spillIfNeededAndAllocateIntegerRegister: (register: MIRPhysicalIntegerRegister) withValue: (value: MIRValue) ::=> Void := {
        integerRegisterFile spillIfNeededAndAllocateRegister: register withValue: value
    }.

    public override method spillIfNeededAndAllocateIntegerRegister: (register: MIRPhysicalIntegerRegister) withValuePointer: (value: MIRValue) ::=> Void := {
        integerRegisterFile spillIfNeededAndAllocateRegister: register withValuePointer: value
    }.

    public override method spillIfNeededAndAllocateIntegerRegister: (register: MIRPhysicalIntegerRegister) withResultValue: (value: MIRValue) ::=> Void := {
        integerRegisterFile spillIfNeededAndAllocateRegister: register withResultValue: value
    }.

    public override method allocateFloatRegisterForValue: (value: MIRValue) ::=> MIRPhysicalLocation
        := floatRegisterFile allocateForValue: value.

    public override method allocateFloatRegisterForResultValue: (value: MIRLocalValue) ::=> MIRPhysicalLocation
        := floatRegisterFile allocateForResultValue: value.

    public override method spillIfNeededAndAllocateFloatRegister: (register: MIRPhysicalFloatRegister) withValue: (value: MIRValue) ::=> Void := {
        floatRegisterFile spillIfNeededAndAllocateRegister: register withValue: value
    }.

    public override method spillIfNeededAndAllocateFloatRegister: (register: MIRPhysicalFloatRegister) withResultValue: (value: MIRValue) ::=> Void := {
        floatRegisterFile spillIfNeededAndAllocateRegister: register withResultValue: value
    }.

    public override method allocateVectorRegisterForValue: (value: MIRValue) ::=> MIRPhysicalLocation
        := vectorRegisterFile allocateForValue: value.

    public override method allocateVectorRegisterForValue: (value: MIRLocalValue) ::=> MIRPhysicalLocation
        := vectorRegisterFile allocateForResultValue: value.

    public override method spillIfNeededAndAllocateVectorRegister: (register: MIRPhysicalVectorRegister) withValue: (value: MIRValue) ::=> Void := {
        vectorRegisterFile spillIfNeededAndAllocateRegister: register withValue: value
    }.

    public override method spillIfNeededAndAllocateVectorRegister: (register: MIRPhysicalVectorRegister) withResultValue: (value: MIRValue) ::=> Void := {
        vectorRegisterFile spillIfNeededAndAllocateRegister: register withResultValue: value
    }.
}.
