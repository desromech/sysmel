public final class MIRStackFrameLayout superclass: Object; definition: {
    protected field compilationTarget => MIRCompilationTarget.

    public field callPreservedRegisterAreaSize => UInt64.
    public field stackFrameSize => UInt64.
    public field stackFrameAlignment => UInt64.

    public method isRequired => Boolean
        := stackFrameSize > 0u64.

    public method temporaryFrameSize => UInt64
        := stackFrameSize - callPreservedRegisterAreaSize.

    public method buildLayoutForFunction: (function: MIRFunction) withTarget: (target: MIRCompilationTarget) ::=> Void := {
        compilationTarget := target.

        stackFrameAlignment := compilationTarget stackFrameAlignment asUInt64.
        callPreservedRegisterAreaSize := function touchedCallPreservedRegisters size * compilationTarget pointerSize.
        stackFrameSize := callPreservedRegisterAreaSize.

        ## We might need to assign a local offset in case the argument is passed through a register and we need to spill it.
        function arguments do: {:(MIRArgumentValue)eachArgument :: Void |
            eachArgument offset = 0i64 ifTrue: (self assignNextLocationToLocalValue: eachArgument).
        }.

        function temporaries do: {:(MIRTemporaryVariable)eachLocal :: Void |
            self assignNextLocationToLocalValue: eachLocal
        }.

        function instructionsDo: {:(MIRInstruction)eachInstruction :: Void |
            self assignNextLocationToLocalValue: eachInstruction
        }.

        stackFrameSize := stackFrameSize alignedTo: stackFrameAlignment
    }.

    public method assignNextLocationToLocalValue: (localValue: MIRLocalValue) ::=> Void := {
        localValue needsStackAllocation ifFalse: (return: void).

        let localAlignment := localValue alignment.
        stackFrameSize := stackFrameSize + localValue size alignedTo: localAlignment.
        stackFrameAlignment := stackFrameAlignment max: localAlignment.
        localValue
            hasValidStackOffset: true;
            offset: stackFrameSize asInt64 negated.
    }.
}.
