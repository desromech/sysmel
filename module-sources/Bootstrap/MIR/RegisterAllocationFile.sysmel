public final class MIRRegisterAllocationFile superclass: Object; definition: {
    public field usedRegisterSet => IdentitySet.
    public field availableRegisters => OrderedCollection.
    public field activeScratchRegisters => OrderedCollection.

    public field activeIntervals => MIRLiveIntervalSortedList.
    private field currentValueIndex => UInt32.

    __Meta__ definition: {
        public method for: (registers: Array) ::=> self
            := self new initializeWithRegisters: registers; yourself
    }.

    public method initializeWithRegisters: (allocatableRegisterList: Array) ::=> Void := {
        activeIntervals := MIRLiveIntervalSortedList new.
        availableRegisters := OrderedCollection new.
        allocatableRegisterList reverseDo: {:each :: Void | availableRegisters add: each}.
        usedRegisterSet := IdentitySet new.
        activeScratchRegisters := OrderedCollection new.
    }.

    public method usesRegister: (register: MIRPhysicalLocation) ::=> Boolean
        := usedRegisterSet includes: register.

    public method beginValueAtIndex: (valueIndex: UInt32) ::=> Void := {
        currentValueIndex := valueIndex.
        self expireOldLiveIntervals.
    }.

    public method expireOldLiveIntervals => Void := {
        availableRegisters addAll: activeScratchRegisters.
        activeScratchRegisters removeAll.

        activeIntervals expireUntil: currentValueIndex doing: {:(MIRLiveInterval)interval :: Void |
            interval register ifNotNil: {
                availableRegisters add: interval register
            }
        }.
    }.

    public method freeAllocatedScratchRegisters => Void := {
        availableRegisters addAll: activeScratchRegisters.
        activeScratchRegisters removeAll.
    }.

    public method spillRegistersIfNeededExceptFor: (registerList: Array) ::=> Void := {
        activeIntervals
            expireAllThat: {:(MIRLiveInterval)interval :: Boolean | (registerList includes: interval register) not }
            doing: {:(MIRLiveInterval)interval :: Void |
                availableRegisters add: interval register.
                interval spill.
            }
    }.

    public method spillIfNeededAndAllocateRegister: (usedRegister: MIRPhysicalLocation) ::=> Void
        := self spillIfNeededAndAllocateRegister: usedRegister withValue: nil.

    public method addActiveRegister: (register: MIRPhysicalLocation) withValue: (value: MIRValue) ::=> Void := {
        usedRegisterSet add: register.
        value isNotNil && value isLocalValue ifTrue: {
            let localValue := (value uncheckedDownCastTo: MIRLocalValue) validCoalescedValue.
            localValue assignedRegister ifNil: {
                let interval := localValue liveInterval.
                interval isSpilled not && localValue hasPointerUsage not && localValue physicalLocationClass isRegister ifTrue: {
                    localValue assignedRegister: register.
                    interval register: register.
                    activeIntervals add: interval.
                    (activeScratchRegisters includes: register) ifTrue: {
                        activeScratchRegisters remove: register
                    }.
                    return: void.
                }
            }
        }.

        (activeScratchRegisters includes: register) ifFalse: {
            activeScratchRegisters add: register
        }.
    }.

    public method spillIfNeededAndAllocateRegister: (usedRegister: MIRPhysicalLocation) withValue: (value: MIRValue) ::=> Void := {
        value isNotNil && (value coalescedAssignedRegister == usedRegister) ifTrue: {
            return: void
        }.

        activeIntervals
            expireAllThat: {:(MIRLiveInterval)interval :: Boolean | interval register == usedRegister }
            doing: {:(MIRLiveInterval)interval :: Void |
                availableRegisters add: interval register.
                interval spill.
            }.

        (availableRegisters includes: usedRegister) ifFalse: {
            self error: "Failed to allocate register " -- usedRegister printString.
        }.

        availableRegisters remove: usedRegister.
        self addActiveRegister: usedRegister withValue: value
    }.

    public method spillIfNeededAndAllocateRegister: (usedRegister: MIRPhysicalLocation) withValuePointer: (value: MIRValue) ::=> Void
        := self spillIfNeededAndAllocateRegister: usedRegister withValue: nil.

    public method spillIfNeededAndAllocateRegister: (usedRegister: MIRPhysicalLocation) withResultValue: (value: MIRValue) ::=> Void := {
        value isNotNil && (value coalescedAssignedRegister == usedRegister) ifTrue: {
            return: void
        }.

        (activeScratchRegisters includes: usedRegister) ifTrue: {
            self addActiveRegister: usedRegister withValue: value.
            return: void
        }.

        activeIntervals
            expireAllThat: {:(MIRLiveInterval)interval :: Boolean | interval register == usedRegister }
            doing: {:(MIRLiveInterval)interval :: Void |
                availableRegisters add: interval register.
                interval spill.
            }.

        availableRegisters remove: usedRegister.
        self addActiveRegister: usedRegister withValue: value
    }.

    public method ensureAvailableRegister => Void := {
        availableRegisters isEmpty ifTrue: {
            let interval := activeIntervals removeLast.
            availableRegisters add: interval register.
            interval spill.
        }.
    }.

    public method ensureAvailableByteRegister => Void := {
        (availableRegisters anySatisfy: {:(MIRPhysicalLocation)each :: Boolean | each canBeUsedForByte }) ifFalse: {
            (activeIntervals
                expireAnyThat: {:(MIRLiveInterval)interval :: Boolean | interval register canBeUsedForByte }
                doing: {:(MIRLiveInterval)interval :: Void |
                    interval register ifNotNil: {
                        availableRegisters add: interval register.
                        interval spill.
                    }
                }) ifFalse: {
                    self error: "Failed to spill byte register"
                }
        }.
    }.

    public method allocateForValue: (value: MIRValue) ::=> MIRPhysicalLocation := {
        let existentAsignment := value ifNotNil: value coalescedAssignedRegister.
        existentAsignment ifNil: {
            self ensureAvailableRegister.
            let register => MIRPhysicalLocation := availableRegisters removeLast.
            self addActiveRegister: register withValue: value.
            register
        }.
    }.

    public method allocateForValuePointer: (value: MIRValue) ::=> MIRPhysicalLocation
        := self allocateForValue: nil.

    public method allocate => MIRPhysicalLocation
        := self allocateForValue: nil.

    public method allocateForResultValue: (value: MIRValue) trySharingWith: (sharingValue: MIRValue) ::=> MIRPhysicalLocation := {
        value isNotNil && value isLocalValue && sharingValue isNotNil && sharingValue isLocalValue ifTrue: {
            let localValue := value downCastTo: MIRLocalValue.
            let sharingLocalValue := sharingValue downCastTo: MIRLocalValue.
            let sharingInterval := sharingLocalValue liveInterval.

            (localValue physicalLocationClass == sharingLocalValue physicalLocationClass) && 
            sharingInterval isSpilled not &&
            sharingInterval register isNotNil && 
            (sharingInterval end <= currentValueIndex) ifTrue: {
                activeIntervals
                    expireAllThat: {:(MIRLiveInterval)interval :: Boolean | interval == sharingInterval }
                    doing: {:(MIRLiveInterval)interval :: Void |
                        availableRegisters add: interval register.
                    }
            }
        }.

        self allocateForValue: value.
    }.

    public method allocateForResultValuePointer: (value: MIRValue) ::=> MIRPhysicalLocation
        := self allocateForValue: nil.

    public method allocateForByteValue: (value: MIRValue) ::=> MIRPhysicalLocation := {
        let existentAsignment := value ifNotNil: value coalescedAssignedRegister.
        existentAsignment ifNotNil: { return: existentAsignment }.

        self ensureAvailableByteRegister.
        
        let availableCount := availableRegisters size.
        let i mutable := availableCount.
        while: (i > 0sz) do: {
            i := i - 1sz.
            let register => MIRPhysicalLocation := availableRegisters at: i.
            register canBeUsedForByte ifTrue: {
                availableRegisters removeAt: i.
                self addActiveRegister: register withValue: value.
                return: register
            }.
        }.

        self error: "Failed to allocate byte register.".
    }.

    public method allocateForByte => MIRPhysicalLocation
        := self allocateForByteValue: nil.

    public method allocateForByteResultValue: (value: MIRValue) trySharingWith: (sharingValue: MIRValue) ::=> MIRPhysicalLocation
        := self allocateForByteValue: value.
}.
