public final class MIRRegisterAllocationFile superclass: Object; definition: {
    public field usedRegisterSet => IdentitySet.
    public field availableRegisters => OrderedCollection.
    public field activeScratchRegisters => OrderedCollection.

    public field activeIntervals => MIRLiveIntervalSortedList.
    private field currentValueIndex => UInt32.
    private field hasExpiredEnteringIntervals => Boolean.
    private field hasExpiredOperandIntervals => Boolean.

    __Meta__ definition: {
        public method for: (registers: Array) ::=> self
            := self new initializeWithRegisters: registers; yourself
    }.

    public method initializeWithRegisters: (allocatableRegisterList: Array) ::=> Void := {
        activeIntervals := MIRLiveIntervalSortedList new.
        availableRegisters := OrderedCollection new.
        allocatableRegisterList reverseDo: {:each :: Void | availableRegisters add: each}.
        usedRegisterSet := IdentitySet new.
        activeScratchRegisters := OrderedCollection new.
    }.

    public method usesRegister: (register: MIRPhysicalLocation) ::=> Boolean
        := usedRegisterSet includes: register.

    public method beginValueAtIndex: (valueIndex: UInt32) ::=> Void := {
        currentValueIndex := valueIndex.
        hasExpiredEnteringIntervals := false.
        hasExpiredOperandIntervals := false.
        self expireOldLiveIntervals.
    }.

    public method expireOldLiveIntervals => Void := {
        hasExpiredEnteringIntervals ifTrue: (return: void).
        hasExpiredEnteringIntervals := true.

        availableRegisters addAll: activeScratchRegisters.
        activeScratchRegisters removeAll.

        activeIntervals expireUntil: currentValueIndex doing: {:(MIRLiveInterval)interval :: Void |
            interval register ifNotNil: {
                availableRegisters add: interval register
            }
        }.
    }.

    public method expireOperandLiveIntervals => Void := {
        hasExpiredEnteringIntervals ifTrue: (return: void).
        hasExpiredEnteringIntervals := true.

        availableRegisters addAll: activeScratchRegisters.
        activeScratchRegisters removeAll.

        activeIntervals expireAt: currentValueIndex doing: {:(MIRLiveInterval)interval :: Void |
            availableRegisters add: interval register
        }.
    }.

    public method spillRegistersIfNeededExceptFor: (registerList: Array) ::=> Void := {
        activeIntervals
            expireAllThat: {:(MIRLiveInterval)interval :: Boolean | (registerList includes: interval register) not }
            doing: {:(MIRLiveInterval)interval :: Void |
                availableRegisters add: interval register.
                interval spill.
            }
    }.

    public method spillIfNeededAndAllocateRegister: (usedRegister: MIRPhysicalLocation) ::=> Void
        := self spillIfNeededAndAllocateRegister: usedRegister withValue: nil.

    public method spillIfNeededAndAllocateRegister: (usedRegister: MIRPhysicalLocation) withValue: (value: MIRValue) ::=> Void := {
        value isNotNil && (value assignedRegister == usedRegister) ifTrue: {
            return: void
        }.

        activeIntervals
            expireAllThat: {:(MIRLiveInterval)interval :: Boolean | interval register == usedRegister }
            doing: {:(MIRLiveInterval)interval :: Void |
                availableRegisters add: interval register.
                interval spill.
            }.

        availableRegisters remove: usedRegister.
        activeScratchRegisters add: usedRegister.
        usedRegisterSet add: usedRegister.
    }.

    public method spillIfNeededAndAllocateRegister: (usedRegister: MIRPhysicalLocation) withValuePointer: (value: MIRValue) ::=> Void
        := self spillIfNeededAndAllocateRegister: usedRegister withValue: nil.

    public method spillIfNeededAndAllocateRegister: (usedRegister: MIRPhysicalLocation) withResultValue: (value: MIRValue) ::=> Void := {
        value isNotNil && (value assignedRegister == usedRegister) || (activeScratchRegisters includes: usedRegister) ifTrue: {
            return: void
        }.

        activeIntervals
            expireAllThat: {:(MIRLiveInterval)interval :: Boolean | interval register == usedRegister }
            doing: {:(MIRLiveInterval)interval :: Void |
                availableRegisters add: interval register.
                interval spill.
            }.

        availableRegisters remove: usedRegister.
        activeScratchRegisters add: usedRegister.
        usedRegisterSet add: usedRegister.
    }.

    public method ensureAvailableRegister => Void := {
        availableRegisters isEmpty ifTrue: {
            let interval := activeIntervals removeLast.
            availableRegisters add: interval register.
            interval spill.
        }.
    }.

    public method ensureAvailableByteRegister => Void := {
        (availableRegisters anySatisfy: {:(MIRPhysicalLocation)each :: Boolean | each canBeUsedForByte }) ifFalse: {
            (activeIntervals
                expireAnyThat: {:(MIRLiveInterval)interval :: Boolean | interval register canBeUsedForByte }
                doing: {:(MIRLiveInterval)interval :: Void |
                    interval register ifNotNil: {
                        availableRegisters add: interval register.
                        interval spill.
                    }
                }) ifFalse: {
                self error: "Failed to spill byte register"
            }
        }.
    }.

    public method allocateForValue: (value: MIRValue) ::=> MIRPhysicalLocation := {
        self ensureAvailableRegister.
        let register => MIRPhysicalLocation := availableRegisters removeLast.
        activeScratchRegisters add: register.
        usedRegisterSet add: register.
        register
    }.

    public method allocate => MIRPhysicalLocation
        := self allocateForValue: nil.

    public method allocateForResultValue: (value: MIRValue) ::=> MIRPhysicalLocation := {
        self expireOperandLiveIntervals.
        self allocateForValue: value
    }.

    public method allocateForByteValue: (value: MIRValue) ::=> MIRPhysicalLocation := {
        self ensureAvailableByteRegister.
        
        let availableCount := availableRegisters size.
        let i mutable := availableCount.
        while: (i > 0sz) do: {
            i := i - 1sz.
            let register => MIRPhysicalLocation := availableRegisters at: i.
            register canBeUsedForByte ifTrue: {
                availableRegisters removeAt: i.
                activeScratchRegisters add: register.
                usedRegisterSet add: register.
                return: register
            }.
        }.

        self error: "Failed to allocate byte register.".
    }.

    public method allocateForByte => MIRPhysicalLocation
        := self allocateForByteValue: nil.

    public method allocateForByteResultValue: (value: MIRValue) ::=> MIRPhysicalLocation := {
        self expireOperandLiveIntervals.
        self allocateForByteValue: value
    }.

    public method allocateForCaptureVector => MIRPhysicalLocation
        := self allocate.
}.
