public final class MIRRegisterAllocationFile superclass: Object; definition: {
    public field registers => Array.
    public field usedRegisters => Array.
    public field activeRegisters => Array.
    public field spillOperations => OrderedCollection.
    public field unspillOperations => OrderedCollection.
    public field storeOperations => OrderedCollection.

    __Meta__ definition: {
        public method for: (registers: Array) ::=> self
            := self new
                registers: registers;
                usedRegisters: ((Array new: registers size)
                    atAllPut: false;
                    yourself);
                activeRegisters: ((Array new: registers size)
                    atAllPut: false;
                    yourself);
                yourself

    }.

    public override method initialize => Void := {
        super initialize.
        spillOperations := OrderedCollection new.
        unspillOperations := OrderedCollection new.
        storeOperations := OrderedCollection new.
    }.

    public method reset => Void := {
        activeRegisters atAllPut: false.
    }.

    public method resetOperations => Void := {
        spillOperations removeAll.
        unspillOperations removeAll.
        storeOperations removeAll.
    }.

    public method preOperations => Array
        := spillOperations asArray -- unspillOperations asArray.

    public method postOperations => Array
        := storeOperations asArray.

    public method makeActiveRegister: (usedRegister: MIRPhysicalLocation) ::=> Void
        := self makeActiveRegister: usedRegister withValue: nil.

    public method makeActiveRegister: (usedRegister: MIRPhysicalLocation) withValue: (value: MIRValue) ::=> Void := {
        let foundIndex := registers indexOf: usedRegister.
        self assert: foundIndex >= 0iptr.
        
        let index := foundIndex asSize.
        activeRegisters at: index put: true.
        usedRegisters at: index put: true.
    }.

    public method makeActiveRegister: (usedRegister: MIRPhysicalLocation) withValuePointer: (value: MIRValue) ::=> Void
        := self makeActiveRegister: usedRegister withValue: value.

    public method makeActiveRegister: (usedRegister: MIRPhysicalLocation) withResultValue: (value: MIRValue) ::=> Void
        := self makeActiveRegister: usedRegister withValue: value.

    public method allocate => MIRPhysicalLocation := {
        let nextRegisterIndex := activeRegisters indexOf: false.
        self assert: nextRegisterIndex >= 0iptr.

        let index := nextRegisterIndex asSize.
        activeRegisters at: index put: true.
        usedRegisters at: index put: true.
        registers at: index
    }.

    public method allocateForByte => MIRPhysicalLocation := {
        let result := self allocate.
        self assert: result canBeUsedForByte.
        result
    }.

    public method allocateForValue: (value: MIRValue) ::=> MIRPhysicalLocation
        := self allocate.

    public method allocateForByteValue: (value: MIRValue) ::=> MIRPhysicalLocation
        := self allocateForByte.

    public method allocateForCaptureVector => MIRPhysicalLocation
        := self allocate.
}.
