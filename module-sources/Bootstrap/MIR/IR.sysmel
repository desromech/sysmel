let PrintingDebugInfo := false.

public abstract class MIRCompilationTarget superclass: Object.
public abstract class MIRCallingConvention superclass: Object.
public abstract class MIRValue superclass: Object.
public abstract class MIRLocalValue superclass: MIRValue.
public abstract class MIRInstruction superclass: MIRLocalValue.
public final class MIRLiveInterval superclass: Object.

public abstract class MIRPhysicalLocation superclass: Object; definition: {
    public virtual method isMemory => Boolean := false.
    public virtual method isImmediate => Boolean := false.
    public virtual method isRegister => Boolean := false.
    public virtual method isRegisterWithPointer => Boolean := false.
    public virtual method isIntegerRegister => Boolean := false.
    public virtual method isFloatRegister => Boolean := false.
    public virtual method isVectorRegister => Boolean := false.
    public virtual method canBeUsedForByte => Boolean := false.
}.

public abstract class MIRPhysicalLocationMemory superclass: MIRPhysicalLocation; definition: {
    public virtual method isMemory => Boolean := true.

    __Meta__ definition: {
        let singleton := MIRPhysicalLocationMemory new.
        public method uniqueInstance => MIRPhysicalLocationMemory
            := singleton.
    }
}.

public abstract class MIRPhysicalLocationRegisterWithPointer superclass: MIRPhysicalLocation; definition: {
    public virtual method isRegisterWithPointer => Boolean := true.

    public field register => MIRPhysicalLocation.
}.

public abstract class MIRPhysicalLocationRegister superclass: MIRPhysicalLocation; definition: {
    public virtual method isRegister => Boolean := true.
}.

public abstract class MIRPhysicalIntegerRegister superclass: MIRPhysicalLocationRegister; definition: {
    public virtual method isIntegerRegister => Boolean := true.
}.

public abstract class MIRPhysicalFloatRegister superclass: MIRPhysicalLocationRegister; definition: {
    public virtual method isFloatRegister => Boolean := true.
}.

public abstract class MIRPhysicalVectorRegister superclass: MIRPhysicalLocationRegister; definition: {
    public virtual method isVectorRegister => Boolean := true.
}.

public class MIRPhysicalLocationImmediate superclass: MIRPhysicalLocation; definition: {
    public field value => MIRValue.

    __Meta__ definition: {
        public method for: (value: MIRValue) ::=> self
            := self new value: value; yourself
    }.

    public virtual method isImmediate => Boolean := true.
}.

Type extend: {
    public virtual method valueSizeForTacTarget: (target: MIRCompilationTarget) ::=> Size
        := target pointerSize.

    public virtual method valueAlignmentForTacTarget: (target: MIRCompilationTarget) ::=> Size
        := target pointerAlignment.

    public virtual method valueTacPhysicalLocationClass => MIRPhysicalLocation class
        := MIRPhysicalIntegerRegister.

    public virtual method valueIsSignedExtended => Boolean := false.
}.

ValueType extend: {
    public override method valueSizeForTacTarget: (target: MIRCompilationTarget) ::=> Size
        := self valueSize.

    public override method valueAlignmentForTacTarget: (target: MIRCompilationTarget) ::=> Size
        := self valueAlignment.

}.

Int8 class extend: {
    public override method valueIsSignedExtended => Boolean := true.
}.

Int16 class extend: {
    public override method valueIsSignedExtended => Boolean := true.
}.

Int32 class extend: {
    public override method valueIsSignedExtended => Boolean := true.
}.

Int64 class extend: {
    public override method valueIsSignedExtended => Boolean := true.
}.

Float32 class extend: {
    public override method valueTacPhysicalLocationClass => MIRPhysicalLocation class
        := MIRPhysicalFloatRegister.
}.

Float64 class extend: {
    public override method valueTacPhysicalLocationClass => MIRPhysicalLocation class
        := MIRPhysicalFloatRegister.
}.

MIRValue definition: {
    private field users => WeakOrderedCollection.
    public field debugSourcePosition => SourcePosition.
    public field debugSourceNode => ASTNode.
    public field debugSourceEnvironment => Environment.
    public field sourceProgramEntity => ProgramEntity.

    public virtual method type => Type
        := self subclassResponsibility.

    public virtual method physicalLocationClass => MIRPhysicalLocation class
        := self subclassResponsibility.

    public virtual method size => UInt64
        := self subclassResponsibility.

    public virtual method alignment => UInt64
        := self subclassResponsibility.

    public virtual method isSignedExtended => Boolean := false.
    public virtual method isFloatingPoint => Boolean := false.
    public virtual method isVector => Boolean := false.

    public virtual method isProgramEntity => Boolean := false.
    public virtual method isFunction => Boolean := false.
    public virtual method isLocalVariable => Boolean := false.

    public virtual method isVariable => Boolean := false.

    public virtual method isLocalValue => Boolean := false.
    public virtual method isArgumentVariable => Boolean := false.
    public virtual method isCaptureValue => Boolean := false.
    public virtual method isCaptureValueOrPointer => Boolean := false.
    public virtual method isTemporaryVariable => Boolean := false.
    public virtual method isGlobalVariable => Boolean := false.

    public virtual method isValuePointer => Boolean := false.

    public virtual method isConstant => Boolean := false.
    public virtual method isConstantInt8 => Boolean := false.
    public virtual method isConstantUInt8 => Boolean := false.
    public virtual method isConstantInt16 => Boolean := false.
    public virtual method isConstantUInt16 => Boolean := false.
    public virtual method isConstantInt32 => Boolean := false.
    public virtual method isConstantUInt32 => Boolean := false.
    public virtual method isConstantInt64 => Boolean := false.
    public virtual method isConstantUInt64 => Boolean := false.
    public virtual method isConstantFloat => Boolean := false.
    public virtual method isConstantFloat32 => Boolean := false.
    public virtual method isConstantFloat64 => Boolean := false.

    public virtual method isImmediateValue1 => Boolean := false.

    public virtual method isImmediate8 => Boolean := false.
    public virtual method isImmediate16 => Boolean := false.
    public virtual method isImmediate32 => Boolean := false.
    public virtual method isImmediateS32 => Boolean := false.
    public virtual method isImmediate64 => Boolean := self isImmediate32.
    public virtual method isRelativeImmediate32 => Boolean := false.

    public virtual method isImmediateU8 => Boolean := false.

    public virtual method getConstantValue64 => Int64
        := self error: "Not an immediate 64 constant".

    public virtual method assignedRegister => MIRPhysicalLocation := nil.
    public virtual method clearAssignedRegister => Void := {}.
    public virtual method markMemoryCopyRequired => Void := {}.

    public method printDebugInfoOn: (stream: Stream) ::=> Void := {
        debugSourcePosition isNotNil && PrintingDebugInfo ifTrue: {
            stream space; nextPutAll: "# at"; print: debugSourcePosition
        }
    }.

    public virtual method usedValuesDo: (aBlock: (MIRValue) => Void) ::=> Void := {}.

    public method usersDo: (aBlock: (MIRValue) => Void) ::=> Void := {
        users ifNotNil: {:users | users do: aBlock }
    }.

    public method registerInUsedValues => Void := {
        self usedValuesDo: {:(MIRValue)each :: Void | each registerUser: self }
    }.

    public method unregisterFromUsedValues => Void := {
        self usedValuesDo: {:(MIRValue)each :: Void | each unregisterUser: self }
    }.

    public method registerUser: (user: MIRValue) ::=> Void := {
        users ifNil: {
            users := WeakOrderedCollection new
        }.

        users add: user
    }.

    public method unregisterUser: (user: MIRValue) ::=> Void := {
        users ifNotNil: {
            users removeAllOcurrencesOf: user
        }.
    }.

    public override method postCopy => Void := {
        super postCopy.
        users := nil
    }.

    public method userCount => Size
        := users ifNil: 0sz ifNotNil: users size.
}.

public final class MIRBasicBlock superclass: MIRLocalValue.

public abstract class MIRProgramEntity superclass: MIRValue; definition: {
    public field name => Symbol.
    public field compilationTarget => MIRCompilationTarget.
    public field exportedSymbols => Array.

    ## TODO: Add proper support for the different visibility levels.
    public field isWeak => Boolean.
    public field isPublic => Boolean.
    public field isPrivate => Boolean.

    public method makeWeak => Void := {
        isWeak := true.
    }.

    public method makePrivate => Void := {
        isPrivate := true.
    }.

    public override method isProgramEntity => Boolean := true.

    public virtual method callingConvention => MIRCallingConvention
        := self error: "Not a function with a defined calling convention.".

    public override method initialize => Void := {
        exportedSymbols := #().
    }.

    public method addExportedSymbols: (extraSymbols: Array) ::=> Void := {
        exportedSymbols := exportedSymbols -- extraSymbols
    }.
}.

public abstract class MIRImportedProgramEntity superclass: MIRProgramEntity; definition: {
    public field callingConvention => MIRCallingConvention.
    public field alternativeSymbols => Array.

    public override method physicalLocationClass => MIRPhysicalLocation class
        := MIRPhysicalIntegerRegister.
}.

public final class MIRImportedVariable superclass: MIRImportedProgramEntity; definition: {
    public field type => Type.
    public field size => UInt64.
    public field alignment => UInt64.
    public field physicalLocationClass => MIRPhysicalLocation class.
}.

public final class MIRImportedFunction superclass: MIRImportedProgramEntity; definition: {
    public override method physicalLocationClass => MIRPhysicalLocation class
        := MIRPhysicalIntegerRegister.

    public override method isRelativeImmediate32 => Boolean := true.

    public override method printOn: (stream: Stream) ::=> Void := {
        stream nextPutAll: "importedFunction".
        name ifNotNil: (stream space; string: name).
    }.

    public override method fullPrintOn: (stream: Stream) ::=> Void := {
        stream print: self; nextPutAll: " [".
        alternativeSymbols doWithIndex: {:each :(Size)index :: Void |
            index > 0sz ifTrue: (stream nextPutAll: ", ").
            stream string: each.
        }.
        stream nextPut: ']'c8.
        self printDebugInfoOn: stream.
    }.
}.

public abstract class MIRVariable superclass: MIRProgramEntity; definition: {
    public field type => Type.
    public field size => UInt64.
    public field alignment => UInt64.
    public field physicalLocationClass => MIRPhysicalLocation class.
    public field isSignedExtended => Boolean.
    public field isGCRoot => Boolean.

    public override method isVariable => Boolean := true.

    public override method isFloatingPoint => Boolean := type asDecayedType isPrimitiveFloatType.
    public override method isVector => Boolean := type asDecayedType isPrimitiveVectorType.
}.

MIRLocalValue definition: {
    public field name => Symbol.
    public field index => UInt32.

    public readonly field type => Type.
    public field size => UInt64.
    public field alignment => UInt64.
    public field physicalLocationClass => MIRPhysicalLocation class.
    public field isSignedExtended => Boolean.
    public field isGCRoot => Boolean.

    public field hasValidStackOffset => Boolean.
    public field offset => Int64.
    public field assignedRegister => MIRPhysicalLocation.

    public field needsSpilling => Boolean.
    public field liveInterval => MIRLiveInterval.
    public field hasPointerUsage => Boolean.

    public field sourceBinding => SymbolBinding.

    __Meta__ definition: {
        public method withName: (name: Symbol) type: (type: Type) compilationTarget: (compilationTarget: MIRCompilationTarget) ::=> self
            := self new
                name: name;
                initializeWithType: type compilationTarget: compilationTarget;
                yourself.

        public method withType: (type: Type) compilationTarget: (compilationTarget: MIRCompilationTarget) ::=> self
            := self new initializeWithType: type compilationTarget: compilationTarget; yourself.
    }.

    public virtual method initializeWithType: (newType: Type) compilationTarget: (compilationTarget: MIRCompilationTarget) ::=> Void := {
        self assert: newType isNotNil.
        type := newType.
        size := (type valueSizeForTacTarget: compilationTarget) asUInt64.
        alignment := (type valueAlignmentForTacTarget: compilationTarget) asUInt64.
        isGCRoot := type isGarbageCollectedPointerType.
        physicalLocationClass := type valueTacPhysicalLocationClass.
    }.

    public override method clearAssignedRegister => Void := {
        assignedRegister := nil.
    }.

    public override method markMemoryCopyRequired ::=> Void := {
        needsSpilling := true.
    }.

    public method needsStackAllocation => Boolean
        := self hasValidType && (self hasPointerUsage || self needsSpilling || (assignedRegister isNil && self userCount > 0sz)).

    public override method isLocalVariable => Boolean := true.

    public virtual method resetRegisterAllocation => Void := {
        assignedRegister := nil.
    }.

    public virtual method computeLiveInterval => Void := {
        liveInterval := MIRLiveInterval for: self.

        hasPointerUsage := false.
        self usersDo: {:(MIRValue)each :: Void |
            each isLocalValue ifTrue: {
                liveInterval insertUsage: (each downCastTo: MIRLocalValue) index.
            } ifFalse: {
                each isValuePointer ifTrue: {
                    hasPointerUsage := true.
                }
            }
        }.
    }.

    public override method isLocalValue => Boolean := true.

    public override method isFloatingPoint => Boolean := type asDecayedType isPrimitiveFloatType.
    public override method isVector => Boolean := type asDecayedType isPrimitiveVectorType.

    public method hasValidType => Boolean := type isVoidType not.
}.

public final class MIRLocalVariable superclass: MIRLocalValue; definition: {
}.

public final class MIRArgumentValue superclass: MIRLocalValue; definition: {
    public field passingRegister => MIRPhysicalLocation.

    public override method isArgumentVariable => Boolean := true.

    public override method printOn: (stream: Stream) ::=> Void := {
        stream nextPut: 'a'c8; print: index.
        name ifNotNil: (stream space; string: name)
    }.
}.

public final class MIRCaptureVariable superclass: MIRLocalVariable; definition: {
    public override method isCaptureValue => Boolean := true.
    public override method isCaptureValueOrPointer => Boolean := true.

    public override method printOn: (stream: Stream) ::=> Void := {
        stream nextPut: 'c'c8; print: index.
        name ifNotNil: (stream space; string: name)
    }.
}.

public final class MIRTemporaryVariable superclass: MIRLocalVariable; definition: {
    public override method isTemporaryVariable => Boolean := true.

    public override method printOn: (stream: Stream) ::=> Void := {
        stream nextPut: 't'c8; print: index.
        name ifNotNil: (stream space; string: name)
    }.
}.

public final class MIRGlobalVariable superclass: MIRVariable; definition: {
    public override method isGlobalVariable => Boolean := true.

    public override method printOn: (stream: Stream) ::=> Void := {
        stream nextPutAll: "global".
        name ifNotNil: (stream space; string: name).
    }.

    public override method fullPrintOn: (stream: Stream) ::=> Void := {
        stream print: self; nextPutAll: " => "; print: type.
        self printDebugInfoOn: stream.
    }.
}.

public final class MIRValuePointer superclass: MIRValue; definition: {
    public field value => MIRValue.

    public override method isValuePointer => Boolean := true.
    public override method isCaptureValueOrPointer => Boolean := value isCaptureValue.

    public override method usedValuesDo: (aBlock: (MIRValue) => Void) ::=> Void := {
        aBlock(value)
    }.

    public override method physicalLocationClass => MIRPhysicalLocation class
        := MIRPhysicalIntegerRegister.

    public override method printOn: (stream: Stream) ::=> Void := {
        stream print: value; nextPutAll: " address".
    }.
}.

MIRVariable definition: {
    public method asValuePointer => MIRValuePointer
        := MIRValuePointer new
            value: self;
            registerInUsedValues;
            yourself.
}.

MIRLocalValue definition: {
    public method asValuePointer => MIRValuePointer
        := MIRValuePointer new
            value: self;
            registerInUsedValues;
            yourself.
}.

public abstract class MIRConstant superclass: MIRValue; definition: {
    public override method isConstant => Boolean := true.
}.

public abstract class MIRConstantInteger superclass: MIRConstant; definition: {
    public override method isConstant => Boolean := true.

    public override method physicalLocationClass => MIRPhysicalLocation class
        := MIRPhysicalIntegerRegister.
}.

public final class MIRGenericObjectPointerConstant superclass: MIRConstant; definition: {
    public field object => Untyped.
    public field size => Size.
    public field alignment => Size.
    public field type => Type.

    public override method physicalLocationClass => MIRPhysicalLocation class
        := MIRPhysicalIntegerRegister.

    public override method printOn: (stream: Stream) ::=> Void := {
        stream nextPutAll: "genericObjectPointerConstant("; print: RawTuple::type(object); nextPut: ')'c8
    }.
}.

public final class MIRPolymorphicInlineCache superclass: MIRConstant; definition: {
    public override method alignment => Size := UIntPointer valueAlignment.
    public override method size => Size := UIntPointer valueSize.
    public override method type => Type := ObjectModel::PolymorphicInlineCache.

    public override method physicalLocationClass => MIRPhysicalLocation class
        := MIRPhysicalIntegerRegister.

    public override method printOn: (stream: Stream) ::=> Void := {
        stream nextPutAll: "polymorphicInlineCache"
    }.
}.

public final class MIRStringLiteralPointerConstant superclass: MIRConstant; definition: {
    public field string => String.
    public field size => Size.
    public field alignment => Size.
    public field type => Type.
    public field nullTerminated => Boolean.

    public override method physicalLocationClass => MIRPhysicalLocation class
        := MIRPhysicalIntegerRegister.

    public override method printOn: (stream: Stream) ::=> Void := {
        stream nextPutAll: "stringLiteralPointerConstant("; print: string; nextPut: ')'c8
    }.
}.

public final class MIRStructureConstant superclass: MIRConstant; definition: {
    public field value => AnyValue.
    public field size => Size.
    public field alignment => Size.
    public field type => Type.

    public override method physicalLocationClass => MIRPhysicalLocation class
        := MIRPhysicalLocationMemory.

    public override method printOn: (stream: Stream) ::=> Void := {
        stream nextPutAll: "structureConstant("; print: value; nextPut: ')'c8
    }.
}.

public final class MIRConstantInt8 superclass: MIRConstantInteger; definition: {
    public field value => Int8.

    public override method isSignedExtended => Boolean := true.
    public override method isConstantInt8 => Boolean := true.
    public override method isImmediate8 => Boolean := true.
    public override method isImmediateU8 => Boolean := value >= 0i8.
    public override method isImmediate16 => Boolean := true.
    public override method isImmediate32 => Boolean := true.

    public override method type => Type := Int8.
    public override method size => UInt64 := 1u64.
    public override method alignment => UInt64 := 1u64.

    public override method getConstantValue64 => Int64 := value asInt64.

    public override method printOn: (stream: Stream) ::=> Void := {
        stream print: value; nextPutAll: "i8"
    }.

    Int8 extend: {
        public method asTacConstant => MIRConstantInt8
            := MIRConstantInt8 new value: self; yourself
    }.
}.

public final class MIRConstantUInt8 superclass: MIRConstantInteger; definition: {
    public field value => UInt8.

    public override method isConstantUInt8 => Boolean := true.
    public override method isImmediate8 => Boolean := true.
    public override method isImmediateU8 => Boolean := true.
    public override method isImmediate16 => Boolean := true.
    public override method isImmediate32 => Boolean := true.

    public override method type => Type := UInt8.
    public override method size => UInt64 := 1u64.
    public override method alignment => UInt64 := 1u64.
    
    public override method getConstantValue64 => Int64 := value asInt64.

    public override method printOn: (stream: Stream) ::=> Void := {
        stream print: value; nextPutAll: "u8"
    }.

    UInt8 extend: {
        public method asTacConstant => MIRConstantUInt8
            := MIRConstantUInt8 new value: self; yourself
    }
}.

public final class MIRConstantInt16 superclass: MIRConstantInteger; definition: {
    public field value => Int16.

    public override method isSignedExtended => Boolean := true.
    public override method isConstantInt16 => Boolean := true.
    public override method isImmediateU8 => Boolean := (0i16 <= value) && (value <= 16rff i16).
    public override method isImmediate16 => Boolean := true.
    public override method isImmediate32 => Boolean := true.

    public override method type => Type := Int16.
    public override method size => UInt64 := 2u64.
    public override method alignment => UInt64 := 2u64.

    public override method getConstantValue64 => Int64 := value asInt64.

    public override method printOn: (stream: Stream) ::=> Void := {
        stream print: value; nextPutAll: "i16"
    }.

    Int16 extend: {
        public method asTacConstant => MIRConstantInt16
            := MIRConstantInt16 new value: self; yourself
    }
}.

public final class MIRConstantUInt16 superclass: MIRConstantInteger; definition: {
    public field value => UInt16.

    public override method isConstantUInt16 => Boolean := true.
    public override method isImmediateU8 => Boolean := value <= 16rff u16.
    public override method isImmediate16 => Boolean := true.
    public override method isImmediate32 => Boolean := true.

    public override method type => Type := UInt16.
    public override method size => UInt64 := 2u64.
    public override method alignment => UInt64 := 2u64.

    public override method getConstantValue64 => Int64 := value asInt64.

    public override method printOn: (stream: Stream) ::=> Void := {
        stream print: value; nextPutAll: "u16"
    }.

    UInt16 extend: {
        public method asTacConstant => MIRConstantUInt16
            := MIRConstantUInt16 new value: self; yourself
    }
}.

public final class MIRConstantInt32 superclass: MIRConstantInteger; definition: {
    public field value => Int32.

    public override method isSignedExtended => Boolean := true.
    public override method isConstantInt32 => Boolean := true.
    public override method isImmediateU8 => Boolean := (0i32 <= value) && (value <= 16rff i32).
    public override method isImmediate32 => Boolean := true.
    public override method isImmediateS32 => Boolean := true.

    public override method type => Type := Int32.
    public override method size => UInt64 := 4u64.
    public override method alignment => UInt64 := 4u64.

    public override method getConstantValue64 => Int64 := value asInt64.

    public override method printOn: (stream: Stream) ::=> Void := {
        stream print: value; nextPutAll: "i32"
    }.

    Int32 extend: {
        public method asTacConstant => MIRConstantInt32
            := MIRConstantInt32 new value: self; yourself
    }
}.

public final class MIRConstantUInt32 superclass: MIRConstantInteger; definition: {
    public field value => UInt32.

    public override method isConstantUInt32 => Boolean := true.
    public override method isImmediateU8 => Boolean := value <= 16rff u32.
    public override method isImmediate32 => Boolean := true.
    public override method isImmediateS32 => Boolean := value <= 16r7FFFFFFF u32.

    public override method type => Type := UInt32.
    public override method size => UInt64 := 4u64.
    public override method alignment => UInt64 := 4u64.

    public override method getConstantValue64 => Int64 := value asInt64.

    public override method printOn: (stream: Stream) ::=> Void := {
        stream print: value; nextPutAll: "u32"
    }.

    UInt32 extend: {
        public method asTacConstant => MIRConstantUInt32
            := MIRConstantUInt32 new value: self; yourself
    }
}.

public final class MIRConstantInt64 superclass: MIRConstantInteger; definition: {
    public field value => Int64.

    public override method isSignedExtended => Boolean := true.
    public override method isConstantInt64 => Boolean := true.
    public override method isImmediate64 => Boolean := true.
    public override method isImmediateU8 => Boolean := (0i64 <= value) && (value <= 16rff i64).
    public override method isImmediateS32 => Boolean := value asInt32 asInt64 = value.

    public override method type => Type := Int64.
    public override method alignment => UInt64 := 8u64.
    public override method size => UInt64 := 8u64.
    
    public override method getConstantValue64 => Int64 := value.

    public override method printOn: (stream: Stream) ::=> Void := {
        stream print: value; nextPutAll: "i64"
    }.

    Int64 extend: {
        public method asTacConstant => MIRConstantInt64
            := MIRConstantInt64 new value: self; yourself
    }
}.

public final class MIRConstantUInt64 superclass: MIRConstantInteger; definition: {
    public field value => UInt64.

    public override method isConstantUInt64 => Boolean := true.
    public override method isImmediateU8 => Boolean := value <= 16rff u64.
    public override method isImmediateS32 => Boolean := value asInt32 asInt64 asUInt64 = value.
    public override method isImmediate64 => Boolean := true.

    public override method getConstantValue64 => Int64 := value asInt64.

    public override method type => Type := UInt64.
    public override method alignment => UInt64 := 8u64.
    public override method size => UInt64 := 8u64.

    public override method printOn: (stream: Stream) ::=> Void := {
        stream print: value; nextPutAll: "u64"
    }.

    UInt64 extend: {
        public method asTacConstant => MIRConstantUInt64
            := MIRConstantUInt64 new value: self; yourself
    }.
}.

public final class MIRConstantFloatingPoint superclass: MIRConstant; definition: {
    public override method isFloatingPoint => Boolean := true.
    public override method isConstantFloat => Boolean := true.

    public override method physicalLocationClass => MIRPhysicalLocation class
        := MIRPhysicalFloatRegister.
}.

public final class MIRConstantFloat32 superclass: MIRConstantFloatingPoint; definition: {
    public field value => Float32.

    public override method isConstantFloat32 => Boolean := true.
    public override method isImmediate32 => Boolean := true.

    public override method type => Type := Float32.
    public override method alignment => UInt64 := 4u64.
    public override method size => UInt64 := 4u64.

    public override method printOn: (stream: Stream) ::=> Void := {
        stream print: value; nextPutAll: "f32"
    }.

    Float32 extend: {
        public method asTacConstant => MIRConstantFloat32
            := MIRConstantFloat32 new value: self; yourself
    }.
}.

public final class MIRConstantFloat64 superclass: MIRConstantFloatingPoint; definition: {
    public field value => Float64.

    public override method isConstantFloat64 => Boolean := true.
    public override method isImmediate64 => Boolean := true.

    public override method type => Type := Float64.
    public override method alignment => UInt64 := 8u64.
    public override method size => UInt64 := 8u64.

    public override method printOn: (stream: Stream) ::=> Void := {
        stream print: value; nextPutAll: "f64"
    }.

    Float64 extend: {
        public method asTacConstant => MIRConstantFloat64
            := MIRConstantFloat64 new value: self; yourself
    }.
}.

public final class MIROperation superclass: Object; definition: {
    public field name => Symbol.
    public field isTerminator => Boolean.
    public field isDebug => Boolean.

    protected field perTargetCodeGenerators => IdentityDictionary.
    protected field perTargetRegisterConstraints => IdentityDictionary.

    __Meta__ definition: {
        public method named: (name: Symbol) ::=> self
            := self new name: name; yourself.

        public method terminatorNamed: (name: Symbol) ::=> self
            := self new name: name; isTerminator: true; yourself.

        public method debugNamed: (name: Symbol) ::=> self
            := self new name: name; isDebug: true; yourself.
    }.

    public override method initialize => Void := {
        perTargetCodeGenerators := IdentityDictionary new.
        perTargetRegisterConstraints := IdentityDictionary new.
    }.

    public override method printOn: (stream: Stream) ::=> Void := {
        stream string: name
    }.
}.

Void extend: {
    public method asTacConstant => MIRConstant
        := 0u8 asTacConstant.
}.

MIRInstruction definition: {
    public field previous => MIRInstruction.
    public field next => MIRInstruction.

    public field operation => MIROperation.
    public field operands => Array.

    public field resultRegister => MIRPhysicalLocation.
    public field operandRegisters => Array.
    public field scratchRegisters => Array.
    public field captureVectorPointerRegister => MIRPhysicalLocation.
    public field callingConvention => MIRCallingConvention.

    public override method initialize => Void := {
        super initialize.
        operands := #().
    }.

    public method firstOperandRegister => MIRPhysicalLocation := operandRegisters first.
    public method secondOperandRegister => MIRPhysicalLocation := operandRegisters second.
    public method thirdOperandRegister => MIRPhysicalLocation := operandRegisters third.
    public method fourthOperandRegister => MIRPhysicalLocation := operandRegisters fourth.

    public method firstScratchRegister => MIRPhysicalLocation := scratchRegisters first.
    public method secondScratchRegister => MIRPhysicalLocation := scratchRegisters first.

    public method isTerminator => Boolean := operation isTerminator.
    public method isDebug => Boolean := operation isDebug.

    public method scratchRegisterCount: (count: Size) ::=> Void := {
        scratchRegisters := Array new: count
    }.

    public override method printOn: (stream: Stream) ::=> Void := {
        stream nextPut: '$'c8; print: index
    }.

    public override method fullPrintOn: (stream: Stream) ::=> Void := {
        self hasValidType ifTrue: {
            stream print: self; nextPutAll: " := ".
        }.
        stream print: operation.
        operands doWithIndex: {:(MIRValue)eachOperand :(Size)index :: Void |
            index = 0sz
                ifTrue: (stream space)
                ifFalse: (stream nextPutAll: ", ").
            stream print: eachOperand
        }.
        self printDebugInfoOn: stream.
    }.

    public override method usedValuesDo: (aBlock: (MIRValue) => Void) ::=> Void := {
        operands do: aBlock
    }.

    public override method computeLiveInterval => Void := {
        super computeLiveInterval.
        liveInterval insertUsage: index
    }.

    public method usesCapture => Boolean
        := operands anySatisfy: {:(MIRValue)operand :: Boolean | operand isCaptureValue}.

    public override method resetRegisterAllocation => Void := {
        super resetRegisterAllocation.
        resultRegister := nil.
        operandRegisters := Array new: operands size.
        scratchRegisters := #().
    }.
}.

public abstract class MIRInstructionSurroundingOperation superclass: Object.

public global MIR::Operation::Branch := MIROperation terminatorNamed: #branch.
public global MIR::Operation::ConditionalBranch := MIROperation terminatorNamed: #condBranch.

public global MIR::Operation::MoveInt8 := MIROperation named: #moveInt8.
public global MIR::Operation::MoveInt16 := MIROperation named: #moveInt16.
public global MIR::Operation::MoveInt32 := MIROperation named: #moveInt32.
public global MIR::Operation::MoveInt64 := MIROperation named: #moveInt64.
public global MIR::Operation::MovePointer := MIROperation named: #movePointer.
public global MIR::Operation::MoveFloat32 := MIROperation named: #moveFloat32.
public global MIR::Operation::MoveFloat64 := MIROperation named: #moveFloat64.
public global MIR::Operation::MoveStruct := MIROperation named: #moveStruct.

public global MIR::Operation::LoadInt8 := MIROperation named: #loadInt8.
public global MIR::Operation::LoadInt16 := MIROperation named: #loadInt16.
public global MIR::Operation::LoadInt32 := MIROperation named: #loadInt32.
public global MIR::Operation::LoadInt64 := MIROperation named: #loadInt64.
public global MIR::Operation::LoadUInt8 := MIROperation named: #loadUInt8.
public global MIR::Operation::LoadUInt16 := MIROperation named: #loadUInt16.
public global MIR::Operation::LoadUInt32 := MIROperation named: #loadUInt32.
public global MIR::Operation::LoadUInt64 := MIROperation named: #loadUInt64.
public global MIR::Operation::LoadPointer := MIROperation named: #loadPointer.
public global MIR::Operation::LoadFloat32 := MIROperation named: #loadFloat32.
public global MIR::Operation::LoadFloat64 := MIROperation named: #loadFloat64.
public global MIR::Operation::LoadStruct := MIROperation named: #loadStruct.

public global MIR::Operation::StoreInt8 := MIROperation named: #storeInt8.
public global MIR::Operation::StoreInt16 := MIROperation named: #storeInt16.
public global MIR::Operation::StoreInt32 := MIROperation named: #storeInt32.
public global MIR::Operation::StoreInt64 := MIROperation named: #storeInt64.
public global MIR::Operation::StorePointer := MIROperation named: #storePointer.
public global MIR::Operation::StoreFloat32 := MIROperation named: #storeFloat32.
public global MIR::Operation::StoreFloat64 := MIROperation named: #storeFloat64.
public global MIR::Operation::StoreStruct := MIROperation named: #storeStruct.

public global MIR::Operation::CallInt8 := MIROperation named: #callInt8.
public global MIR::Operation::CallInt16 := MIROperation named: #callInt16.
public global MIR::Operation::CallInt32 := MIROperation named: #callInt32.
public global MIR::Operation::CallInt64 := MIROperation named: #callInt64.
public global MIR::Operation::CallPointer := MIROperation named: #callPointer.
public global MIR::Operation::CallFloat32 := MIROperation named: #callFloat32.
public global MIR::Operation::CallFloat64 := MIROperation named: #callFloat64.
public global MIR::Operation::CallStruct := MIROperation named: #callStruct.
public global MIR::Operation::CallVoid := MIROperation named: #callVoid.

public global MIR::Operation::ReturnInt8 := MIROperation terminatorNamed: #returnInt8.
public global MIR::Operation::ReturnInt16 := MIROperation terminatorNamed: #returnInt16.
public global MIR::Operation::ReturnInt32 := MIROperation terminatorNamed: #returnInt32.
public global MIR::Operation::ReturnInt64 := MIROperation terminatorNamed: #returnInt64.
public global MIR::Operation::ReturnPointer := MIROperation terminatorNamed: #returnPointer.
public global MIR::Operation::ReturnFloat32 := MIROperation terminatorNamed: #returnFloat32.
public global MIR::Operation::ReturnFloat64 := MIROperation terminatorNamed: #returnFloat64.
public global MIR::Operation::ReturnStruct := MIROperation terminatorNamed: #returnStruct.
public global MIR::Operation::ReturnVoid := MIROperation terminatorNamed: #returnVoid.

public global MIR::Operation::Trap := MIROperation named: #trap.
public global MIR::Operation::UnreachableTrap := MIROperation terminatorNamed: #unreachableTrap.

public global MIR::Operation::DebugSetBindingValue := MIROperation debugNamed: #debugSetBindingValue.
public global MIR::Operation::DebugSetMutableBindingValue := MIROperation debugNamed: #debugSetMutableBindingValue.

MIRBasicBlock definition: {
    public field previous => MIRBasicBlock.
    public field next => MIRBasicBlock.

    public field firstInstruction => MIRInstruction.
    public field lastInstruction => MIRInstruction.

    public override method physicalLocationClass => MIRPhysicalLocation class
        := MIRPhysicalIntegerRegister.

    public override method isRelativeImmediate32 => Boolean := true.


    public method addInstruction: (instruction: MIRInstruction) before: (position: MIRInstruction) ::=> Void := {
        let before := position ifNotNil: position previous ifNil: lastInstruction.
        let after := position.

        ## Do not add instructions after a terminator.
        before isNotNil && before isTerminator ifTrue: (return: void).

        before ifNotNil: {
            before next: instruction.
            instruction previous: before.
        } ifNil: {
            firstInstruction := instruction
        }.

        after ifNotNil: {
            after previous: instruction.
            instruction next: after
        } ifNil: {
            lastInstruction := instruction
        }.
    }.

    public method addInstruction: (instruction: MIRInstruction) ::=> Void := {
        self addInstruction: instruction before: nil
    }.

    public method instructionsDo: aBlock ::=> Void := {
        let position mutable := firstInstruction.
        while: (position isNotNil) do: {
            let nextPosition := position next.
            aBlock(position).
            position := nextPosition
        }
    }.

    public override method printOn: (stream: Stream) ::=> Void := {
        stream nextPut: '@'c8; print: index.
        name ifNotNil: (stream nextPut: ':'c8; string: name)
    }.

    public override method fullPrintOn: (stream: Stream) ::=> Void := {
        stream print: self; nextPut: ':'c8.
        self printDebugInfoOn: stream.
        stream nl.
        self instructionsDo: {:(MIRInstruction)each :: Void |
            stream nextPutAll: "    "; fullPrint: each; nl
        }.
    }.
}.

public final class MIRFunction superclass: MIRProgramEntity; definition: {
    public field callingConvention => MIRCallingConvention.

    public field arguments => Array.
    public field captures => Array.
    public field temporaries => OrderedCollection.

    public field touchedCallPreservedRegisters => Array.

    public field firstBasicBlock => MIRBasicBlock.
    public field lastBasicBlock => MIRBasicBlock.

    public field trampolineTarget => MIRProgramEntity.

    public field captureVectorSize => UInt64.
    public field captureVectorAlignment => UInt64.

    public override method isFunction => Boolean := true.

    public override method physicalLocationClass => MIRPhysicalLocation class
        := MIRPhysicalIntegerRegister.

    public override method isRelativeImmediate32 => Boolean := true.

    public override method size => UInt64
        := compilationTarget pointerSize asUInt64.

    public override method alignment => UInt64
        := compilationTarget pointerAlignment asUInt64.

    public override method initialize => Void := {
        super initialize.
        arguments := #().
        captures := #().
        temporaries := OrderedCollection new
    }.

    public method addTemporary: (temporary: MIRTemporaryVariable) ::=> MIRTemporaryVariable := {
        temporaries add: temporary.
        temporary
    }.

    public method newArgument: (name: Symbol) withType: (type: Type) sourceBinding: (sourceBinding: SymbolBinding)::=> MIRArgumentValue
        := (MIRArgumentValue withName: name type: type compilationTarget: compilationTarget)
            sourceBinding: sourceBinding;
            yourself.

    public method newArgument: (name: Symbol) withType: (type: Type) ::=> MIRArgumentValue
        := self newArgument: name withType: type sourceBinding: nil.

    public method newArgumentWithType: (type: Type) ::=> MIRArgumentValue
        := self newArgument: nil withType: type.

    public method newCapture: (name: Symbol) withType: (type: Type) ::=> MIRCaptureVariable
        := MIRCaptureVariable withName: name type: type compilationTarget: compilationTarget.

    public method newCaptureWithType: (type: Type) ::=> MIRCaptureVariable
        := self newCapture: nil withType: type.

    public method newTemporary: (name: Symbol) withType: (type: Type) ::=> MIRTemporaryVariable
        := self addTemporary: (MIRTemporaryVariable withName: name type: type compilationTarget: compilationTarget).

    public method newTemporaryWithType: (type: Type) ::=> MIRTemporaryVariable
        := self newTemporary: nil withType: type.

    public method newTemporaryUInt8 => MIRTemporaryVariable
        := self newTemporaryWithType: UInt8.

    public method newTemporaryInt8 => MIRTemporaryVariable
        := self newTemporaryWithType: Int8.

    public method newTemporaryUInt16 => MIRTemporaryVariable
        := self newTemporaryWithType: UInt16.

    public method newTemporaryInt16 => MIRTemporaryVariable
        := self newTemporaryWithType: Int8.

    public method newTemporaryUInt32 => MIRTemporaryVariable
        := self newTemporaryWithType: UInt32.

    public method newTemporaryInt32 => MIRTemporaryVariable
        := self newTemporaryWithType: Int32.

    public method newTemporaryUInt64 => MIRTemporaryVariable
        := self newTemporaryWithType: UInt64.

    public method newTemporaryInt64 => MIRTemporaryVariable
        := self newTemporaryWithType: Int64.

    public method newTemporaryUIntPointer => MIRTemporaryVariable
        := compilationTarget pointerSize = 8sz
            ifTrue: (self newTemporaryUInt64)
            ifFalse: (self newTemporaryUInt32).

    public method newTemporaryIntPointer => MIRTemporaryVariable
        := compilationTarget pointerSize = 8sz
            ifTrue: (self newTemporaryInt64)
            ifFalse: (self newTemporaryInt32).

    public method newTemporaryFloat32 => MIRTemporaryVariable
        := self newTemporaryWithType: Float32.

    public method newTemporaryFloat64 => MIRTemporaryVariable
        := self newTemporaryWithType: Float64.

    public method addBasicBlock: (basicBlock: MIRBasicBlock) before: (position: MIRBasicBlock) ::=> Void := {
        let before := position ifNotNil: position previous ifNil: lastBasicBlock.
        let after := position.

        before ifNotNil: {
            before next: basicBlock.
            basicBlock previous: before.
        } ifNil: {
            firstBasicBlock := basicBlock
        }.

        after ifNotNil: {
            after previous: basicBlock.
            basicBlock next: after
        } ifNil: {
            lastBasicBlock := basicBlock
        }.
    }.

    public method addBasicBlock: (basicBlock: MIRBasicBlock) ::=> Void := {
        self addBasicBlock: basicBlock before: nil
    }.

    public method basicBlocksDo: (aBlock: (MIRBasicBlock) => Void) ::=> Void := {
        let position mutable := firstBasicBlock.
        while: (position isNotNil) do: {
            let nextPosition := position next.
            aBlock(position).
            position := nextPosition
        }
    }.

    public method enumerateBlocks => Void := {
        let index mutable := 0u32.
        self basicBlocksDo: {:(MIRBasicBlock)each :: Void |
            each index: index.
            index := index + 1u32.
        }.
    }.

    public method instructionsDo: (aBlock: (MIRInstruction) => Void) ::=> Void := {
        self basicBlocksDo: {:(MIRBasicBlock)each :: Void |
            each instructionsDo: aBlock
        }.
    }.

    public method allLocalValuesDo: (aBlock: (MIRLocalValue) => Void) ::=> Void := {
        arguments do: aBlock.
        captures do: aBlock.
        temporaries do: aBlock.
        self basicBlocksDo: {:(MIRBasicBlock)eachBasicBlock :: Void |
            aBlock(eachBasicBlock).
            eachBasicBlock instructionsDo: {:(MIRInstruction)eachInstruction :: Void |
                aBlock(eachInstruction)
            }.
        }.
    }.

    public method enumerateLocals => Void := {
        let index mutable := 0u32.
        self allLocalValuesDo: {:(MIRLocalValue)each :: Void |
            each index: index.
            index := index + 1u32
        }.
        
    }.

    public method computeLiveIntervals => Void := {
        self enumerateLocals.
        self allLocalValuesDo: {:(MIRLocalValue)eachLocal :: Void |
            eachLocal computeLiveInterval
        }.
    }.

    public method computeCaptureVectorLayout => Void := {
        let offset mutable := 0u64.
        let alignment mutable := 1u64.
        captures do: {:(MIRCaptureVariable)each :: Void |
            offset := offset alignedTo: each alignment.
            alignment := alignment max: each alignment.

            each offset: offset asInt64.
            offset := offset + each size
        }.

        offset := offset alignedTo: alignment.
        self captureVectorSize: offset.
        self captureVectorAlignment: alignment.
    }.

    public override method printOn: (stream: Stream) ::=> Void := {
        stream nextPutAll: "function".
        name ifNotNil: (stream space; string: name).
    }.

    public override method fullPrintOn: (stream: Stream) ::=> Void := {
        stream print: self; nextPutAll: " {".
        self printDebugInfoOn: stream.
        stream nl.
        self enumerateBlocks; enumerateLocals.
        self basicBlocksDo: {:(MIRBasicBlock)each :: Void |
            stream fullPrint: each
        }.
        stream nextPut: '}'c8; nl.
    }.
}.

public final class MIRBlockBuilder superclass: Object; definition: {
    public field block => MIRBasicBlock.
    public field function => MIRFunction.

    ## Debugging information
    public field debugSourcePosition => SourcePosition.
    public field debugSourceNode => ASTNode.
    public field debugSourceEnvironment => Environment.

    public method addInstruction: (instruction: MIRInstruction) ::=> MIRInstruction := {
        block addInstruction: instruction.
        instruction
            debugSourcePosition: debugSourcePosition;
            debugSourceNode: debugSourceNode;
            debugSourceEnvironment: debugSourceEnvironment.
        instruction
    }.

    public method temporaryUInt8 => MIRTemporaryVariable := function newTemporaryUInt8.
    public method temporaryInt8 => MIRTemporaryVariable := function newTemporaryInt8.
    public method temporaryUInt16 => MIRTemporaryVariable := function newTemporaryUInt16.
    public method temporaryInt16 => MIRTemporaryVariable := function newTemporaryInt16.
    public method temporaryUInt32 => MIRTemporaryVariable := function newTemporaryUInt32.
    public method temporaryInt32 => MIRTemporaryVariable := function newTemporaryInt32.
    public method temporaryUInt64 => MIRTemporaryVariable := function newTemporaryUInt64.
    public method temporaryInt64 => MIRTemporaryVariable := function newTemporaryInt64.
    public method temporaryUIntPointer => MIRTemporaryVariable := function newTemporaryUIntPointer.
    public method temporaryFloat32 => MIRTemporaryVariable := function newTemporaryFloat32.
    public method temporaryFloat64 => MIRTemporaryVariable := function newTemporaryFloat64.

    public method compilationTarget => MIRCompilationTarget := function compilationTarget.
    public method pointerSize => Size := function compilationTarget pointerSize.
    public method uintPointerType => Type := function compilationTarget uintPointerType.
    public method has64BitsPointers => Boolean := self pointerSize = 8sz.

    public method operation: (operation: MIROperation) ::=> MIRInstruction
        := self addInstruction: ((MIRInstruction withType: Void compilationTarget: self compilationTarget)
            operation: operation;
            yourself).

    public method operation: (operation: MIROperation) withOperands: (operands: Array) type: (type: Type) ::=> MIRInstruction := {
        self assert: (operands allSatisfy: {:each :: Boolean | each isNotNil}).
        self addInstruction: ((MIRInstruction withType: type compilationTarget: self compilationTarget)
             operation: operation;
             operands: operands;
             registerInUsedValues;
             yourself)
    }.

    public method operation: (operation: MIROperation) withOperands: (operands: Array) ::=> MIRInstruction
        := self operation: operation withOperands: operands type: Void.

    public method operation: (operation: MIROperation) with: (operand: MIRValue) ::=> MIRInstruction
        := self operation: operation withOperands: (Array with: operand).

    public method operation: (operation: MIROperation) with: (operand: MIRValue) type: (type: Type) ::=> MIRInstruction
        := self operation: operation withOperands: (Array with: operand) type: type.

    public method operation: (operation: MIROperation) with: (firstOperand: MIRValue) with: (secondOperand: MIRValue) ::=> MIRInstruction
        := self operation: operation withOperands: (Array with: firstOperand with: secondOperand).

    public method operation: (operation: MIROperation) with: (firstOperand: MIRValue) with: (secondOperand: MIRValue) type: (type: Type) ::=> MIRInstruction
        := self operation: operation withOperands: (Array with: firstOperand with: secondOperand) type: type.

    public method operation: (operation: MIROperation) with: (firstOperand: MIRValue) with: (secondOperand: MIRValue) with: (thirdOperand: MIRValue) ::=> MIRInstruction
        := self operation: operation withOperands: (Array with: firstOperand with: secondOperand with: thirdOperand).

    public method operation: (operation: MIROperation) with: (firstOperand: MIRValue) with: (secondOperand: MIRValue) with: (thirdOperand: MIRValue) with: (fourthOperand: MIRValue) ::=> MIRInstruction
        := self operation: operation withOperands: (Array with: firstOperand with: secondOperand with: thirdOperand with: fourthOperand).

    public method branch: (destination: MIRValue) ::=> MIRInstruction
        := self operation: MIR::Operation::Branch with: destination.

    public method when: (condition: MIRValue) branchIfTrue: (trueDestination: MIRValue) branchIfFalse: (falseDestination: MIRValue) ::=> MIRInstruction
        := self operation: MIR::Operation::ConditionalBranch with: condition with: trueDestination with: falseDestination.

    public method call: (function: MIRValue) operation: (callOperation: MIROperation) convention: (callingConvention: MIRCallingConvention) arguments: (arguments: Array) type: (type: Type) ::=> MIRInstruction
        := self addInstruction: ((MIRInstruction withType: type compilationTarget: self compilationTarget)
            operation: callOperation;
            operands: (Array with: function) -- arguments;
            registerInUsedValues;
            callingConvention: callingConvention;
            yourself).

    public method callInt8: (function: MIRValue) convention: (callingConvention: MIRCallingConvention) arguments: (arguments: Array) type: (type: Type) ::=> MIRInstruction
        := self call: function operation: MIR::Operation::CallInt8 convention: callingConvention arguments: arguments type: type.

    public method callInt8: (function: MIRValue) arguments: (arguments: Array) type: (type: Type) ::=> MIRInstruction
        := self callInt8: function convention: self compilationTarget defaultCallingConvention arguments: arguments type: type.

    public method callInt8: (function: MIRValue) with: (firstArgument: MIRValue) type: (type: Type) ::=> MIRInstruction
        := self callInt8: function arguments: (Array with: firstArgument) type: type.

    public method callInt16: (function: MIRValue) convention: (callingConvention: MIRCallingConvention) arguments: (arguments: Array) type: (type: Type) ::=> MIRInstruction
        := self call: function operation: MIR::Operation::CallInt16 convention: callingConvention arguments: arguments type: type.

    public method callInt16: (function: MIRValue) arguments: (arguments: Array) type: (type: Type) ::=> MIRInstruction
        := self callInt16: function convention: self compilationTarget defaultCallingConvention arguments: arguments type: type.

    public method callInt16: (function: MIRValue) with: (firstArgument: MIRValue) type: (type: Type) ::=> MIRInstruction
        := self callInt16: function arguments: (Array with: firstArgument) type: type.

    public method callInt32: (function: MIRValue) convention: (callingConvention: MIRCallingConvention) arguments: (arguments: Array) type: (type: Type) ::=> MIRInstruction
        := self call: function operation: MIR::Operation::CallInt32 convention: callingConvention arguments: arguments type: type.

    public method callInt32: (function: MIRValue) arguments: (arguments: Array) type: (type: Type) ::=> MIRInstruction
        := self callInt32: function convention: self compilationTarget defaultCallingConvention arguments: arguments type: type.

    public method callInt32: (function: MIRValue) with: (firstArgument: MIRValue) type: (type: Type) ::=> MIRInstruction
        := self callInt32: function arguments: (Array with: firstArgument) type: type.

    public method callInt64: (function: MIRValue) convention: (callingConvention: MIRCallingConvention) arguments: (arguments: Array) type: (type: Type) ::=> MIRInstruction
        := self call: function operation: MIR::Operation::CallInt64 convention: callingConvention arguments: arguments type: type.

    public method callInt64: (function: MIRValue) arguments: (arguments: Array) type: (type: Type) ::=> MIRInstruction
        := self callInt64: function convention: self compilationTarget defaultCallingConvention arguments: arguments type: type.

    public method callInt64: (function: MIRValue) with: (firstArgument: MIRValue) type: (type: Type) ::=> MIRInstruction
        := self callInt64: function arguments: (Array with: firstArgument) type: type.

    public method callPointer: (function: MIRValue) convention: (callingConvention: MIRCallingConvention) arguments: (arguments: Array) type: (type: Type) ::=> MIRInstruction
        := self call: function operation: MIR::Operation::CallPointer convention: self compilationTarget defaultCallingConvention arguments: arguments type: type.

    public method callPointer: (function: MIRValue) arguments: (arguments: Array) type: (type: Type) ::=> MIRInstruction
        := self callPointer: function convention: self compilationTarget defaultCallingConvention arguments: arguments type: type.

    public method callPointer: (function: MIRValue) with: (firstArgument: MIRValue) type: (type: Type) ::=> MIRInstruction
        := self callPointer: function arguments: (Array with: firstArgument) type: type.

    public method callPointer: (function: MIRValue) with: (firstArgument: MIRValue) with: (secondArgument: MIRValue) type: (type: Type) ::=> MIRInstruction
        := self callPointer: function arguments: (Array with: firstArgument with: secondArgument) type: type.

    public method callPointer: (function: MIRValue) with: (firstArgument: MIRValue) with: (secondArgument: MIRValue) with: (thirdArgument: MIRValue) type: (type: Type) ::=> MIRInstruction
        := self callPointer: function arguments: (Array with: firstArgument with: secondArgument with: thirdArgument) type: type.

    public method callFloat32: (function: MIRValue) convention: (callingConvention: MIRCallingConvention) arguments: (arguments: Array) ::=> MIRInstruction
        := self call: function operation: MIR::Operation::CallFloat32 convention: callingConvention arguments: arguments type: Float32.

    public method callFloat32: (function: MIRValue) arguments: (arguments: Array) ::=> MIRInstruction
        := self callFloat32: function convention: self compilationTarget defaultCallingConvention arguments: arguments.

    public method callFloat32: (function: MIRValue) with: (firstArgument: MIRValue) ::=> MIRInstruction
        := self callFloat32: function arguments: (Array with: firstArgument).

    public method callFloat64: (function: MIRValue) convention: (callingConvention: MIRCallingConvention) arguments: (arguments: Array) ::=> MIRInstruction
        := self call: function operation: MIR::Operation::CallFloat64 convention: callingConvention arguments: arguments type: Float64.

    public method callFloat64: (function: MIRValue) arguments: (arguments: Array) ::=> MIRInstruction
        := self callFloat64: function convention: self compilationTarget defaultCallingConvention arguments: arguments.

    public method callFloat64: (function: MIRValue) with: (firstArgument: MIRValue) ::=> MIRInstruction
        := self callFloat64: function arguments: (Array with: firstArgument).

    public method callStruct: (function: MIRValue) convention: (callingConvention: MIRCallingConvention) arguments: (arguments: Array) type: (type: Type) ::=> MIRInstruction
        := self call: function operation: MIR::Operation::CallStruct convention: callingConvention arguments: arguments type: type.

    public method callStruct: (function: MIRValue) arguments: (arguments: Array) type: (type: Type) ::=> MIRInstruction
        := self callStruct: function convention: self compilationTarget defaultCallingConvention arguments: arguments type: type.

    public method callVoid: (function: MIRValue) convention: (callingConvention: MIRCallingConvention) arguments: (arguments: Array) ::=> MIRInstruction
        := self call: function operation: MIR::Operation::CallVoid convention: callingConvention arguments: arguments type: Void.

    public method callVoid: (function: MIRValue) arguments: (arguments: Array) ::=> MIRInstruction
        := self callVoid: function convention: self compilationTarget defaultCallingConvention arguments: arguments.

    public method callVoid: (function: MIRValue) with: (firstArgument: MIRValue) ::=> MIRInstruction
        := self callVoid: function arguments: (Array with: firstArgument).

    public method callVoid: (function: MIRValue) with: (firstArgument: MIRValue) with: (secondArgument: MIRValue) ::=> MIRInstruction
        := self callVoid: function arguments: (Array with: firstArgument with: secondArgument).

    public method callVoid: (function: MIRValue) with: (firstArgument: MIRValue) with: (secondArgument: MIRValue) with: (thirdArgument: MIRValue) ::=> MIRInstruction
        := self callVoid: function arguments: (Array with: firstArgument with: secondArgument with: thirdArgument).

    public method moveInt8: (source: MIRValue) ::=> MIRInstruction
        := self operation: MIR::Operation::MoveInt8 with: source type: Int8.

    public method moveInt16: (source: MIRValue) ::=> MIRInstruction
        := self operation: MIR::Operation::MoveInt16 with: source type: Int16.

    public method moveInt32: (source: MIRValue) ::=> MIRInstruction
        := self operation: MIR::Operation::MoveInt32 with: source type: Int32.

    public method moveInt64: (source: MIRValue) ::=> MIRInstruction
        := self operation: MIR::Operation::MoveInt64 with: source type: Int64.

    public method moveUInt8: (source: MIRValue) ::=> MIRInstruction
        := self operation: MIR::Operation::MoveInt8 with: source type: UInt8.

    public method moveUInt16: (source: MIRValue) ::=> MIRInstruction
        := self operation: MIR::Operation::MoveInt16 with: source type: UInt16.

    public method moveUInt32: (source: MIRValue) ::=> MIRInstruction
        := self operation: MIR::Operation::MoveInt32 with: source type: UInt32.

    public method moveUInt64: (source: MIRValue) ::=> MIRInstruction
        := self operation: MIR::Operation::MoveInt64 with: source type: UInt64.

    public method moveStruct: (source: MIRValue) type: (type: Type) ::=> MIRInstruction
        := self operation: MIR::Operation::MoveStruct with: source type: type.

    public method movePointer: (source: MIRValue) type: (type: Type) ::=> MIRInstruction
        := self operation: MIR::Operation::MovePointer with: source type: type.

    public method moveFloat32: (source: MIRValue) ::=> MIRInstruction
        := self operation: MIR::Operation::MoveFloat32 with: source type: Float32.

    public method moveFloat64: (source: MIRValue) ::=> MIRInstruction
        := self operation: MIR::Operation::MoveFloat64 with: source type: Float32.

    public method constantOffsetImmediateFor: (constantOffset: Int64) ::=> MIRValue
        := self has64BitsPointers && (constantOffset asInt32 asInt64 ~= constantOffset)
            ifTrue: (constantOffset asTacConstant)
            ifFalse: (constantOffset asInt32 asTacConstant).

    public method loadInt8: (pointer: MIRValue) constantOffset: (constantOffset: Int64) ::=> MIRInstruction
        := self operation: MIR::Operation::LoadInt8 with: pointer with: (self constantOffsetImmediateFor: constantOffset) type: Int8.

    public method loadInt16: (pointer: MIRValue) constantOffset: (constantOffset: Int64) ::=> MIRInstruction
        := self operation: MIR::Operation::LoadInt16 with: pointer with: (self constantOffsetImmediateFor: constantOffset) type: Int16.

    public method loadInt32: (pointer: MIRValue) constantOffset: (constantOffset: Int64) ::=> MIRInstruction
        := self operation: MIR::Operation::LoadInt32 with: pointer with: (self constantOffsetImmediateFor: constantOffset) type: Int32.

    public method loadInt64: (pointer: MIRValue) constantOffset: (constantOffset: Int64) ::=> MIRInstruction
        := self operation: MIR::Operation::LoadInt64 with: pointer with: (self constantOffsetImmediateFor: constantOffset) type: Int64.

    public method loadUInt8: (pointer: MIRValue) constantOffset: (constantOffset: Int64) ::=> MIRInstruction
        := self operation: MIR::Operation::LoadUInt8 with: pointer with: (self constantOffsetImmediateFor: constantOffset) type: UInt8.

    public method loadUInt16: (pointer: MIRValue) constantOffset: (constantOffset: Int64) ::=> MIRInstruction
        := self operation: MIR::Operation::LoadUInt16 with: pointer with: (self constantOffsetImmediateFor: constantOffset) type: UInt16.

    public method loadUInt32: (pointer: MIRValue) constantOffset: (constantOffset: Int64) ::=> MIRInstruction
        := self operation: MIR::Operation::LoadUInt32 with: pointer with: (self constantOffsetImmediateFor: constantOffset) type: UInt32.

    public method loadUInt64: (pointer: MIRValue) constantOffset: (constantOffset: Int64) ::=> MIRInstruction
        := self operation: MIR::Operation::LoadUInt64 with: pointer with: (self constantOffsetImmediateFor: constantOffset) type: UInt64.

    public method loadFloat32: (pointer: MIRValue) constantOffset: (constantOffset: Int64) ::=> MIRInstruction
        := self operation: MIR::Operation::LoadFloat32 with: pointer with: (self constantOffsetImmediateFor: constantOffset) type: Float32.

    public method loadFloat64: (pointer: MIRValue) constantOffset: (constantOffset: Int64) ::=> MIRInstruction
        := self operation: MIR::Operation::LoadFloat64 with: pointer with: (self constantOffsetImmediateFor: constantOffset) type: Float64.

    public method loadPointer: (pointer: MIRValue) constantOffset: (constantOffset: Int64) type: (type: Type) ::=> MIRInstruction
        := self operation: MIR::Operation::LoadPointer with: pointer with: (self constantOffsetImmediateFor: constantOffset) type: type.

    public method pointerMul: (index: MIRValue) constantScale: (constantScale: Int64) type: (type: Type) ::=> MIRInstruction
        := self pointerMul: index with: (self constantOffsetImmediateFor: constantScale) type: type.

    public method pointerAdd: (pointer: MIRValue) constantOffset: (constantOffset: Int64) type: (type: Type) ::=> MIRValue := {
        constantOffset = 0i64 ifTrue: {
            pointer
        } ifFalse: {
            self pointerAdd: pointer with: (self constantOffsetImmediateFor: constantOffset) type: type
        }
    }.

    public method loadStruct: (pointer: MIRValue) constantOffset: (constantOffset: Int64) type: (type: Type) ::=> MIRInstruction
        := self operation: MIR::Operation::LoadStruct with: pointer with: (self constantOffsetImmediateFor: constantOffset) type: Type.

    public method pointerConstantWith: (value: UInt64) ::=> MIRValue
        := self has64BitsPointers
            ifTrue: (value asTacConstant)
            ifFalse: (value asUInt32 asTacConstant).

    public method storeInt8: (value: MIRValue) into: (pointer: MIRValue) constantOffset: (constantOffset: Int64) ::=> MIRInstruction
        := self operation: MIR::Operation::StoreInt8 with: value with: pointer with: (self constantOffsetImmediateFor: constantOffset).

    public method storeInt16: (value: MIRValue) into: (pointer: MIRValue) constantOffset: (constantOffset: Int64) ::=> MIRInstruction
        := self operation: MIR::Operation::StoreInt16 with: value with: pointer with: (self constantOffsetImmediateFor: constantOffset).

    public method storeInt32: (value: MIRValue) into: (pointer: MIRValue) constantOffset: (constantOffset: Int64) ::=> MIRInstruction
        := self operation: MIR::Operation::StoreInt32 with: value with: pointer with: (self constantOffsetImmediateFor: constantOffset).

    public method storeInt64: (value: MIRValue) into: (pointer: MIRValue) constantOffset: (constantOffset: Int64) ::=> MIRInstruction
        := self operation: MIR::Operation::StoreInt64 with: value with: pointer with: (self constantOffsetImmediateFor: constantOffset).

    public method storePointer: (value: MIRValue) into: (pointer: MIRValue) constantOffset: (constantOffset: Int64) ::=> MIRInstruction
        := self operation: MIR::Operation::StorePointer with: value with: pointer with: (self constantOffsetImmediateFor: constantOffset).

    public method storeFloat32: (value: MIRValue) into: (pointer: MIRValue) constantOffset: (constantOffset: Int64) ::=> MIRInstruction
        := self operation: MIR::Operation::StoreFloat32 with: value with: pointer with: (self constantOffsetImmediateFor: constantOffset).

    public method storeFloat64: (value: MIRValue) into: (pointer: MIRValue) constantOffset: (constantOffset: Int64) ::=> MIRInstruction
        := self operation: MIR::Operation::StoreFloat64 with: value with: pointer with: (self constantOffsetImmediateFor: constantOffset).

    public method storeStruct: (value: MIRValue) into: (pointer: MIRValue) constantOffset: (constantOffset: Int64) ::=> MIRInstruction
        := self operation: MIR::Operation::StoreStruct with: value with: pointer with: (self constantOffsetImmediateFor: constantOffset).

    public method loadEffectiveAddress: (basePointer: MIRValue) index: (indexValue: MIRValue) constantScale: (constantScale: Int64) type: (type: Type) ::=> MIRValue := {
        constantScale = 0i64 ifTrue: {
            basePointer
        } ifFalse: {
            indexValue isImmediate64 ifTrue: {
                let constantOffset := indexValue getConstantValue64 * constantScale.
                self pointerAdd: basePointer constantOffset: constantOffset type: type
            } ifFalse: {
                constantScale = 1i64 ifTrue: {
                    self pointerAdd: basePointer with: indexValue type: type
                } ifFalse: {
                    constantScale = -1i64 ifTrue: {
                        self pointerSub: basePointer with: indexValue type: type
                    } ifFalse: {
                        self pointerAdd: basePointer
                            with: (self pointerMul: indexValue constantScale: constantScale type: type)
                            type: type
                    }
                }.
            }.
        }.
    }.

    public method returnVoid ::=> MIRInstruction
        := self operation: MIR::Operation::ReturnVoid.

    public method returnInt8: (value: MIRValue) ::=> MIRInstruction
        := self operation: MIR::Operation::ReturnInt8 with: value.

    public method returnInt16: (value: MIRValue) ::=> MIRInstruction
        := self operation: MIR::Operation::ReturnInt16 with: value.

    public method returnInt32: (value: MIRValue) ::=> MIRInstruction
        := self operation: MIR::Operation::ReturnInt32 with: value.

    public method returnInt64: (value: MIRValue) ::=> MIRInstruction
        := self operation: MIR::Operation::ReturnInt64 with: value.

    public method returnPointer: (value: MIRValue) ::=> MIRInstruction
        := self has64BitsPointers
            ifTrue: (self returnInt64: value)
            ifFalse: (self returnInt32: value).

    public method returnFloat32: (value: MIRValue) ::=> MIRInstruction
        := self operation: MIR::Operation::ReturnFloat32 with: value.

    public method returnFloat64: (value: MIRValue) ::=> MIRInstruction
        := self operation: MIR::Operation::ReturnFloat64 with: value.

    public method returnStruct: (value: MIRValue) ::=> MIRInstruction
        := self operation: MIR::Operation::ReturnStruct with: value.

    public method trap ::=> MIRInstruction
        := self operation: MIR::Operation::Trap.

    public method unreachableTrap ::=> MIRInstruction
        := self operation: MIR::Operation::UnreachableTrap.

    public method debugSetBinding: (binding: SymbolBinding) value: (value: MIRValue) ::=> MIRInstruction
        := self addInstruction: ((MIRInstruction withType: Void compilationTarget: self compilationTarget)
            operation: MIR::Operation::DebugSetBindingValue;
            operands: (Array with: value);
            registerInUsedValues;
            sourceBinding: binding;
            yourself).

    public method debugSetMutableBinding: (binding: SymbolBinding) value: (value: MIRValue) ::=> MIRInstruction
        := self addInstruction: ((MIRInstruction withType: Void compilationTarget: self compilationTarget)
            operation: MIR::Operation::DebugSetMutableBindingValue;
            operands: (Array with: value);
            registerInUsedValues;
            sourceBinding: binding;
            yourself).
}.

public final class MIRFunctionBuilder superclass: Object; definition: {
    public field function => MIRFunction.

    ## Debugging information
    public field debugSourcePosition => SourcePosition.
    public field debugSourceNode => ASTNode.
    public field debugSourceEnvironment => Environment.

    MIRFunction extend: {
        public method build: (aBlock: (MIRFunctionBuilder) => Void) ::=> Void := {
            let builder := MIRFunctionBuilder new
                function: self;
                yourself.
            aBlock(builder).
        }.
    }.

    public method basicBlock: (name: Symbol) build: (aBlock: (MIRBlockBuilder) => Void) ::=> Void := {
        let block := MIRBasicBlock new name: name; yourself.
        function addBasicBlock: block.

        let blockBuilder := MIRBlockBuilder new
            block: block;
            function: function;
            yourself.
        aBlock(blockBuilder).
        block.
    }.

    public method setValueDebugInfo: (value: MIRValue) ::=> Void := {
        value
            debugSourcePosition: debugSourcePosition;
            debugSourceNode: debugSourceNode;
            debugSourceEnvironment: debugSourceEnvironment
    }.

    public method newTemporary: (name: Symbol) withType: (type: Type) ::=> MIRTemporaryVariable := {
        let temporary := function newTemporary: name withType: type.
        self setValueDebugInfo: temporary.
        temporary
    }.
}.

#(
    Int8BitNot Int16BitNot Int32BitNot Int64BitNot
    Int8Negate Int16Negate Int32Negate Int64Negate
    Int8LowBit Int16LowBit Int32LowBit Int64LowBit
    Int8HighBit Int16HighBit Int32HighBit Int64HighBit
    Int8PopCount Int16PopCount Int32PopCount Int64PopCount

    Float32Negate Float64Negate
    Float32Sqrt Float64Sqrt

    TruncateInt64ToInt32 TruncateInt64ToInt16 TruncateInt64ToInt8
    TruncateInt32ToInt16 TruncateInt32ToInt8
    TruncateInt16ToInt8

    SignExtendInt8ToInt16 SignExtendInt8ToInt32 SignExtendInt8ToInt64
    SignExtendInt16ToInt32 SignExtendInt16ToInt64
    SignExtendInt32ToInt64

    ZeroExtendInt8ToInt16 ZeroExtendInt8ToInt32 ZeroExtendInt8ToInt64
    ZeroExtendInt16ToInt32 ZeroExtendInt16ToInt64
    ZeroExtendInt32ToInt64

    UInt8ToFloat32 Int8ToFloat32 UInt16ToFloat32 Int16ToFloat32 UInt32ToFloat32 Int32ToFloat32 UInt64ToFloat32 Int64ToFloat32
    UInt8ToFloat64 Int8ToFloat64 UInt16ToFloat64 Int16ToFloat64 UInt32ToFloat64 Int32ToFloat64 UInt64ToFloat64 Int64ToFloat64

    Float32ToFloat64 Float32ToUInt8 Float32ToInt8 Float32ToUInt16 Float32ToInt16 Float32ToUInt32 Float32ToInt32 Float32ToUInt64 Float32ToInt64
    Float64ToFloat32 Float64ToUInt8 Float64ToInt8 Float64ToUInt16 Float64ToInt16 Float64ToUInt32 Float64ToInt32 Float64ToUInt64 Float64ToInt64
    Float32ToIEEEUInt32 Float64ToIEEEUInt64 IEEEUInt32ToFloat32 IEEEUInt64ToFloat64
    
) do: {:(Symbol)operationName :: Void |
    let operationNameString := operationName asString.
    let lowerOperationNameString := operationNameString first asLowercase asString -- operationNameString allButFirst.
    let lowerOperationName := lowerOperationNameString asSymbol.
    let operation := MIROperation named: lowerOperationName.
    let globalName := ("MIR::Operation::" -- operationNameString) asSymbol.

    MIRBlockBuilder
        withSelector: (lowerOperationNameString -- ":type:") asSymbol addMethod: {:(MIRBlockBuilder)self :(MIRValue)operand :(Type)type :: MIRInstruction |
            self operation: operation with: operand type: type.
        } makeFinal recompileAndOptimize.
    __OwnerProgramEntity__ setPublicSymbol: globalName value: operation
}.

#(
    Int8Add Int16Add Int32Add Int64Add PointerAdd
    Int8Sub Int16Sub Int32Sub Int64Sub PointerSub
    Int8Mul Int16Mul Int32Mul Int64Mul PointerMul
    Int8SDiv Int16SDiv Int32SDiv Int64SDiv
    Int8UDiv Int16UDiv Int32UDiv Int64UDiv
    Int8SRem Int16SRem Int32SRem Int64SRem
    Int8URem Int16URem Int32URem Int64URem

    Int8BitAnd Int16BitAnd Int32BitAnd Int64BitAnd
    Int8BitOr Int16BitOr Int32BitOr Int64BitOr
    Int8BitXor Int16BitXor Int32BitXor Int64BitXor
    Int8ArithmeticShiftRight Int16ArithmeticShiftRight Int32ArithmeticShiftRight Int64ArithmeticShiftRight
    Int8LogicalShiftLeft Int16LogicalShiftLeft Int32LogicalShiftLeft Int64LogicalShiftLeft
    Int8LogicalShiftRight Int16LogicalShiftRight Int32LogicalShiftRight Int64LogicalShiftRight

    Int8Compare Int16Compare Int32Compare Int64Compare

    Float32Add Float64Add
    Float32Sub Float64Sub
    Float32Mul Float64Mul
    Float32Div Float64Div

    Float32UnorderedCompare Float64UnorderedCompare
) do: {:(Symbol)operationName :: Void |
    let operationNameString := operationName asString.
    let lowerOperationNameString := operationNameString first asLowercase asString -- operationNameString allButFirst.
    let lowerOperationName := lowerOperationNameString asSymbol.
    let operation := MIROperation named: lowerOperationName.
    let globalName := ("MIR::Operation::" -- operationNameString) asSymbol.

    MIRBlockBuilder
        withSelector: (lowerOperationNameString -- ":with:type:") asSymbol addMethod: {:(MIRBlockBuilder)self :(MIRValue)left :(MIRValue)right :(Type)type :: MIRInstruction |
            self operation: operation with: left with: right type: type.
        } makeFinal recompileAndOptimize.
    __OwnerProgramEntity__ setPublicSymbol: globalName value: operation
}.

let ComparisonOperationToBranchMap := Dictionary new.

#(
    Int8Equals Int16Equals Int32Equals Int64Equals PointerEquals
    Int8NotEquals Int16NotEquals Int32NotEquals Int64NotEquals PointerNotEquals

    Int8LessThan Int16LessThan Int32LessThan Int64LessThan
    Int8LessOrEquals Int16LessOrEquals Int32LessOrEquals Int64LessOrEquals
    Int8GreaterThan Int16GreaterThan Int32GreaterThan Int64GreaterThan
    Int8GreaterOrEquals Int16GreaterOrEquals Int32GreaterOrEquals Int64GreaterOrEquals

    UInt8LessThan UInt16LessThan UInt32LessThan UInt64LessThan
    UInt8LessOrEquals UInt16LessOrEquals UInt32LessOrEquals UInt64LessOrEquals
    UInt8GreaterThan UInt16GreaterThan UInt32GreaterThan UInt64GreaterThan
    UInt8GreaterOrEquals UInt16GreaterOrEquals UInt32GreaterOrEquals UInt64GreaterOrEquals

    Float32UnorderedEquals Float64UnorderedEquals
    Float32UnorderedNotEquals Float64UnorderedNotEquals
    Float32UnorderedLessThan Float64UnorderedLessThan
    Float32UnorderedLessOrEquals Float64UnorderedLessOrEquals
    Float32UnorderedGreaterThan Float64UnorderedGreaterThan
    Float32UnorderedGreaterOrEquals Float64UnorderedGreaterOrEquals
) do: {:(Symbol)operationName :: Void |
    let operationNameString := operationName asString.
    let lowerOperationNameString := operationNameString first asLowercase asString -- operationNameString allButFirst.

    let branchOperationNameString := operationNameString -- "Branch".
    let lowerBranchOperationNameString := branchOperationNameString first asLowercase asString -- branchOperationNameString allButFirst.

    let operation := MIROperation named: lowerOperationNameString asSymbol.
    let globalName := ("MIR::Operation::" -- operationNameString) asSymbol.

    let branchOperation := MIROperation terminatorNamed: lowerBranchOperationNameString asSymbol.
    let branchGlobalName := ("MIR::Operation::" -- branchOperationNameString) asSymbol.

    MIRBlockBuilder
        withSelector: (lowerOperationNameString -- ":with:") asSymbol addMethod: {:(MIRBlockBuilder)self :(MIRValue)left :(MIRValue)right :: MIRInstruction |
            self operation: operation with: left with: right type: Boolean.
        } makeFinal recompileAndOptimize;
        withSelector: (lowerOperationNameString -- ":with:branchIfTrue:branchIfFalse:") asSymbol addMethod: {:(MIRBlockBuilder)self :(MIRValue)left :(MIRValue)right :(MIRValue)trueDestination :(MIRValue)falseDestination :: MIRInstruction |
            self operation: branchOperation with: left with: right with: trueDestination with: falseDestination.
        } makeFinal recompileAndOptimize.

    ComparisonOperationToBranchMap at: operation put: branchOperation.
    __OwnerProgramEntity__
        setPublicSymbol: globalName value: operation;
        setPublicSymbol: branchGlobalName value: branchOperation
}.

MIRFunction definition: {
    public method performBasicOptimizations => Void := {
        self fuseComparisonAndBranches
    }.

    public method fuseComparisonAndBranches => Void := {
        self basicBlocksDo: {:(MIRBasicBlock)eachBasicBlock :: Void |
            let position mutable := eachBasicBlock firstInstruction.
            while: position isNotNil do: {
                let nextPosition mutable := position next.
                nextPosition isNotNil &&
                (nextPosition operation == MIR::Operation::ConditionalBranch) &&
                (nextPosition operands first == position) && 
                (position userCount = 1sz) ifTrue: {
                    let positionOperation := position operation.
                    let comparisonAndBranchOperation => MIROperation := ComparisonOperationToBranchMap atOrNil: positionOperation.
                    comparisonAndBranchOperation ifNotNil: {
                        nextPosition unregisterFromUsedValues.
                        position
                            initializeWithType: Void compilationTarget: self compilationTarget;
                            operation: comparisonAndBranchOperation;
                            unregisterFromUsedValues;
                            operands: position operands -- nextPosition operands allButFirst;
                            registerInUsedValues;
                            next: nextPosition next.
                        eachBasicBlock lastInstruction == nextPosition ifTrue: {
                            eachBasicBlock lastInstruction: position
                        }.

                        nextPosition := nextPosition next
                    }.
                }.

                position := nextPosition.
            }
        }
    }.
}.

public final class MIRFunctionDefinitionPatch superclass: Object; definition: {
    public field functionDefinition => FunctionDefinition.
    public field checkedEntryPoint => MIRProgramEntity.
    public field uncheckedEntryPoint => MIRProgramEntity.
    public field uncheckedCapturelessEntryPoint => MIRProgramEntity.
}.

public final class MIRModule superclass: MIRProgramEntity; definition: {
    public field programEntities => OrderedCollection.
    public field baseObjectTracer => ImageTracer.
    public field functionDefinitionPatches => OrderedCollection.

    public override method initialize => Void := {
        super initialize.
        programEntities := OrderedCollection new.
        functionDefinitionPatches := OrderedCollection new.
    }.

    public method addProgramEntity: (programEntity: MIRProgramEntity) ::=> Void := {
        programEntities add: programEntity
    }.

    public method build: (name: Symbol) function: (aBlock: (MIRFunctionBuilder) => Void) ::=> MIRFunction := {
        let function := MIRFunction new
            compilationTarget: compilationTarget;
            callingConvention: compilationTarget defaultCallingConvention;
            name: name;
            yourself.
        self addProgramEntity: function.
        function build: aBlock; yourself
    }.

    public override method fullPrintOn: (stream: Stream) ::=> Void := {
        self programEntities do: {:(MIRProgramEntity)each :: Void |
            stream fullPrint: each; nl
        }
    }.

    public method asTargetIR => AnyValue
        := compilationTarget generateTargetIRForMIRModule: self
}.

MIRCallingConvention definition: {
    public abstract method computeArgumentPassingLayoutOf: (function: MIRFunction) ::=> Void
        := self subclassResponsibility.

    public abstract method integerCallPreservedRegisters => Array
        := self subclassResponsibility.
}.

MIRCompilationTarget definition: {
    public abstract method name => Symbol
        := self subclassResponsibility.

    public abstract method pointerSize => Size
        := self subclassResponsibility.

    public abstract method pointerAlignment => Size
        := self subclassResponsibility.

    public abstract method uintPointerType => Type
        := self subclassResponsibility.

    public abstract method stackFrameAlignment => Size
        := self subclassResponsibility.

    public abstract method allIntegerRegisters => Array
        := self subclassResponsibility.

    public abstract method allocableIntegerRegisters => Array
        := self subclassResponsibility.

    public abstract method allFloatRegisters => Array
        := self subclassResponsibility.

    public abstract method allocableFloatRegisters => Array
        := self subclassResponsibility.

    public abstract method allVectorRegisters => Array
        := self subclassResponsibility.

    public abstract method allocableVectorRegisters => Array
        := self subclassResponsibility.

    public abstract method usesVectorRegistersForFloatOperations => Boolean
        := self subclassResponsibility.

    public abstract method generateTargetIRForMIRModule: (module: MIRModule) ::=> AnyValue
        := self subclassResponsibility.

    public abstract method defaultCallingConvention => MIRCallingConvention
        := self subclassResponsibility.

    public virtual method objectModel => ObjectModelVariant
        := self pointerSize = 4sz ifTrue: ObjectModelVariant32 uniqueInstance ifFalse: ObjectModelVariant64 uniqueInstance.
}.
