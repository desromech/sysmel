let PrintingDebugInfo := false.

public final class MIRContext superclass: Object.
public abstract class MIRCompilationTarget superclass: Object.
public abstract class MIRCallingConvention superclass: Object.
public abstract class MIRValue superclass: Object.
public abstract class MIRLocalValue superclass: MIRValue.
public abstract class MIRInstruction superclass: MIRLocalValue.
public final class MIRLiveInterval superclass: Object.

public abstract class MIRRegisterAllocator superclass: Object.

public abstract class MIRPhysicalLocation superclass: Object; definition: {
    __Meta__ definition: {
        public virtual method isRegister => Boolean := false.
    }.

    public virtual method isMemory => Boolean := false.
    public virtual method isSpecificMemoryLocation => Boolean := false.
    public virtual method isImmediate => Boolean := false.
    public virtual method isRegister => Boolean := false.
    public virtual method isRegisterWithPointer => Boolean := false.
    public virtual method isRegisterSequence => Boolean := false.
    public virtual method isRegisterOrSequence => Boolean := false.
    public virtual method isIntegerRegister => Boolean := false.
    public virtual method isFloatRegister => Boolean := false.
    public virtual method isVectorRegister => Boolean := false.
    public virtual method canBeUsedForByte => Boolean := false.

    public virtual method firstComponent => MIRPhysicalLocation 
        := self error: "Physical location does not have multiple components.".

    public virtual method secondComponent => MIRPhysicalLocation 
        := self error: "Physical location does not have multiple components.".

    public virtual method addRegistersOnto: (aCollection: OrderedCollection) ::=> Void
        := self error: "Not a register or register sequence.".

    public virtual method addRegistersOntoSet: (set: ObjectPointerSet) ::=> Void
        := self error: "Not a register or register sequence.".

    public virtual method includesRegister: (register: MIRPhysicalLocation) ::=> Boolean
        := false.

    public virtual method includesRegisterInList: (list: Array) ::=> Boolean
        := false.

}.

public abstract class MIRPhysicalLocationMemory superclass: MIRPhysicalLocation; definition: {
    public override method isMemory => Boolean := true.

    __Meta__ definition: {
        let singleton := MIRPhysicalLocationMemory new.
        public method uniqueInstance => MIRPhysicalLocationMemory
            := singleton.
    }
}.

public abstract class MIRSpecificPhysicalMemoryLocation superclass: MIRPhysicalLocation; definition: {
    public field isCallArgument => Boolean.
    public field isStructure => Boolean.
    public field isPointer => Boolean.
    public field offset => Int64.
    public field scratchRegisters => Array.

    public override method isMemory => Boolean := true.
    public override method isSpecificMemoryLocation => Boolean := true.

    public method firstScratchRegister => MIRPhysicalLocation
        := scratchRegisters first.
}.

public final class MIRPhysicalLocationSpecificStackPointerOffset superclass: MIRSpecificPhysicalMemoryLocation; definition: {
}.

public abstract class MIRPhysicalLocationRegisterWithPointer superclass: MIRPhysicalLocation; definition: {
    public override method isRegisterWithPointer => Boolean := true.

    public field register => MIRPhysicalLocation.
}.

public abstract class MIRPhysicalLocationRegister superclass: MIRPhysicalLocation; definition: {
    __Meta__ definition: {
        public override method isRegister => Boolean := true.
    }.

    public override method isRegister => Boolean := true.
    public override method isRegisterOrSequence => Boolean := true.

    public override method addRegistersOnto: (aCollection: OrderedCollection) ::=> Void := {
        aCollection add: self
    }.

    public override method addRegistersOntoSet: (set: ObjectPointerSet) ::=> Void := {
        set add: self.
    }.


    public override method includesRegister: (register: MIRPhysicalLocation) ::=> Boolean
        := self == register.

    public override method includesRegisterInList: (list: Array) ::=> Boolean
        := list includes: self.
}.

public abstract class MIRPhysicalIntegerRegister superclass: MIRPhysicalLocationRegister; definition: {
    public override method isIntegerRegister => Boolean := true.
}.

public abstract class MIRPhysicalFloatRegister superclass: MIRPhysicalLocationRegister; definition: {
    public override method isFloatRegister => Boolean := true.
}.

public abstract class MIRPhysicalVectorRegister superclass: MIRPhysicalLocationRegister; definition: {
    public override method isVectorRegister => Boolean := true.
}.

public abstract class MIRPhysicalLocationRegisterSequence superclass: MIRPhysicalLocationRegister; definition: {
    public override method isRegisterSequence => Boolean := true.
    public override method isRegisterOrSequence => Boolean := true.

    public abstract method do: (aBlock: (MIRPhysicalLocationRegister => Void)) ::=> Void
        := self subclassResponsibility.
}.

MIRPhysicalLocation definition: {
    public virtual method includesRegisterOfSequence: (registerSequence: MIRPhysicalLocationRegisterSequence) ::=> Boolean
        := false.
}.

MIRPhysicalLocationRegister definition: {
    public override method includesRegisterOfSequence: (registerSequence: MIRPhysicalLocationRegisterSequence) ::=> Boolean
        := registerSequence includesRegister: self.
}.

public final class MIRPhysicalLocationRegisterPair superclass: MIRPhysicalLocationRegisterSequence; definition: {
    public field firstComponent => MIRPhysicalLocationRegister.
    public field secondComponent => MIRPhysicalLocationRegister.

    __Meta__ definition: {
        public method with: (first: MIRPhysicalLocationRegister) with: (second: MIRPhysicalLocationRegister) ::=> self
            := self new firstComponent: first; secondComponent: second; yourself.
    }.

    public override method isRegisterSequence => Boolean := true.

    public override method canBeUsedForByte => Boolean
        := firstComponent canBeUsedForByte || secondComponent canBeUsedForByte.

    public override method addRegistersOnto: (list: OrderedCollection) ::=> Void := {
        list add: firstComponent.
        list add: secondComponent.
    }.

    public override method addRegistersOntoSet: (set: ObjectPointerSet) ::=> Void := {
        set add: firstComponent.
        set add: secondComponent.
    }.

    public override method includesRegister: (register: MIRPhysicalLocation) ::=> Boolean
        := (self == register) || (firstComponent == register) || (secondComponent == register).

    public override method includesRegisterInList: (list: Array) ::=> Boolean
        := (list includes: self) || (list includes: firstComponent) || (list includes: secondComponent).

    public override method do: (aBlock: (MIRPhysicalLocationRegister => Void)) ::=> Void := {
        aBlock(firstComponent).
        aBlock(secondComponent).
    }.

    public override method includesRegisterOfSequence: (registerSequence: MIRPhysicalLocationRegisterSequence) ::=> Boolean
        := (registerSequence includesRegister: firstComponent) || (registerSequence includesRegister: secondComponent).

    public override method printOn: (aStream: Stream) ::=> Void := {
        aStream nextPut: '('c8; print: firstComponent; nextPutAll: ", "; print: secondComponent; nextPut: ')'c8
    }.
}.

public class MIRPhysicalLocationImmediate superclass: MIRPhysicalLocation; definition: {
    public field value => MIRValue.

    __Meta__ definition: {
        public method for: (value: MIRValue) ::=> self
            := self new value: value; yourself
    }.

    public virtual method isImmediate => Boolean := true.
}.

public class MIRPhysicalLocationValuePointerOrAssignedRegister superclass: MIRPhysicalLocation; definition: {
    public field value => MIRValue.

    __Meta__ definition: {
        public method for: (value: MIRValue) ::=> self
            := self new value: value; yourself
    }.
}.

public class MIRPhysicalLocationValuePointer superclass: MIRPhysicalLocation; definition: {
    public field value => MIRValue.
    public field isFatPointer => Boolean.

    __Meta__ definition: {
        public method for: (value: MIRValue) isFatPointer: (isFatPointer: Boolean) ::=> self
            := self new value: value; isFatPointer: isFatPointer; yourself
    }.
}.

Type extend: {
    public virtual method valueSizeForMirTarget: (target: MIRCompilationTarget) ::=> Size
        := target pointerSize.

    public virtual method valueAlignmentForMirTarget: (target: MIRCompilationTarget) ::=> Size
        := target pointerAlignment.

    ## FIXME: Implement these two methods properly.
    public virtual method instanceSizeForMirTarget: (target: MIRCompilationTarget) ::=> Size
        := self instanceSize.

    public virtual method instanceAlignmentForMirTarget: (target: MIRCompilationTarget) ::=> Size
        := self instanceAlignment.

    public virtual method valueMirPhysicalLocationClass => MIRPhysicalLocation class
        := MIRPhysicalIntegerRegister.

    public virtual method valueIsSignedExtended => Boolean := false.
}.

ValueType extend: {
    public override method valueSizeForMirTarget: (target: MIRCompilationTarget) ::=> Size
        := self valueSize.

    public override method valueAlignmentForMirTarget: (target: MIRCompilationTarget) ::=> Size
        := self valueAlignment.

    public override method valueMirPhysicalLocationClass => MIRPhysicalLocation class
        := MIRPhysicalLocationMemory.
}.

PointerLikeType extend: {
    public override method valueMirPhysicalLocationClass => MIRPhysicalLocation class
        := MIRPhysicalIntegerRegister.
}.

PrimitiveInteger class extend: {
    public override method valueMirPhysicalLocationClass => MIRPhysicalLocation class
        := MIRPhysicalIntegerRegister.
}.

Boolean class extend: {
    public override method valueMirPhysicalLocationClass => MIRPhysicalLocation class
        := MIRPhysicalIntegerRegister.
}.

PrimitiveFloat class extend: {
    public override method valueMirPhysicalLocationClass => MIRPhysicalLocation class
        := MIRPhysicalFloatRegister.
}.

Int8 class extend: {
    public override method valueIsSignedExtended => Boolean := true.
}.

Int16 class extend: {
    public override method valueIsSignedExtended => Boolean := true.
}.

Int32 class extend: {
    public override method valueIsSignedExtended => Boolean := true.
}.

Int64 class extend: {
    public override method valueIsSignedExtended => Boolean := true.
}.

MIRContext definition: {
    private field constants => ObjectPointerDictionary.

    public override method initialize => Void := {
        super initialize.
        constants := ObjectPointerDictionary new.
    }.
}.

MIRValue definition: {
    public field context => MIRContext.

    private field users => WeakOrderedCollection.
    public field sourceProgramEntity => ProgramEntity.

    __Meta__ definition: {
        public method forContext: (context: MIRContext) ::=> self
            := self new context: context; yourself
    }.

    public virtual method debugSourcePosition => SourcePosition := nil.
    public virtual method debugSourceNode => ASTNode := nil.
    public virtual method debugSourceEnvironment => Environment := nil.

    public virtual method type => Type
        := self subclassResponsibility.

    public virtual method physicalLocationClass => MIRPhysicalLocation class
        := self subclassResponsibility.

    public virtual method size => UInt64
        := self subclassResponsibility.

    public virtual method alignment => UInt64
        := self subclassResponsibility.

    public virtual method isSignedExtended => Boolean := false.
    public virtual method isFloatingPoint => Boolean := false.
    public virtual method isVector => Boolean := false.

    public virtual method isProgramEntity => Boolean := false.
    public virtual method isFunction => Boolean := false.
    public virtual method isLocalVariable => Boolean := false.

    public virtual method isBasicBlock => Boolean := false.

    public virtual method isVariable => Boolean := false.

    public virtual method isLocalValue => Boolean := false.
    public virtual method isArgumentVariable => Boolean := false.
    public virtual method isCaptureValue => Boolean := false.
    public virtual method isCaptureValueOrPointer => Boolean := false.
    public virtual method isTemporaryVariable => Boolean := false.
    public virtual method isGlobalVariable => Boolean := false.
    public virtual method isInstruction => Boolean := false.
    public virtual method isPhiInstruction => Boolean := false.

    public virtual method isValuePointer => Boolean := false.

    public virtual method isConstant => Boolean := false.
    public virtual method isConstantZero => Boolean := false.
    public virtual method isConstantInt8 => Boolean := false.
    public virtual method isConstantUInt8 => Boolean := false.
    public virtual method isConstantInt16 => Boolean := false.
    public virtual method isConstantUInt16 => Boolean := false.
    public virtual method isConstantInt32 => Boolean := false.
    public virtual method isConstantUInt32 => Boolean := false.
    public virtual method isConstantUInt32x2 => Boolean := false.
    public virtual method isConstantInt64 => Boolean := false.
    public virtual method isConstantUInt64 => Boolean := false.
    public virtual method isConstantUInt64x2 => Boolean := false.
    public virtual method isConstantFloat => Boolean := false.
    public virtual method isConstantFloat32 => Boolean := false.
    public virtual method isConstantFloat64 => Boolean := false.

    public virtual method isImmediate8 => Boolean := false.
    public virtual method isImmediate16 => Boolean := false.
    public virtual method isImmediate32 => Boolean := false.
    public virtual method isImmediateS32 => Boolean := false.
    public virtual method isImmediate64 => Boolean := self isImmediate32.
    public virtual method isRelativeImmediate32 => Boolean := false.

    public virtual method isImmediateU8 => Boolean := false.
    public virtual method isExternal => Boolean := false.
    public virtual method isThreadLocal => Boolean := false.

    public virtual method isNoGC => Boolean := false.

    public virtual method isDebug => Boolean := false.
    public virtual method isTerminator => Boolean := false.
    public virtual method isPure => Boolean := false.

    public virtual method getConstantValue64 => Int64
        := self error: "Not an immediate 64 constant".

    public virtual method coalescedAssignedRegister => MIRPhysicalLocation := nil.
    public virtual method clearCoalescedAssignedRegister => Void := {}.
    public virtual method markCoalescedMemoryCopyRequired => Void := {}.

    public method printDebugInfoOn: (stream: Stream) ::=> Void := {
        self debugSourcePosition isNotNil && PrintingDebugInfo ifTrue: {
            stream space; nextPutAll: "# at"; print: self debugSourcePosition
        }
    }.

    public virtual method usedValuesDo: (aBlock: (MIRValue) => Void) ::=> Void := {}.
    public virtual method replaceUsedValue: (usedValue: MIRValue) with: (replacement: MIRValue) ::=> Void := {}.

    public method usersDo: (aBlock: (MIRValue) => Void) ::=> Void := {
        users ifNotNil: {:users | users do: aBlock }
    }.

    public method replaceUser: (oldUser: MIRValue) with: (newUser: MIRValue) ::=> Void := {
        users ifNotNil: {
            (users includes: oldUser) ifTrue: {
                users replaceAll: oldUser with: newUser
            } ifFalse: {
                self registerUser: newUser
            }.
        }
    }.

    public virtual method replaceWith: (replacement: MIRValue) ::=> Void := {
        self == replacement ifTrue: (return: void).
        
        users ifNotNil: {
            users do: {:(MIRValue)user :: Void |
                user replaceUsedValue: self with: replacement.
                replacement registerUser: user
            }.
        }.

        self usedValuesDo: {:(MIRValue)usedValue :: Void |
            usedValue unregisterUser: self
        }.
    }.

    public method registerInUsedValues => Void := {
        self usedValuesDo: {:(MIRValue)each :: Void | each registerUser: self }
    }.

    public method unregisterFromUsedValues => Void := {
        self usedValuesDo: {:(MIRValue)each :: Void | each unregisterUser: self }
    }.

    public method registerUser: (user: MIRValue) ::=> Void := {
        users ifNil: {
            users := WeakOrderedCollection new
        }.

        users add: user
    }.

    public method unregisterUser: (user: MIRValue) ::=> Void := {
        users ifNotNil: {
            users removeAllOcurrencesOf: user
        }.
    }.

    public override method postCopy => Void := {
        super postCopy.
        users := nil
    }.

    public method userCount => Size
        := users ifNil: 0sz ifNotNil: users size.
}.

public final class MIRBasicBlock superclass: MIRLocalValue.

public abstract class MIRProgramEntity superclass: MIRValue; definition: {
    public field debugSourcePosition => SourcePosition.
    public field debugSourceNode => ASTNode.
    public field debugSourceEnvironment => Environment.

    public field name => Symbol.
    public field compilationTarget => MIRCompilationTarget.
    public field exportedSymbols => Array.

    ## TODO: Add proper support for the different visibility levels.
    public field isWeak => Boolean.
    public field isPublic => Boolean.
    public field isPrivate => Boolean.

    public method makeWeak => Void := {
        isWeak := true.
    }.

    public method makePrivate => Void := {
        isPrivate := true.
    }.

    public override method isProgramEntity => Boolean := true.

    public virtual method callingConvention => MIRCallingConvention
        := self error: "Not a function with a defined calling convention.".

    public override method initialize => Void := {
        exportedSymbols := #().
    }.

    public method addExportedSymbols: (extraSymbols: Array) ::=> Void := {
        exportedSymbols := exportedSymbols -- extraSymbols
    }.

    public virtual method performStandardOptimizations => Void := {

    }.
}.

public final class MIRFunction superclass: MIRProgramEntity.

public abstract class MIRImportedProgramEntity superclass: MIRProgramEntity; definition: {
    public field callingConvention => MIRCallingConvention.
    public field alternativeSymbols => Array.

    public override method physicalLocationClass => MIRPhysicalLocation class
        := MIRPhysicalIntegerRegister.
}.

public final class MIRImportedVariable superclass: MIRImportedProgramEntity; definition: {
    public field type => Type.
    public field size => UInt64.
    public field alignment => UInt64.
    public field physicalLocationClass => MIRPhysicalLocation class.
}.

public final class MIRImportedFunction superclass: MIRImportedProgramEntity; definition: {
    public override method physicalLocationClass => MIRPhysicalLocation class
        := MIRPhysicalIntegerRegister.

    public override method isRelativeImmediate32 => Boolean := true.

    public override method printOn: (stream: Stream) ::=> Void := {
        stream nextPutAll: "importedFunction".
        name ifNotNil: (stream space; string: name).
    }.

    public override method fullPrintOn: (stream: Stream) ::=> Void := {
        stream print: self; nextPutAll: " [".
        alternativeSymbols doWithIndex: {:each :(Size)index :: Void |
            index > 0sz ifTrue: (stream nextPutAll: ", ").
            stream string: each.
        }.
        stream nextPut: ']'c8.
        self printDebugInfoOn: stream.
    }.
}.

MIRLocalValue definition: {
    public field debugSourcePosition => SourcePosition.
    public field debugSourceNode => ASTNode.
    public field debugSourceEnvironment => Environment.

    public field name => Symbol.
    public field index => UInt32.

    public readonly field type => Type.
    public field size => UInt64.
    public field alignment => UInt64.
    public field physicalLocationClass => MIRPhysicalLocation class.
    public field isSignedExtended => Boolean.
    public field isValueInstance => Boolean.
    public field gcRootEntryType => GCRootEntryType.

    public field hasValidStackSegmentOffset => Boolean.
    public field stackSegment => UInt8.
    public field stackSegmentOffset => UInt64.
    public field stackValueIsPointer => Boolean.

    public field hasValidStackAnchorOffset => Boolean.
    public field offset => Int64. ## Offset from frame pointer or stack pointer.
    public field assignedRegister => MIRPhysicalLocation.

    public field needsSpilling => Boolean.
    public field liveInterval => MIRLiveInterval.
    public field hasPointerUsage => Boolean.

    public field sourceBinding => SymbolBinding.
    public field coalescedParent => MIRLocalValue.

    __Meta__ definition: {
        public method withName: (name: Symbol) type: (type: Type) compilationTarget: (compilationTarget: MIRCompilationTarget) ::=> self
            := self new
                name: name;
                initializeWithType: type compilationTarget: compilationTarget;
                yourself.

        public method withType: (type: Type) compilationTarget: (compilationTarget: MIRCompilationTarget) ::=> self
            := self new initializeWithType: type compilationTarget: compilationTarget; yourself.
    }.

    public virtual method initializeWithType: (newType: Type) compilationTarget: (compilationTarget: MIRCompilationTarget) ::=> Void := {
        self assert: newType isNotNil.
        type := newType.
        size := (type valueSizeForMirTarget: compilationTarget) asUInt64.
        alignment := (type valueAlignmentForMirTarget: compilationTarget) asUInt64.
        gcRootEntryType := type gcRootEntryType.
        physicalLocationClass := type valueMirPhysicalLocationClass.
        coalescedParent := self.
    }.

    public method isGCRoot => Boolean
        := gcRootEntryType ~= GCRootEntryType::None.

    public override method coalescedAssignedRegister => MIRPhysicalLocation
        := self validCoalescedValue assignedRegister.

    public method coalesceWith: (otherValue: MIRLocalValue) ::=> Void := {
        let leftParent := self validCoalescedValue.
        let rightParent := otherValue validCoalescedValue.
        leftParent coalescedParent: rightParent
    }.

    public method validCoalescedValue => MIRLocalValue := {
        coalescedParent ~~ self ifTrue: {
            coalescedParent := coalescedParent validCoalescedValue.
        }.

        self assert: coalescedParent ~~ nil.
        coalescedParent
    }.

    public override method clearCoalescedAssignedRegister => Void := {
        self validCoalescedValue assignedRegister: nil
    }.

    public override method markCoalescedMemoryCopyRequired ::=> Void := {
        self validCoalescedValue needsSpilling: true
    }.

    public method needsStackAllocation => Boolean
        := self hasValidType && (self hasPointerUsage || self needsSpilling || (assignedRegister isNil && (self userCount > 0sz))).

    public override method isLocalVariable => Boolean := true.

    public method resetCoalescing => Void := {
        coalescedParent := self.
    }.

    public virtual method resetRegisterAllocation => Void := {
        assignedRegister := nil.
    }.

    public virtual method parentBlock => MIRBasicBlock := nil.

    public virtual method usageIndexFor: (usedValue: MIRLocalValue) ::=> UInt32
        := index.

    public virtual method computeLiveInterval => Void := {
        liveInterval := MIRLiveInterval for: self.

        hasPointerUsage := false.
        self usersDo: {:(MIRValue)each :: Void |
            each isLocalValue ifTrue: {
                liveInterval insertUsage: ((each downCastTo: MIRLocalValue) usageIndexFor: self).
            } ifFalse: {
                each isValuePointer ifTrue: {
                    hasPointerUsage := true.
                }
            }
        }.
    }.

    public override method isLocalValue => Boolean := true.

    public override method isFloatingPoint => Boolean := type asDecayedType isPrimitiveFloatType.
    public override method isVector => Boolean := type asDecayedType isPrimitiveVectorType.

    public method hasValidType => Boolean := type isVoidType not.
}.

public class MIRSpecialLocalValue superclass: MIRLocalValue; definition: {
}.

public final class MIRCaptureVectorPointerValue superclass: MIRSpecialLocalValue; definition: {
    public field closure => MIRLocalValue.
    public field closureRegister => MIRPhysicalLocation.
    public field loadRegister => MIRPhysicalLocation.
}.

public final class MIRThreadLocalSegmentPointerValue superclass: MIRSpecialLocalValue; definition: {
    public field segmentIndexRegister => MIRPhysicalLocation.
    public field segmentPointerVectorRegister => MIRPhysicalLocation.
    public field loadRegister => MIRPhysicalLocation.
}.

public final class MIRGotPointerValue superclass: MIRSpecialLocalValue; definition: {
    public field loadRegister => MIRPhysicalLocation.
}.

public final class MIRLocalVariable superclass: MIRLocalValue; definition: {
}.

public final class MIRArgumentValue superclass: MIRLocalValue; definition: {
    public field passingRegister => MIRPhysicalLocation.
    public field isResultPointer => Boolean.

    public override method isArgumentVariable => Boolean := true.

    public override method printOn: (stream: Stream) ::=> Void := {
        stream nextPut: 'a'c8; print: index.
        name ifNotNil: (stream space; string: name)
    }.
}.

public final class MIRCaptureVariable superclass: MIRLocalVariable; definition: {
    public override method isCaptureValue => Boolean := true.
    public override method isCaptureValueOrPointer => Boolean := true.

    public override method printOn: (stream: Stream) ::=> Void := {
        stream nextPut: 'c'c8; print: index.
        name ifNotNil: (stream space; string: name)
    }.
}.

public final class MIRTemporaryVariable superclass: MIRLocalVariable; definition: {
    public override method isTemporaryVariable => Boolean := true.

    public override method printOn: (stream: Stream) ::=> Void := {
        stream nextPut: 't'c8; print: index.
        name ifNotNil: (stream space; string: name)
    }.
}.

public final class MIRGlobalVariable superclass: MIRProgramEntity; definition: {
    public field type => Type.
    public field size => UInt64.
    public field alignment => UInt64.

    public field valueType => Type.
    public field valueSize => UInt64.
    public field valueAlignment => UInt64.
    public field isSignedExtended => Boolean.
    public field isValueInstance => Boolean.
    public field gcRootEntryType => GCRootEntryType.
    public field isReadOnly => Boolean.
    public field isExternal => Boolean.
    public field isThreadLocal => Boolean.
    public field initialValue => MIRValue.

    public override method isVariable => Boolean := true.
    public override method isGlobalVariable => Boolean := true.

    public override method physicalLocationClass => MIRPhysicalLocation class := MIRPhysicalIntegerRegister.

    __Meta__ definition: {
        public method withName: (name: Symbol) type: (type: Type) valueType: (valueType: Type) isValueInstance: (isValueInstance: Boolean) compilationTarget: (compilationTarget: MIRCompilationTarget) ::=> self
            := self new
                name: name;
                initializeWithType: type valueType: valueType isValueInstance: isValueInstance compilationTarget: compilationTarget;
                yourself.

        public method withType: (type: Type) valueType: (valueType: Type) isValueInstance: (isValueInstance: Boolean) compilationTarget: (compilationTarget: MIRCompilationTarget) ::=> self
            := self new initializeWithType: type valueType: valueType isValueInstance: isValueInstance compilationTarget: compilationTarget; yourself.
    }.
    
    public method initializeWithType: (newType: Type) valueType: (newValueType: Type) isValueInstance: (newIsValueInstance: Boolean)  compilationTarget: (compilationTarget: MIRCompilationTarget) ::=> Void := {
        self assert: newType isNotNil.
        type := newType.
        size := (type valueSizeForMirTarget: compilationTarget) asUInt64.
        alignment := (type valueAlignmentForMirTarget: compilationTarget) asUInt64.            

        isValueInstance := newIsValueInstance.
        valueType := newValueType.
        isValueInstance ifTrue: {
            valueSize := (valueType instanceSizeForMirTarget: compilationTarget) asUInt64.
            valueAlignment := (valueType instanceAlignmentForMirTarget: compilationTarget) asUInt64.
        } ifFalse: {
            valueSize := (valueType valueSizeForMirTarget: compilationTarget) asUInt64.
            valueAlignment := (valueType valueAlignmentForMirTarget: compilationTarget) asUInt64.            
        }.
        gcRootEntryType := valueType gcRootEntryType.
    }.

    public override method printOn: (stream: Stream) ::=> Void := {
        stream nextPutAll: "global".
        name ifNotNil: (stream space; string: name).
        isExternal ifTrue: (stream nextPutAll: " external").
        isThreadLocal ifTrue: (stream nextPutAll: " threadLocal").
    }.

    public override method fullPrintOn: (stream: Stream) ::=> Void := {
        stream print: self; nextPutAll: " => "; print: type.
        self printDebugInfoOn: stream.
    }.
}.

public final class MIRValuePointer superclass: MIRValue; definition: {
    public field value => MIRValue.
    public field type => Type.
    public field size => UInt64.
    public field alignment => UInt64.

    public override method physicalLocationClass => MIRPhysicalLocation class
        := MIRPhysicalIntegerRegister.

    public method initializeWithType: (newType: Type) compilationTarget: (compilationTarget: MIRCompilationTarget) ::=> Void := {
        type := newType.
        size := type valueSize.
        alignment := type valueAlignment.
    }.

    public override method isValuePointer => Boolean := true.
    public override method isCaptureValueOrPointer => Boolean := value isCaptureValue.

    public override method usedValuesDo: (aBlock: (MIRValue) => Void) ::=> Void := {
        aBlock(value)
    }.

    public override method replaceUsedValue: (usedValue: MIRValue) with: (replacement: MIRValue) ::=> Void := {
        value == usedValue ifTrue: {
            value := replacement
        }
    }.

    public override method physicalLocationClass => MIRPhysicalLocation class
        := MIRPhysicalIntegerRegister.

    public override method printOn: (stream: Stream) ::=> Void := {
        stream print: value; nextPutAll: (type validAddressSpace isFatPointer ifTrue: " fatAddress" ifFalse: " address").
    }.
}.

MIRLocalValue definition: {
    public method asValuePointerWithType: (type: Type) compilationTarget: (compilationTarget: MIRCompilationTarget) ::=> MIRValuePointer
        := MIRValuePointer new
            value: self;
            initializeWithType: type compilationTarget: compilationTarget;
            registerInUsedValues;
            yourself.
}.

public abstract class MIRConstant superclass: MIRValue; definition: {
    public override method isConstant => Boolean := true.
}.

public abstract class MIRConstantInteger superclass: MIRConstant; definition: {
    public override method isConstant => Boolean := true.

    public override method physicalLocationClass => MIRPhysicalLocation class
        := MIRPhysicalIntegerRegister.
}.

public final class MIRGenericObjectPointerConstant superclass: MIRConstant; definition: {
    public field object => Untyped.
    public field size => Size.
    public field alignment => Size.
    public field type => Type.

    public override method physicalLocationClass => MIRPhysicalLocation class
        := MIRPhysicalIntegerRegister.

    public override method printOn: (stream: Stream) ::=> Void := {
        stream nextPutAll: "genericObjectPointerConstant("; print: RawTuple::type(self object); nextPut: ')'c8
    }.
}.

public final class MIRPolymorphicInlineCache superclass: MIRConstant; definition: {
    public override method alignment => Size := UIntPointer valueAlignment.
    public override method size => Size := UIntPointer valueSize.
    public override method type => Type := ObjectModel::PolymorphicInlineCache.

    public override method physicalLocationClass => MIRPhysicalLocation class
        := MIRPhysicalIntegerRegister.

    public override method printOn: (stream: Stream) ::=> Void := {
        stream nextPutAll: "polymorphicInlineCache"
    }.
}.

public final class MIRStringLiteralPointerConstant superclass: MIRConstant; definition: {
    public field string => String.
    public field size => Size.
    public field alignment => Size.
    public field type => Type.
    public field nullTerminated => Boolean.

    public override method physicalLocationClass => MIRPhysicalLocation class
        := MIRPhysicalIntegerRegister.

    public override method printOn: (stream: Stream) ::=> Void := {
        stream nextPutAll: "stringLiteralPointerConstant("; print: string; nextPut: ')'c8
    }.
}.

public final class MIRStructureConstant superclass: MIRConstant; definition: {
    public field value => AnyValue.
    public field size => Size.
    public field alignment => Size.
    public field type => Type.

    public override method physicalLocationClass => MIRPhysicalLocation class
        := MIRPhysicalLocationMemory.

    public override method printOn: (stream: Stream) ::=> Void := {
        stream nextPutAll: "structureConstant("; print: value; nextPut: ')'c8
    }.
}.

public final class MIRConstantInt8 superclass: MIRConstantInteger; definition: {
    public field value => Int8.

    public override method isSignedExtended => Boolean := true.
    public override method isConstantInt8 => Boolean := true.
    public override method isImmediate8 => Boolean := true.
    public override method isImmediateU8 => Boolean := value >= 0i8.
    public override method isImmediate16 => Boolean := true.
    public override method isImmediate32 => Boolean := true.

    public override method isConstantZero => Boolean := value = 0i8.

    public override method type => Type := Int8.
    public override method size => UInt64 := 1u64.
    public override method alignment => UInt64 := 1u64.

    public override method getConstantValue64 => Int64 := value asInt64.

    public override method printOn: (stream: Stream) ::=> Void := {
        stream print: value; nextPutAll: "i8"
    }.
}.

public final class MIRConstantUInt8 superclass: MIRConstantInteger; definition: {
    public field value => UInt8.

    public override method isConstantUInt8 => Boolean := true.
    public override method isImmediate8 => Boolean := true.
    public override method isImmediateU8 => Boolean := true.
    public override method isImmediate16 => Boolean := true.
    public override method isImmediate32 => Boolean := true.

    public override method isConstantZero => Boolean := value = 0u8.

    public override method type => Type := UInt8.
    public override method size => UInt64 := 1u64.
    public override method alignment => UInt64 := 1u64.
    
    public override method getConstantValue64 => Int64 := value asInt64.

    public override method printOn: (stream: Stream) ::=> Void := {
        stream print: value; nextPutAll: "u8"
    }.
}.

public final class MIRConstantInt16 superclass: MIRConstantInteger; definition: {
    public field value => Int16.

    public override method isSignedExtended => Boolean := true.
    public override method isConstantInt16 => Boolean := true.
    public override method isImmediateU8 => Boolean := (0i16 <= value) && (value <= 16rff i16).
    public override method isImmediate16 => Boolean := true.
    public override method isImmediate32 => Boolean := true.

    public override method isConstantZero => Boolean := value = 0i16.

    public override method type => Type := Int16.
    public override method size => UInt64 := 2u64.
    public override method alignment => UInt64 := 2u64.

    public override method getConstantValue64 => Int64 := value asInt64.

    public override method printOn: (stream: Stream) ::=> Void := {
        stream print: value; nextPutAll: "i16"
    }.
}.

public final class MIRConstantUInt16 superclass: MIRConstantInteger; definition: {
    public field value => UInt16.

    public override method isConstantUInt16 => Boolean := true.
    public override method isImmediateU8 => Boolean := value <= 16rff u16.
    public override method isImmediate16 => Boolean := true.
    public override method isImmediate32 => Boolean := true.

    public override method isConstantZero => Boolean := value = 0u16.

    public override method type => Type := UInt16.
    public override method size => UInt64 := 2u64.
    public override method alignment => UInt64 := 2u64.

    public override method getConstantValue64 => Int64 := value asInt64.

    public override method printOn: (stream: Stream) ::=> Void := {
        stream print: value; nextPutAll: "u16"
    }.
}.

public final class MIRConstantInt32 superclass: MIRConstantInteger; definition: {
    public field value => Int32.

    public override method isSignedExtended => Boolean := true.
    public override method isConstantInt32 => Boolean := true.
    public override method isImmediateU8 => Boolean := (0i32 <= value) && (value <= 16rff i32).
    public override method isImmediate32 => Boolean := true.
    public override method isImmediateS32 => Boolean := true.

    public override method isConstantZero => Boolean := value = 0i32.

    public override method type => Type := Int32.
    public override method size => UInt64 := 4u64.
    public override method alignment => UInt64 := 4u64.

    public override method getConstantValue64 => Int64 := value asInt64.

    public override method printOn: (stream: Stream) ::=> Void := {
        stream print: value; nextPutAll: "i32"
    }.
}.

public final class MIRConstantUInt32 superclass: MIRConstantInteger; definition: {
    public field value => UInt32.

    public override method isConstantUInt32 => Boolean := true.
    public override method isImmediateU8 => Boolean := value <= 16rff u32.
    public override method isImmediate32 => Boolean := true.
    public override method isImmediateS32 => Boolean := value <= 16r7FFFFFFF u32.

    public override method isConstantZero => Boolean := value = 0u32.

    public override method type => Type := UInt32.
    public override method size => UInt64 := 4u64.
    public override method alignment => UInt64 := 4u64.

    public override method getConstantValue64 => Int64 := value asInt64.

    public override method printOn: (stream: Stream) ::=> Void := {
        stream print: value; nextPutAll: "u32"
    }.
}.

public final class MIRConstantUInt32x2 superclass: MIRConstantInteger; definition: {
    public field first => UInt32.
    public field second => UInt32.

    public override method isConstantUInt32x2 => Boolean := true.
    public override method isConstantZero => Boolean := (first = 0u32) && (second = 0u32).

    public override method type => Type := UInt32.
    public override method size => UInt64 := 8u64.
    public override method alignment => UInt64 := 4u64.

    public override method printOn: (stream: Stream) ::=> Void := {
        stream nextPutAll: "u32x2("; print: first; nextPutAll: ", "; print: second; nextPut: ')'c8
    }.
}.

public final class MIRConstantInt64 superclass: MIRConstantInteger; definition: {
    public field value => Int64.

    public override method isSignedExtended => Boolean := true.
    public override method isConstantInt64 => Boolean := true.
    public override method isImmediate64 => Boolean := true.
    public override method isImmediateU8 => Boolean := (0i64 <= value) && (value <= 16rff i64).
    public override method isImmediateS32 => Boolean := value asInt32 asInt64 = value.

    public override method isConstantZero => Boolean := value = 0i64.

    public override method type => Type := Int64.
    public override method alignment => UInt64 := 8u64.
    public override method size => UInt64 := 8u64.
    
    public override method getConstantValue64 => Int64 := value.

    public override method printOn: (stream: Stream) ::=> Void := {
        stream print: value; nextPutAll: "i64"
    }.
}.

public final class MIRConstantUInt64 superclass: MIRConstantInteger; definition: {
    public field value => UInt64.

    public override method isConstantUInt64 => Boolean := true.
    public override method isImmediateU8 => Boolean := value <= 16rff u64.
    public override method isImmediateS32 => Boolean := value asInt32 asInt64 asUInt64 = value.
    public override method isImmediate64 => Boolean := true.

    public override method isConstantZero => Boolean := value = 0u64.

    public override method getConstantValue64 => Int64 := value asInt64.

    public override method type => Type := UInt64.
    public override method alignment => UInt64 := 8u64.
    public override method size => UInt64 := 8u64.

    public override method printOn: (stream: Stream) ::=> Void := {
        stream print: value; nextPutAll: "u64"
    }.
}.

public final class MIRConstantUInt64x2 superclass: MIRConstantInteger; definition: {
    public field first => UInt64.
    public field second => UInt64.

    public override method isConstantUInt64x2 => Boolean := true.
    public override method isConstantZero => Boolean := (first = 0u64) && (second = 0u64).

    public override method type => Type := UInt64.
    public override method alignment => UInt64 := 16u64.
    public override method size => UInt64 := 8u64.

    public override method printOn: (stream: Stream) ::=> Void := {
        stream nextPutAll: "u64x2("; print: first; nextPutAll: ", "; print: second; nextPut: ')'c8
    }.
}.

public final class MIRConstantFloatingPoint superclass: MIRConstant; definition: {
    public override method isFloatingPoint => Boolean := true.
    public override method isConstantFloat => Boolean := true.

    public override method physicalLocationClass => MIRPhysicalLocation class
        := MIRPhysicalFloatRegister.
}.

public final class MIRConstantFloat32 superclass: MIRConstantFloatingPoint; definition: {
    public field value => Float32.

    public override method isConstantFloat32 => Boolean := true.
    public override method isImmediate32 => Boolean := true.

    public override method type => Type := Float32.
    public override method alignment => UInt64 := 4u64.
    public override method size => UInt64 := 4u64.

    public override method printOn: (stream: Stream) ::=> Void := {
        stream print: value; nextPutAll: "f32"
    }.
}.

public final class MIRConstantFloat64 superclass: MIRConstantFloatingPoint; definition: {
    public field value => Float64.

    public override method isConstantFloat64 => Boolean := true.
    public override method isImmediate64 => Boolean := true.

    public override method type => Type := Float64.
    public override method alignment => UInt64 := 8u64.
    public override method size => UInt64 := 8u64.

    public override method printOn: (stream: Stream) ::=> Void := {
        stream print: value; nextPutAll: "f64"
    }.
}.

MIRContext definition: {
    public method uint8: (value: UInt8) ::=> MIRConstantUInt8
        := constants at: value ifAbsentPut: {:: MIRConstantUInt8 |
            (MIRConstantUInt8 forContext: self)
                value: value;
                yourself
        }.

    public method int8: (value: Int8) ::=> MIRConstantInt8
        := constants at: value ifAbsentPut: {:: MIRConstantInt8 |
            (MIRConstantInt8 forContext: self)
                value: value;
                yourself
        }.


    public method uint16: (value: UInt16) ::=> MIRConstantUInt16
        := constants at: value ifAbsentPut: {:: MIRConstantUInt16 |
            (MIRConstantUInt16 forContext: self)
                value: value;
                yourself
        }.

    public method int16: (value: Int16) ::=> MIRConstantInt16
        := constants at: value ifAbsentPut: {:: MIRConstantInt16 |
            (MIRConstantInt16 forContext: self)
                value: value;
                yourself
        }.

    public method uint32: (value: UInt32) ::=> MIRConstantUInt32
        := constants at: value ifAbsentPut: {:: MIRConstantUInt32 |
            (MIRConstantUInt32 forContext: self)
                value: value;
                yourself
        }.

    public method int32: (value: Int32) ::=> MIRConstantInt32
        := constants at: value ifAbsentPut: {:: MIRConstantInt32 |
            (MIRConstantInt32 forContext: self)
                value: value;
                yourself
        }.

    public method uint64: (value: UInt64) ::=> MIRConstantUInt64
        := constants at: value ifAbsentPut: {:: MIRConstantUInt64 |
            (MIRConstantUInt64 forContext: self)
                value: value;
                yourself
        }.

    public method int64: (value: Int64) ::=> MIRConstantInt64
        := constants at: value ifAbsentPut: {:: MIRConstantInt64 |
            (MIRConstantInt64 forContext: self)
                value: value;
                yourself
        }.

    public method float32: (value: Float32) ::=> MIRConstantFloat32
        := constants at: value ifAbsentPut: {:: MIRConstantFloat32 |
            (MIRConstantFloat32 forContext: self)
                value: value;
                yourself
        }.

    public method float64: (value: Float64) ::=> MIRConstantFloat64
        := constants at: value ifAbsentPut: {:: MIRConstantFloat64 |
            (MIRConstantFloat64 forContext: self)
                value: value;
                yourself
        }.

    public method voidConstant => MIRConstant
        := self uint8: 0u8.
}.

public final class MIROperationTargetSpecific superclass: Object; definition: {
    public field registerConstraints => ((MIRInstruction, MIRRegisterAllocator) => Void).
    public field codeGenerator => AnyValue.
}.

public final class MIROperation superclass: Object; definition: {
    public field name => Symbol.
    public field phiMoveOperation => MIROperation.
    public field isAssociative => Boolean.
    public field isCall => Boolean.
    public field isDebug => Boolean.
    public field isCommutative => Boolean.
    public field isLoad => Boolean.
    public field isMove => Boolean.
    public field isPure => Boolean.
    public field isStore => Boolean.
    public field isTerminator => Boolean.

    public field x86 => MIROperationTargetSpecific.
    public field x86_64 => MIROperationTargetSpecific.
    public field arm => MIROperationTargetSpecific.
    public field arm64 => MIROperationTargetSpecific.
    public field riscv32 => MIROperationTargetSpecific.
    public field riscv64 => MIROperationTargetSpecific.

    public field constantFoldingRules => Array.

    public method isPhi => Boolean
        := phiMoveOperation ~~ nil.

    __Meta__ definition: {
        public method named: (name: Symbol) ::=> self
            := self new name: name; yourself.

        public method pureNamed: (name: Symbol) ::=> self
            := self new name: name; isPure: true; yourself.

        public method callNamed: (name: Symbol) ::=> self
            := self new name: name; isCall: true; yourself.

        public method loadNamed: (name: Symbol) ::=> self
            := self new name: name; isLoad: true; yourself.

        public method storeNamed: (name: Symbol) ::=> self
            := self new name: name; isStore: true; yourself.

        public method loadStoreNamed: (name: Symbol) ::=> self
            := self new name: name; isLoad: true; isStore: true; yourself.

        public method moveNamed: (name: Symbol) ::=> self
            := self new name: name; isPure: true; isMove: true; yourself.

        public method phiNamed: (name: Symbol) moveOperation: (moveOperation: MIROperation) ::=> self
            := self new name: name; phiMoveOperation: moveOperation; yourself.

        public method terminatorNamed: (name: Symbol) ::=> self
            := self new name: name; isTerminator: true; yourself.

        public method debugNamed: (name: Symbol) ::=> self
            := self new name: name; isDebug: true; yourself.
    }.

    public override method initialize => Void := {
        x86 := MIROperationTargetSpecific new.
        x86_64 := MIROperationTargetSpecific new.
        arm := MIROperationTargetSpecific new.
        arm64 := MIROperationTargetSpecific new.
        riscv32 := MIROperationTargetSpecific new.
        riscv64 := MIROperationTargetSpecific new.
        constantFoldingRules := #().
    }.

    public override method printOn: (stream: Stream) ::=> Void := {
        stream string: name
    }.
}.

MIRValue definition: {
    public virtual method isInstructionWithOperation: (operation: MIROperation) ::=> Boolean
        := false.
}.

MIRInstruction definition: {
    public field parentBlock => MIRBasicBlock.
    public field previous => MIRInstruction.
    public field next => MIRInstruction.

    public field operation => MIROperation.
    public field operands => Array.

    public field resultRegister => MIRPhysicalLocation.
    public field operandRegisters => Array.
    public field scratchRegisters => Array.

    public field captureVectorPointerValue => MIRCaptureVectorPointerValue.
    public field captureVectorPointerRegister => MIRPhysicalLocation.

    public field gotPointerValue => MIRThreadLocalSegmentPointerValue.
    public field gotPointerRegister => MIRPhysicalLocation.

    public field threadLocalSegmentPointerValue => MIRThreadLocalSegmentPointerValue.
    public field threadLocalSegmentPointerRegister => MIRPhysicalLocation.

    public field callingConvention => MIRCallingConvention.
    public field targetPhi => MIRInstruction.

    public override method initialize => Void := {
        super initialize.
        operands := #().
    }.

    public method firstOperand => MIRValue := operands first.
    public method secondOperand => MIRValue := operands second.
    public method thirdOperand => MIRValue := operands third.
    public method fourthOperand => MIRValue := operands fourth.

    public method firstOperandRegister => MIRPhysicalLocation := operandRegisters first.
    public method secondOperandRegister => MIRPhysicalLocation := operandRegisters second.
    public method thirdOperandRegister => MIRPhysicalLocation := operandRegisters third.
    public method fourthOperandRegister => MIRPhysicalLocation := operandRegisters fourth.

    public method firstScratchRegister => MIRPhysicalLocation := scratchRegisters first.
    public method secondScratchRegister => MIRPhysicalLocation := scratchRegisters first.

    public override method isTerminator => Boolean := operation isTerminator.
    public override method isDebug => Boolean := operation isDebug.
    public override method isPure => Boolean := operation isPure.

    public override method isInstruction => Boolean := true.
    public override method isPhiInstruction => Boolean := operation isPhi.

    public override method isInstructionWithOperation: (operationToTest: MIROperation) ::=> Boolean
        := operation == operationToTest.

    public method scratchRegisterCount: (count: Size) ::=> Void := {
        scratchRegisters := Array new: count
    }.

    public override method printOn: (stream: Stream) ::=> Void := {
        stream nextPut: '$'c8; print: index
    }.

    public override method fullPrintOn: (stream: Stream) ::=> Void := {
        self hasValidType ifTrue: {
            stream print: self; nextPutAll: " := ".
        }.
        stream print: operation.
        operation isPhi ifTrue: {
            operands isEmpty ifFalse: {
                stream nextPutAll: " [".
                operands pairsDo: {:(MIRValue)block :(MIRValue)value :: Void |
                    stream nl; nextPutAll: "        "; print: block; nextPutAll: " -> "; print: value
                }.

                stream nl; nextPutAll: "    "; nextPut: ']'c8.
            }.
        } ifFalse: {
            operands doWithIndex: {:(MIRValue)eachOperand :(Size)index :: Void |
                index = 0sz
                    ifTrue: (stream space)
                    ifFalse: (stream nextPutAll: ", ").
                stream print: eachOperand
            }.
        }.

        self validCoalescedValue ~~ self ifTrue: {
            stream nextPutAll: " ## Coalesced with "; print: self validCoalescedValue
        }.

        let register := self coalescedAssignedRegister.
        register ifNotNil: {
            stream nextPutAll: " ## Register "; print: register
        }.

        liveInterval ifNotNil: {
            stream nextPutAll: " ## Interval "; print: liveInterval
        }.

        self printDebugInfoOn: stream.
    }.

    public override method usedValuesDo: (aBlock: (MIRValue) => Void) ::=> Void := {
        operands do: aBlock
    }.

    public override method replaceUsedValue: (usedValue: MIRValue) with: (replacement: MIRValue) ::=> Void := {
        operands replaceAll: usedValue with: replacement
    }.

    public override method replaceWith: (replacement: MIRValue) ::=> Void := {
        self == replacement ifTrue: (return: void).

        super replaceWith: replacement.
        parentBlock ifNotNil: {parentBlock removeInstruction: self }
    }.

    public method hasOnlyDebugUsers => Boolean
        := users isNil || (users allSatisfy: {:(MIRValue)user :: Boolean | user isDebug}).

    public method deleteAllDebugUsers => Void := {
        users ifNotNil: {
            users copy do: {:(MIRInstruction)user :: Void |
                user deleteFromParent
            }
        }
    }.

    public method deleteFromParent => Void
        := parentBlock deleteInstruction: self.

    public override method computeLiveInterval => Void := {
        super computeLiveInterval.
        liveInterval insertUsage: index.

        operation isPhi ifTrue: {
            operands pairsDo: {:(MIRBasicBlock)incomingBlock :(MIRValue)incomingValue :: Void |
                liveInterval insertUsage: incomingBlock indexAtEnd
            }
        }
    }.

    public override method usageIndexFor: (usedValue: MIRLocalValue) ::=> UInt32 := {
        self assert: parentBlock isNotNil.
        usedValue parentBlock ~~ parentBlock ifTrue: {
            ## This is needed for values used inside of loops.
            index max: parentBlock maxPredecessorIndex
        } ifFalse: {
            index
        }
    }.

    public method usesCapture => Boolean
        := operands anySatisfy: {:(MIRValue)operand :: Boolean | operand isCaptureValueOrPointer }.

    public method usesThreadLocalSegmentPointer => Boolean
        := operands anySatisfy: {:(MIRValue)operand :: Boolean | operand isThreadLocal }.

    public method phiIncomingBlocksAndValuesDoReplacingValues: (aBlock: (MIRBasicBlock, MIRValue) => MIRValue) ::=> Void := {
        self assert: self isPhiInstruction.
        let i mutable := 0sz.
        let operandCount := operands size.

        while: (i < operandCount) do: {
            let block => MIRBasicBlock := operands at: i.
            let oldValue => MIRValue := operands at: i + 1sz.
            let newValue := aBlock(block, oldValue).
            operands at: i + 1sz put: newValue
        } continueWith: (i := i + 2sz).
    }.

    public override method resetRegisterAllocation => Void := {
        super resetRegisterAllocation.
        resultRegister := nil.
        captureVectorPointerRegister := nil.
        operandRegisters := Array new: operands size.
        scratchRegisters := #().
    }.
}.

public global MIR::Operation::Branch := MIROperation terminatorNamed: #branch.
public global MIR::Operation::ConditionalBranch := MIROperation terminatorNamed: #condBranch.

public global MIR::Operation::MoveInt8       := MIROperation moveNamed: #moveInt8.
public global MIR::Operation::MoveInt16      := MIROperation moveNamed: #moveInt16.
public global MIR::Operation::MoveInt32      := MIROperation moveNamed: #moveInt32.
public global MIR::Operation::MoveInt64      := MIROperation moveNamed: #moveInt64.
public global MIR::Operation::MovePointer    := MIROperation moveNamed: #movePointer.
public global MIR::Operation::MoveFatPointer := MIROperation moveNamed: #moveFatPointer.
public global MIR::Operation::MoveFloat32    := MIROperation moveNamed: #moveFloat32.
public global MIR::Operation::MoveFloat64    := MIROperation moveNamed: #moveFloat64.
public global MIR::Operation::MoveStruct     := MIROperation moveNamed: #moveStruct.

public global MIR::Operation::PhiInt8       := MIROperation phiNamed: #phiInt8 moveOperation: MIR::Operation::MoveInt8.
public global MIR::Operation::PhiInt16      := MIROperation phiNamed: #phiInt16 moveOperation: MIR::Operation::MoveInt16.
public global MIR::Operation::PhiInt32      := MIROperation phiNamed: #phiInt32 moveOperation: MIR::Operation::MoveInt32.
public global MIR::Operation::PhiInt64      := MIROperation phiNamed: #phiInt64 moveOperation: MIR::Operation::MoveInt64.
public global MIR::Operation::PhiPointer    := MIROperation phiNamed: #phiPointer moveOperation: MIR::Operation::MovePointer.
public global MIR::Operation::PhiFatPointer := MIROperation phiNamed: #phiFatPointer moveOperation: MIR::Operation::MoveFatPointer.
public global MIR::Operation::PhiFloat32    := MIROperation phiNamed: #phiFloat32 moveOperation: MIR::Operation::MoveFloat32.
public global MIR::Operation::PhiFloat64    := MIROperation phiNamed: #phiFloat64 moveOperation: MIR::Operation::MoveFloat64.
public global MIR::Operation::PhiStruct     := MIROperation phiNamed: #phiStruct moveOperation: MIR::Operation::MoveStruct.

public global MIR::Operation::LoadInt8       := MIROperation loadNamed: #loadInt8.
public global MIR::Operation::LoadInt16      := MIROperation loadNamed: #loadInt16.
public global MIR::Operation::LoadInt32      := MIROperation loadNamed: #loadInt32.
public global MIR::Operation::LoadInt64      := MIROperation loadNamed: #loadInt64.
public global MIR::Operation::LoadUInt8      := MIROperation loadNamed: #loadUInt8.
public global MIR::Operation::LoadUInt16     := MIROperation loadNamed: #loadUInt16.
public global MIR::Operation::LoadUInt32     := MIROperation loadNamed: #loadUInt32.
public global MIR::Operation::LoadUInt64     := MIROperation loadNamed: #loadUInt64.
public global MIR::Operation::LoadPointer    := MIROperation loadNamed: #loadPointer.
public global MIR::Operation::LoadFatPointer := MIROperation loadNamed: #loadFatPointer.
public global MIR::Operation::LoadFloat32    := MIROperation loadNamed: #loadFloat32.
public global MIR::Operation::LoadFloat64    := MIROperation loadNamed: #loadFloat64.
public global MIR::Operation::LoadStruct     := MIROperation loadNamed: #loadStruct.

public global MIR::Operation::StoreInt8       := MIROperation storeNamed: #storeInt8.
public global MIR::Operation::StoreInt16      := MIROperation storeNamed: #storeInt16.
public global MIR::Operation::StoreInt32      := MIROperation storeNamed: #storeInt32.
public global MIR::Operation::StoreInt64      := MIROperation storeNamed: #storeInt64.
public global MIR::Operation::StorePointer    := MIROperation storeNamed: #storePointer.
public global MIR::Operation::StoreFatPointer := MIROperation storeNamed: #storeFatPointer.
public global MIR::Operation::StoreFloat32    := MIROperation storeNamed: #storeFloat32.
public global MIR::Operation::StoreFloat64    := MIROperation storeNamed: #storeFloat64.
public global MIR::Operation::StoreStruct     := MIROperation storeNamed: #storeStruct.

public global MIR::Operation::GenerationalWriteBarrier := MIROperation named: #generationalWriteBarrier.

public global MIR::Operation::Memcpy := MIROperation loadStoreNamed: #memcpy.
public global MIR::Operation::Memset := MIROperation loadStoreNamed: #memset.

public global MIR::Operation::CallInt8       := MIROperation callNamed: #callInt8.
public global MIR::Operation::CallInt16      := MIROperation callNamed: #callInt16.
public global MIR::Operation::CallInt32      := MIROperation callNamed: #callInt32.
public global MIR::Operation::CallInt64      := MIROperation callNamed: #callInt64.
public global MIR::Operation::CallPointer    := MIROperation callNamed: #callPointer.
public global MIR::Operation::CallFatPointer := MIROperation callNamed: #callFatPointer.
public global MIR::Operation::CallFloat32    := MIROperation callNamed: #callFloat32.
public global MIR::Operation::CallFloat64    := MIROperation callNamed: #callFloat64.
public global MIR::Operation::CallStruct     := MIROperation callNamed: #callStruct.
public global MIR::Operation::CallVoid       := MIROperation callNamed: #callVoid.

public global MIR::Operation::ReturnInt8       := MIROperation terminatorNamed: #returnInt8.
public global MIR::Operation::ReturnInt16      := MIROperation terminatorNamed: #returnInt16.
public global MIR::Operation::ReturnInt32      := MIROperation terminatorNamed: #returnInt32.
public global MIR::Operation::ReturnInt64      := MIROperation terminatorNamed: #returnInt64.
public global MIR::Operation::ReturnPointer    := MIROperation terminatorNamed: #returnPointer.
public global MIR::Operation::ReturnFatPointer := MIROperation terminatorNamed: #returnFatPointer.
public global MIR::Operation::ReturnFloat32    := MIROperation terminatorNamed: #returnFloat32.
public global MIR::Operation::ReturnFloat64    := MIROperation terminatorNamed: #returnFloat64.
public global MIR::Operation::ReturnStruct     := MIROperation terminatorNamed: #returnStruct.
public global MIR::Operation::ReturnVoid       := MIROperation terminatorNamed: #returnVoid.

public global MIR::Operation::ExceptionSetjmp := MIROperation terminatorNamed: #exceptionSetjmp.
public global MIR::Operation::ExceptionLongjmp := MIROperation terminatorNamed: #exceptionLongjmp.

public global MIR::Operation::Trap := MIROperation named: #trap.
public global MIR::Operation::UnreachableTrap := MIROperation terminatorNamed: #unreachableTrap.

public global MIR::Operation::DebugSetBindingValue := MIROperation debugNamed: #debugSetBindingValue.
public global MIR::Operation::DebugSetMutableBindingValue := MIROperation debugNamed: #debugSetMutableBindingValue.
public global MIR::Operation::DebugSetMutableBindingSpecificValue := MIROperation debugNamed: #debugSetMutableBindingSpecificValue.

MIRBasicBlock definition: {
    public field parent => MIRFunction.

    public field previous => MIRBasicBlock.
    public field next => MIRBasicBlock.

    public field firstInstruction => MIRInstruction.
    public field lastInstruction => MIRInstruction.

    public field traversalColor => UInt8.
    public field predecessors => OrderedCollection.
    public field predecessorKinds => OrderedCollection.
    public field successors => Array.
    public field maxPredecessorIndex => UInt32.
    public field maxIndexAtEnd => UInt32.

    public override method isBasicBlock => Boolean := true.

    public override method initialize => Void := {
        super initialize.
        self resetConnectivityWithSucessors.
    }.

    public method resetConnectivityWithSucessors => Void := {
        successors := #().
        predecessors := OrderedCollection new.
        predecessorKinds := OrderedCollection new.
        lastInstruction isNotNil && lastInstruction isTerminator ifTrue: {
            successors := (lastInstruction operands select: {:(MIRValue)each :: Boolean | each isBasicBlock}) asArray
        }.
    }.

    public method addPredecessor: (predecessor: MIRBasicBlock) isBackEdge: (isBackEdge: Boolean) ::=> Void := {
        self predecessors add: predecessor.
        self predecessorKinds add: isBackEdge.
    }.

    public method hasBackEdge => Boolean
        := (predecessorKinds indexOf: true) >= 0iptr.

    public method traverseForConnectivityAndLivenessFrom: (predecessor: MIRBasicBlock) sortingInto: (sortedBlocks: OrderedCollection) ::=> Void := {
        predecessor ifNotNil: {
            self addPredecessor: predecessor isBackEdge: self isGray.
        }.

        if: self isWhite then: {
            self markGray.
            self successors reverseDo: {:(MIRBasicBlock)eachSuccessor :: Void|
                eachSuccessor traverseForConnectivityAndLivenessFrom: self sortingInto: sortedBlocks
            }.

            self markBlack.
            sortedBlocks add: self.
        }.
    }.

    public method addPredecessor: (predecessor: MIRBasicBlock) ::=> Void := {
        predecessors add: predecessor.
    }.

    public method markWhite => Void := {
        self traversalColor: 0u8
    }.

    public method isWhite => Boolean := self traversalColor == 0u8.

    public method markGray => Void := {
        self traversalColor: 1u8
    }.

    public method isGray => Boolean := self traversalColor == 1u8.

    public method markBlack => Void := {
        self traversalColor: 2u8
    }.

    public method isBlack => Boolean := self traversalColor == 2u8.

    public override method physicalLocationClass => MIRPhysicalLocation class
        := MIRPhysicalIntegerRegister.

    public override method isRelativeImmediate32 => Boolean := true.

    public method addInstruction: (instruction: MIRInstruction) before: (position: MIRInstruction) ::=> Void := {
        self assert: instruction parentBlock isNil.
        let before := position ifNotNil: position previous ifNil: lastInstruction.
        let after := position.

        ## Do not add instructions after a terminator.
        before isNotNil && before isTerminator ifTrue: (return: void).

        before ifNotNil: {
            before next: instruction.
            instruction previous: before.
        } ifNil: {
            firstInstruction := instruction
        }.

        after ifNotNil: {
            after previous: instruction.
            instruction next: after
        } ifNil: {
            lastInstruction := instruction
        }.

        instruction parentBlock: self
    }.

    public method addInstruction: (instruction: MIRInstruction) ::=> Void := {
        self addInstruction: instruction before: nil
    }.

    public method removeInstruction: (instruction: MIRInstruction) ::=> Void := {
        self assert: instruction parentBlock == self.

        let previousInstruction := instruction previous.
        let nextInstruction := instruction next.

        previousInstruction ifNotNil: {
            previousInstruction next: nextInstruction
        } ifNil: {
            firstInstruction := nextInstruction
        }.

        nextInstruction ifNotNil: {
            nextInstruction previous: previousInstruction
        } ifNil: {
            lastInstruction := previousInstruction
        }.

        instruction
            parentBlock: nil;
            previous: nil;
            next: nil
    }.

    public method deleteInstruction: (instruction: MIRInstruction) ::=> Void := {
        self assert: instruction userCount = 0sz.
        self removeInstruction: instruction.
        instruction unregisterFromUsedValues
    }.

    public inline method instructionsDo: (aBlock: (MIRInstruction => Void)) ::=> Void := {
        let position mutable := firstInstruction.
        while: (position isNotNil) do: {
            let nextPosition := position next.
            aBlock(position).
            position := nextPosition
        }
    }.

    public override method replaceWith: (replacement: MIRValue) ::=> Void := {
        self == replacement ifTrue: (return: void).

        super replaceWith: replacement.
        self parent ifNotNil: {:parent :: Void | parent removeBasicBlock: self }
    }.

    public override method printOn: (stream: Stream) ::=> Void := {
        stream nextPut: '@'c8; print: index.
        name ifNotNil: (stream nextPut: ':'c8; string: name)
    }.

    public override method fullPrintOn: (stream: Stream) ::=> Void := {
        stream print: self; nextPut: ':'c8.
        self printDebugInfoOn: stream.
        stream nl.
        self instructionsDo: {:(MIRInstruction)each :: Void |
            stream nextPutAll: "    "; fullPrint: each; nl
        }.
    }.

    public method indexAtEnd => UInt32
        := lastInstruction ifNotNil: lastInstruction index + 1u32 ifNil: index.
}.

MIRFunction definition: {
    public field callingConvention => MIRCallingConvention.

    public field arguments => Array.
    public field captures => Array.
    public field temporaries => OrderedCollection.
    public field isNoGC => Boolean.

    public field touchedCallPreservedRegisters => Array.
    public field touchedCallPreservedVectorRegisters => Array.

    public field firstBasicBlock => MIRBasicBlock.
    public field lastBasicBlock => MIRBasicBlock.

    public field trampolineTarget => MIRProgramEntity.

    public field captureVectorPointerValue => MIRCaptureVectorPointerValue.
    public field captureVectorSize => UInt64.
    public field captureVectorAlignment => UInt64.

    public field threadLocalSegmentPointerValue => MIRThreadLocalSegmentPointerValue.
    public field gotPointerValue => MIRGotPointerValue.

    public field argumentPassingStackAlignment => UInt64.
    public field argumentPassingStackSize => UInt64.

    public field maxCalloutAlignment => UInt64.
    public field maxCalloutSize => UInt64.
    public field performsCallouts => Boolean.

    public override method isFunction => Boolean := true.

    public override method physicalLocationClass => MIRPhysicalLocation class
        := MIRPhysicalIntegerRegister.

    public override method isRelativeImmediate32 => Boolean := true.

    public override method size => UInt64
        := compilationTarget pointerSize asUInt64.

    public override method alignment => UInt64
        := compilationTarget pointerAlignment asUInt64.

    public override method initialize => Void := {
        super initialize.
        arguments := #().
        captures := #().
        temporaries := OrderedCollection new.
        maxCalloutAlignment := 1u64.
        maxCalloutSize := 0u64.
    }.

    public method addTemporary: (temporary: MIRTemporaryVariable) ::=> MIRTemporaryVariable := {
        temporaries add: temporary.
        temporary
    }.

    public method newArgument: (name: Symbol) withType: (type: Type) sourceBinding: (sourceBinding: SymbolBinding)::=> MIRArgumentValue
        := (MIRArgumentValue withName: name type: type compilationTarget: compilationTarget)
            sourceBinding: sourceBinding;
            yourself.

    public method newArgument: (name: Symbol) withType: (type: Type) ::=> MIRArgumentValue
        := self newArgument: name withType: type sourceBinding: nil.

    public method newArgumentWithType: (type: Type) ::=> MIRArgumentValue
        := self newArgument: nil withType: type.

    public method newCapture: (name: Symbol) withType: (type: Type) ::=> MIRCaptureVariable
        := MIRCaptureVariable withName: name type: type compilationTarget: compilationTarget.

    public method newCaptureWithType: (type: Type) ::=> MIRCaptureVariable
        := self newCapture: nil withType: type.

    public method newTemporary: (name: Symbol) withType: (type: Type) ::=> MIRTemporaryVariable
        := self addTemporary: (MIRTemporaryVariable withName: name type: type compilationTarget: compilationTarget).

    public method newTemporaryWithType: (type: Type) ::=> MIRTemporaryVariable
        := self newTemporary: nil withType: type.

    public method newTemporaryUInt8 => MIRTemporaryVariable
        := self newTemporaryWithType: UInt8.

    public method newTemporaryInt8 => MIRTemporaryVariable
        := self newTemporaryWithType: Int8.

    public method newTemporaryUInt16 => MIRTemporaryVariable
        := self newTemporaryWithType: UInt16.

    public method newTemporaryInt16 => MIRTemporaryVariable
        := self newTemporaryWithType: Int8.

    public method newTemporaryUInt32 => MIRTemporaryVariable
        := self newTemporaryWithType: UInt32.

    public method newTemporaryInt32 => MIRTemporaryVariable
        := self newTemporaryWithType: Int32.

    public method newTemporaryUInt64 => MIRTemporaryVariable
        := self newTemporaryWithType: UInt64.

    public method newTemporaryInt64 => MIRTemporaryVariable
        := self newTemporaryWithType: Int64.

    public method newTemporaryUIntPointer => MIRTemporaryVariable
        := compilationTarget pointerSize = 8sz
            ifTrue: (self newTemporaryUInt64)
            ifFalse: (self newTemporaryUInt32).

    public method newTemporaryIntPointer => MIRTemporaryVariable
        := compilationTarget pointerSize = 8sz
            ifTrue: (self newTemporaryInt64)
            ifFalse: (self newTemporaryInt32).

    public method newTemporaryFloat32 => MIRTemporaryVariable
        := self newTemporaryWithType: Float32.

    public method newTemporaryFloat64 => MIRTemporaryVariable
        := self newTemporaryWithType: Float64.

    public method addBasicBlock: (basicBlock: MIRBasicBlock) before: (position: MIRBasicBlock) ::=> Void := {
        self assert: basicBlock parent isNil.

        let before := position ifNotNil: position previous ifNil: lastBasicBlock.
        let after := position.

        before ifNotNil: {
            before next: basicBlock.
            basicBlock previous: before.
        } ifNil: {
            firstBasicBlock := basicBlock
        }.

        after ifNotNil: {
            after previous: basicBlock.
            basicBlock next: after
        } ifNil: {
            lastBasicBlock := basicBlock
        }.

        basicBlock parent: self
    }.

    public method addBasicBlock: (basicBlock: MIRBasicBlock) ::=> Void := {
        self addBasicBlock: basicBlock before: nil
    }.

    public method removeBasicBlock: (basicBlock: MIRBasicBlock) ::=> Void := {
        self assert: basicBlock parent == self.

        let previous := basicBlock previous.
        let next := basicBlock next.

        previous ifNotNil: {
            previous next: next
        } ifNil: {
            self firstBasicBlock: next
        }.

        next ifNotNil: {
            next previous: previous
        } ifNil: {
            self lastBasicBlock: previous
        }.

        basicBlock
            parent: nil;
            previous: nil;
            next: nil
    }.
    
    public inline method basicBlocksDo: (aBlock: (MIRBasicBlock) => Void) ::=> Void := {
        let position mutable := firstBasicBlock.
        while: (position isNotNil) do: {
            let nextPosition := position next.
            aBlock(position).
            position := nextPosition
        }
    }.

    public method enumerateBlocks => Void := {
        let index mutable := 0u32.
        self basicBlocksDo: {:(MIRBasicBlock)each :: Void |
            each index: index.
            index := index + 1u32.
        }.
    }.

    public inline method instructionsDo: (aBlock: (MIRInstruction) => Void) ::=> Void := {
        self basicBlocksDo: {:(MIRBasicBlock)each :: Void |
            each instructionsDo: aBlock
        }.
    }.

    public inline method allLocalValuesDo: (aBlock: (MIRLocalValue) => Void) ::=> Void := {
        arguments do: aBlock.
        captureVectorPointerValue ifNotNil: aBlock(captureVectorPointerValue).
        captures do: aBlock.
        gotPointerValue ifNotNil: aBlock(gotPointerValue).
        threadLocalSegmentPointerValue ifNotNil: aBlock(threadLocalSegmentPointerValue).

        temporaries do: aBlock.
        self basicBlocksDo: {:(MIRBasicBlock)eachBasicBlock :: Void |
            aBlock(eachBasicBlock).
            eachBasicBlock instructionsDo: {:(MIRInstruction)eachInstruction :: Void |
                aBlock(eachInstruction)
            }.
        }.
    }.

    public method computeBasicBlockConnectivityAndNormalize => Void := {
        self basicBlocksDo: {:(MIRBasicBlock)each :: Void |
            each resetConnectivityWithSucessors
        }.

        let sortedBlocks := OrderedCollection new.
        firstBasicBlock ifNotNil: {
            firstBasicBlock traverseForConnectivityAndLivenessFrom: nil sortingInto: sortedBlocks
        }.

        self basicBlocksDo: {:(MIRBasicBlock)eachBasicBlock :: Void |
            eachBasicBlock isBlack ifFalse: {
                self assert: eachBasicBlock isWhite.
                self removeBasicBlock: eachBasicBlock
            }
        }.

        ## Use the new sorted order.
        sortedBlocks do: {:(MIRBasicBlock)each :: Void |
            each parent: nil; previous: nil; next: nil.
        }.
        firstBasicBlock := nil.
        lastBasicBlock := nil.

        sortedBlocks reverseDo: {:(MIRBasicBlock)each :: Void |
            self addBasicBlock: each
        }.
    }.

    public method ensureCaptureVectorPointerValue => Void := {
        captures isEmpty ifTrue: {
            captureVectorPointerValue := nil
        } ifFalse: {
            captureVectorPointerValue := MIRCaptureVectorPointerValue withType: AnyValue compilationTarget: compilationTarget,
            captureVectorPointerValue closure: arguments first.
            captureVectorPointerValue closure registerUser: captureVectorPointerValue.
        }.

        self instructionsDo: {:(MIRInstruction)each :: Void |
            each usesCapture ifTrue: {
                each captureVectorPointerValue: captureVectorPointerValue.
                captureVectorPointerValue ifNotNil: {
                    captureVectorPointerValue registerUser: each
                }
            }.
        }.
    }.

    public method ensureThreadLocalSegmentPointerValue => Void := {
        self compilationTarget usesThreadLocalSegmentPointer ifFalse: {
            return: void
        }.

        self instructionsDo: {:(MIRInstruction)each :: Void |
            each usesThreadLocalSegmentPointer ifTrue: {
                threadLocalSegmentPointerValue ifNil: {
                    threadLocalSegmentPointerValue := MIRThreadLocalSegmentPointerValue withType: AnyValue compilationTarget: compilationTarget
                }.

                each threadLocalSegmentPointerValue: threadLocalSegmentPointerValue.
                threadLocalSegmentPointerValue registerUser: each
            }.
        }.
    }.

    public method enumerateLocals => Void := {
        let index mutable := 0u32.
        self allLocalValuesDo: {:(MIRLocalValue)each :: Void |
            each index: index.
            index := index + 1u32
        }.

        ## TODO: Check the correctness of this algorithm.
        self basicBlocksDo: {:(MIRBasicBlock)each :: Void |
            each maxIndexAtEnd: each indexAtEnd.
        }.

        self basicBlocksDo: {:(MIRBasicBlock)each :: Void |
            let maxPredIndex mutable := 0u32.
            each predecessors do: {:(MIRBasicBlock)eachPred :: Void |
                maxPredIndex := maxPredIndex max: eachPred maxIndexAtEnd
            }.

            each maxPredecessorIndex: maxPredIndex.
            
            each maxIndexAtEnd: (each maxIndexAtEnd max: each maxPredecessorIndex).
        }.
    }.

    public method normalizeAndComputeLiveIntervals => Void := {
        self
            computeBasicBlockConnectivityAndNormalize.

        self allLocalValuesDo: {:(MIRLocalValue)eachLocal :: Void |
            eachLocal resetCoalescing.
            eachLocal isPhiInstruction ifTrue: {
                self normalizePhiInstruction: (eachLocal downCastTo: MIRInstruction)
            }.
        }.

        self ensureCaptureVectorPointerValue.
        self ensureThreadLocalSegmentPointerValue.

        self enumerateLocals.
        self allLocalValuesDo: {:(MIRLocalValue)eachLocal :: Void |
            eachLocal computeLiveInterval
        }.
    }.

    public method normalizePhiInstruction: (instruction: MIRInstruction) ::=> Void := {
        self assert: instruction isPhiInstruction.

        instruction phiIncomingBlocksAndValuesDoReplacingValues: {:(MIRBasicBlock)incomingBlock :(MIRValue)incomingValue :: MIRValue |
            incomingValue isInstruction ifTrue: {
                let incomingInstruction := incomingValue downCastTo: MIRInstruction.
                incomingInstruction targetPhi == instruction ifTrue: {
                    self assert: incomingInstruction parentBlock == incomingBlock.
                    self assert: incomingInstruction operation == instruction operation phiMoveOperation.
                    return: incomingInstruction
                }
            }.

            self assert: incomingBlock lastInstruction isNotNil && incomingBlock lastInstruction isTerminator.

            let moveInstruction := (MIRInstruction withType: instruction type compilationTarget: self compilationTarget)
                operation: instruction operation phiMoveOperation;
                operands: (Array with: incomingValue);
                targetPhi: instruction;
                debugSourcePosition: instruction debugSourcePosition;
                debugSourceNode: instruction debugSourceNode;
                debugSourceEnvironment: instruction debugSourceEnvironment;
                yourself.
            incomingValue replaceUser: instruction with: moveInstruction.
            moveInstruction registerUser: instruction.
            incomingBlock addInstruction: moveInstruction before: incomingBlock lastInstruction.
            moveInstruction
        }.
    }.

    public method computeCaptureVectorLayout => Void := {
        let offset mutable := 0u64.
        let alignment mutable := 1u64.
        captures do: {:(MIRCaptureVariable)each :: Void |
            offset := offset alignedTo: each alignment.
            alignment := alignment max: each alignment.

            each offset: offset asInt64.
            offset := offset + each size
        }.

        offset := offset alignedTo: alignment.
        self captureVectorSize: offset.
        self captureVectorAlignment: alignment.
    }.

    public override method printOn: (stream: Stream) ::=> Void := {
        stream nextPutAll: "function "; print: callingConvention.
        name ifNotNil: (stream space; string: name).
    }.

    public override method fullPrintOn: (stream: Stream) ::=> Void := {
        stream print: self; nextPutAll: " {".
        self printDebugInfoOn: stream.
        stream nl.
        self enumerateBlocks; enumerateLocals.
        self basicBlocksDo: {:(MIRBasicBlock)each :: Void |
            stream fullPrint: each
        }.
        stream nextPut: '}'c8; nl.
    }.
}.

public final class MIRBlockBuilder superclass: Object; definition: {
    public field context => MIRContext.

    public field block => MIRBasicBlock.
    public field function => MIRFunction.
    public field insertionPoint => MIRInstruction.

    ## Debugging information
    public field debugSourcePosition => SourcePosition.
    public field debugSourceNode => ASTNode.
    public field debugSourceEnvironment => Environment.

    __Meta__ definition: {
        public method forContext: (context: MIRContext) ::=> self
            := self new context: context; yourself
    }.

    public method addInstruction: (instruction: MIRInstruction) ::=> MIRInstruction := {
        block addInstruction: instruction before: insertionPoint.
        instruction
            debugSourcePosition: debugSourcePosition;
            debugSourceNode: debugSourceNode;
            debugSourceEnvironment: debugSourceEnvironment.
        instruction
    }.

    public method temporaryUInt8 => MIRTemporaryVariable := function newTemporaryUInt8.
    public method temporaryInt8 => MIRTemporaryVariable := function newTemporaryInt8.
    public method temporaryUInt16 => MIRTemporaryVariable := function newTemporaryUInt16.
    public method temporaryInt16 => MIRTemporaryVariable := function newTemporaryInt16.
    public method temporaryUInt32 => MIRTemporaryVariable := function newTemporaryUInt32.
    public method temporaryInt32 => MIRTemporaryVariable := function newTemporaryInt32.
    public method temporaryUInt64 => MIRTemporaryVariable := function newTemporaryUInt64.
    public method temporaryInt64 => MIRTemporaryVariable := function newTemporaryInt64.
    public method temporaryUIntPointer => MIRTemporaryVariable := function newTemporaryUIntPointer.
    public method temporaryFloat32 => MIRTemporaryVariable := function newTemporaryFloat32.
    public method temporaryFloat64 => MIRTemporaryVariable := function newTemporaryFloat64.

    public method compilationTarget => MIRCompilationTarget := function compilationTarget.
    public method pointerSize => Size := function compilationTarget pointerSize.
    public method uintPointerType => Type := function compilationTarget uintPointerType.
    public method has64BitsPointers => Boolean := self pointerSize = 8sz.

    public method uint8: (value: UInt8) ::=> MIRConstantUInt8
        := context uint8: value.

    public method int8: (value: Int8) ::=> MIRConstantInt8
        := context int8: value.

    public method uint16: (value: UInt16) ::=> MIRConstantUInt16
        := context uint16: value.

    public method int16: (value: Int16) ::=> MIRConstantInt16
        := context int16: value.

    public method uint32: (value: UInt32) ::=> MIRConstantUInt32
        := context uint32: value.

    public method int32: (value: Int32) ::=> MIRConstantInt32
        := context int32: value.

    public method uint64: (value: UInt64) ::=> MIRConstantUInt64
        := context uint64: value.

    public method int64: (value: Int64) ::=> MIRConstantInt64
        := context int64: value.

    public method float32: (value: Float32) ::=> MIRConstantFloat32
        := context float32: value.

    public method float64: (value: Float64) ::=> MIRConstantFloat64
        := context float64: value.

    public method operation: (operation: MIROperation) ::=> MIRInstruction
        := self addInstruction: ((MIRInstruction withType: Void compilationTarget: self compilationTarget)
            operation: operation;
            yourself).

    public method operation: (operation: MIROperation) withOperands: (operands: Array) type: (type: Type) ::=> MIRInstruction := {
        self assert: (operands allSatisfy: {:each :: Boolean | each isNotNil}).
        self addInstruction: ((MIRInstruction withType: type compilationTarget: self compilationTarget)
             operation: operation;
             operands: operands;
             registerInUsedValues;
             yourself)
    }.

    public method operation: (operation: MIROperation) withOperands: (operands: Array) ::=> MIRInstruction
        := self operation: operation withOperands: operands type: Void.

    public method operation: (operation: MIROperation)  type: (type: Type) ::=> MIRInstruction
        := self operation: operation withOperands: #() type: type.

    public method operation: (operation: MIROperation) with: (operand: MIRValue) ::=> MIRInstruction
        := self operation: operation withOperands: (Array with: operand).

    public method operation: (operation: MIROperation) with: (operand: MIRValue) type: (type: Type) ::=> MIRInstruction
        := self operation: operation withOperands: (Array with: operand) type: type.

    public method operation: (operation: MIROperation) with: (firstOperand: MIRValue) with: (secondOperand: MIRValue) ::=> MIRInstruction
        := self operation: operation withOperands: (Array with: firstOperand with: secondOperand).

    public method operation: (operation: MIROperation) with: (firstOperand: MIRValue) with: (secondOperand: MIRValue) type: (type: Type) ::=> MIRInstruction
        := self operation: operation withOperands: (Array with: firstOperand with: secondOperand) type: type.

    public method operation: (operation: MIROperation) with: (firstOperand: MIRValue) with: (secondOperand: MIRValue) with: (thirdOperand: MIRValue) ::=> MIRInstruction
        := self operation: operation withOperands: (Array with: firstOperand with: secondOperand with: thirdOperand).

    public method operation: (operation: MIROperation) with: (firstOperand: MIRValue) with: (secondOperand: MIRValue) with: (thirdOperand: MIRValue) with: (fourthOperand: MIRValue) ::=> MIRInstruction
        := self operation: operation withOperands: (Array with: firstOperand with: secondOperand with: thirdOperand with: fourthOperand).

    public method branch: (destination: MIRValue) ::=> MIRInstruction
        := self operation: MIR::Operation::Branch with: destination.

    public method when: (condition: MIRValue) branchIfTrue: (trueDestination: MIRValue) branchIfFalse: (falseDestination: MIRValue) ::=> MIRInstruction
        := self operation: MIR::Operation::ConditionalBranch with: condition with: trueDestination with: falseDestination.

    public method call: (function: MIRValue) operation: (callOperation: MIROperation) convention: (callingConvention: MIRCallingConvention) arguments: (arguments: Array) type: (type: Type) ::=> MIRInstruction
        := self addInstruction: ((MIRInstruction withType: type compilationTarget: self compilationTarget)
            operation: callOperation;
            operands: (Array with: function) -- arguments;
            registerInUsedValues;
            callingConvention: callingConvention;
            yourself).

    public method callInt8: (function: MIRValue) convention: (callingConvention: MIRCallingConvention) arguments: (arguments: Array) type: (type: Type) ::=> MIRInstruction
        := self call: function operation: MIR::Operation::CallInt8 convention: callingConvention arguments: arguments type: type.

    public method callInt8: (function: MIRValue) arguments: (arguments: Array) type: (type: Type) ::=> MIRInstruction
        := self callInt8: function convention: self compilationTarget defaultCallingConvention arguments: arguments type: type.

    public method callInt8: (function: MIRValue) with: (firstArgument: MIRValue) type: (type: Type) ::=> MIRInstruction
        := self callInt8: function arguments: (Array with: firstArgument) type: type.

    public method callInt16: (function: MIRValue) convention: (callingConvention: MIRCallingConvention) arguments: (arguments: Array) type: (type: Type) ::=> MIRInstruction
        := self call: function operation: MIR::Operation::CallInt16 convention: callingConvention arguments: arguments type: type.

    public method callInt16: (function: MIRValue) arguments: (arguments: Array) type: (type: Type) ::=> MIRInstruction
        := self callInt16: function convention: self compilationTarget defaultCallingConvention arguments: arguments type: type.

    public method callInt16: (function: MIRValue) with: (firstArgument: MIRValue) type: (type: Type) ::=> MIRInstruction
        := self callInt16: function arguments: (Array with: firstArgument) type: type.

    public method callInt32: (function: MIRValue) convention: (callingConvention: MIRCallingConvention) arguments: (arguments: Array) type: (type: Type) ::=> MIRInstruction
        := self call: function operation: MIR::Operation::CallInt32 convention: callingConvention arguments: arguments type: type.

    public method callInt32: (function: MIRValue) arguments: (arguments: Array) type: (type: Type) ::=> MIRInstruction
        := self callInt32: function convention: self compilationTarget defaultCallingConvention arguments: arguments type: type.

    public method callInt32: (function: MIRValue) with: (firstArgument: MIRValue) type: (type: Type) ::=> MIRInstruction
        := self callInt32: function arguments: (Array with: firstArgument) type: type.

    public method callInt64: (function: MIRValue) convention: (callingConvention: MIRCallingConvention) arguments: (arguments: Array) type: (type: Type) ::=> MIRInstruction
        := self call: function operation: MIR::Operation::CallInt64 convention: callingConvention arguments: arguments type: type.

    public method callInt64: (function: MIRValue) arguments: (arguments: Array) type: (type: Type) ::=> MIRInstruction
        := self callInt64: function convention: self compilationTarget defaultCallingConvention arguments: arguments type: type.

    public method callInt64: (function: MIRValue) with: (firstArgument: MIRValue) type: (type: Type) ::=> MIRInstruction
        := self callInt64: function arguments: (Array with: firstArgument) type: type.

    public method callPointer: (function: MIRValue) convention: (callingConvention: MIRCallingConvention) arguments: (arguments: Array) type: (type: Type) ::=> MIRInstruction
        := self call: function operation: MIR::Operation::CallPointer convention: self compilationTarget defaultCallingConvention arguments: arguments type: type.

    public method callPointer: (function: MIRValue) arguments: (arguments: Array) type: (type: Type) ::=> MIRInstruction
        := self callPointer: function convention: self compilationTarget defaultCallingConvention arguments: arguments type: type.

    public method callPointer: (function: MIRValue) with: (firstArgument: MIRValue) type: (type: Type) ::=> MIRInstruction
        := self callPointer: function arguments: (Array with: firstArgument) type: type.

    public method callPointer: (function: MIRValue) with: (firstArgument: MIRValue) with: (secondArgument: MIRValue) type: (type: Type) ::=> MIRInstruction
        := self callPointer: function arguments: (Array with: firstArgument with: secondArgument) type: type.

    public method callPointer: (function: MIRValue) with: (firstArgument: MIRValue) with: (secondArgument: MIRValue) with: (thirdArgument: MIRValue) type: (type: Type) ::=> MIRInstruction
        := self callPointer: function arguments: (Array with: firstArgument with: secondArgument with: thirdArgument) type: type.

    public method callPointer: (function: MIRValue) with: (firstArgument: MIRValue) with: (secondArgument: MIRValue) with: (thirdArgument: MIRValue) with: (fourthArgument: MIRValue) type: (type: Type) ::=> MIRInstruction
        := self callPointer: function arguments: (Array with: firstArgument with: secondArgument with: thirdArgument with: fourthArgument) type: type.

    public method callFatPointer: (function: MIRValue) convention: (callingConvention: MIRCallingConvention) arguments: (arguments: Array) type: (type: Type) ::=> MIRInstruction
        := self call: function operation: MIR::Operation::CallFatPointer convention: self compilationTarget defaultCallingConvention arguments: arguments type: type.

    public method callFatPointer: (function: MIRValue) arguments: (arguments: Array) type: (type: Type) ::=> MIRInstruction
        := self callFatPointer: function convention: self compilationTarget defaultCallingConvention arguments: arguments type: type.

    public method callFatPointer: (function: MIRValue) with: (firstArgument: MIRValue) type: (type: Type) ::=> MIRInstruction
        := self callFatPointer: function arguments: (Array with: firstArgument) type: type.

    public method callFatPointer: (function: MIRValue) with: (firstArgument: MIRValue) with: (secondArgument: MIRValue) type: (type: Type) ::=> MIRInstruction
        := self callFatPointer: function arguments: (Array with: firstArgument with: secondArgument) type: type.

    public method callFatPointer: (function: MIRValue) with: (firstArgument: MIRValue) with: (secondArgument: MIRValue) with: (thirdArgument: MIRValue) type: (type: Type) ::=> MIRInstruction
        := self callFatPointer: function arguments: (Array with: firstArgument with: secondArgument with: thirdArgument) type: type.

    public method callFatPointer: (function: MIRValue) with: (firstArgument: MIRValue) with: (secondArgument: MIRValue) with: (thirdArgument: MIRValue) with: (fourthArgument: MIRValue) type: (type: Type) ::=> MIRInstruction
        := self callFatPointer: function arguments: (Array with: firstArgument with: secondArgument with: thirdArgument with: fourthArgument) type: type.

    public method callFloat32: (function: MIRValue) convention: (callingConvention: MIRCallingConvention) arguments: (arguments: Array) ::=> MIRInstruction
        := self call: function operation: MIR::Operation::CallFloat32 convention: callingConvention arguments: arguments type: Float32.

    public method callFloat32: (function: MIRValue) arguments: (arguments: Array) ::=> MIRInstruction
        := self callFloat32: function convention: self compilationTarget defaultCallingConvention arguments: arguments.

    public method callFloat32: (function: MIRValue) with: (firstArgument: MIRValue) ::=> MIRInstruction
        := self callFloat32: function arguments: (Array with: firstArgument).

    public method callFloat64: (function: MIRValue) convention: (callingConvention: MIRCallingConvention) arguments: (arguments: Array) ::=> MIRInstruction
        := self call: function operation: MIR::Operation::CallFloat64 convention: callingConvention arguments: arguments type: Float64.

    public method callFloat64: (function: MIRValue) arguments: (arguments: Array) ::=> MIRInstruction
        := self callFloat64: function convention: self compilationTarget defaultCallingConvention arguments: arguments.

    public method callFloat64: (function: MIRValue) with: (firstArgument: MIRValue) ::=> MIRInstruction
        := self callFloat64: function arguments: (Array with: firstArgument).

    public method callStruct: (function: MIRValue) convention: (callingConvention: MIRCallingConvention) arguments: (arguments: Array) type: (type: Type) ::=> MIRInstruction
        := self call: function operation: MIR::Operation::CallStruct convention: callingConvention arguments: arguments type: type.

    public method callStruct: (function: MIRValue) arguments: (arguments: Array) type: (type: Type) ::=> MIRInstruction
        := self callStruct: function convention: self compilationTarget defaultCallingConvention arguments: arguments type: type.

    public method callVoid: (function: MIRValue) convention: (callingConvention: MIRCallingConvention) arguments: (arguments: Array) ::=> MIRInstruction
        := self call: function operation: MIR::Operation::CallVoid convention: callingConvention arguments: arguments type: Void.

    public method callVoid: (function: MIRValue) arguments: (arguments: Array) ::=> MIRInstruction
        := self callVoid: function convention: self compilationTarget defaultCallingConvention arguments: arguments.

    public method callVoid: (function: MIRValue) with: (firstArgument: MIRValue) ::=> MIRInstruction
        := self callVoid: function arguments: (Array with: firstArgument).

    public method callVoid: (function: MIRValue) with: (firstArgument: MIRValue) with: (secondArgument: MIRValue) ::=> MIRInstruction
        := self callVoid: function arguments: (Array with: firstArgument with: secondArgument).

    public method callVoid: (function: MIRValue) with: (firstArgument: MIRValue) with: (secondArgument: MIRValue) with: (thirdArgument: MIRValue) ::=> MIRInstruction
        := self callVoid: function arguments: (Array with: firstArgument with: secondArgument with: thirdArgument).

    public method moveInt8: (source: MIRValue) ::=> MIRInstruction
        := self operation: MIR::Operation::MoveInt8 with: source type: Int8.

    public method moveInt16: (source: MIRValue) ::=> MIRInstruction
        := self operation: MIR::Operation::MoveInt16 with: source type: Int16.

    public method moveInt32: (source: MIRValue) ::=> MIRInstruction
        := self operation: MIR::Operation::MoveInt32 with: source type: Int32.

    public method moveInt64: (source: MIRValue) ::=> MIRInstruction
        := self operation: MIR::Operation::MoveInt64 with: source type: Int64.

    public method moveUInt8: (source: MIRValue) ::=> MIRInstruction
        := self operation: MIR::Operation::MoveInt8 with: source type: UInt8.

    public method moveUInt16: (source: MIRValue) ::=> MIRInstruction
        := self operation: MIR::Operation::MoveInt16 with: source type: UInt16.

    public method moveUInt32: (source: MIRValue) ::=> MIRInstruction
        := self operation: MIR::Operation::MoveInt32 with: source type: UInt32.

    public method moveUInt64: (source: MIRValue) ::=> MIRInstruction
        := self operation: MIR::Operation::MoveInt64 with: source type: UInt64.

    public method moveStruct: (source: MIRValue) type: (type: Type) ::=> MIRInstruction
        := self operation: MIR::Operation::MoveStruct with: source type: type.

    public method movePointer: (source: MIRValue) type: (type: Type) ::=> MIRInstruction
        := self operation: MIR::Operation::MovePointer with: source type: type.

    public method moveFatPointer: (source: MIRValue) type: (type: Type) ::=> MIRInstruction
        := self operation: MIR::Operation::MoveFatPointer with: source type: type.

    public method moveFloat32: (source: MIRValue) ::=> MIRInstruction
        := self operation: MIR::Operation::MoveFloat32 with: source type: Float32.

    public method moveFloat64: (source: MIRValue) ::=> MIRInstruction
        := self operation: MIR::Operation::MoveFloat64 with: source type: Float32.

    public method phiInt8 ::=> MIRInstruction
        := self operation: MIR::Operation::PhiInt8 type: Int8.

    public method phiInt16 ::=> MIRInstruction
        := self operation: MIR::Operation::PhiInt16 type: Int16.

    public method phiInt32 ::=> MIRInstruction
        := self operation: MIR::Operation::PhiInt32 type: Int32.

    public method phiInt64 ::=> MIRInstruction
        := self operation: MIR::Operation::PhiInt64 type: Int64.

    public method phiUInt8 ::=> MIRInstruction
        := self operation: MIR::Operation::PhiInt8 type: UInt8.

    public method phiUInt16 ::=> MIRInstruction
        := self operation: MIR::Operation::PhiInt16 type: UInt16.

    public method phiUInt32 ::=> MIRInstruction
        := self operation: MIR::Operation::PhiInt32 type: UInt32.

    public method phiUInt64 ::=> MIRInstruction
        := self operation: MIR::Operation::PhiInt64 type: UInt64.

    public method phiStruct: (type: Type) ::=> MIRInstruction
        := self operation: MIR::Operation::PhiStruct type: type.

    public method phiPointer: (type: Type) ::=> MIRInstruction
        := self operation: MIR::Operation::PhiPointer type: type.

    public method phiFatPointer: (type: Type) ::=> MIRInstruction
        := self operation: MIR::Operation::PhiFatPointer type: type.

    public method phiFloat32 ::=> MIRInstruction
        := self operation: MIR::Operation::PhiFloat32 type: Float32.

    public method phiFloat64 ::=> MIRInstruction
        := self operation: MIR::Operation::PhiFloat64 type: Float32.
        
    public method constantOffsetImmediateFor: (constantOffset: Int64) ::=> MIRValue
        := self has64BitsPointers && (constantOffset asInt32 asInt64 ~= constantOffset)
            ifTrue: (self int64: constantOffset)
            ifFalse: (self int32: constantOffset asInt32).

    public method loadInt8: (pointer: MIRValue) constantOffset: (constantOffset: Int64) ::=> MIRInstruction
        := self operation: MIR::Operation::LoadInt8 with: pointer with: (self constantOffsetImmediateFor: constantOffset) type: Int8.

    public method loadInt16: (pointer: MIRValue) constantOffset: (constantOffset: Int64) ::=> MIRInstruction
        := self operation: MIR::Operation::LoadInt16 with: pointer with: (self constantOffsetImmediateFor: constantOffset) type: Int16.

    public method loadInt32: (pointer: MIRValue) constantOffset: (constantOffset: Int64) ::=> MIRInstruction
        := self operation: MIR::Operation::LoadInt32 with: pointer with: (self constantOffsetImmediateFor: constantOffset) type: Int32.

    public method loadInt64: (pointer: MIRValue) constantOffset: (constantOffset: Int64) ::=> MIRInstruction
        := self operation: MIR::Operation::LoadInt64 with: pointer with: (self constantOffsetImmediateFor: constantOffset) type: Int64.

    public method loadUInt8: (pointer: MIRValue) constantOffset: (constantOffset: Int64) ::=> MIRInstruction
        := self operation: MIR::Operation::LoadUInt8 with: pointer with: (self constantOffsetImmediateFor: constantOffset) type: UInt8.

    public method loadUInt16: (pointer: MIRValue) constantOffset: (constantOffset: Int64) ::=> MIRInstruction
        := self operation: MIR::Operation::LoadUInt16 with: pointer with: (self constantOffsetImmediateFor: constantOffset) type: UInt16.

    public method loadUInt32: (pointer: MIRValue) constantOffset: (constantOffset: Int64) ::=> MIRInstruction
        := self operation: MIR::Operation::LoadUInt32 with: pointer with: (self constantOffsetImmediateFor: constantOffset) type: UInt32.

    public method loadUInt64: (pointer: MIRValue) constantOffset: (constantOffset: Int64) ::=> MIRInstruction
        := self operation: MIR::Operation::LoadUInt64 with: pointer with: (self constantOffsetImmediateFor: constantOffset) type: UInt64.

    public method loadFloat32: (pointer: MIRValue) constantOffset: (constantOffset: Int64) ::=> MIRInstruction
        := self operation: MIR::Operation::LoadFloat32 with: pointer with: (self constantOffsetImmediateFor: constantOffset) type: Float32.

    public method loadFloat64: (pointer: MIRValue) constantOffset: (constantOffset: Int64) ::=> MIRInstruction
        := self operation: MIR::Operation::LoadFloat64 with: pointer with: (self constantOffsetImmediateFor: constantOffset) type: Float64.

    public method loadPointer: (pointer: MIRValue) constantOffset: (constantOffset: Int64) type: (type: Type) ::=> MIRInstruction
        := self operation: MIR::Operation::LoadPointer with: pointer with: (self constantOffsetImmediateFor: constantOffset) type: type.

    public method loadFatPointer: (pointer: MIRValue) constantOffset: (constantOffset: Int64) type: (type: Type) ::=> MIRInstruction
        := self operation: MIR::Operation::LoadFatPointer with: pointer with: (self constantOffsetImmediateFor: constantOffset) type: type.

    public method pointerMul: (index: MIRValue) constantScale: (constantScale: Int64) type: (type: Type) ::=> MIRInstruction
        := self pointerMul: index with: (self constantOffsetImmediateFor: constantScale) type: type.

    public method pointerAdd: (pointer: MIRValue) constantOffset: (constantOffset: Int64) type: (type: Type) ::=> MIRValue := {
        constantOffset = 0i64 ifTrue: {
            pointer
        } ifFalse: {
            self pointerAdd: pointer with: (self constantOffsetImmediateFor: constantOffset) type: type
        }
    }.

    public method fatPointerAdd: (pointer: MIRValue) constantOffset: (constantOffset: Int64) type: (type: Type) ::=> MIRValue := {
        constantOffset = 0i64 ifTrue: {
            pointer
        } ifFalse: {
            self fatPointerAddOffset: pointer with: (self constantOffsetImmediateFor: constantOffset) type: type
        }
    }.

    public method loadStruct: (pointer: MIRValue) constantOffset: (constantOffset: Int64) type: (type: Type) ::=> MIRInstruction
        := self operation: MIR::Operation::LoadStruct with: pointer with: (self constantOffsetImmediateFor: constantOffset) type: type.

    public method pointerConstantWith: (value: UInt64) ::=> MIRValue
        := self has64BitsPointers
            ifTrue: (self uint64: value)
            ifFalse: (self uint32: value asUInt32).

    public method storeInt8: (value: MIRValue) into: (pointer: MIRValue) constantOffset: (constantOffset: Int64) ::=> MIRInstruction
        := self operation: MIR::Operation::StoreInt8 with: value with: pointer with: (self constantOffsetImmediateFor: constantOffset).

    public method storeInt16: (value: MIRValue) into: (pointer: MIRValue) constantOffset: (constantOffset: Int64) ::=> MIRInstruction
        := self operation: MIR::Operation::StoreInt16 with: value with: pointer with: (self constantOffsetImmediateFor: constantOffset).

    public method storeInt32: (value: MIRValue) into: (pointer: MIRValue) constantOffset: (constantOffset: Int64) ::=> MIRInstruction
        := self operation: MIR::Operation::StoreInt32 with: value with: pointer with: (self constantOffsetImmediateFor: constantOffset).

    public method storeInt64: (value: MIRValue) into: (pointer: MIRValue) constantOffset: (constantOffset: Int64) ::=> MIRInstruction
        := self operation: MIR::Operation::StoreInt64 with: value with: pointer with: (self constantOffsetImmediateFor: constantOffset).

    public method storePointer: (value: MIRValue) into: (pointer: MIRValue) constantOffset: (constantOffset: Int64) ::=> MIRInstruction
        := self operation: MIR::Operation::StorePointer with: value with: pointer with: (self constantOffsetImmediateFor: constantOffset).

    public method storeFatPointer: (value: MIRValue) into: (pointer: MIRValue) constantOffset: (constantOffset: Int64) ::=> MIRInstruction
        := self operation: MIR::Operation::StoreFatPointer with: value with: pointer with: (self constantOffsetImmediateFor: constantOffset).

    public method storeFloat32: (value: MIRValue) into: (pointer: MIRValue) constantOffset: (constantOffset: Int64) ::=> MIRInstruction
        := self operation: MIR::Operation::StoreFloat32 with: value with: pointer with: (self constantOffsetImmediateFor: constantOffset).

    public method storeFloat64: (value: MIRValue) into: (pointer: MIRValue) constantOffset: (constantOffset: Int64) ::=> MIRInstruction
        := self operation: MIR::Operation::StoreFloat64 with: value with: pointer with: (self constantOffsetImmediateFor: constantOffset).

    public method storeStruct: (value: MIRValue) into: (pointer: MIRValue) constantOffset: (constantOffset: Int64) ::=> MIRInstruction
        := self operation: MIR::Operation::StoreStruct with: value with: pointer with: (self constantOffsetImmediateFor: constantOffset).

    public method generationalWriteBarrier: (pointer: MIRValue) constantOffset: (constantOffset: Int64) value: (storedValue: MIRValue) rememberFunction: (rememberFunction: MIRValue) ::=> MIRInstruction
        := self operation: MIR::Operation::GenerationalWriteBarrier with: pointer with: (self constantOffsetImmediateFor: constantOffset) with: storedValue with: rememberFunction.

    public method memcpy: (destination: MIRValue) source: (source: MIRValue) size: (size: MIRValue) ::=> MIRInstruction
        := self operation: MIR::Operation::Memcpy with: destination with: source with: size.

    public method memset: (destination: MIRValue) value: (value: MIRValue) size: (size: MIRValue) ::=> MIRInstruction
        := self operation: MIR::Operation::Memset with: destination with: value with: size.

    public method exceptionSetjmp: (jmpbuffer: MIRValue) ::=> MIRInstruction
        := self operation: MIR::Operation::ExceptionSetjmp with: jmpbuffer.

    public method exceptionLongjmp: (jmpbuffer: MIRValue) ::=> MIRInstruction
        := self operation: MIR::Operation::ExceptionLongjmp with: jmpbuffer.

    public method loadEffectiveAddress: (basePointer: MIRValue) index: (indexValue: MIRValue) constantScale: (constantScale: Int64) type: (type: Type) ::=> MIRValue := {
        constantScale = 0i64 ifTrue: {
            basePointer
        } ifFalse: {
            indexValue isImmediate64 ifTrue: {
                let constantOffset := indexValue getConstantValue64 * constantScale.
                self pointerAdd: basePointer constantOffset: constantOffset type: type
            } ifFalse: {
                constantScale = 1i64 ifTrue: {
                    self pointerAdd: basePointer with: indexValue type: type
                } ifFalse: {
                    constantScale = -1i64 ifTrue: {
                        self pointerSub: basePointer with: indexValue type: type
                    } ifFalse: {
                        self pointerAdd: basePointer
                            with: (self pointerMul: indexValue constantScale: constantScale type: type)
                            type: type
                    }
                }.
            }.
        }.
    }.

    public method loadFatEffectiveAddress: (basePointer: MIRValue) index: (indexValue: MIRValue) constantScale: (constantScale: Int64) type: (type: Type) ::=> MIRValue := {
        constantScale = 0i64 ifTrue: {
            basePointer
        } ifFalse: {
            indexValue isImmediate64 ifTrue: {
                let constantOffset := indexValue getConstantValue64 * constantScale.
                self fatPointerAdd: basePointer constantOffset: constantOffset type: type
            } ifFalse: {
                constantScale = 1i64 ifTrue: {
                    self fatPointerAddOffset: basePointer with: indexValue type: type
                } ifFalse: {
                    constantScale = -1i64 ifTrue: {
                        self fatPointerSubOffset: basePointer with: indexValue type: type
                    } ifFalse: {
                        self fatPointerAddOffset: basePointer
                            with: (self pointerMul: indexValue constantScale: constantScale type: type)
                            type: type
                    }
                }.
            }.
        }.
    }.

    public method returnVoid ::=> MIRInstruction
        := self operation: MIR::Operation::ReturnVoid.

    public method returnInt8: (value: MIRValue) ::=> MIRInstruction
        := self operation: MIR::Operation::ReturnInt8 with: value.

    public method returnInt16: (value: MIRValue) ::=> MIRInstruction
        := self operation: MIR::Operation::ReturnInt16 with: value.

    public method returnInt32: (value: MIRValue) ::=> MIRInstruction
        := self operation: MIR::Operation::ReturnInt32 with: value.

    public method returnInt64: (value: MIRValue) ::=> MIRInstruction
        := self operation: MIR::Operation::ReturnInt64 with: value.

    public method returnPointer: (value: MIRValue) ::=> MIRInstruction
        := self operation: MIR::Operation::ReturnPointer with: value.

    public method returnFatPointer: (value: MIRValue) ::=> MIRInstruction
        := self operation: MIR::Operation::ReturnFatPointer with: value.

    public method returnFloat32: (value: MIRValue) ::=> MIRInstruction
        := self operation: MIR::Operation::ReturnFloat32 with: value.

    public method returnFloat64: (value: MIRValue) ::=> MIRInstruction
        := self operation: MIR::Operation::ReturnFloat64 with: value.

    public method returnStruct: (value: MIRValue) ::=> MIRInstruction
        := self operation: MIR::Operation::ReturnStruct with: value.

    public method trap ::=> MIRInstruction
        := self operation: MIR::Operation::Trap.

    public method unreachableTrap ::=> MIRInstruction
        := self operation: MIR::Operation::UnreachableTrap.

    public method debugSetBinding: (binding: SymbolBinding) value: (value: MIRValue) ::=> MIRInstruction
        := self addInstruction: ((MIRInstruction withType: Void compilationTarget: self compilationTarget)
            operation: MIR::Operation::DebugSetBindingValue;
            operands: (Array with: value);
            registerInUsedValues;
            sourceBinding: binding;
            yourself).

    public method debugSetMutableBinding: (binding: SymbolBinding) value: (value: MIRValue) ::=> MIRInstruction
        := self addInstruction: ((MIRInstruction withType: Void compilationTarget: self compilationTarget)
            operation: MIR::Operation::DebugSetMutableBindingValue;
            operands: (Array with: value);
            registerInUsedValues;
            sourceBinding: binding;
            yourself).

    public method debugSetMutableBindingSpecificValue: (binding: SymbolBinding) value: (value: MIRValue) ::=> MIRInstruction
        := self addInstruction: ((MIRInstruction withType: Void compilationTarget: self compilationTarget)
            operation: MIR::Operation::DebugSetMutableBindingSpecificValue;
            operands: (Array with: value);
            registerInUsedValues;
            sourceBinding: binding;
            yourself).
}.

public final class MIRFunctionBuilder superclass: Object; definition: {
    public field function => MIRFunction.

    ## Debugging information
    public field debugSourcePosition => SourcePosition.
    public field debugSourceNode => ASTNode.
    public field debugSourceEnvironment => Environment.

    MIRFunction extend: {
        public method build: (aBlock: (MIRFunctionBuilder) => Void) ::=> Void := {
            let builder := MIRFunctionBuilder new
                function: self;
                yourself.
            aBlock(builder).
        }.
    }.

    public method basicBlock: (name: Symbol) build: (aBlock: (MIRBlockBuilder) => Void) ::=> Void := {
        let block := (MIRBasicBlock forContext: function context) name: name; yourself.
        function addBasicBlock: block.

        let blockBuilder := (MIRBlockBuilder forContext: function context)
            block: block;
            function: function;
            yourself.
        aBlock(blockBuilder).
        block.
    }.

    public method setValueDebugInfo: (value: MIRLocalValue) ::=> Void := {
        value
            debugSourcePosition: debugSourcePosition;
            debugSourceNode: debugSourceNode;
            debugSourceEnvironment: debugSourceEnvironment
    }.

    public method newTemporary: (name: Symbol) withType: (type: Type) ::=> MIRTemporaryVariable := {
        let temporary := function newTemporary: name withType: type.
        self setValueDebugInfo: temporary.
        temporary
    }.
}.

#(
    BooleanNot
    Int8BitNot Int16BitNot Int32BitNot Int64BitNot
    Int8Negate Int16Negate Int32Negate Int64Negate
    Int8LowBit Int16LowBit Int32LowBit Int64LowBit
    Int8HighBit Int16HighBit Int32HighBit Int64HighBit
    Int8PopCount Int16PopCount Int32PopCount Int64PopCount

    Float32Negate Float64Negate
    Float32Sqrt Float64Sqrt

    TruncateInt64ToInt32 TruncateInt64ToInt16 TruncateInt64ToInt8
    TruncateInt32ToInt16 TruncateInt32ToInt8
    TruncateInt16ToInt8

    SignExtendInt8ToInt16 SignExtendInt8ToInt32 SignExtendInt8ToInt64
    SignExtendInt16ToInt32 SignExtendInt16ToInt64
    SignExtendInt32ToInt64

    ZeroExtendInt8ToInt16 ZeroExtendInt8ToInt32 ZeroExtendInt8ToInt64
    ZeroExtendInt16ToInt32 ZeroExtendInt16ToInt64
    ZeroExtendInt32ToInt64

    UInt8ToFloat32 Int8ToFloat32 UInt16ToFloat32 Int16ToFloat32 UInt32ToFloat32 Int32ToFloat32 UInt64ToFloat32 Int64ToFloat32
    UInt8ToFloat64 Int8ToFloat64 UInt16ToFloat64 Int16ToFloat64 UInt32ToFloat64 Int32ToFloat64 UInt64ToFloat64 Int64ToFloat64

    Float32ToFloat64 Float32ToUInt8 Float32ToInt8 Float32ToUInt16 Float32ToInt16 Float32ToUInt32 Float32ToInt32 Float32ToUInt64 Float32ToInt64
    Float64ToFloat32 Float64ToUInt8 Float64ToInt8 Float64ToUInt16 Float64ToInt16 Float64ToUInt32 Float64ToInt32 Float64ToUInt64 Float64ToInt64
    Float32ToIEEEUInt32 Float64ToIEEEUInt64 IEEEUInt32ToFloat32 IEEEUInt64ToFloat64

    FatPointerExtractFirst FatPointerExtractSecond
) do: {:(Symbol)operationName :: Void |
    let operationNameString := operationName asString.
    let lowerOperationNameString := operationNameString first asLowercase asString -- operationNameString allButFirst.
    let lowerOperationName := lowerOperationNameString asSymbol.
    let operation := MIROperation pureNamed: lowerOperationName.
    let globalName := ("MIR::Operation::" -- operationNameString) asSymbol.

    MIRBlockBuilder
        withSelector: (lowerOperationNameString -- ":type:") asSymbol addMethod: {:(MIRBlockBuilder)self :(MIRValue)operand :(Type)type :: MIRInstruction |
            self operation: operation with: operand type: type.
        } makeFinal recompileAndOptimize.
    __OwnerProgramEntity__ setPublicSymbol: globalName value: operation
}.

#(
    Int8Add Int16Add Int32Add Int64Add PointerAdd FatPointerAdd FatPointerAddOffset
    Int8Sub Int16Sub Int32Sub Int64Sub PointerSub FatPointerSub FatPointerSubOffset
    Int8Mul Int16Mul Int32Mul Int64Mul PointerMul
    Int8SDiv Int16SDiv Int32SDiv Int64SDiv
    Int8UDiv Int16UDiv Int32UDiv Int64UDiv
    Int8SRem Int16SRem Int32SRem Int64SRem
    Int8URem Int16URem Int32URem Int64URem

    Int8BitAnd Int16BitAnd Int32BitAnd Int64BitAnd
    Int8BitOr Int16BitOr Int32BitOr Int64BitOr
    Int8BitXor Int16BitXor Int32BitXor Int64BitXor BooleanXor
    Int8ArithmeticShiftRight Int16ArithmeticShiftRight Int32ArithmeticShiftRight Int64ArithmeticShiftRight
    Int8LogicalShiftLeft Int16LogicalShiftLeft Int32LogicalShiftLeft Int64LogicalShiftLeft
    Int8LogicalShiftRight Int16LogicalShiftRight Int32LogicalShiftRight Int64LogicalShiftRight

    Int8Compare Int16Compare Int32Compare Int64Compare

    Float32Add Float64Add
    Float32Sub Float64Sub
    Float32Mul Float64Mul
    Float32Div Float64Div

    Float32UnorderedCompare Float64UnorderedCompare

    FatPointerConstruct
) do: {:(Symbol)operationName :: Void |
    let operationNameString := operationName asString.
    let lowerOperationNameString := operationNameString first asLowercase asString -- operationNameString allButFirst.
    let lowerOperationName := lowerOperationNameString asSymbol.
    let operation := MIROperation pureNamed: lowerOperationName.
    operation isCommutative: (#("Add" "Mul" "And" "Or" "Xor") anySatisfy: {:(String)suffix :: Boolean |
        operationNameString endsWith: suffix
    }).
    operation isAssociative: operation isCommutative && (operationNameString beginsWith: "Float") not.

    let globalName := ("MIR::Operation::" -- operationNameString) asSymbol.

    MIRBlockBuilder
        withSelector: (lowerOperationNameString -- ":with:type:") asSymbol addMethod: {:(MIRBlockBuilder)self :(MIRValue)left :(MIRValue)right :(Type)type :: MIRInstruction |
            self operation: operation with: left with: right type: type.
        } makeFinal recompileAndOptimize.
    __OwnerProgramEntity__ setPublicSymbol: globalName value: operation
}.

public global MIR::ComparisonOperationToBranchMap := Dictionary new.

#(
    Int8Equals Int16Equals Int32Equals Int64Equals PointerEquals FatPointerEquals
    Int8NotEquals Int16NotEquals Int32NotEquals Int64NotEquals PointerNotEquals FatPointerNotEquals

    Int8LessThan Int16LessThan Int32LessThan Int64LessThan
    Int8LessOrEquals Int16LessOrEquals Int32LessOrEquals Int64LessOrEquals
    Int8GreaterThan Int16GreaterThan Int32GreaterThan Int64GreaterThan
    Int8GreaterOrEquals Int16GreaterOrEquals Int32GreaterOrEquals Int64GreaterOrEquals

    UInt8LessThan UInt16LessThan UInt32LessThan UInt64LessThan
    UInt8LessOrEquals UInt16LessOrEquals UInt32LessOrEquals UInt64LessOrEquals
    UInt8GreaterThan UInt16GreaterThan UInt32GreaterThan UInt64GreaterThan
    UInt8GreaterOrEquals UInt16GreaterOrEquals UInt32GreaterOrEquals UInt64GreaterOrEquals

    PointerLessThan FatPointerLessThan
    PointerLessOrEquals FatPointerLessOrEquals
    PointerGreaterThan FatPointerGreaterThan
    PointerGreaterOrEquals FatPointerGreaterOrEquals

    Float32UnorderedEquals Float64UnorderedEquals
    Float32UnorderedNotEquals Float64UnorderedNotEquals
    Float32UnorderedLessThan Float64UnorderedLessThan
    Float32UnorderedLessOrEquals Float64UnorderedLessOrEquals
    Float32UnorderedGreaterThan Float64UnorderedGreaterThan
    Float32UnorderedGreaterOrEquals Float64UnorderedGreaterOrEquals
) do: {:(Symbol)operationName :: Void |
    let operationNameString := operationName asString.
    let lowerOperationNameString := operationNameString first asLowercase asString -- operationNameString allButFirst.

    let branchOperationNameString := operationNameString -- "Branch".
    let lowerBranchOperationNameString := branchOperationNameString first asLowercase asString -- branchOperationNameString allButFirst.

    let operation := MIROperation pureNamed: lowerOperationNameString asSymbol.
    let globalName := ("MIR::Operation::" -- operationNameString) asSymbol.

    let branchOperation := MIROperation terminatorNamed: lowerBranchOperationNameString asSymbol.
    let branchGlobalName := ("MIR::Operation::" -- branchOperationNameString) asSymbol.

    MIRBlockBuilder
        withSelector: (lowerOperationNameString -- ":with:") asSymbol addMethod: {:(MIRBlockBuilder)self :(MIRValue)left :(MIRValue)right :: MIRInstruction |
            self operation: operation with: left with: right type: Boolean.
        } makeFinal recompileAndOptimize;
        withSelector: (lowerOperationNameString -- ":with:branchIfTrue:branchIfFalse:") asSymbol addMethod: {:(MIRBlockBuilder)self :(MIRValue)left :(MIRValue)right :(MIRValue)trueDestination :(MIRValue)falseDestination :: MIRInstruction |
            self operation: branchOperation with: left with: right with: trueDestination with: falseDestination.
        } makeFinal recompileAndOptimize.

    MIR::ComparisonOperationToBranchMap at: operation put: branchOperation.
    __OwnerProgramEntity__
        setPublicSymbol: globalName value: operation;
        setPublicSymbol: branchGlobalName value: branchOperation
}.

public final class MIRFunctionDefinitionPatch superclass: Object; definition: {
    public field functionDefinition => FunctionDefinition.
    public field checkedEntryPoint => MIRProgramEntity.
    public field uncheckedEntryPoint => MIRProgramEntity.
    public field uncheckedCapturelessEntryPoint => MIRProgramEntity.
}.

public final class MIRModule superclass: MIRProgramEntity; definition: {
    public field programEntities => OrderedCollection.
    public field baseObjectTracer => ImageTracer.
    public field functionDefinitionPatches => OrderedCollection.
    public field sourceProgramEntityDictionary => ObjectPointerDictionary.

    public override method initialize => Void := {
        super initialize.
        programEntities := OrderedCollection new.
        functionDefinitionPatches := OrderedCollection new.
        sourceProgramEntityDictionary := ObjectPointerDictionary new.
    }.

    public method addProgramEntity: (programEntity: MIRProgramEntity) ::=> Void := {
        programEntity sourceProgramEntity ifNotNil: {
            sourceProgramEntityDictionary at: programEntity sourceProgramEntity put: programEntity 
        }.
        programEntities add: programEntity
    }.

    public method importFunctionNamed: (name: Symbol) ::=> MIRImportedFunction := {
        let function := (MIRImportedFunction forContext: context)
            compilationTarget: compilationTarget;
            callingConvention: compilationTarget defaultCallingConvention;
            name: name;
            yourself.
        self addProgramEntity: function.
        function
    }.

    public method build: (name: Symbol) function: (aBlock: (MIRFunctionBuilder) => Void) ::=> MIRFunction := {
        let function := (MIRFunction forContext: context)
            compilationTarget: compilationTarget;
            callingConvention: compilationTarget defaultCallingConvention;
            name: name;
            yourself.
        self addProgramEntity: function.
        function build: aBlock; yourself
    }.

    public override method fullPrintOn: (stream: Stream) ::=> Void := {
        self programEntities do: {:(MIRProgramEntity)each :: Void |
            stream fullPrint: each; nl
        }
    }.

    public method asTargetIR => AnyValue
        := compilationTarget generateTargetIRForMIRModule: self.

    public method asTargetNativeCodeIR => AnyValue
        := compilationTarget generateTargetNativeCodeIRForMIRModule: self.

    public method asTargetNativeCode => NativeCode
        := compilationTarget generateTargetNativeCodeForMIRModule: self.

    public override method performStandardOptimizations => Void := {
        super performStandardOptimizations.
        programEntities do: {:(MIRProgramEntity)each :: Void |
            each performStandardOptimizations
        }
    }.
}.

MIRCallingConvention definition: {
    public abstract method computeArgumentPassingLayoutOf: (function: MIRFunction) ::=> Void
        := self subclassResponsibility.

    public abstract method integerCallPreservedRegisters => Array
        := self subclassResponsibility.

    public abstract method floatCallPreservedRegisters => Array
        := self subclassResponsibility.

    public abstract method vectorCallPreservedRegisters => Array
        := self subclassResponsibility.

    public abstract method allocableIntegerRegisters => Array
        := self subclassResponsibility.

    public abstract method allocableFloatRegisters => Array
        := self subclassResponsibility.

    public abstract method allocableVectorRegisters => Array
        := self subclassResponsibility.

    public virtual method preferredRegisterForCaptureVectorPointer => MIRPhysicalIntegerRegister
        := nil.

    public virtual method preferredRegisterForGotPointer => MIRPhysicalIntegerRegister
        := nil.

    public virtual method preferredRegisterForThreadLocalSegmentPointer => MIRPhysicalIntegerRegister
        := nil.

    public virtual method framePointerAnchorIsAtBottom => Boolean ## Required by the Win64 calling convention.
        := false.
}.

MIRCompilationTarget definition: {
    public abstract method name => Symbol
        := self subclassResponsibility.

    public abstract method getTargetSpecificBlockFor: (operation: MIROperation) ::=> MIROperationTargetSpecific
        := self subclassResponsibility.

    public virtual method passesReturnPointerThroughStack => Boolean
        := false.
        
    public abstract method pointerSize => Size
        := self subclassResponsibility.

    public abstract method pointerAlignment => Size
        := self subclassResponsibility.

    public abstract method uintPointerType => Type
        := self subclassResponsibility.

    public abstract method stackFrameAlignment => Size
        := self subclassResponsibility.

    public abstract method allIntegerRegisters => Array
        := self subclassResponsibility.

    public abstract method allFloatRegisters => Array
        := self subclassResponsibility.

    public abstract method allVectorRegisters => Array
        := self subclassResponsibility.

    public abstract method usesVectorRegistersForFloatOperations => Boolean
        := self subclassResponsibility.

    public abstract method callPreservedVectorSize => Size
        := self subclassResponsibility.

    public abstract method callPreservedVectorAlignment => Size
        := self subclassResponsibility.

    public abstract method generateTargetIRForMIRModule: (module: MIRModule) ::=> AnyValue
        := self subclassResponsibility.

    public abstract method generateTargetNativeCodeIRForMIRModule: (module: MIRModule) ::=> AnyValue
        := self subclassResponsibility.

    public virtual method generateTargetNativeCodeForMIRModule: (module: MIRModule) ::=> NativeCode
        := (self generateTargetNativeCodeIRForMIRModule: module) asNativeCode.

    public abstract method defaultCallingConvention => MIRCallingConvention
        := self subclassResponsibility.

    public abstract method callingConventionNamed: (conventionName: Symbol) ::=> MIRCallingConvention
        := self subclassResponsibility.

    public virtual method objectModel => ObjectModelVariant
        := self pointerSize = 4sz ifTrue: ObjectModelVariant32 uniqueInstance ifFalse: ObjectModelVariant64 uniqueInstance.

    public abstract method usesThreadLocalSegmentPointer => Boolean
        := self subclassResponsibility.
}.
