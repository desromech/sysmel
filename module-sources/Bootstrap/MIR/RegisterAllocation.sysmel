   
public abstract class MIRRegisterAllocator superclass: Object; definition: {
    public field compilationTarget => MIRCompilationTarget.

    public abstract method allocateRegistersIn: (function: MIRFunction) withTarget: (target: MIRCompilationTarget) ::=> Void
        := self subclassResponsibility.

    public abstract method allocateRegister: (register: MIRPhysicalLocation) forInstructionResult: (instruction: MIRInstruction) ::=> Void
        := self subclassResponsibility.

    public abstract method allocateRegister: (register: MIRPhysicalLocation) forInstructionResultPointer: (instruction: MIRInstruction) ::=> Void
        := self subclassResponsibility.

    public abstract method allocateRegister: (register: MIRPhysicalLocation) forInstruction: (instruction: MIRInstruction) operandAt: (operandIndex: Size) ::=> Void
        := self subclassResponsibility.

    public abstract method allocateRegister: (register: MIRPhysicalLocation) forInstruction: (instruction: MIRInstruction) operandPointerAt: (operandIndex: Size) ::=> Void
        := self subclassResponsibility.

    public abstract method allocateRegister: (register: MIRPhysicalLocation) forInstruction: (instruction: MIRInstruction) scratchAt: (operandIndex: Size) ::=> Void
        := self subclassResponsibility.

    public abstract method allocateRegisterForInstructionResult: (instruction: MIRInstruction) ::=> Void
        := self subclassResponsibility.

    public abstract method allocateRegisterForInstruction: (instruction: MIRInstruction) operandAt: (operandIndex: Size) ::=> Void
        := self subclassResponsibility.

    public abstract method allocateRegister8ForInstructionResult: (instruction: MIRInstruction) ::=> Void
        := self subclassResponsibility.

    public abstract method allocateRegister8ForInstruction: (instruction: MIRInstruction) operandAt: (operandIndex: Size) ::=> Void
        := self subclassResponsibility.

    public virtual method allocateRegister: (requiredRegister: MIRPhysicalLocation) orImmediateU8ForInstruction: (instruction: MIRInstruction) operandAt: (operandIndex: Size) ::=> Void := {
        let operand := instruction operands at: operandIndex.
        operand isImmediateU8 ifTrue: {
            instruction operandRegisters at: operandIndex put: (MIRPhysicalLocationImmediate for: operand)
        } ifFalse: {
            self allocateRegister: requiredRegister forInstruction: instruction operandAt: operandIndex
        }
    }.

    public virtual method allocateRegisterOrImmediate8ForInstruction: (instruction: MIRInstruction) operandAt: (operandIndex: Size) ::=> Void := {
        let operand := instruction operands at: operandIndex.
        operand isImmediate8 ifTrue: {
            instruction operandRegisters at: operandIndex put: (MIRPhysicalLocationImmediate for: operand)
        } ifFalse: {
            self allocateRegisterForInstruction: instruction operandAt: operandIndex
        }
    }.

    public virtual method allocateRegisterOrImmediate16ForInstruction: (instruction: MIRInstruction) operandAt: (operandIndex: Size) ::=> Void := {
        let operand := instruction operands at: operandIndex.
        operand isImmediate16 ifTrue: {
            instruction operandRegisters at: operandIndex put: (MIRPhysicalLocationImmediate for: operand)
        } ifFalse: {
            self allocateRegisterForInstruction: instruction operandAt: operandIndex
        }
    }.

    public virtual method allocateRegisterOrImmediate32ForInstruction: (instruction: MIRInstruction) operandAt: (operandIndex: Size) ::=> Void := {
        let operand := instruction operands at: operandIndex.
        operand isImmediate32 ifTrue: {
            instruction operandRegisters at: operandIndex put: (MIRPhysicalLocationImmediate for: operand)
        } ifFalse: {
            self allocateRegisterForInstruction: instruction operandAt: operandIndex
        }
    }.

    public virtual method allocateRegisterOrImmediate64ForInstruction: (instruction: MIRInstruction) operandAt: (operandIndex: Size) ::=> Void := {
        let operand := instruction operands at: operandIndex.
        operand isImmediate64 ifTrue: {
            instruction operandRegisters at: operandIndex put: (MIRPhysicalLocationImmediate for: operand)
        } ifFalse: {
            self allocateRegisterForInstruction: instruction operandAt: operandIndex
        }
    }.

    public virtual method allocateRegisterOrImmediateS32ForInstruction: (instruction: MIRInstruction) operandAt: (operandIndex: Size) ::=> Void := {
        let operand := instruction operands at: operandIndex.
        operand isImmediateS32 ifTrue: {
            instruction operandRegisters at: operandIndex put: (MIRPhysicalLocationImmediate for: operand)
        } ifFalse: {
            self allocateRegisterForInstruction: instruction operandAt: operandIndex
        }
    }.

    public virtual method allocateImmediate32ForInstruction: (instruction: MIRInstruction) operandAt: (operandIndex: Size) ::=> Void := {
        let operand := instruction operands at: operandIndex.
        operand isImmediate32 ifTrue: {
            instruction operandRegisters at: operandIndex put: (MIRPhysicalLocationImmediate for: operand)
        } ifFalse: {
            self error: "An immediate32 operand is required here."
        }
    }.

    public virtual method allocateRegisterOrRelativeImmediate32ForInstruction: (instruction: MIRInstruction) operandAt: (operandIndex: Size) ::=> Void := {
        let operand := instruction operands at: operandIndex.
        operand isRelativeImmediate32 ifTrue: {
            instruction operandRegisters at: operandIndex put: (MIRPhysicalLocationImmediate for: operand)
        } ifFalse: {
            self allocateRegisterForInstruction: instruction operandAt: operandIndex
        }
    }.

    public virtual method allocateMemoryForInstruction: (instruction: MIRInstruction) operandAt: (operandIndex: Size) ::=> Void := {
        instruction operandRegisters at: operandIndex put: MIRPhysicalLocationMemory uniqueInstance
    }.

    public virtual method allocateMemoryForInstructionResult: (instruction: MIRInstruction) ::=> Void := {
        instruction resultRegister: MIRPhysicalLocationMemory uniqueInstance
    }.

    public abstract method allocateIntegerRegisterForValue: (value: MIRValue) ::=> MIRPhysicalLocation
        := self subclassResponsibility.

    public abstract method allocateIntegerRegister8ForValue: (value: MIRValue) ::=> MIRPhysicalLocation
        := self subclassResponsibility.

    public abstract method allocateFloatRegisterForValue: (value: MIRValue) ::=> MIRPhysicalLocation
        := self subclassResponsibility.

    public abstract method allocateVectorRegisterForValue: (value: MIRValue) ::=> MIRPhysicalLocation
        := self subclassResponsibility.

    public method makeActiveRegister: (register: MIRPhysicalLocation) withValue: (value: MIRValue) ::=> Void := {
        register makeActiveWithValue: value inRegisterAllocator: self
    }.

    public method makeActiveRegister: (register: MIRPhysicalLocation) withValuePointer: (value: MIRValue) ::=> Void := {
        register makeActiveWithValuePointer: value inRegisterAllocator: self
    }.

    public method makeActiveRegister: (register: MIRPhysicalLocation) withResultValue: (value: MIRValue) ::=> Void := {
        register makeActiveWithResultValue: value inRegisterAllocator: self
    }.

    public abstract method makeActiveIntegerRegister: (register: MIRPhysicalIntegerRegister) withValue: (value: MIRValue) ::=> Void
        := self subclassResponsibility.

    public abstract method makeActiveIntegerRegister: (register: MIRPhysicalIntegerRegister) withValuePointer: (value: MIRValue) ::=> Void
        := self subclassResponsibility.

    public abstract method makeActiveIntegerRegister: (register: MIRPhysicalIntegerRegister) withResultValue: (value: MIRValue) ::=> Void
        := self subclassResponsibility.

    public abstract method makeActiveFloatRegister: (register: MIRPhysicalFloatRegister) withValue: (value: MIRValue) ::=> Void
        := self subclassResponsibility.

    public abstract method makeActiveFloatRegister: (register: MIRPhysicalFloatRegister) withValuePointer: (value: MIRValue) ::=> Void
        := self subclassResponsibility.

    public abstract method makeActiveFloatRegister: (register: MIRPhysicalFloatRegister) withResultValue: (value: MIRValue) ::=> Void
        := self subclassResponsibility.

    public abstract method makeActiveVectorRegister: (register: MIRPhysicalVectorRegister) withValue: (value: MIRValue) ::=> Void
        := self subclassResponsibility.

    public abstract method makeActiveVectorRegister: (register: MIRPhysicalVectorRegister) withValuePointer: (value: MIRValue) ::=> Void
        := self subclassResponsibility.

    public abstract method makeActiveVectorRegister: (register: MIRPhysicalVectorRegister) withResultValue: (value: MIRValue) ::=> Void
        := self subclassResponsibility.

    public virtual method allocateRegisterOrMemoryForInstruction: (instruction: MIRInstruction) operandAt: (operandIndex: Size) ::=> Void := {
        self allocateRegisterForInstruction: instruction operandAt: operandIndex
    }.
}.

MIRPhysicalLocation extend: {
    __Meta__ extend: {
        public abstract method allocateRegisterForValue: (value: MIRValue) with: (registerAllocator: MIRRegisterAllocator) ::=> MIRPhysicalLocation
            := self subclassResponsibility.
    }.

    public abstract method makeActiveWithValue: (value: MIRValue) inRegisterAllocator: (registerAllocator: MIRRegisterAllocator) ::=> Void
        := self subclassResponsibility.

    public abstract method makeActiveWithValuePointer: (value: MIRValue) inRegisterAllocator: (registerAllocator: MIRRegisterAllocator) ::=> Void
        := self subclassResponsibility.

    public abstract method makeActiveWithResultValue: (value: MIRValue) inRegisterAllocator: (registerAllocator: MIRRegisterAllocator) ::=> Void
        := self subclassResponsibility.
}.

MIRPhysicalIntegerRegister extend: {
    __Meta__ extend: {
        public override method allocateRegisterForValue: (value: MIRValue) with: (registerAllocator: MIRRegisterAllocator) ::=> MIRPhysicalLocation
            := registerAllocator allocateIntegerRegisterForValue: value.
    }.

    public override method makeActiveWithValue: (value: MIRValue) inRegisterAllocator: (registerAllocator: MIRRegisterAllocator) ::=> Void := {
        registerAllocator makeActiveIntegerRegister: self withValue: value
    }.

    public override method makeActiveWithValuePointer: (value: MIRValue) inRegisterAllocator: (registerAllocator: MIRRegisterAllocator) ::=> Void := {
        registerAllocator makeActiveIntegerRegister: self withValuePointer: value
    }.

    public override method makeActiveWithResultValue: (value: MIRValue) inRegisterAllocator: (registerAllocator: MIRRegisterAllocator) ::=> Void := {
        registerAllocator makeActiveIntegerRegister: self withResultValue: value
    }.
}.

MIRPhysicalFloatRegister extend: {
    __Meta__ extend: {
        public override method allocateRegisterForValue: (value: MIRValue) with: (registerAllocator: MIRRegisterAllocator) ::=> MIRPhysicalLocation
            := registerAllocator allocateFloatRegisterForValue: value.
    }.

    public override method makeActiveWithValue: (value: MIRValue) inRegisterAllocator: (registerAllocator: MIRRegisterAllocator) ::=> Void := {
        registerAllocator makeActiveFloatRegister: self withValue: value
    }.

    public override method makeActiveWithValuePointer: (value: MIRValue) inRegisterAllocator: (registerAllocator: MIRRegisterAllocator) ::=> Void := {
        registerAllocator makeActiveFloatRegister: self withValuePointer: value
    }.

    public override method makeActiveWithResultValue: (value: MIRValue) inRegisterAllocator: (registerAllocator: MIRRegisterAllocator) ::=> Void := {
        registerAllocator makeActiveFloatRegister: self withResultValue: value
    }.
}.

MIRPhysicalVectorRegister extend: {
    __Meta__ extend: {
        public override method allocateRegisterForValue: (value: MIRValue) with: (registerAllocator: MIRRegisterAllocator) ::=> MIRPhysicalLocation
            := registerAllocator allocateVectorRegisterForValue: value.
    }.

    public override method makeActiveWithValue: (value: MIRValue) inRegisterAllocator: (registerAllocator: MIRRegisterAllocator) ::=> Void := {
        registerAllocator makeActiveVectorRegister: self withValue: value
    }.

    public override method makeActiveWithValuePointer: (value: MIRValue) inRegisterAllocator: (registerAllocator: MIRRegisterAllocator) ::=> Void := {
        registerAllocator makeActiveVectorRegister: self withValuePointer: value
    }.

    public override method makeActiveWithResultValue: (value: MIRValue) inRegisterAllocator: (registerAllocator: MIRRegisterAllocator) ::=> Void := {
        registerAllocator makeActiveVectorRegister: self withResultValue: value
    }.
}.

public class MIRInstructionLoadValueInRegisterOperation superclass: MIRInstructionSurroundingOperation; definition: {
    public field value => MIRValue.
    public field register => MIRPhysicalLocation.
}.

public class MIRInstructionStoreValueInRegisterOperation superclass: MIRInstructionSurroundingOperation; definition: {
    public field value => MIRLocalVariable.
    public field register => MIRPhysicalLocation.
}.

public class MIRInstructionMoveRegisterOperation superclass: MIRInstructionSurroundingOperation; definition: {
    public field sourceRegister => MIRPhysicalLocation.
    public field destinationRegister => MIRPhysicalLocation.
}.

MIROperation extend: {
    public method forTarget: (target: Symbol) registerConstraintsWith: (registerAssignmentBlock: (MIRInstruction, MIRRegisterAllocator) => Void) ::=> Void := {
        perTargetRegisterConstraints at: target put: registerAssignmentBlock
    }.

    public method forTargets: (targets: Array) registerConstraintsWith: (registerAssignmentBlock: (MIRInstruction, MIRRegisterAllocator) => Void) ::=> Void := {
        targets do: {:(Symbol)eachTarget :: Void |
            self forTarget: eachTarget registerConstraintsWith: registerAssignmentBlock
        }
    }.

    public method computeRegisterConstraintsOf: (instruction: MIRInstruction) with: (registerAllocator: MIRRegisterAllocator) ::=> Void := {
        let targetName := registerAllocator compilationTarget name.
        (perTargetRegisterConstraints at: targetName
            ifAbsent: {:: Void |
            self error: "Missing register constraints for MIR operation '" -- name printString -- "' in " -- targetName asString -- "."
        }) (instruction, registerAllocator)
    }.
}.

MIRCallingConvention extend: {
    public abstract method registerConstraintsOfCallInt8: (instruction: MIRInstruction) with: (registerAllocator: MIRRegisterAllocator) ::=> Void
        := self subclassResponsibility.

    public abstract method registerConstraintsOfCallInt16: (instruction: MIRInstruction) with: (registerAllocator: MIRRegisterAllocator) ::=> Void
        := self subclassResponsibility.

    public abstract method registerConstraintsOfCallInt32: (instruction: MIRInstruction) with: (registerAllocator: MIRRegisterAllocator) ::=> Void
        := self subclassResponsibility.

    public abstract method registerConstraintsOfCallInt64: (instruction: MIRInstruction) with: (registerAllocator: MIRRegisterAllocator) ::=> Void
        := self subclassResponsibility.

    public abstract method registerConstraintsOfCallFloat32: (instruction: MIRInstruction) with: (registerAllocator: MIRRegisterAllocator) ::=> Void
        := self subclassResponsibility.

    public abstract method registerConstraintsOfCallFloat64: (instruction: MIRInstruction) with: (registerAllocator: MIRRegisterAllocator) ::=> Void
        := self subclassResponsibility.

    public abstract method registerConstraintsOfCallStruct: (instruction: MIRInstruction) with: (registerAllocator: MIRRegisterAllocator) ::=> Void
        := self subclassResponsibility.

    public abstract method registerConstraintsOfCallVoid: (instruction: MIRInstruction) with: (registerAllocator: MIRRegisterAllocator) ::=> Void
        := self subclassResponsibility.
}.

public final class MIRRegisterAllocationFile superclass: Object; definition: {
    public field registers => Array.
    public field usedRegisters => Array.
    public field activeRegisters => Array.
    public field spillOperations => OrderedCollection.
    public field unspillOperations => OrderedCollection.
    public field storeOperations => OrderedCollection.

    __Meta__ definition: {
        public method for: (registers: Array) ::=> self
            := self new
                registers: registers;
                usedRegisters: ((Array new: registers size)
                    atAllPut: false;
                    yourself);
                activeRegisters: ((Array new: registers size)
                    atAllPut: false;
                    yourself);
                yourself

    }.

    public override method initialize => Void := {
        super initialize.
        spillOperations := OrderedCollection new.
        unspillOperations := OrderedCollection new.
        storeOperations := OrderedCollection new.
    }.

    public method reset => Void := {
        activeRegisters atAllPut: false.
    }.

    public method resetOperations => Void := {
        spillOperations removeAll.
        unspillOperations removeAll.
        storeOperations removeAll.
    }.

    public method preOperations => Array
        := spillOperations asArray -- unspillOperations asArray.

    public method postOperations => Array
        := storeOperations asArray.

    public method makeActiveRegister: (usedRegister: MIRPhysicalLocation) ::=> Void
        := self makeActiveRegister: usedRegister withValue: nil.

    public method makeActiveRegister: (usedRegister: MIRPhysicalLocation) withValue: (value: MIRValue) ::=> Void := {
        let foundIndex := registers indexOf: usedRegister.
        self assert: foundIndex >= 0iptr.
        
        let index := foundIndex asSize.
        activeRegisters at: index put: true.
        usedRegisters at: index put: true.
    }.

    public method makeActiveRegister: (usedRegister: MIRPhysicalLocation) withValuePointer: (value: MIRValue) ::=> Void
        := self makeActiveRegister: usedRegister withValue: value.

    public method makeActiveRegister: (usedRegister: MIRPhysicalLocation) withResultValue: (value: MIRValue) ::=> Void
        := self makeActiveRegister: usedRegister withValue: value.

    public method allocate => MIRPhysicalLocation := {
        let nextRegisterIndex := activeRegisters indexOf: false.
        self assert: nextRegisterIndex >= 0iptr.

        let index := nextRegisterIndex asSize.
        activeRegisters at: index put: true.
        usedRegisters at: index put: true.
        registers at: index
    }.

    public method allocateForByte => MIRPhysicalLocation := {
        let result := self allocate.
        self assert: result canBeUsedForByte.
        result
    }.

    public method allocateForValue: (value: MIRValue) ::=> MIRPhysicalLocation
        := self allocate.

    public method allocateForByteValue: (value: MIRValue) ::=> MIRPhysicalLocation
        := self allocateForByte.

    public method allocateForCaptureVector => MIRPhysicalLocation
        := self allocate.
}.

public final class MIRSimpleRegisterAllocator superclass: MIRRegisterAllocator; definition: {
    protected field integerRegisterFile => MIRRegisterAllocationFile.
    protected field floatRegisterFile => MIRRegisterAllocationFile.
    protected field vectorRegisterFile => MIRRegisterAllocationFile.

    public override method allocateRegistersIn: (function: MIRFunction) withTarget: (target: MIRCompilationTarget) ::=> Void := {
        compilationTarget := target.

        integerRegisterFile := MIRRegisterAllocationFile for: target allocableIntegerRegisters.
        vectorRegisterFile := MIRRegisterAllocationFile for: target allocableVectorRegisters.
        target usesVectorRegistersForFloatOperations ifTrue: {
            floatRegisterFile := vectorRegisterFile
        } ifFalse: {
            floatRegisterFile := MIRRegisterAllocationFile for: target allocableFloatRegisters.
        }.

        function basicBlocksDo: {:(MIRBasicBlock)basicBlock :: Void |
            self allocateRegistersInBasicBlock: basicBlock
        }
    }.

    public method allocateRegistersInBasicBlock: (basicBlock: MIRBasicBlock) ::=> Void := {
        basicBlock instructionsDo: {:(MIRInstruction)instruction :: Void |
            self allocateInstructionRegisters: instruction
        }
    }.

    public method allocateInstructionRegisters: (instruction: MIRInstruction) ::=> Void := {
        instruction isDebug ifTrue: {
            ## FIXME: Avoid requiring this spilling.
            instruction operands first markSpillingRequired.
            return: void.
        }.

        self resetRegisterFiles.
        self resetRegisterFilesInstructionOperations.
        instruction resetRegisterAllocation.
        instruction operation computeRegisterConstraintsOf: instruction with: self.
        instruction usesCapture ifTrue: {
            instruction captureVectorPointerRegister: integerRegisterFile allocateForCaptureVector
        }.
    }.

    public method resetRegisterFiles => Void := {
        integerRegisterFile reset.
        floatRegisterFile ifNotNil: (floatRegisterFile reset).
        vectorRegisterFile ifNotNil: (vectorRegisterFile reset).
    }.

    public method resetRegisterFilesInstructionOperations => Void := {
        integerRegisterFile resetOperations.
        floatRegisterFile ifNotNil: (floatRegisterFile resetOperations).
        vectorRegisterFile ifNotNil: (vectorRegisterFile resetOperations).
    }.

    public override method allocateRegisterForInstructionResult: (instruction: MIRInstruction) ::=> Void := {
        let result := instruction result.
        result ifNotNil: {
            instruction resultRegister: (self allocateRegisterForOperand: result).
            result markSpillingRequired
        }
    }.

    public override method allocateRegister8ForInstructionResult: (instruction: MIRInstruction) ::=> Void := {
        let result := instruction result.
        result ifNotNil: {
            instruction resultRegister: (self allocateRegister8ForOperand: result).
            result markSpillingRequired
        }
    }.

    public override method allocateRegister: (register: MIRPhysicalLocation) forInstructionResult: (instruction: MIRInstruction) ::=> Void := {
        instruction resultRegister: register.
        instruction result markSpillingRequired.
        self makeActiveRegister: register withResultValue: instruction result.
    }.

    public override method allocateRegister: (register: MIRPhysicalLocation) forInstructionResultPointer: (instruction: MIRInstruction) ::=> Void := {
        instruction resultRegister: (MIRPhysicalLocationRegisterWithPointer new register: register; yourself).
        instruction result markSpillingRequired.
        self makeActiveRegister: register withValuePointer: instruction result.
    }.

    public override method allocateRegister: (register: MIRPhysicalLocation) forInstruction: (instruction: MIRInstruction) operandAt: (operandIndex: Size) ::=> Void := {
        instruction operandRegisters at: operandIndex put: register.
        let operand => MIRValue := instruction operands at: operandIndex.
        operand markSpillingRequired.
        self makeActiveRegister: register withValue: operand
    }.

    public override method allocateRegister: (register: MIRPhysicalLocation) forInstruction: (instruction: MIRInstruction) operandPointerAt: (operandIndex: Size) ::=> Void := {
        instruction operandRegisters at: operandIndex put: (MIRPhysicalLocationRegisterWithPointer new register: register; yourself).
        let operand => MIRValue := instruction operands at: operandIndex.
        operand markSpillingRequired.
        self makeActiveRegister: register withValuePointer: operand
    }.

    public override method allocateRegister: (register: MIRPhysicalLocation) forInstruction: (instruction: MIRInstruction) scratchAt: (scratchIndex: Size) ::=> Void := {
        ##instruction scratchRegisters at: scratchIndex put: register.
        self makeActiveRegister: register withValue: nil
    }.

    public override method allocateRegisterForInstruction: (instruction: MIRInstruction) operandAt: (operandIndex: Size) ::=> Void := {
        let operand => MIRValue := instruction operands at: operandIndex.
        let register :=
            (operandIndex == 0sz) &&
            (instruction resultRegister isNotNil) &&
            (instruction result physicalLocationClass == instruction operands first physicalLocationClass)
            ifTrue: (instruction resultRegister)
            ifFalse: (self allocateRegisterForOperand: operand).
        instruction operandRegisters at: operandIndex put: register.
        operand markSpillingRequired.
    }.
    
    public override method allocateRegister8ForInstruction: (instruction: MIRInstruction) operandAt: (operandIndex: Size) ::=> Void := {
        let operand => MIRValue  := instruction operands at: operandIndex.
        let register :=
            (operandIndex == 0sz) &&
            (instruction resultRegister isNotNil) &&
            (instruction result physicalLocationClass == instruction operands first physicalLocationClass)
            ifTrue: (instruction resultRegister)
            ifFalse: (self allocateRegister8ForOperand: operand).
        instruction operandRegisters at: operandIndex put: register.
        operand markSpillingRequired.
    }.

    public method allocateRegisterForOperand: (operand: MIRValue) ::=> MIRPhysicalLocation := {
        operand physicalLocationClass allocateRegisterForValue: operand with: self
    }.

    public method allocateRegister8ForOperand: (operand: MIRValue) ::=> MIRPhysicalLocation
        := self allocateIntegerRegister8ForValue: operand.

    public override method allocateIntegerRegisterForValue: (value: MIRValue) ::=> MIRPhysicalLocation
        := integerRegisterFile allocateForValue: value.

    public override method allocateIntegerRegister8ForValue: (value: MIRValue) ::=> MIRPhysicalLocation
        := integerRegisterFile allocateForByteValue: value.

    public override method makeActiveIntegerRegister: (register: MIRPhysicalIntegerRegister) withValue: (value: MIRValue) ::=> Void := {
        integerRegisterFile makeActiveRegister: register withValue: value
    }.

    public override method makeActiveIntegerRegister: (register: MIRPhysicalIntegerRegister) withValuePointer: (value: MIRValue) ::=> Void := {
        integerRegisterFile makeActiveRegister: register withValuePointer: value
    }.

    public override method makeActiveIntegerRegister: (register: MIRPhysicalIntegerRegister) withResultValue: (value: MIRValue) ::=> Void := {
        integerRegisterFile makeActiveRegister: register withResultValue: value
    }.

    public override method allocateFloatRegisterForValue: (value: MIRValue) ::=> MIRPhysicalLocation
        := floatRegisterFile allocateForValue: value.

    public override method makeActiveFloatRegister: (register: MIRPhysicalFloatRegister) withValue: (value: MIRValue) ::=> Void := {
        floatRegisterFile makeActiveRegister: register withValue: value
    }.

    public override method makeActiveFloatRegister: (register: MIRPhysicalFloatRegister) withValuePointer: (value: MIRValue) ::=> Void := {
        floatRegisterFile makeActiveRegister: register withValuePointer: value
    }.

    public override method makeActiveFloatRegister: (register: MIRPhysicalFloatRegister) withResultValue: (value: MIRValue) ::=> Void := {
        floatRegisterFile makeActiveRegister: register withResultValue: value
    }.

    public override method allocateVectorRegisterForValue: (value: MIRValue) ::=> MIRPhysicalLocation
        := vectorRegisterFile allocateForValue: value.

    public override method makeActiveVectorRegister: (register: MIRPhysicalVectorRegister) withValue: (value: MIRValue) ::=> Void := {
        vectorRegisterFile makeActiveRegister: register withValue: value
    }.

    public override method makeActiveVectorRegister: (register: MIRPhysicalVectorRegister) withValuePointer: (value: MIRValue) ::=> Void := {
        vectorRegisterFile makeActiveRegister: register withValuePointer: value
    }.

    public override method makeActiveVectorRegister: (register: MIRPhysicalVectorRegister) withResultValue: (value: MIRValue) ::=> Void := {
        vectorRegisterFile makeActiveRegister: register withResultValue: value
    }.
}.
