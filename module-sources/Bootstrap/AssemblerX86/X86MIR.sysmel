MIRPhysicalLocation extend: {
    public virtual method x86::int8For: (codegen: MIRFunctionAsmCodeGenerator) ::=> AsmInstructionOperand
        := self error: "Not a x86 register with int8 section.".

    public virtual method x86::int16For: (codegen: MIRFunctionAsmCodeGenerator) ::=> AsmInstructionOperand
        := self error: "Not a x86 register with int16 section.".

    public virtual method x86::int32For: (codegen: MIRFunctionAsmCodeGenerator) ::=> AsmInstructionOperand
        := self error: "Not a x86 register with int32 section.".

    public virtual method x86::int64For: (codegen: MIRFunctionAsmCodeGenerator) ::=> AsmInstructionOperand
        := self error: "Not a x86 register with int64 section.".

    public virtual method x86::float32For: (codegen: MIRFunctionAsmCodeGenerator) ::=> AsmInstructionOperand
        := self error: "Not a x86 register with float32 section.".

    public virtual method x86::float64For: (codegen: MIRFunctionAsmCodeGenerator) ::=> AsmInstructionOperand
        := self error: "Not a x86 register with float64 section.".

    public virtual method x86::vector128For: (codegen: MIRFunctionAsmCodeGenerator) ::=> AsmInstructionOperand
        := self error: "Not a x86 register with vector128 section.".

    public virtual method x86::int8PointerWithOffset: (offset: MIRPhysicalLocation) for: (codegen: MIRFunctionAsmCodeGenerator) ::=> AsmInstructionOperand
        := self error: "Not a x86 pointer.".

    public virtual method x86::int16PointerWithOffset: (offset: MIRPhysicalLocation) for: (codegen: MIRFunctionAsmCodeGenerator) ::=> AsmInstructionOperand
        := self error: "Not a x86 pointer.".

    public virtual method x86::int32PointerWithOffset: (offset: MIRPhysicalLocation) for: (codegen: MIRFunctionAsmCodeGenerator) ::=> AsmInstructionOperand
        := self error: "Not a x86 pointer.".

    public virtual method x86::int64PointerWithOffset: (offset: MIRPhysicalLocation) for: (codegen: MIRFunctionAsmCodeGenerator) ::=> AsmInstructionOperand
        := self error: "Not a x86 pointer.".

    public virtual method x86::float32PointerWithOffset: (offset: MIRPhysicalLocation) for: (codegen: MIRFunctionAsmCodeGenerator) ::=> AsmInstructionOperand
        := self error: "Not a x86 pointer.".

    public virtual method x86::float64PointerWithOffset: (offset: MIRPhysicalLocation) for: (codegen: MIRFunctionAsmCodeGenerator) ::=> AsmInstructionOperand
        := self error: "Not a x86 pointer.".

    public virtual method x86::vector128PointerWithOffset: (offset: MIRPhysicalLocation) for: (codegen: MIRFunctionAsmCodeGenerator) ::=> AsmInstructionOperand
        := self error: "Not a x86 pointer.".

    public virtual method x86::immediate32For: (codegen: MIRAsmCodeGenerator) ::=> AsmImmediate
        := self error: "Not an immediate 32".

    public virtual method x86::immediateS32OrInt64For: (codegen: MIRAsmCodeGenerator) ::=> AsmInstructionOperand
        := self error: "Not an immediate S32 or int64 register".

    public virtual method x86::rel32OrInt32For: (codegen: MIRAsmCodeGenerator) ::=> AsmInstructionOperand
        := self error: "Not a x86 relative32 immediate or int32 register".

    public virtual method x86::rel32OrInt64For: (codegen: MIRAsmCodeGenerator) ::=> AsmInstructionOperand
        := self error: "Not a x86 relative32 immediate or int64 register".

    public virtual method x86::relCall32OrInt32For: (codegen: MIRAsmCodeGenerator) ::=> AsmInstructionOperand
        := self error: "Not a x86 relativeCall32 immediate or int32 register".

    public virtual method x86::relCall32OrInt64For: (codegen: MIRAsmCodeGenerator) ::=> AsmInstructionOperand
        := self error: "Not a x86 relativeCall32 immediate or int64 register".

    public abstract method x86::loadFromValue: (value: MIRValue) pointer: (valuePointer: AsmX86RegisterAddress) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void
        := self shouldBeImplemented.

    public abstract method x86::loadFromVariable: (local: MIRValue) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        local size = 0sz ifFalse: {
            self x86::loadFromValue: local pointer: (local x86::pointerWithCodegen: codegen) with: codegen
        }.
    }.

    public abstract method x86::loadFromRegister: (register: MIRPhysicalLocation) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void
        := self shouldBeImplemented.

    public abstract method x86::storeValue: (value: MIRValue) inPointer: (valuePointer: AsmX86RegisterAddress) isCallArgument: (isCallArgument: Boolean) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void
        := self shouldBeImplemented.

    public abstract method x86::storeInVariable: (local: MIRValue) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        local size = 0sz ifFalse: {
            self x86::storeValue: local inPointer: (local x86::pointerWithCodegen: codegen) isCallArgument: false with: codegen
        }
    }.

    public abstract method x86::pushWith: (codegen: MIRFunctionAsmCodeGenerator) valueSize: (size: UInt64)::=> Void
        := self shouldBeImplemented.

    public abstract method x86_64::loadFromValue: (value: MIRValue) pointer: (valuePointer: AsmX86RegisterAddress) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void
        := self shouldBeImplemented.

    public abstract method x86_64::loadFromRegister: (register: MIRPhysicalLocation) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void
        := self shouldBeImplemented.

    public virtual method x86_64::loadFromVariable: (local: MIRValue) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        local size = 0sz ifFalse: {
            self x86_64::loadFromValue: local pointer: (local x86_64::pointerWithCodegen: codegen) with: codegen
        }.
    }.

    public abstract method x86_64::storeValue: (value: MIRValue) inPointer: (valuePointer: AsmX86RegisterAddress) isCallArgument: (isCallArgument: Boolean) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void
        := self shouldBeImplemented.

    public virtual method x86_64::storeInVariable: (local: MIRValue) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        local size = 0sz ifFalse: {
            self x86_64::storeValue: local inPointer: (local x86_64::pointerWithCodegen: codegen) isCallArgument: false with: codegen
        }
    }.

    public abstract method x86_64::pushWith: (codegen: MIRFunctionAsmCodeGenerator) valueSize: (size: UInt64)::=> Void
        := self shouldBeImplemented.
}.

MIRPhysicalLocationImmediate extend: {
    public override method x86::int8For: (codegen: MIRFunctionAsmCodeGenerator) ::=> AsmInstructionOperand
        := value asm::immediate8For: codegen.

    public override method x86::int16For: (codegen: MIRFunctionAsmCodeGenerator) ::=> AsmInstructionOperand
        := value asm::immediate16For: codegen.

    public override method x86::int32For: (codegen: MIRFunctionAsmCodeGenerator) ::=> AsmInstructionOperand
        := value asm::immediate32For: codegen.

    public override method x86::immediate32For: (codegen: MIRAsmCodeGenerator) ::=> AsmImmediate
        := value asm::immediate32For: codegen.

    public override method x86::immediateS32OrInt64For: (codegen: MIRAsmCodeGenerator) ::=> AsmInstructionOperand
        := value asm::immediateS32For: codegen.

    public override method x86::int64For: (codegen: MIRFunctionAsmCodeGenerator) ::=> AsmInstructionOperand
        := value asm::immediate64For: codegen.

    public override method x86::rel32OrInt32For: (codegen: MIRAsmCodeGenerator) ::=> AsmInstructionOperand
        := value asm::immediate32For: codegen.

    public override method x86::rel32OrInt64For: (codegen: MIRAsmCodeGenerator) ::=> AsmInstructionOperand
        := value asm::immediate32For: codegen.

    public override method x86::relCall32OrInt32For: (codegen: MIRAsmCodeGenerator) ::=> AsmInstructionOperand
        := value asm::immediateCall32For: codegen.

    public override method x86::relCall32OrInt64For: (codegen: MIRAsmCodeGenerator) ::=> AsmInstructionOperand
        := value asm::immediateCall32For: codegen.
}.

MIRPhysicalLocationValuePointer extend: {
    public override method x86::int8PointerWithOffset: (offset: MIRPhysicalLocation) for: (codegen: MIRFunctionAsmCodeGenerator) ::=> AsmInstructionOperand
        := (value x86_x86_64::pointerWithCodegen: codegen) + (offset x86::immediate32For: codegen)
                size: 1u8;
                yourself.

    public override method x86::int16PointerWithOffset: (offset: MIRPhysicalLocation) for: (codegen: MIRFunctionAsmCodeGenerator) ::=> AsmInstructionOperand
        := (value x86_x86_64::pointerWithCodegen: codegen) + (offset x86::immediate32For: codegen)
                size: 2u8;
                yourself.

    public override method x86::int32PointerWithOffset: (offset: MIRPhysicalLocation) for: (codegen: MIRFunctionAsmCodeGenerator) ::=> AsmInstructionOperand
        := (value x86_x86_64::pointerWithCodegen: codegen) + (offset x86::immediate32For: codegen)
                size: 4u8;
                yourself.

    public override method x86::int64PointerWithOffset: (offset: MIRPhysicalLocation) for: (codegen: MIRFunctionAsmCodeGenerator) ::=> AsmInstructionOperand
        := (value x86_x86_64::pointerWithCodegen: codegen) + (offset x86::immediate32For: codegen)
                size: 8u8;
                yourself.

    public override method x86::float32PointerWithOffset: (offset: MIRPhysicalLocation) for: (codegen: MIRFunctionAsmCodeGenerator) ::=> AsmInstructionOperand
        := (value x86_x86_64::pointerWithCodegen: codegen) + (offset x86::immediate32For: codegen)
                size: 4u8;
                yourself.

    public override method x86::float64PointerWithOffset: (offset: MIRPhysicalLocation) for: (codegen: MIRFunctionAsmCodeGenerator) ::=> AsmInstructionOperand
        := (value x86_x86_64::pointerWithCodegen: codegen) + (offset x86::immediate32For: codegen)
                size: 8u8;
                yourself.

    public override method x86::vector128PointerWithOffset: (offset: MIRPhysicalLocation) for: (codegen: MIRFunctionAsmCodeGenerator) ::=> AsmInstructionOperand
        := (value x86_x86_64::pointerWithCodegen: codegen) + (offset x86::immediate32For: codegen)
                size: 16u8;
                yourself.
}.

MIRPhysicalLocationValuePointerOrAssignedRegister extend: {
    public override method x86::int8For: (codegen: MIRFunctionAsmCodeGenerator) ::=> AsmInstructionOperand := {
        value coalescedAssignedRegister ifNotNil: {:(MIRPhysicalLocation)register :: AsmInstructionOperand | 
            register x86::int8For: codegen
        } ifNil: {
            (value x86_x86_64::pointerWithCodegen: codegen) copy
                size: 1u8;
                yourself
        }
    }.

    public override method x86::int16For: (codegen: MIRFunctionAsmCodeGenerator) ::=> AsmInstructionOperand := {
        value coalescedAssignedRegister ifNotNil: {:(MIRPhysicalLocation)register :: AsmInstructionOperand | 
            register x86::int16For: codegen
        } ifNil: {
            (value x86_x86_64::pointerWithCodegen: codegen) copy
                size: 2u8;
                yourself
        }
    }.

    public override method x86::int32For: (codegen: MIRFunctionAsmCodeGenerator) ::=> AsmInstructionOperand := {
        value coalescedAssignedRegister ifNotNil: {:(MIRPhysicalLocation)register :: AsmInstructionOperand | 
            register x86::int32For: codegen
        } ifNil: {
            (value x86_x86_64::pointerWithCodegen: codegen) copy
                size: 4u8;
                yourself
        }
    }.

    public override method x86::int64For: (codegen: MIRFunctionAsmCodeGenerator) ::=> AsmInstructionOperand := {
        value coalescedAssignedRegister ifNotNil: {:(MIRPhysicalLocation)register :: AsmInstructionOperand | 
            register x86::int64For: codegen
        } ifNil: {
            (value x86_x86_64::pointerWithCodegen: codegen) copy
                size: 8u8;
                yourself
        }
    }.

    public override method x86::float32For: (codegen: MIRFunctionAsmCodeGenerator) ::=> AsmInstructionOperand := {
        value coalescedAssignedRegister ifNotNil: {:(MIRPhysicalLocation)register :: AsmInstructionOperand | 
            register x86::float32For: codegen
        } ifNil: {
            (value x86_x86_64::pointerWithCodegen: codegen) copy
                size: 4u8;
                yourself
        }
    }.

    public override method x86::float64For: (codegen: MIRFunctionAsmCodeGenerator) ::=> AsmInstructionOperand := {
        value coalescedAssignedRegister ifNotNil: {:(MIRPhysicalLocation)register :: AsmInstructionOperand | 
            register x86::float64For: codegen
        } ifNil: {
            (value x86_x86_64::pointerWithCodegen: codegen) copy
                size: 8u8;
                yourself
        }
    }.

    public override method x86::vector128For: (codegen: MIRFunctionAsmCodeGenerator) ::=> AsmInstructionOperand := {
        value coalescedAssignedRegister ifNotNil: {:(MIRPhysicalLocation)register :: AsmInstructionOperand | 
            register x86::vector128For: codegen
        } ifNil: {
            (value x86_x86_64::pointerWithCodegen: codegen) copy
                size: 16u8;
                yourself
        }
    }.

    public override method x86::immediateS32OrInt64For: (codegen: MIRFunctionAsmCodeGenerator) ::=> AsmInstructionOperand := {
        value coalescedAssignedRegister ifNotNil: {:(MIRPhysicalLocation)register :: AsmInstructionOperand | 
            register x86::immediateS32OrInt64For: codegen
        } ifNil: {
            (value x86_x86_64::pointerWithCodegen: codegen) copy
                size: 8u8;
                yourself
        }
    }.
}.

MIRSpecificPhysicalMemoryLocation extend: {
    public abstract method x86::pointerWithCodegen: (codegen: MIRFunctionAsmCodeGenerator) ::=> AsmX86RegisterAddress
        := self subclassResponsibility.

    public abstract method x86_64::pointerWithCodegen: (codegen: MIRFunctionAsmCodeGenerator) ::=> AsmX86RegisterAddress
        := self subclassResponsibility.
}.

MIRPhysicalLocationSpecificStackPointerOffset extend: {
    public override method x86::pointerWithCodegen: (codegen: MIRFunctionAsmCodeGenerator) ::=> AsmX86RegisterAddress := {
        AsmX86RegisterAddress base: X86::ESP size: 1u8 displacement: offset asInt32 asAsmImmediate
    }.

    public override method x86_64::pointerWithCodegen: (codegen: MIRFunctionAsmCodeGenerator) ::=> AsmX86RegisterAddress := {
        AsmX86RegisterAddress base: X86::RSP size: 1u8 displacement: offset asInt32 asAsmImmediate
    }.
}.

public final class MIRX86IntegerRegister superclass: MIRPhysicalIntegerRegister; definition: {
    public field int8 => AsmX86Int8Register.
    public field int16 => AsmX86Int16Register.
    public field int32 => AsmX86Int32Register.

    public method x86::int8 => AsmX86Int8Register := int8.
    public method x86::int16 => AsmX86Int16Register := int16.
    public method x86::int32 => AsmX86Int32Register := int32.

    public override method canBeUsedForByte => Boolean := int8 value < 4u8.
    
    public override method x86::int8For: (codegen: MIRFunctionAsmCodeGenerator) ::=> AsmInstructionOperand := int8.
    public override method x86::int16For: (codegen: MIRFunctionAsmCodeGenerator) ::=> AsmInstructionOperand := int16.
    public override method x86::int32For: (codegen: MIRFunctionAsmCodeGenerator) ::=> AsmInstructionOperand := int32.

    public override method asm::canonicalRegister ::=> AsmRegister := int32.

    public override method x86::rel32OrInt32For: (codegen: MIRAsmCodeGenerator) ::=> AsmInstructionOperand := int32.

    __Meta__ definition: {
        public method int8: (int8: AsmX86Int8Register) int16: (int16: AsmX86Int16Register) int32: (int32: AsmX86Int32Register) ::=> self
            := self new int8: int8; int16: int16; int32: int32; yourself.
    }.

    public override method x86::loadFromVariable: (variable: MIRValue) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        let variableSize := variable size.
        let isSignedExtended := variable isSignedExtended.
        self assert: (variableSize = 1sz) || (variableSize = 2sz) || (variableSize = 4sz).

        let variablePointer := variable x86::pointerWithCodegen: codegen.
        variableSize = 1u64 && isSignedExtended ifTrue: (codegen textSection x86::movsx: self x86::int32 src: variablePointer).
        variableSize = 1u64 && isSignedExtended not ifTrue: (codegen textSection x86::movzx: self x86::int32 src: variablePointer).
        variableSize = 2u64 && isSignedExtended ifTrue: (codegen textSection x86::movsx: self x86::int32 src: variablePointer).
        variableSize = 2u64 && isSignedExtended not ifTrue: (codegen textSection x86::movzx: self x86::int32 src: variablePointer).
        variableSize = 4u64 ifTrue: (codegen textSection x86::mov: self x86::int32 src: variablePointer).
    }.

    public override method x86::storeInVariable: (variable: MIRValue) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        let variableSize := variable size.
        self assert: (variableSize = 1u64) || (variableSize = 2u64) || (variableSize = 4u64).
        
        let variablePointer := variable x86::pointerWithCodegen: codegen.
        variableSize = 1u64 ifTrue: (codegen textSection x86::mov: variablePointer src: self x86::int8).
        variableSize = 2u64 ifTrue: (codegen textSection x86::mov: variablePointer src: self x86::int16).
        variableSize = 4u64 ifTrue: (codegen textSection x86::mov: variablePointer src: self x86::int32).
    }.

    public override method x86::pushWith: (codegen: MIRFunctionAsmCodeGenerator) valueSize: (size: UInt64)::=> Void := {
        codegen textSection x86::push: self x86::int32
    }.
}.

public final class MIRX86_64IntegerRegister superclass: MIRPhysicalIntegerRegister; definition: {
    public field int8 => AsmX86Int8Register.
    public field int16 => AsmX86Int16Register.
    public field int32 => AsmX86Int32Register.
    public field int64 => AsmX86Int64Register.

    public method x86::int8 => AsmX86Int8Register := int8.
    public method x86::int16 => AsmX86Int16Register := int16.
    public method x86::int32 => AsmX86Int32Register := int32.
    public method x86::int64 => AsmX86Int64Register := int64.

    public override method canBeUsedForByte => Boolean := true.

    public override method x86::int8For: (codegen: MIRFunctionAsmCodeGenerator) ::=> AsmInstructionOperand := int8.
    public override method x86::int16For: (codegen: MIRFunctionAsmCodeGenerator) ::=> AsmInstructionOperand := int16.
    public override method x86::int32For: (codegen: MIRFunctionAsmCodeGenerator) ::=> AsmInstructionOperand := int32.
    public override method x86::int64For: (codegen: MIRFunctionAsmCodeGenerator) ::=> AsmInstructionOperand := int64.

    public override method asm::canonicalRegister ::=> AsmRegister := int64.

    public override method x86::immediateS32OrInt64For: (codegen: MIRAsmCodeGenerator) ::=> AsmInstructionOperand
        := int64.

    public override method x86::int8PointerWithOffset: (offset: MIRPhysicalLocation) for: (codegen: MIRFunctionAsmCodeGenerator) ::=> AsmInstructionOperand
        := AsmX86RegisterAddress base: int64 size: 1u8 displacement: (offset x86::immediate32For: codegen).

    public override method x86::int16PointerWithOffset: (offset: MIRPhysicalLocation) for: (codegen: MIRFunctionAsmCodeGenerator) ::=> AsmInstructionOperand
        := AsmX86RegisterAddress base: int64 size: 2u8 displacement: (offset x86::immediate32For: codegen).

    public override method x86::int32PointerWithOffset: (offset: MIRPhysicalLocation) for: (codegen: MIRFunctionAsmCodeGenerator) ::=> AsmInstructionOperand
        := AsmX86RegisterAddress base: int64 size: 4u8 displacement: (offset x86::immediate32For: codegen).

    public override method x86::int64PointerWithOffset: (offset: MIRPhysicalLocation) for: (codegen: MIRFunctionAsmCodeGenerator) ::=> AsmInstructionOperand
        := AsmX86RegisterAddress base: int64 size: 8u8 displacement: (offset x86::immediate32For: codegen).

    public virtual method x86::float32PointerWithOffset: (offset: MIRPhysicalLocation) for: (codegen: MIRFunctionAsmCodeGenerator) ::=> AsmInstructionOperand
        := AsmX86RegisterAddress base: int64 size: 4u8 displacement: (offset x86::immediate32For: codegen).

    public virtual method x86::float64PointerWithOffset: (offset: MIRPhysicalLocation) for: (codegen: MIRFunctionAsmCodeGenerator) ::=> AsmInstructionOperand
        := AsmX86RegisterAddress base: int64 size: 8u8 displacement: (offset x86::immediate32For: codegen).

    public virtual method x86::vector128PointerWithOffset: (offset: MIRPhysicalLocation) for: (codegen: MIRFunctionAsmCodeGenerator) ::=> AsmInstructionOperand
        := AsmX86RegisterAddress base: int64 size: 16u8 displacement: (offset x86::immediate32For: codegen).

    public override method x86::rel32OrInt64For: (codegen: MIRAsmCodeGenerator) ::=> AsmInstructionOperand
        := int64.
    public override method x86::relCall32OrInt32For: (codegen: MIRAsmCodeGenerator) ::=> AsmInstructionOperand
        := int32.
    public override method x86::relCall32OrInt64For: (codegen: MIRAsmCodeGenerator) ::=> AsmInstructionOperand
        := int64.

    __Meta__ definition: {
        public method int8: (int8: AsmX86Int8Register) int16: (int16: AsmX86Int16Register) int32: (int32: AsmX86Int32Register) int64: (int64: AsmX86Int64Register) ::=> self
            := self new int8: int8; int16: int16; int32: int32; int64: int64; yourself.
    }.

    public override method x86_64::loadFromRegister: (register: MIRPhysicalLocation) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        self assert: register isIntegerRegister.

        self ~~ register ifTrue: {
            codegen textSection x86::mov: self x86::int64 src: (register x86::int64For: codegen).
        }.
    }.

    public override method x86_64::loadFromValue: (value: MIRValue) pointer: (valuePointer: AsmX86RegisterAddress) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        let valueSize := value size.
        valueSize = 0sz ifTrue: {return: void}.

        let isSignedExtended := value isSignedExtended.
        self assert: valueSize <= 8sz.

        valueSize <= 1u64 ifTrue: {
            isSignedExtended
                ifTrue: (codegen textSection x86::movsx: self x86::int32 src: valuePointer byte)
                ifFalse:  (codegen textSection x86::movzx: self x86::int32 src: valuePointer byte).
            return: void
        }.

        valueSize <= 2u64 ifTrue: {
            isSignedExtended
                ifTrue: (codegen textSection x86::movsx: self x86::int32 src: valuePointer word)
                ifFalse:  (codegen textSection x86::movzx: self x86::int32 src: valuePointer word).
            return: void
        }.

        valueSize <= 4u64 ifTrue: {
            codegen textSection x86::mov: self x86::int32 src: valuePointer dword.
            return: void
        }.

        codegen textSection x86::mov: self x86::int64 src: valuePointer qword
    }.

    public override method x86_64::storeValue: (value: MIRValue) inPointer: (valuePointer: AsmX86RegisterAddress) isCallArgument: (isCallArgument: Boolean) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        isCallArgument ifTrue: {
            codegen textSection x86::mov: valuePointer qword src: self x86::int64.
            return: void
        }.

        let valueSize := value size.
        valueSize = 0sz ifTrue: {return: void}.

        (valueSize = 1u64) || (valueSize = 2u64) || (valueSize = 4u64) || (valueSize = 8u64) ifFalse: {
            self error: (value printString -- " " -- value type printString -- " invalid value size " -- valueSize asString -- " for integer register")
        }.

        valueSize = 1u64 ifTrue: (codegen textSection x86::mov: valuePointer byte src: self x86::int8).
        valueSize = 2u64 ifTrue: (codegen textSection x86::mov: valuePointer word src: self x86::int16).
        valueSize = 4u64 ifTrue: (codegen textSection x86::mov: valuePointer dword src: self x86::int32).
        valueSize = 8u64 ifTrue: (codegen textSection x86::mov: valuePointer qword src: self x86::int64).
    }.

    public override method x86_64::pushWith: (codegen: MIRFunctionAsmCodeGenerator) valueSize: (size: UInt64)::=> Void := {
        codegen textSection x86::push: self x86::int64
    }.

    public override method printOn: (stream: Stream) ::=> Void := {
        stream print: int64
    }.
}.

public final class MIRX86VectorRegister superclass: MIRPhysicalVectorRegister; definition: {
    public field register => AsmX86VectorRegister.

    __Meta__ definition: {
        public method register: (reg: AsmX86VectorRegister) ::=> self
            := self new register: reg; yourself.
    }.

    public override method asm::canonicalRegister ::=> AsmRegister := register.

    public override method x86_64::loadFromRegister: (register: MIRPhysicalLocation) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        self assert: register isVectorRegister.

        self ~~ register ifTrue: {
            codegen textSection x86::movaps: self register src: (register x86::vector128For: codegen)
        }.
    }.

    public override method x86::float32For: (codegen: MIRFunctionAsmCodeGenerator) ::=> AsmInstructionOperand
        := register.

    public override method x86::float64For: (codegen: MIRFunctionAsmCodeGenerator) ::=> AsmInstructionOperand
        := register.

    public override method x86::vector128For: (codegen: MIRFunctionAsmCodeGenerator) ::=> AsmInstructionOperand
        := register.

    public override method x86::loadFromValue: (value: MIRValue) pointer: (valuePointer: AsmX86RegisterAddress) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        let valueSize := value size.
        valueSize = 0sz ifTrue: {return: void}.

        (valueSize = 4u64) || (valueSize = 8u64) || (valueSize = 16u64) ifFalse: {
            self error: (value printString -- " " -- value type printString -- " invalid value size " -- valueSize asString -- " for vector register")
        }.

        let valuePointer := value x86_64::pointerWithCodegen: codegen.
        valueSize = 4u64 ifTrue: (codegen textSection x86::movss: self register src: valuePointer dword).
        valueSize = 8u64 ifTrue: (codegen textSection x86::movsd: self register src: valuePointer qword).
        valueSize = 16u64 ifTrue: (codegen textSection x86::movaps: self register src: valuePointer oword).
    }.

    public override method x86::storeValue: (value: MIRValue) inPointer: (valuePointer: AsmX86RegisterAddress) isCallArgument: (isCallArgument: Boolean) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        let valueSize := value size.
        valueSize = 0sz ifTrue: {return: void}.

        (valueSize = 4u64) || (valueSize = 8u64) || (valueSize = 16u64) ifFalse: {
            self error: (value printString -- " " -- value type printString -- " invalid value size " -- valueSize asString -- " for vector register")
        }.

        let valuePointer := value x86_64::pointerWithCodegen: codegen.
        valueSize = 4u64 ifTrue: (codegen textSection x86::movss: valuePointer dword src: register).
        valueSize = 8u64 ifTrue: (codegen textSection x86::movsd: valuePointer qword src: register).
        valueSize = 16u64 ifTrue: (codegen textSection x86::movaps: valuePointer oword src: register).
    }.

    public override method x86_64::loadFromValue: (value: MIRValue) pointer: (valuePointer: AsmX86RegisterAddress) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        let valueSize := value size.
        valueSize = 0sz ifTrue: {return: void}.

        (valueSize = 4u64) || (valueSize = 8u64) || (valueSize = 16u64) ifFalse: {
            self error: (value printString -- " " -- value type printString -- " invalid value size " -- valueSize asString -- " for vector register")
        }.

        valueSize = 4u64 ifTrue: (codegen textSection x86::movss: self register src: valuePointer dword).
        valueSize = 8u64 ifTrue: (codegen textSection x86::movsd: self register src: valuePointer qword).
        valueSize = 16u64 ifTrue: (codegen textSection x86::movaps: self register src: valuePointer oword).
    }.

    public override method x86_64::storeValue: (value: MIRValue) inPointer: (valuePointer: AsmX86RegisterAddress) isCallArgument: (isCallArgument: Boolean) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        let valueSize := value size.
        valueSize = 0sz ifTrue: {return: void}.

        (valueSize = 4u64) || (valueSize = 8u64) || (valueSize = 16u64) ifFalse: {
            self error: (value printString -- " " -- value type printString -- " invalid value size " -- valueSize asString -- " for vector register")
        }.

        valueSize = 4u64 ifTrue: (codegen textSection x86::movss: valuePointer dword src: register).
        valueSize = 8u64 ifTrue: (codegen textSection x86::movsd: valuePointer qword src: register).
        valueSize = 16u64 ifTrue: (codegen textSection x86::movaps: valuePointer oword src: register).
    }.

    public override method x86_64::pushWith: (codegen: MIRFunctionAsmCodeGenerator) valueSize: (size: UInt64)::=> Void := {
        size <= 8sz ifTrue: {
            codegen textSection
                x86::sub: X86::RSP with: 8i8 asAsmImmediate;
                x86::movsd: X86::RSP x86::qword src: register.

            return: void
        }.
        size <= 16sz ifTrue: {
            codegen textSection
                x86::sub: X86::RSP with: 16i8 asAsmImmediate;
                x86::movaps: X86::RSP x86::oword src: register.
            return: void
        }.

        self error: "Unsupported push size for vector register"
    }.

    public override method printOn: (stream: Stream) ::=> Void := {
        stream print: register
    }.
}.

public global MIR::X86::EAX => MIRX86IntegerRegister := MIRX86IntegerRegister int8: X86::AL int16: X86::AX int32: X86::EAX.
public global MIR::X86::ECX => MIRX86IntegerRegister := MIRX86IntegerRegister int8: X86::CL int16: X86::CX int32: X86::ECX.
public global MIR::X86::EDX => MIRX86IntegerRegister := MIRX86IntegerRegister int8: X86::DL int16: X86::DX int32: X86::EDX.
public global MIR::X86::EBX => MIRX86IntegerRegister := MIRX86IntegerRegister int8: X86::BL int16: X86::BX int32: X86::EBX.
public global MIR::X86::ESP => MIRX86IntegerRegister := MIRX86IntegerRegister int8: nil int16: X86::SP int32: X86::ESP.
public global MIR::X86::EBP => MIRX86IntegerRegister := MIRX86IntegerRegister int8: nil int16: X86::BP int32: X86::EBP.
public global MIR::X86::ESI => MIRX86IntegerRegister := MIRX86IntegerRegister int8: nil int16: X86::SI int32: X86::ESI.
public global MIR::X86::EDI => MIRX86IntegerRegister := MIRX86IntegerRegister int8: nil int16: X86::DI int32: X86::EDI.

public global MIR::X86::XMM0 => MIRX86VectorRegister := MIRX86VectorRegister register: X86::XMM0.
public global MIR::X86::XMM1 => MIRX86VectorRegister := MIRX86VectorRegister register: X86::XMM1.
public global MIR::X86::XMM2 => MIRX86VectorRegister := MIRX86VectorRegister register: X86::XMM2.
public global MIR::X86::XMM3 => MIRX86VectorRegister := MIRX86VectorRegister register: X86::XMM3.
public global MIR::X86::XMM4 => MIRX86VectorRegister := MIRX86VectorRegister register: X86::XMM4.
public global MIR::X86::XMM5 => MIRX86VectorRegister := MIRX86VectorRegister register: X86::XMM5.
public global MIR::X86::XMM6 => MIRX86VectorRegister := MIRX86VectorRegister register: X86::XMM6.
public global MIR::X86::XMM7 => MIRX86VectorRegister := MIRX86VectorRegister register: X86::XMM7.

public global MIR::X86::IntegerRegisters => Array := (MIR::X86::EAX, MIR::X86::ECX, MIR::X86::EDX, MIR::X86::EBX, MIR::X86::ESP, MIR::X86::EBP, MIR::X86::ESI, MIR::X86::EDI).
public global MIR::X86::AllocableIntegerRegisters => Array := (MIR::X86::EAX, MIR::X86::ECX, MIR::X86::EDX, MIR::X86::EBX, MIR::X86::ESI, MIR::X86::EDI).

public global MIR::X86::VectorRegisters => Array := (MIR::X86::XMM0, MIR::X86::XMM1, MIR::X86::XMM2, MIR::X86::XMM3, MIR::X86::XMM4, MIR::X86::XMM5, MIR::X86::XMM6, MIR::X86::XMM7).
public global MIR::X86::AllocableVectorRegisters => Array := MIR::X86::VectorRegisters.

public global MIR::X86_64::RAX => MIRX86_64IntegerRegister := MIRX86_64IntegerRegister int8: X86::RAXB int16: X86::AX int32: X86::EAX int64: X86::RAX.
public global MIR::X86_64::RCX => MIRX86_64IntegerRegister := MIRX86_64IntegerRegister int8: X86::RCXB int16: X86::CX int32: X86::ECX int64: X86::RCX.
public global MIR::X86_64::RDX => MIRX86_64IntegerRegister := MIRX86_64IntegerRegister int8: X86::RDXB int16: X86::DX int32: X86::EDX int64: X86::RDX.
public global MIR::X86_64::RBX => MIRX86_64IntegerRegister := MIRX86_64IntegerRegister int8: X86::RBXB int16: X86::BX int32: X86::EBX int64: X86::RBX.
public global MIR::X86_64::RSP => MIRX86_64IntegerRegister := MIRX86_64IntegerRegister int8: X86::RSPB int16: X86::SP int32: X86::ESP int64: X86::RSP.
public global MIR::X86_64::RBP => MIRX86_64IntegerRegister := MIRX86_64IntegerRegister int8: X86::RBPB int16: X86::BP int32: X86::EBP int64: X86::RBP.
public global MIR::X86_64::RSI => MIRX86_64IntegerRegister := MIRX86_64IntegerRegister int8: X86::RSIB int16: X86::SI int32: X86::ESI int64: X86::RSI.
public global MIR::X86_64::RDI => MIRX86_64IntegerRegister := MIRX86_64IntegerRegister int8: X86::RDIB int16: X86::DI int32: X86::EDI int64: X86::RDI.
public global MIR::X86_64::R8 => MIRX86_64IntegerRegister := MIRX86_64IntegerRegister int8: X86::R8B int16: X86::R8W int32: X86::R8D int64: X86::R8.
public global MIR::X86_64::R9 => MIRX86_64IntegerRegister := MIRX86_64IntegerRegister int8: X86::R9B int16: X86::R9W int32: X86::R9D int64: X86::R9.
public global MIR::X86_64::R10 => MIRX86_64IntegerRegister := MIRX86_64IntegerRegister int8: X86::R10B int16: X86::R10W int32: X86::R10D int64: X86::R10.
public global MIR::X86_64::R11 => MIRX86_64IntegerRegister := MIRX86_64IntegerRegister int8: X86::R11B int16: X86::R11W int32: X86::R11D int64: X86::R11.
public global MIR::X86_64::R12 => MIRX86_64IntegerRegister := MIRX86_64IntegerRegister int8: X86::R12B int16: X86::R12W int32: X86::R12D int64: X86::R12.
public global MIR::X86_64::R13 => MIRX86_64IntegerRegister := MIRX86_64IntegerRegister int8: X86::R13B int16: X86::R13W int32: X86::R13D int64: X86::R13.
public global MIR::X86_64::R14 => MIRX86_64IntegerRegister := MIRX86_64IntegerRegister int8: X86::R14B int16: X86::R14W int32: X86::R14D int64: X86::R14.
public global MIR::X86_64::R15 => MIRX86_64IntegerRegister := MIRX86_64IntegerRegister int8: X86::R15B int16: X86::R15W int32: X86::R15D int64: X86::R15.

public global MIR::X86_64::XMM8 => MIRX86VectorRegister := MIRX86VectorRegister register: X86::XMM8.
public global MIR::X86_64::XMM9 => MIRX86VectorRegister := MIRX86VectorRegister register: X86::XMM9.
public global MIR::X86_64::XMM10 => MIRX86VectorRegister := MIRX86VectorRegister register: X86::XMM10.
public global MIR::X86_64::XMM11 => MIRX86VectorRegister := MIRX86VectorRegister register: X86::XMM11.
public global MIR::X86_64::XMM12 => MIRX86VectorRegister := MIRX86VectorRegister register: X86::XMM12.
public global MIR::X86_64::XMM13 => MIRX86VectorRegister := MIRX86VectorRegister register: X86::XMM13.
public global MIR::X86_64::XMM14 => MIRX86VectorRegister := MIRX86VectorRegister register: X86::XMM14.
public global MIR::X86_64::XMM15 => MIRX86VectorRegister := MIRX86VectorRegister register: X86::XMM15.

public global MIR::X86_64::VectorRegisters => Array := (
    MIR::X86::XMM0, MIR::X86::XMM1, MIR::X86::XMM2, MIR::X86::XMM3,
    MIR::X86::XMM4, MIR::X86::XMM5, MIR::X86::XMM6, MIR::X86::XMM7,
    MIR::X86_64::XMM8, MIR::X86_64::XMM9, MIR::X86_64::XMM10, MIR::X86_64::XMM11,
    MIR::X86_64::XMM12, MIR::X86_64::XMM13, MIR::X86_64::XMM14, MIR::X86_64::XMM15).

public global MIR::X86_64::IntegerRegisters => Array := (
    MIR::X86_64::RAX, MIR::X86_64::RCX, MIR::X86_64::RDX, MIR::X86_64::RBX,
    MIR::X86_64::RSP, MIR::X86_64::RBP, MIR::X86_64::RSI, MIR::X86_64::RDI,
    MIR::X86_64::R8, MIR::X86_64::R9, MIR::X86_64::R10, MIR::X86_64::R11,
    MIR::X86_64::R12, MIR::X86_64::R13, MIR::X86_64::R14, MIR::X86_64::R15
).

public global MIR::X86_64::SysV::AllocableIntegerRegisters => Array := (
    ## Scratch registers
    MIR::X86_64::RAX, MIR::X86_64::R11,
    
    ## Parameters
    MIR::X86_64::RSI, MIR::X86_64::RDI, MIR::X86_64::RCX, MIR::X86_64::RDX,
    MIR::X86_64::R8, MIR::X86_64::R9,

    ## Call Preserved
    MIR::X86_64::RBX, MIR::X86_64::R12, MIR::X86_64::R13, MIR::X86_64::R14,
    
    ## Static chain pointer
    MIR::X86_64::R10,

    ## GOT base pointer
    MIR::X86_64::R15
).

public global MIR::X86_64::SysV::AllocableVectorRegisters => Array := MIR::X86_64::VectorRegisters.

public global MIR::X86_64::Win64::AllocableIntegerRegisters => Array := (
    ## Scratch registers
    MIR::X86_64::RAX, MIR::X86_64::R10, MIR::X86_64::R11,
    
    ## Parameters
    MIR::X86_64::RCX, MIR::X86_64::RDX, MIR::X86_64::R8, MIR::X86_64::R9,

    ## Call Preserved
    MIR::X86_64::RDI, MIR::X86_64::RSI, MIR::X86_64::RBX, MIR::X86_64::R12, MIR::X86_64::R13, MIR::X86_64::R14, MIR::X86_64::R15
).

public global MIR::X86_64::Win64::AllocableVectorRegisters => Array := MIR::X86_64::VectorRegisters.


public abstract class MIRSX86StackBasedCallingConvention superclass: MIRCallingConvention; definition: {
    public method asm::generateCall: (instruction: MIRInstruction) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        codegen textSection
            x86::call: (instruction firstOperandRegister x86::rel32OrInt32For: codegen)
    }.
}.

public final class MIRSX86CDeclCallingConvention superclass: MIRSX86StackBasedCallingConvention; definition: {
    public override method allocableIntegerRegisters => Array
        := MIR::X86::AllocableIntegerRegisters.

    public override method allocableVectorRegisters => Array
        := MIR::X86::AllocableVectorRegisters.

    public override method preferredRegisterForCaptureVectorPointer => MIRPhysicalLocationRegister
        := MIR::X86_64::R10.
}.

public global MIR::X86::CDeclCallingConvention := MIRSX86CDeclCallingConvention new.

public final class MIRX86CompilationTarget superclass: MIRAsmCompilationTarget; definition: {
    public override method name => Symbol
        := #x86.

    public override method allIntegerRegisters => Array
        := MIR::X86::IntegerRegisters.

    public override method allVectorRegisters => Array
        := MIR::X86::VectorRegisters.

    public override method usesVectorRegistersForFloatOperations => Boolean
        := true.

    public override method defaultCallingConvention => MIRCallingConvention
        := MIR::X86::CDeclCallingConvention.

    public override method emitFunctionPrologueWith: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        codegen textSection x86::endbr32.

        codegen stackFrameLayout hasRequiredConstruction ifTrue: {
            codegen textSection
                x86::push: X86::EBP;
                cfiPushRegister: X86::EBP;
                x86::mov: X86::EBP src: X86::ESP;
                cfiSaveFramePointer: X86::EBP.
        }.
    }.

    public override method emitStackFrameConstructionWith: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        codegen textSection cfiEndPrologue
    }.

    public override method emitFunctionEpilogueWith: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        codegen stackFrameLayout hasRequiredConstruction ifTrue: {
            codegen textSection
                x86::mov: X86::ESP src: X86::EBP;
                x86::pop: X86::EBP.
        }.
    }.

    public override method emitMoveValue: (value: MIRValue) intoLocation: (register: MIRPhysicalLocation) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        value x86::moveIntoRegister: register with: codegen
    }.

    public override method emitUnspillValue: (value: MIRValue) intoLocation: (register: MIRPhysicalLocation) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        value x86::unspillIntoRegister: register with: codegen
    }.

    public override method emitMoveRegister: (register: MIRPhysicalLocation) intoValue: (value: MIRValue) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        value x86::moveFromRegister: register with: codegen
    }.
}.

public global X86_64::SysV::IntegerArgumentRegisters := (
    MIR::X86_64::RDI, MIR::X86_64::RSI, MIR::X86_64::RDX, MIR::X86_64::RCX, MIR::X86_64::R8, MIR::X86_64::R9
).

public global X86_64::SysV::VectorArgumentRegisters := (
    MIR::X86::XMM0, MIR::X86::XMM1, MIR::X86::XMM2, MIR::X86::XMM3, MIR::X86::XMM4, MIR::X86::XMM5, MIR::X86::XMM6, MIR::X86::XMM7
).

public global X86::SysV::CallPreservedRegister := (
    MIR::X86::EBX, MIR::X86::ESP, MIR::X86::EBP, MIR::X86::ESI, MIR::X86::EDI
).

public global X86_64::SysV::CallPreservedRegister := (
    MIR::X86_64::RBX, MIR::X86_64::RSP, MIR::X86_64::RBP, MIR::X86_64::R12, MIR::X86_64::R13, MIR::X86_64::R14, MIR::X86_64::R15
).

public final class MIRSysVX86_64RegisterAssignmentState superclass: Object; definition: {
    public field usedIntegerRegisterCount => Size.
    public field usedVectorRegisterCount => Size.

    public method allocateIntegerRegister => MIRPhysicalLocation := {
        usedIntegerRegisterCount < X86_64::SysV::IntegerArgumentRegisters size ifTrue: {
            let register := X86_64::SysV::IntegerArgumentRegisters at: usedIntegerRegisterCount.
            usedIntegerRegisterCount := usedIntegerRegisterCount + 1sz.
            register
        } ifFalse: {
            nil
        }
    }.

    public method allocateVectorRegister => MIRPhysicalLocation := {
        usedVectorRegisterCount < X86_64::SysV::IntegerArgumentRegisters size ifTrue: {
            let register := X86_64::SysV::VectorArgumentRegisters at: usedVectorRegisterCount.
            usedVectorRegisterCount := usedVectorRegisterCount + 1sz.
            register
        } ifFalse: {
            nil
        }
    }.

    public method allocateIntegerOfSize: (size: UInt64) alignment: (alignment: UInt64) ::=> MIRPhysicalLocation
        := size <= 8u64 ifTrue: (self allocateIntegerRegister) ifFalse: nil.

    public method allocateVectorOfSize: (size: UInt64) alignment: (alignment: UInt64) ::=> MIRPhysicalLocation
        := size <= 16u64 ifTrue: (self allocateVectorRegister) ifFalse: nil.

    public method assignRegisterToValue: (value: MIRValue) ::=> MIRPhysicalLocation := {
        (value isFloatingPoint || value isVector)
            ifTrue: (self allocateVectorOfSize: value size alignment: value alignment)
            ifFalse: (self allocateIntegerOfSize: value size alignment: value alignment).
    }.
}.

public abstract class MIRX86_64CallingConvention superclass: MIRCallingConvention; definition: {
    public abstract method registerConstraintsOfCall: (instruction: MIRInstruction) with: (allocator: MIRRegisterAllocator) ::=> Void
        := self subclassResponsibility.

    public override method registerConstraintsOfCallInt8: (instruction: MIRInstruction) with: (allocator: MIRRegisterAllocator) ::=> Void := {
        self registerConstraintsOfCall: instruction with: allocator.
        allocator allocateRegister: MIR::X86_64::RAX forInstructionResult: instruction.
    }.

    public override method registerConstraintsOfCallInt16: (instruction: MIRInstruction) with: (allocator: MIRRegisterAllocator) ::=> Void := {
        self registerConstraintsOfCall: instruction with: allocator.
        allocator allocateRegister: MIR::X86_64::RAX forInstructionResult: instruction.
    }.

    public override method registerConstraintsOfCallInt32: (instruction: MIRInstruction) with: (allocator: MIRRegisterAllocator) ::=> Void := {
        self registerConstraintsOfCall: instruction with: allocator.
        allocator allocateRegister: MIR::X86_64::RAX forInstructionResult: instruction.
    }.

    public override method registerConstraintsOfCallInt64: (instruction: MIRInstruction) with: (allocator: MIRRegisterAllocator) ::=> Void := {
        self registerConstraintsOfCall: instruction with: allocator.
        allocator allocateRegister: MIR::X86_64::RAX forInstructionResult: instruction.
    }.

    public override method registerConstraintsOfCallPointer: (instruction: MIRInstruction) with: (allocator: MIRRegisterAllocator) ::=> Void := {
        self registerConstraintsOfCall: instruction with: allocator.
        allocator allocateRegister: MIR::X86_64::RAX forInstructionResult: instruction.
    }.

    public override method registerConstraintsOfCallFloat32: (instruction: MIRInstruction) with: (allocator: MIRRegisterAllocator) ::=> Void := {
        self registerConstraintsOfCall: instruction with: allocator.
        allocator allocateRegister: MIR::X86::XMM0 forInstructionResult: instruction.
    }.

    public override method registerConstraintsOfCallFloat64: (instruction: MIRInstruction) with: (allocator: MIRRegisterAllocator) ::=> Void := {
        self registerConstraintsOfCall: instruction with: allocator.
        allocator allocateRegister: MIR::X86::XMM0 forInstructionResult: instruction.
    }.

    public override method registerConstraintsOfCallStruct: (instruction: MIRInstruction) with: (allocator: MIRRegisterAllocator) ::=> Void := {
        self registerConstraintsOfCall: instruction with: allocator.
        allocator allocateMemoryForInstructionResult: instruction.
    }.

    public override method registerConstraintsOfCallVoid: (instruction: MIRInstruction) with: (allocator: MIRRegisterAllocator) ::=> Void := {
        self registerConstraintsOfCall: instruction with: allocator
    }.

    public method asm::generateCall: (instruction: MIRInstruction) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        codegen textSection x86::call: (instruction firstOperandRegister x86::relCall32OrInt64For: codegen).
    }.

    public override method asm::generateCallInt8: (instruction: MIRInstruction) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        self asm::generateCall: instruction with: codegen
    }.

    public override method asm::generateCallInt16: (instruction: MIRInstruction) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        self asm::generateCall: instruction with: codegen
    }.

    public override method asm::generateCallInt32: (instruction: MIRInstruction) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        self asm::generateCall: instruction with: codegen
    }.

    public override method asm::generateCallInt64: (instruction: MIRInstruction) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        self asm::generateCall: instruction with: codegen
    }.

    public override method asm::generateCallPointer: (instruction: MIRInstruction) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        self asm::generateCall: instruction with: codegen
    }.

    public override method asm::generateCallFloat32: (instruction: MIRInstruction) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        self asm::generateCall: instruction with: codegen
    }.

    public override method asm::generateCallFloat64: (instruction: MIRInstruction) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        self asm::generateCall: instruction with: codegen
    }.

    public override method asm::generateCallStruct: (instruction: MIRInstruction) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        self asm::generateCall: instruction with: codegen
    }.

    public override method asm::generateCallVoid: (instruction: MIRInstruction) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        self asm::generateCall: instruction with: codegen
    }.
}.

public final class MIRSysVX86_64CallingConvention superclass: MIRX86_64CallingConvention; definition: {
    public override method allocableIntegerRegisters => Array
        := MIR::X86_64::SysV::AllocableIntegerRegisters.

    public override method allocableVectorRegisters => Array
        := MIR::X86_64::SysV::AllocableVectorRegisters.

    public override method preferredRegisterForCaptureVectorPointer => MIRPhysicalIntegerRegister
        := nil.

    public override method registerConstraintsOfCall: (instruction: MIRInstruction) with: (allocator: MIRRegisterAllocator) ::=> Void := {
        let registerArguments := OrderedCollection new.
        let stackArguments := OrderedCollection new.
        let hasStackIntegerArgument mutable := false.
        let hasStackFloatOrVectorArgument mutable := false.
        let hasStructureArgument mutable := false.
        let structureSizeThreshold := 8u64.

        let stackArgumentAlignment := 8u64.
        let stackSize mutable := 0u64.
        let stackAlignment mutable := 16u64.

        let registerAssignmentState := MIRSysVX86_64RegisterAssignmentState new.
        1sz until: instruction operands size do: {:(Size)operandIndex :: Void |
            let operand => MIRValue := instruction operands at: operandIndex.
            let register := registerAssignmentState assignRegisterToValue: operand.
            register ifNotNil: {
                registerArguments add: operandIndex; add: register
            } ifNil: {
                let operandAlignment := operand alignment max: stackArgumentAlignment.
                let operandSize := operand size alignedTo: operandAlignment.
                let argumentOffset := stackSize alignedTo: operandAlignment.

                stackSize := argumentOffset + operandSize.
                stackAlignment := stackAlignment max: operandAlignment.
                
                (operand isFloatingPoint || operand isVector) ifTrue: {
                    hasStackFloatOrVectorArgument := true
                } ifFalse: {
                    operandSize <= structureSizeThreshold ifTrue: {
                        hasStackIntegerArgument := true
                    } ifFalse: {
                        hasStructureArgument := true
                    }.
                }.

                stackArguments add: operandIndex; add: argumentOffset
            }
        }.

        stackSize := stackSize alignedTo: stackAlignment.
        allocator addRequiredCalloutSize: stackSize withAlignment: stackAlignment.

        instruction scratchRegisterCount: 4sz.
        hasStructureArgument ifTrue: {
            ## We need these specific registers for using rep movs.
            allocator
                allocateRegister: MIR::X86_64::RDI forInstruction: instruction scratchAt: 0sz;
                allocateRegister: MIR::X86_64::RSI forInstruction: instruction scratchAt: 1sz;
                allocateRegister: MIR::X86_64::RCX forInstruction: instruction scratchAt: 2sz.

            hasStackFloatOrVectorArgument ifTrue: {
                allocator allocateVectorRegisterForInstruction: instruction scratchAt: 3sz
            }.

            allocator freeAllocatedScratchRegisters.

            registerArguments pairsDo: {:(Size)operandIndex :register :: Void |
                allocator allocateRegister: register forInstruction: instruction operandAt: operandIndex
            }.
        } ifFalse: {
            registerArguments pairsDo: {:(Size)operandIndex :register :: Void |
                allocator allocateRegister: register forInstruction: instruction operandAt: operandIndex
            }.

            hasStackIntegerArgument ifTrue: {
                allocator allocateIntegerRegisterForInstruction: instruction scratchAt: 0sz
            }.

            hasStackFloatOrVectorArgument ifTrue: {
                allocator allocateVectorRegisterForInstruction: instruction scratchAt: 3sz
            }
        }.

        stackArguments pairsDo: {:(Size)operandIndex :(UInt64)stackOffset :: Void |
            let operand => MIRValue := instruction operands at: operandIndex.
            (operand isFloatingPoint || operand isVector) ifTrue: {
                allocator allocateSpecificCallStackPointerOffset: stackOffset asInt64 forInstruction: instruction operandAt: operandIndex scratchRegister: instruction scratchRegisters fourth
            } ifFalse: {
                operand size <= structureSizeThreshold ifTrue: {
                    allocator allocateSpecificCallStackPointerOffset: stackOffset asInt64 forInstruction: instruction operandAt: operandIndex scratchRegister: instruction scratchRegisters first
                } ifFalse: {
                    allocator allocateSpecificCallStackPointerOffset: stackOffset asInt64 forInstruction: instruction structureOperandAt: operandIndex
                }
            }.
        }.
                
        allocator allocateRegisterOrRelativeImmediate32ForInstruction: instruction operandAt: 0sz.
        allocator
            allocateCaptureVectorPointerRegisterForInstruction: instruction;
            spillIntegerRegistersExceptFor: X86_64::SysV::CallPreservedRegister
    }.

    public override method integerCallPreservedRegisters => Array
        := X86_64::SysV::CallPreservedRegister.

    public override method computeArgumentPassingLayoutOf: (function: MIRFunction) ::=> Void := {
        let registerAssignmentState := MIRSysVX86_64RegisterAssignmentState new.
        let stackSize mutable := 0u64.
        let stackArgumentAlignment := 8u64.

        function arguments do: {:(MIRArgumentValue)argument :: Void |
            let register := registerAssignmentState assignRegisterToValue: argument.
            register ifNotNil: {
                argument passingRegister: register
            } ifNil: {
                let argumentAlignment := argument alignment max: stackArgumentAlignment.
                let argumentSize := argument size alignedTo: argumentAlignment.
                let argumentOffset := stackSize alignedTo: argumentAlignment.

                argument
                    stackSegment: MIRStackFrameSegment::ArgumentPassingZone;
                    stackSegmentOffset: stackSize;
                    hasValidStackSegmentOffset: true.
                stackSize := argumentOffset + argumentSize
            }
        }.

        function
            argumentPassingStackAlignment: stackArgumentAlignment;
            argumentPassingStackSize: (stackSize alignedTo: stackArgumentAlignment)
    }.
}.

public global X86_64::Win64::IntegerArgumentRegisters := (
    MIR::X86_64::RCX, MIR::X86_64::RDX, MIR::X86_64::R8, MIR::X86_64::R9
).

public global X86_64::Win64::VectorArgumentRegisters := (
    MIR::X86::XMM0, MIR::X86::XMM1, MIR::X86::XMM2, MIR::X86::XMM3
).

public global X86_64::Win64::CallPreservedRegister := (
    MIR::X86_64::RBX, MIR::X86_64::RSP, MIR::X86_64::RBP, MIR::X86_64::RDI, MIR::X86_64::RSI,
    MIR::X86_64::R12, MIR::X86_64::R13, MIR::X86_64::R14, MIR::X86_64::R15,
    MIR::X86::XMM6, MIR::X86::XMM7, MIR::X86_64::XMM8, MIR::X86_64::XMM9, MIR::X86_64::XMM10, MIR::X86_64::XMM11, MIR::X86_64::XMM12,
    MIR::X86_64::XMM13, MIR::X86_64::XMM14, MIR::X86_64::XMM15 
).

public final class MIRWinX64RegisterAssignmentState superclass: Object; definition: {
    public field usedRegisterCount => Size.

    public method allocateIntegerRegister => MIRPhysicalLocation := {
        usedRegisterCount < 4sz ifTrue: {
            let register := X86_64::Win64::IntegerArgumentRegisters at: usedRegisterCount.
            usedRegisterCount := usedRegisterCount + 1sz.
            register
        } ifFalse: {
            nil
        }
    }.

    public method allocateVectorRegister => MIRPhysicalLocation := {
        usedRegisterCount < 4sz ifTrue: {
            let register := X86_64::Win64::VectorArgumentRegisters at: usedRegisterCount.
            usedRegisterCount := usedRegisterCount + 1sz.
            register
        } ifFalse: {
            nil
        }
    }.

    public method allocateIntegerOfSize: (size: UInt64) alignment: (alignment: UInt64) ::=> MIRPhysicalLocation
        := size <= 8u64 ifTrue: (self allocateIntegerRegister) ifFalse: nil.

    public method allocateVectorOfSize: (size: UInt64) alignment: (alignment: UInt64) ::=> MIRPhysicalLocation
        := size <= 16u64 ifTrue: (self allocateVectorRegister) ifFalse: nil.

    public method assignRegisterToValue: (value: MIRValue) ::=> MIRPhysicalLocation := {
        (value isFloatingPoint || value isVector)
            ifTrue: (self allocateVectorOfSize: value size alignment: value alignment)
            ifFalse: (self allocateIntegerOfSize: value size alignment: value alignment).
    }.
}.

public final class MIRWinX64CallingConvention superclass: MIRX86_64CallingConvention; definition: {
    public override method allocableIntegerRegisters => Array
        := MIR::X86_64::Win64::AllocableIntegerRegisters.

    public override method allocableVectorRegisters => Array
        := MIR::X86_64::Win64::AllocableVectorRegisters.

    public override method preferredRegisterForCaptureVectorPointer => MIRPhysicalIntegerRegister
        := nil.

    public override method registerConstraintsOfCall: (instruction: MIRInstruction) with: (allocator: MIRRegisterAllocator) ::=> Void := {
        let registerArguments := OrderedCollection new.
        let stackArguments := OrderedCollection new.
        let hasStackIntegerArgument mutable := false.
        let hasStackFloatOrVectorArgument mutable := false.
        let hasStructureArgument mutable := false.
        let structureSizeThreshold := 8u64.

        let stackArgumentAlignment := 8u64.
        let stackSize mutable := 0u64.
        let stackAlignment mutable := 16u64.

        let registerAssignmentState := MIRWinX64RegisterAssignmentState new.
        1sz until: instruction operands size do: {:(Size)operandIndex :: Void |
            let operand => MIRValue := instruction operands at: operandIndex.
            let register := registerAssignmentState assignRegisterToValue: operand.
            register ifNotNil: {
                registerArguments add: operandIndex; add: register
            } ifNil: {
                let operandAlignment := operand alignment max: stackArgumentAlignment.
                let operandSize := operand size alignedTo: operandAlignment.
                let argumentOffset := stackSize alignedTo: operandAlignment.

                stackSize := argumentOffset + operandSize.
                stackAlignment := stackAlignment max: operandAlignment.
                
                (operand isFloatingPoint || operand isVector) ifTrue: {
                    hasStackFloatOrVectorArgument := true
                } ifFalse: {
                    hasStackIntegerArgument := true
                }.

                stackArguments add: operandIndex; add: argumentOffset
            }
        }.

        stackSize := (stackSize max: 32u64) alignedTo: stackAlignment.
        allocator addRequiredCalloutSize: stackSize withAlignment: stackAlignment.

        instruction scratchRegisterCount: 2sz.
        registerArguments pairsDo: {:(Size)operandIndex :register :: Void |
            allocator allocateRegister: register forInstruction: instruction operandAt: operandIndex
        }.

        hasStackIntegerArgument ifTrue: {
            allocator allocateIntegerRegisterForInstruction: instruction scratchAt: 0sz
        }.

        hasStackFloatOrVectorArgument ifTrue: {
            allocator allocateVectorRegisterForInstruction: instruction scratchAt: 1sz
        }.

        stackArguments pairsDo: {:(Size)operandIndex :(UInt64)stackOffset :: Void |
            let operand => MIRValue := instruction operands at: operandIndex.
            (operand isFloatingPoint || operand isVector) ifTrue: {
                allocator allocateSpecificCallStackPointerOffset: stackOffset asInt64 forInstruction: instruction operandAt: operandIndex scratchRegister: instruction scratchRegisters fourth
            } ifFalse: {
                operand size <= structureSizeThreshold ifTrue: {
                    allocator allocateSpecificCallStackPointerOffset: stackOffset asInt64 forInstruction: instruction operandAt: operandIndex scratchRegister: instruction scratchRegisters first
                } ifFalse: {
                    error("TODO: Pass value pointer.")
                }
            }.
        }.
                
        allocator allocateRegisterOrRelativeImmediate32ForInstruction: instruction operandAt: 0sz.
        allocator
            allocateCaptureVectorPointerRegisterForInstruction: instruction;
            spillIntegerRegistersExceptFor: X86_64::SysV::CallPreservedRegister
    }.

    public override method integerCallPreservedRegisters => Array
        := X86_64::Win64::CallPreservedRegister.

    public override method computeArgumentPassingLayoutOf: (function: MIRFunction) ::=> Void := {
        let registerAssignmentState := MIRWinX64RegisterAssignmentState new.
        let stackSize mutable := 0u64.
        let stackArgumentAlignment := 8u64.

        function arguments do: {:(MIRArgumentValue)argument :: Void |
            let register := registerAssignmentState assignRegisterToValue: argument.
            register ifNotNil: {
                argument passingRegister: register
            }.

            let argumentAlignment := argument alignment max: stackArgumentAlignment.
            let argumentSize := argument size alignedTo: argumentAlignment.
            let argumentOffset := stackSize alignedTo: argumentAlignment.

            argument
                stackSegment: MIRStackFrameSegment::ArgumentPassingZone;
                stackSegmentOffset: stackSize;
                hasValidStackSegmentOffset: true.
            stackSize := argumentOffset + argumentSize
        }.

        function
            argumentPassingStackAlignment: (stackArgumentAlignment max: 16u64);
            argumentPassingStackSize: ((stackSize alignedTo: stackArgumentAlignment) max: 32u64)
    }.
}.

public global MIR::X86_64::SysVCallingConvention := MIRSysVX86_64CallingConvention new.
public global MIR::X86_64::Win64CallingConvention := MIRWinX64CallingConvention new.

public final class MIRX86_64CompilationTarget superclass: MIRAsmCompilationTarget; definition: {
    public override method name => Symbol
        := #x86_64.

    public override method allIntegerRegisters => Array
        := MIR::X86_64::IntegerRegisters.

    public override method allVectorRegisters => Array
        := MIR::X86::VectorRegisters.

    public override method usesVectorRegistersForFloatOperations => Boolean
        := true.

    public override method defaultCallingConvention => MIRCallingConvention
        := asmCompilationTarget isWindows
            ifTrue: MIR::X86_64::Win64CallingConvention
            ifFalse: MIR::X86_64::SysVCallingConvention.

    public override method emitFunctionPrologueWith: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        asmCompilationTarget isWindows ifFalse: {
            codegen textSection x86::endbr64
        }.

        let stackFrameLayout := codegen stackFrameLayout.
        stackFrameLayout hasRequiredConstruction ifTrue: {
            codegen textSection
                x86::push: X86::RBP;
                cfiPushRegister: X86::RBP;
                x86::mov: X86::RBP src: X86::RSP;
                cfiSaveFramePointer: X86::RBP.

            codegen function touchedCallPreservedRegisters do: {:(MIRPhysicalLocation)each :: Void |
                let reg := (each x86::int64For: codegen) downCastTo: AsmRegister.
                codegen textSection
                    x86::push: reg;
                    cfiPushRegister: reg.
            }.
        }.
    }.

    public override method emitStackFrameConstructionWith: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        let stackFrameLayout := codegen stackFrameLayout.
        stackFrameLayout hasRequiredConstruction ifTrue: {
            codegen stackMap frameBase: (AsmStackMapLocationRegister for: X86::RBP)
        }.

        let frameSize := stackFrameLayout frameAllocationSize.
        frameSize > 0u64 ifTrue: {
            codegen textSection
                x86::sub: X86::RSP with: frameSize asInt32 asAsmImmediate;
                cfiStackSizeAdvance: frameSize asInt64
        }.
        codegen textSection cfiEndPrologue.
        
        codegen
            emitSpillRegisterArgumentsInStackFrame;
            emitUnspillEntryValuesFromStackFrame
    }.

    public override method emitFunctionEpilogueWith: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        let stackFrameLayout := codegen stackFrameLayout.
        stackFrameLayout hasRequiredConstruction ifTrue: {
            let preservedRegisters := codegen function touchedCallPreservedRegisters.
            preservedRegisters isEmpty ifTrue: {
                codegen textSection
                    cfiBeginEpilogue;
                    x86::mov: X86::RSP src: X86::RBP;
                    cfiRestoreFramePointer: X86::RBP offset: 0i64;
                    x86::pop: X86::RBP;
                    cfiPopRegister: X86::RBP.
            } ifFalse: {
                codegen textSection
                    cfiBeginEpilogue;
                    x86::lea: X86::RSP src: X86::RBP x86::qword + (preservedRegisters size asInt64 * -8i64) asAsmImmediate;
                    cfiRestoreFramePointer: X86::RBP offset: preservedRegisters size asInt64.
                preservedRegisters reverseDo: {:(MIRPhysicalLocation)each :: Void |
                    let reg := (each x86::int64For: codegen) downCastTo: AsmRegister.
                    codegen textSection
                        x86::pop: reg;
                        cfiPopRegister: reg.
                }.

                codegen textSection
                    x86::pop: X86::RBP;
                    cfiPopRegister: X86::RBP.
            }.

        }.
    }.

    public override method emitMoveValue: (value: MIRValue) intoLocation: (register: MIRPhysicalLocation) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        value x86_64::moveIntoRegister: register with: codegen
    }.

    public override method emitMoveValue: (value: MIRValue) intoSpecificMemoryLocation: (memoryLocation: MIRSpecificPhysicalMemoryLocation) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        value x86_64::moveIntoSpecificMemoryLocation: memoryLocation with: codegen
    }.

    public override method emitUnspillValue: (value: MIRValue) intoLocation: (register: MIRPhysicalLocation) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        value x86_64::unspillIntoRegister: register with: codegen
    }.

    public override method emitMoveValuePointer: (value: MIRValue) intoLocation: (register: MIRPhysicalLocation) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        value x86_64::movePointerIntoRegister: register with: codegen
    }.

    public override method emitMoveRegister: (register: MIRPhysicalLocation) intoValue: (value: MIRValue) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        value x86_64::moveFromRegister: register with: codegen
    }.

    public override method emitLoadCaptureVectorPointerFromClosure: (closurePointer: MIRPhysicalLocation) intoRegister: (register: MIRPhysicalLocation) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        let closurePointerRegister := (closurePointer x86::int64For: codegen) downCastTo: AsmX86IntRegister.
        let reg := (register x86::int64For: codegen) downCastTo: AsmX86IntRegister.
        codegen textSection x86::mov: reg src: closurePointerRegister x86::qword + codegen closureCaptureVectorMemberOffset asInt32 asAsmImmediate
    }.
}.

MIRValue extend: {
    public abstract method x86::pointerWithCodegen: (codegen: MIRFunctionAsmCodeGenerator) ::=> AsmX86RegisterAddress
        := self subclassResponsibility.

    public abstract method x86_64::pointerWithCodegen: (codegen: MIRFunctionAsmCodeGenerator) ::=> AsmX86RegisterAddress
        := self subclassResponsibility.

    public abstract method x86::moveIntoRegister: (register: MIRPhysicalLocation) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void
        := self subclassResponsibility.

    public abstract method x86::moveIntoSpecificMemoryLocation: (memoryLocation: MIRSpecificPhysicalMemoryLocation) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void
        := self subclassResponsibility.

    public virtual method x86::unspillIntoRegister: (register: MIRPhysicalLocation) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void
        := self x86::moveIntoRegister: register with: codegen.

    public abstract method x86::movePointerIntoRegister: (register: MIRPhysicalLocation) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void
        := self subclassResponsibility.

    public abstract method x86::moveFromRegister: (register: MIRPhysicalLocation) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void
        := self subclassResponsibility.

    public abstract method x86::pushWith: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void
        := self subclassResponsibility.

    public virtual method x86_64::moveIntoRegister: (register: MIRPhysicalLocation) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void
        := self x86::moveIntoRegister: register with: codegen.

    public virtual method x86_64::moveIntoSpecificMemoryLocation: (memoryLocation: MIRSpecificPhysicalMemoryLocation) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void
        := self x86::moveIntoSpecificMemoryLocation: memoryLocation with: codegen.

    public virtual method x86_64::unspillIntoRegister: (register: MIRPhysicalLocation) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void
        := self x86_64::moveIntoRegister: register with: codegen.

    public virtual method x86_64::movePointerIntoRegister: (register: MIRPhysicalLocation) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void
        := self x86::movePointerIntoRegister: register with: codegen.

    public virtual method x86_64::moveFromRegister: (register: MIRPhysicalLocation) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void
        := self x86::moveFromRegister: register with: codegen.

    public virtual method x86_64::pushWith: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void
        := self subclassResponsibility.

    public virtual method x86_64::pushWith: (codegen: MIRFunctionAsmCodeGenerator) scratchRegister: (scratchRegister: AsmInstructionOperand)::=> Void := {
        self x86_64::pushWith: codegen
    }.

    public method x86_x86_64::pointerWithCodegen: (codegen: MIRFunctionAsmCodeGenerator) ::=> AsmX86RegisterAddress
        := codegen target pointerSize = 8sz
            ifTrue: (self x86_64::pointerWithCodegen: codegen)
            ifFalse: (self x86::pointerWithCodegen: codegen).
}.

MIRProgramEntity extend: {
    public override method x86::moveIntoRegister: (register: MIRPhysicalLocation) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        codegen textSection x86::mov: (register x86::int32For: codegen) src: (codegen symbolForProgramEntity: self) dword
    }.

    public override method x86::moveIntoSpecificMemoryLocation: (memoryLocation: MIRSpecificPhysicalMemoryLocation) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        let scratch := memoryLocation firstScratchRegister.
        codegen textSection
            x86::lea: (scratch x86::int32For: codegen) src: (codegen symbolForProgramEntity: self) dword;
            x86::mov: (memoryLocation x86::pointerWithCodegen: codegen) dword src: (scratch x86::int32For: codegen)
    }.

    public override method x86::movePointerIntoRegister: (register: MIRPhysicalLocation) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        codegen textSection x86::mov: (register x86::int32For: codegen) src: (codegen symbolForProgramEntity: self) dword
    }.

    public override method x86_64::moveIntoRegister: (register: MIRPhysicalLocation) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        codegen textSection x86::lea: (register x86::int64For: codegen) src: (codegen symbolForProgramEntity: self) x86::qwordPtr
    }.

    public override method x86_64::moveIntoSpecificMemoryLocation: (memoryLocation: MIRSpecificPhysicalMemoryLocation) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        let scratch := memoryLocation firstScratchRegister.
        codegen textSection
            x86::lea: (scratch x86::int64For: codegen) src: (codegen symbolForProgramEntity: self) qword;
            x86::mov: (memoryLocation x86_64::pointerWithCodegen: codegen) qword src: (scratch x86::int64For: codegen)
    }.

    public override method x86_64::movePointerIntoRegister: (register: MIRPhysicalLocation) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        codegen textSection x86::lea: (register x86::int64For: codegen) src: (codegen symbolForProgramEntity: self) x86::qwordPtr
    }.
}.

MIRVariable extend: {
    public override method x86::moveIntoRegister: (register: MIRPhysicalLocation) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        register x86::loadFromVariable: self with: codegen
    }.

    public override method x86::moveFromRegister: (register: MIRPhysicalLocation) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        register x86::storeInVariable: self with: codegen
    }.

    public override method x86::movePointerIntoRegister: (register: MIRPhysicalLocation) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        codegen textSection x86::lea: (register x86::int32For: codegen) src: (self x86::pointerWithCodegen: codegen)
    }.

    public override method x86_64::moveIntoRegister: (register: MIRPhysicalLocation) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        register x86_64::loadFromVariable: self with: codegen
    }.

    public override method x86_64::moveFromRegister: (register: MIRPhysicalLocation) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        register x86_64::storeInVariable: self with: codegen
    }.

    public override method x86_64::movePointerIntoRegister: (register: MIRPhysicalLocation) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        codegen textSection x86::lea: (register x86::int64For: codegen) src: (self x86_64::pointerWithCodegen: codegen)
    }.
}.

MIRLocalValue extend: {
    public override method x86::pointerWithCodegen: (codegen: MIRFunctionAsmCodeGenerator) ::=> AsmX86RegisterAddress := {
        let coalescedValue := self validCoalescedValue.
        self assert: coalescedValue hasValidStackAnchorOffset.
        AsmX86RegisterAddress base: X86::EBP size: coalescedValue size asUInt8 displacement: coalescedValue offset asInt32 asAsmImmediate
    }.

    public override method x86_64::pointerWithCodegen: (codegen: MIRFunctionAsmCodeGenerator) ::=> AsmX86RegisterAddress := {
        let coalescedValue := self validCoalescedValue.
        self assert: coalescedValue hasValidStackAnchorOffset.
        AsmX86RegisterAddress base: X86::RBP size: coalescedValue size asUInt8 displacement: coalescedValue offset asInt32 asAsmImmediate
    }.

    public override method x86::moveIntoRegister: (register: MIRPhysicalLocation) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        let coalescedRegister := self coalescedAssignedRegister.
        coalescedRegister ifNil: {
            register x86::loadFromVariable: self with: codegen
        } ifNotNil: {
            register x86::loadFromRegister: coalescedRegister with: codegen
        }
    }.

    public override method x86::moveIntoSpecificMemoryLocation: (memoryLocation: MIRSpecificPhysicalMemoryLocation) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        let coalescedRegister := self coalescedAssignedRegister.
        let targetPointer := memoryLocation x86_64::pointerWithCodegen: codegen.
        coalescedRegister ifNotNil: {
            coalescedRegister x86::storeValue: self inPointer: targetPointer isCallArgument: memoryLocation isCallArgument with: codegen
        } ifNil: {
            memoryLocation isStructure ifTrue: {
                codegen textSection
                    x86::lea: X86::EDI src: (memoryLocation x86::pointerWithCodegen: codegen);
                    x86::lea: X86::ESI src: (self x86::pointerWithCodegen: codegen);
                    x86::mov: X86::ECX src: self size asAsmImmediate;
                    x86::rep; x86::movsb
            } ifFalse: {
                let scratchRegister := memoryLocation firstScratchRegister.
                scratchRegister
                    x86::loadFromVariable: self with: codegen;
                    x86::storeValue: self inPointer: targetPointer isCallArgument: memoryLocation isCallArgument with: codegen
            }.
        }
    }.

    public override method x86::unspillIntoRegister: (register: MIRPhysicalLocation) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        register x86::loadFromVariable: self with: codegen
    }.

    public override method x86::moveFromRegister: (register: MIRPhysicalLocation) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        let coalescedRegister := self coalescedAssignedRegister.
        coalescedRegister ifNotNil: {
            coalescedRegister x86::loadFromRegister: coalescedRegister with: codegen.
            needsSpilling ifTrue: {
                register x86::storeInVariable: self with: codegen
            }.
        } ifNil: {
            register x86::storeInVariable: self with: codegen
        }.
    }.

    public override method x86::movePointerIntoRegister: (register: MIRPhysicalLocation) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        codegen textSection x86::lea: (register x86::int32For: codegen) src: (self x86::pointerWithCodegen: codegen)
    }.

    public override method x86_64::moveIntoRegister: (register: MIRPhysicalLocation) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        let coalescedRegister := self coalescedAssignedRegister.
        coalescedRegister ifNotNil: {
            register x86_64::loadFromRegister: coalescedRegister with: codegen
        } ifNil: {
            register x86_64::loadFromVariable: self with: codegen
        }
    }.

    public override method x86_64::moveIntoSpecificMemoryLocation: (memoryLocation: MIRSpecificPhysicalMemoryLocation) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        let coalescedRegister := self coalescedAssignedRegister.
        let targetPointer := memoryLocation x86_64::pointerWithCodegen: codegen.
        coalescedRegister ifNotNil: {
            coalescedRegister x86_64::storeValue: self inPointer: targetPointer isCallArgument: memoryLocation isCallArgument with: codegen
        } ifNil: {
            memoryLocation isStructure ifTrue: {
                codegen textSection
                    x86::lea: X86::RDI src: (memoryLocation x86::pointerWithCodegen: codegen);
                    x86::lea: X86::RSI src: (self x86::pointerWithCodegen: codegen);
                    x86::mov: X86::RCX src: self size asAsmImmediate;
                    x86::rep; x86::movsb
            } ifFalse: {
                let scratchRegister := memoryLocation firstScratchRegister.
                scratchRegister
                    x86_64::loadFromVariable: self with: codegen;
                    x86_64::storeValue: self inPointer: targetPointer isCallArgument: memoryLocation isCallArgument with: codegen
            }.
        }
    }.

    public override method x86_64::unspillIntoRegister: (register: MIRPhysicalLocation) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        register x86_64::loadFromVariable: self with: codegen
    }.

    public override method x86_64::moveFromRegister: (register: MIRPhysicalLocation) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        let coalescedRegister := self coalescedAssignedRegister.
        coalescedRegister ifNotNil: {
            coalescedRegister x86_64::loadFromRegister: register with: codegen.
            needsSpilling ifTrue: {
                register x86_64::storeInVariable: self with: codegen
            }.
        } ifNil: {
            register x86_64::storeInVariable: self with: codegen
        }.
    }.

    public override method x86_64::movePointerIntoRegister: (register: MIRPhysicalLocation) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        codegen textSection x86::lea: (register x86::int64For: codegen) src: (self x86_64::pointerWithCodegen: codegen)
    }.
}.

MIRValuePointer extend: {
    public override method x86::moveIntoRegister: (register: MIRPhysicalLocation) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        codegen textSection x86::lea: (register x86::int64For: codegen) src: (value x86::pointerWithCodegen: codegen)
    }.

    public override method x86_64::moveIntoRegister: (register: MIRPhysicalLocation) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        codegen textSection x86::lea: (register x86::int64For: codegen) src: (value x86_64::pointerWithCodegen: codegen)
    }.
}.

MIRCaptureVariable extend: {
    public override method x86::pointerWithCodegen: (codegen: MIRFunctionAsmCodeGenerator) ::=> AsmX86RegisterAddress
        := AsmX86RegisterAddress
            base: ((codegen validCaptureVectorPointerRegister x86::int32For: codegen) downCastTo: AsmX86Register)
            size: self size asUInt8
            displacement: (codegen captureVectorDataOffset asInt32 + self offset asInt32) asAsmImmediate.

    public override method x86_64::pointerWithCodegen: (codegen: MIRFunctionAsmCodeGenerator) ::=> AsmX86RegisterAddress
        := AsmX86RegisterAddress
            base: ((codegen validCaptureVectorPointerRegister x86::int32For: codegen) downCastTo: AsmX86Register)
            size: self size asUInt8
            displacement: (codegen captureVectorDataOffset asInt32 + self offset asInt32) asAsmImmediate.
}.

MIRConstant extend: {
    public override method x86_64::moveFromRegister: (register: MIRPhysicalLocation) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void
        := self error: "Cannot move into constant.".
}.

MIRConstantInt8 extend: {
    public override method x86::moveIntoSpecificMemoryLocation: (memoryLocation: MIRSpecificPhysicalMemoryLocation) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        codegen textSection x86::mov: (memoryLocation x86::pointerWithCodegen: codegen) byte src: value asAsmImmediate
    }.

    public override method x86::moveIntoRegister: (register: MIRPhysicalLocation) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        codegen textSection x86::mov: (register x86::int32For: codegen) src: value asUInt32 asAsmImmediate.
    }.

    public override method x86_64::pushWith: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        codegen textSection x86::push: value asInt32 asAsmImmediate
    }.
}.

MIRConstantUInt8 extend: {
    public override method x86::moveIntoSpecificMemoryLocation: (memoryLocation: MIRSpecificPhysicalMemoryLocation) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        codegen textSection x86::mov: (memoryLocation x86::pointerWithCodegen: codegen) byte src: value asAsmImmediate
    }.

    public override method x86::moveIntoRegister: (register: MIRPhysicalLocation) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        codegen textSection x86::mov: (register x86::int32For: codegen) src: value asUInt32 asAsmImmediate.
    }.

    public override method x86_64::pushWith: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        codegen textSection x86::push: value asInt32 asAsmImmediate
    }.
}.

MIRConstantInt16 extend: {
    public override method x86::moveIntoSpecificMemoryLocation: (memoryLocation: MIRSpecificPhysicalMemoryLocation) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        codegen textSection x86::mov: (memoryLocation x86::pointerWithCodegen: codegen) word src: value asAsmImmediate
    }.

    public override method x86::moveIntoRegister: (register: MIRPhysicalLocation) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        codegen textSection x86::mov: (register x86::int32For: codegen) src: value asUInt32 asAsmImmediate.
    }.

    public override method x86_64::pushWith: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        codegen textSection x86::push: value asInt32 asAsmImmediate
    }.
}.

MIRConstantUInt16 extend: {
    public override method x86::moveIntoSpecificMemoryLocation: (memoryLocation: MIRSpecificPhysicalMemoryLocation) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        codegen textSection x86::mov: (memoryLocation x86::pointerWithCodegen: codegen) word src: value asAsmImmediate
    }.

    public override method x86::moveIntoRegister: (register: MIRPhysicalLocation) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        codegen textSection x86::mov: (register x86::int32For: codegen) src: value asUInt32 asAsmImmediate.
    }.

    public override method x86_64::pushWith: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        codegen textSection x86::push: value asInt32 asAsmImmediate
    }.
}.

MIRConstantInt32 extend: {
    public override method x86::moveIntoSpecificMemoryLocation: (memoryLocation: MIRSpecificPhysicalMemoryLocation) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        codegen textSection x86::mov: (memoryLocation x86::pointerWithCodegen: codegen) dword src: value asAsmImmediate
    }.
    
    public override method x86::moveIntoRegister: (register: MIRPhysicalLocation) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        codegen textSection x86::mov: (register x86::int32For: codegen) src: value asAsmImmediate.
    }.

    public override method x86_64::pushWith: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        codegen textSection x86::push: value asAsmImmediate
    }.
}.

MIRConstantUInt32 extend: {
    public override method x86::moveIntoSpecificMemoryLocation: (memoryLocation: MIRSpecificPhysicalMemoryLocation) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        codegen textSection x86::mov: (memoryLocation x86::pointerWithCodegen: codegen) dword src: value asAsmImmediate
    }.

    public override method x86::moveIntoRegister: (register: MIRPhysicalLocation) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        codegen textSection x86::mov: (register x86::int32For: codegen) src: value asAsmImmediate.
    }.

    public override method x86_64::pushWith: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        codegen textSection x86::push: value asAsmImmediate
    }.
}.

MIRConstantInt64 extend: {
    public override method x86_64::moveIntoSpecificMemoryLocation: (memoryLocation: MIRSpecificPhysicalMemoryLocation) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        codegen textSection x86::mov: (memoryLocation x86_64::pointerWithCodegen: codegen) qword src: value asAsmImmediate
    }.

    public override method x86_64::moveIntoRegister: (register: MIRPhysicalLocation) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        codegen textSection x86::mov: (register x86::int64For: codegen) src: value asAsmImmediate.
    }.

    public override method x86_64::pushWith: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        codegen textSection x86::push: (codegen symbolForInt64Constant: value) x86::qwordPtr
    }.
}.

MIRConstantUInt64 extend: {
    public override method x86_64::moveIntoSpecificMemoryLocation: (memoryLocation: MIRSpecificPhysicalMemoryLocation) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        codegen textSection x86::mov: (memoryLocation x86_64::pointerWithCodegen: codegen) qword src: value asAsmImmediate
    }.

    public override method x86_64::moveIntoRegister: (register: MIRPhysicalLocation) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        codegen textSection x86::mov: (register x86::int64For: codegen) src: value asAsmImmediate.
    }.

    public override method x86_64::pushWith: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        codegen textSection x86::push: (codegen symbolForUInt64Constant: value) x86::qwordPtr
    }.
}.

MIRConstantFloat32 extend: {
    public override method x86::moveIntoSpecificMemoryLocation: (memoryLocation: MIRSpecificPhysicalMemoryLocation) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        codegen textSection x86::mov: (memoryLocation x86::pointerWithCodegen: codegen) dword src: value asIEEEFloat32Encoding asAsmImmediate
    }.

    public override method x86_64::moveIntoRegister: (register: MIRPhysicalLocation) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        codegen textSection x86::movss: (register x86::float32For: codegen) src: (codegen symbolForFloat32Constant: value) x86::dwordPtr
    }.

    public override method x86_64::pushWith: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        codegen textSection x86::push: value asIEEEFloat32Encoding asAsmImmediate
    }.
}.

MIRConstantFloat64 extend: {
    public override method x86_64::moveIntoRegister: (register: MIRPhysicalLocation) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        codegen textSection x86::movsd: (register x86::float64For: codegen) src: (codegen symbolForFloat64Constant: value) x86::qwordPtr
    }.

    public override method x86_64::moveIntoSpecificMemoryLocation: (memoryLocation: MIRSpecificPhysicalMemoryLocation) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        codegen textSection x86::mov: (memoryLocation x86::pointerWithCodegen: codegen) qword src: value asIEEEFloat64Encoding asAsmImmediate
    }.

    public override method x86_64::pushWith: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        codegen textSection x86::push: (codegen symbolForFloat64Constant: value) x86::qwordPtr
    }.
}.

MIRGenericObjectPointerConstant extend: {
    public override method x86_64::moveIntoRegister: (register: MIRPhysicalLocation) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        codegen textSection x86::mov: (register x86::int64For: codegen) src: (codegen x86_64::pointerForGCRootObjectTableEntryFor: self object).
    }.

    public override method x86_64::moveIntoSpecificMemoryLocation: (memoryLocation: MIRSpecificPhysicalMemoryLocation) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        let scratch := memoryLocation firstScratchRegister.
        codegen textSection
            x86::mov: (scratch x86::int64For: codegen) src: (codegen x86_64::pointerForGCRootObjectTableEntryFor: self object);
            x86::mov: (memoryLocation x86_64::pointerWithCodegen: codegen) qword src: (scratch x86::int64For: codegen)
    }.

    public override method x86_64::movePointerIntoRegister: (register: MIRPhysicalLocation) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        codegen textSection x86::mov: (register x86::int64For: codegen) src: (codegen x86_64::pointerForGCRootObjectTableEntryFor: self object).
    }.

    public override method x86_64::pushWith: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        codegen textSection x86::push: (codegen x86_64::pointerForGCRootObjectTableEntryFor: self object)
    }.
}.

MIRPolymorphicInlineCache extend: {
    public override method x86_64::moveIntoRegister: (register: MIRPhysicalLocation) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        codegen textSection x86::lea: (register x86::int64For: codegen) src: (codegen x86_64::pointerForPICEntry: self).
    }.

    public override method x86_64::moveIntoSpecificMemoryLocation: (memoryLocation: MIRSpecificPhysicalMemoryLocation) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        let scratch := memoryLocation firstScratchRegister.
        codegen textSection
            x86::lea: (scratch x86::int64For: codegen) src: (codegen x86_64::pointerForPICEntry: self);
            x86::mov: (memoryLocation x86_64::pointerWithCodegen: codegen) qword src: (scratch x86::int64For: codegen)
    }.

    public override method x86_64::movePointerIntoRegister: (register: MIRPhysicalLocation) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        codegen textSection x86::lea: (register x86::int64For: codegen) src: (codegen x86_64::pointerForPICEntry: self).
    }.
}.

MIRStructureConstant extend: {
    public override method x86_64::movePointerIntoRegister: (register: MIRPhysicalLocation) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        codegen textSection x86::lea: (register x86::int64For: codegen) src: (codegen symbolOfStructureConstant: self) x86::bytePtr.
    }.
}.

MIRStringLiteralPointerConstant extend: {
    public override method x86_64::moveIntoRegister: (register: MIRPhysicalLocation) with: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        codegen textSection x86::lea: (register x86::int64For: codegen) src: (codegen symbolOfStringLiteral: string nullTerminated: nullTerminated) x86::bytePtr
    }.

    public override method x86::pushWith: (codegen: MIRFunctionAsmCodeGenerator) ::=> Void := {
        codegen textSection x86::push: (codegen symbolOfStringLiteral: string nullTerminated: nullTerminated) dword
    }.
}.

MIRFunctionAsmCodeGenerator extend: {
    public method x86::pointerForGCRootObjectTableEntryFor: (object: Untyped) ::=> AsmInstructionOperand := {
        let offset := moduleGenerator offsetOfGCRootObjectTableEntryFor: object.
        AsmX86RegisterAddress size: target pointerSize asUInt8 displacement: moduleGenerator gcRootObjectTableSymbol dword + offset asInt64
    }.

    public method x86_64::pointerForGCRootObjectTableEntryFor: (object: Untyped) ::=> AsmInstructionOperand := {
        let offset := moduleGenerator offsetOfGCRootObjectTableEntryFor: object.
        AsmX86RegisterAddress size: target pointerSize asUInt8 displacement: moduleGenerator gcRootObjectTableSymbol qword + offset asInt64
    }.

    public method x86_64::pointerForPICEntry: (picEntry: MIRPolymorphicInlineCache) ::=> AsmInstructionOperand := {
        let offset := moduleGenerator offsetOfPICTableEntryFor: picEntry.
        AsmX86RegisterAddress size: target pointerSize asUInt8 displacement: moduleGenerator picTableSymbol qword + offset asInt64
    }.
}.

let x86::integerAluUnaryInt8RegisterConstraints := {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
    allocator
        allocateRegisterOrImmediate32ForInstruction: instruction operandAt: 0sz;
        allocateRegister8ForInstructionResult: instruction trySharingWithOperandAt: 0sz
}.

let x86::integerAluUnaryInt16RegisterConstraints := {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
    allocator
        allocateRegisterOrImmediate32ForInstruction: instruction operandAt: 0sz;
        allocateRegisterForInstructionResult: instruction trySharingWithOperandAt: 0sz
}.

let x86::integerAluUnaryInt32RegisterConstraints := {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
    allocator
        allocateRegisterImmediate32OrDirectPointerForInstruction: instruction operandAt: 0sz;
        allocateRegisterForInstructionResult: instruction trySharingWithOperandAt: 0sz
}.

let x86::integerAluUnaryInt64RegisterConstraints := x86::integerAluUnaryInt32RegisterConstraints.

let x86::integerAluInt8RegisterConstraints := {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
    allocator
        allocateRegisterOrImmediate32ForInstruction: instruction operandAt: 0sz;
        allocateRegisterImmediate8OrDirectPointerForInstruction: instruction operandAt: 1sz;
        allocateRegister8ForInstructionResult: instruction trySharingWithOperandAt: 0sz
}.

let x86::integerAluInt16RegisterConstraints := {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
    allocator
        allocateRegisterOrImmediate32ForInstruction: instruction operandAt: 0sz;
        allocateRegisterImmediate16OrDirectPointerForInstruction: instruction operandAt: 1sz;
        allocateRegisterForInstructionResult: instruction trySharingWithOperandAt: 0sz
}.

let x86::integerAluInt32RegisterConstraints := {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
    allocator
        allocateRegisterImmediate32OrDirectPointerForInstruction: instruction operandAt: 0sz;
        allocateRegisterImmediate32OrDirectPointerForInstruction: instruction operandAt: 1sz;
        allocateRegisterForInstructionResult: instruction trySharingWithOperandAt: 0sz
}.

let x86::integerAluInt64RegisterConstraints := {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
    allocator
        allocateRegisterImmediate64OrDirectPointerForInstruction: instruction operandAt: 0sz;
        allocateRegisterImmediateS32OrDirectPointerForInstruction: instruction operandAt: 1sz;
        allocateRegisterForInstructionResult: instruction trySharingWithOperandAt: 0sz
}.

MIR::Operation::BooleanNot
    forTargets: #(x86 x86_64) registerConstraintsWith: {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
        allocator
            allocateRegisterOrImmediate32ForInstruction: instruction operandAt: 0sz;
            allocateRegister8ForInstructionResult: instruction
    };
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        let result := instruction resultRegister x86::int32For: codegen.
        let operand := instruction firstOperandRegister x86::int32For: codegen.
        codegen textSection
            x86::xor: result with: result;
            x86::test: operand with: operand;
            x86::sete: (instruction resultRegister x86::int8For: codegen)
    }.

MIR::Operation::BooleanXor
    forTargets: #(x86 x86_64) registerConstraintsWith: {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
        allocator
            allocateRegisterOrImmediate32ForInstruction: instruction operandAt: 0sz;
            allocateRegisterOrImmediate32ForInstruction: instruction operandAt: 1sz;
            allocateRegisterForInstructionResult: instruction trySharingWithOperandAt: 0sz
    };
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::mov: (instruction resultRegister x86::int32For: codegen) src: (instruction firstOperandRegister x86::int32For: codegen);
            x86::xor: (instruction resultRegister x86::int32For: codegen) with: (instruction secondOperandRegister x86::int32For: codegen)
    }.

MIR::Operation::Int8Negate
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerAluUnaryInt8RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::mov: (instruction resultRegister x86::int32For: codegen) src: (instruction firstOperandRegister x86::int32For: codegen);
            x86::neg: (instruction resultRegister x86::int8For: codegen)
    }.

MIR::Operation::Int8BitNot
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerAluUnaryInt8RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::mov: (instruction resultRegister x86::int32For: codegen) src: (instruction firstOperandRegister x86::int32For: codegen);
            x86::not: (instruction resultRegister x86::int8For: codegen)
    }.

MIR::Operation::Int8Add
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerAluInt8RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::mov: (instruction resultRegister x86::int32For: codegen) src: (instruction firstOperandRegister x86::int32For: codegen);
            x86::add: (instruction resultRegister x86::int8For: codegen) with: (instruction secondOperandRegister x86::int8For: codegen)
    }.

MIR::Operation::Int8Sub
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerAluInt8RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::mov: (instruction resultRegister x86::int32For: codegen) src: (instruction firstOperandRegister x86::int32For: codegen);
            x86::sub: (instruction resultRegister x86::int8For: codegen) with: (instruction secondOperandRegister x86::int8For: codegen)
    }.

MIR::Operation::Int8BitAnd
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerAluInt8RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::mov: (instruction resultRegister x86::int32For: codegen) src: (instruction firstOperandRegister x86::int32For: codegen);
            x86::and: (instruction resultRegister x86::int8For: codegen) with: (instruction secondOperandRegister x86::int8For: codegen)
    }.

MIR::Operation::Int8BitOr
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerAluInt8RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::mov: (instruction resultRegister x86::int32For: codegen) src: (instruction firstOperandRegister x86::int32For: codegen);
            x86::or: (instruction resultRegister x86::int8For: codegen) with: (instruction secondOperandRegister x86::int8For: codegen)
    }.

MIR::Operation::Int8BitXor
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerAluInt8RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::mov: (instruction resultRegister x86::int32For: codegen) src: (instruction firstOperandRegister x86::int32For: codegen);
            x86::xor: (instruction resultRegister x86::int8For: codegen) with: (instruction secondOperandRegister x86::int8For: codegen)
    }.

MIR::Operation::Int8Compare
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerAluInt8RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::mov: (instruction resultRegister x86::int32For: codegen) src: (instruction firstOperandRegister x86::int32For: codegen);
            x86::sub: (instruction resultRegister x86::int8For: codegen) with: (instruction secondOperandRegister x86::int8For: codegen);
            x86::movsx: (instruction resultRegister x86::int32For: codegen) src: (instruction resultRegister x86::int8For: codegen)
    }.

MIR::Operation::Int16Negate
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerAluUnaryInt16RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::mov: (instruction resultRegister x86::int32For: codegen) src: (instruction firstOperandRegister x86::int32For: codegen);
            x86::neg: (instruction resultRegister x86::int16For: codegen)
    }.

MIR::Operation::Int16HighBit
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerAluUnaryInt32RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::lzcnt: (instruction resultRegister x86::int16For: codegen) with: (instruction firstOperandRegister x86::int16For: codegen);
            x86::neg: (instruction resultRegister x86::int16For: codegen);
            x86::add: (instruction resultRegister x86::int16For: codegen) with: 32u8 asAsmImmediate
    }.

MIR::Operation::Int16BitNot
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerAluUnaryInt16RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::mov: (instruction resultRegister x86::int32For: codegen) src: (instruction firstOperandRegister x86::int32For: codegen);
            x86::not: (instruction resultRegister x86::int16For: codegen)
    }.

MIR::Operation::Int16Add
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerAluInt16RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::mov: (instruction resultRegister x86::int32For: codegen) src: (instruction firstOperandRegister x86::int32For: codegen);
            x86::add: (instruction resultRegister x86::int16For: codegen) with: (instruction secondOperandRegister x86::int16For: codegen)
    }.

MIR::Operation::Int16Sub
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerAluInt16RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::mov: (instruction resultRegister x86::int32For: codegen) src: (instruction firstOperandRegister x86::int32For: codegen);
            x86::sub: (instruction resultRegister x86::int16For: codegen) with: (instruction secondOperandRegister x86::int16For: codegen)
    }.

MIR::Operation::Int16BitAnd
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerAluInt16RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::mov: (instruction resultRegister x86::int32For: codegen) src: (instruction firstOperandRegister x86::int32For: codegen);
            x86::and: (instruction resultRegister x86::int16For: codegen) with: (instruction secondOperandRegister x86::int16For: codegen)
    }.

MIR::Operation::Int16BitOr
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerAluInt16RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::mov: (instruction resultRegister x86::int32For: codegen) src: (instruction firstOperandRegister x86::int32For: codegen);
            x86::or: (instruction resultRegister x86::int16For: codegen) with: (instruction secondOperandRegister x86::int16For: codegen)
    }.

MIR::Operation::Int16BitXor
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerAluInt16RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::mov: (instruction resultRegister x86::int32For: codegen) src: (instruction firstOperandRegister x86::int32For: codegen);
            x86::xor: (instruction resultRegister x86::int16For: codegen) with: (instruction secondOperandRegister x86::int16For: codegen)
    }.

MIR::Operation::Int16Compare
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerAluInt16RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::mov: (instruction resultRegister x86::int32For: codegen) src: (instruction firstOperandRegister x86::int32For: codegen);
            x86::sub: (instruction resultRegister x86::int16For: codegen) with: (instruction secondOperandRegister x86::int16For: codegen);
            x86::movsx: (instruction resultRegister x86::int32For: codegen) src: (instruction resultRegister x86::int16For: codegen)
    }.

MIR::Operation::Int32Negate
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerAluUnaryInt32RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::mov: (instruction resultRegister x86::int32For: codegen) src: (instruction firstOperandRegister x86::int32For: codegen);
            x86::neg: (instruction resultRegister x86::int32For: codegen)
    }.

MIR::Operation::Int32HighBit
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerAluUnaryInt32RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::lzcnt: (instruction resultRegister x86::int32For: codegen) with: (instruction firstOperandRegister x86::int32For: codegen);
            x86::neg: (instruction resultRegister x86::int32For: codegen);
            x86::add: (instruction resultRegister x86::int32For: codegen) with: 32u8 asAsmImmediate
    }.

MIR::Operation::Int32BitNot
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerAluUnaryInt32RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::mov: (instruction resultRegister x86::int32For: codegen) src: (instruction firstOperandRegister x86::int32For: codegen);
            x86::not: (instruction resultRegister x86::int32For: codegen)
    }.

MIR::Operation::Int32Add
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerAluInt32RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::mov: (instruction resultRegister x86::int32For: codegen) src: (instruction firstOperandRegister x86::int32For: codegen);
            x86::add: (instruction resultRegister x86::int32For: codegen) with: (instruction secondOperandRegister x86::int32For: codegen)
    }.

MIR::Operation::Int32Sub
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerAluInt32RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::mov: (instruction resultRegister x86::int32For: codegen) src: (instruction firstOperandRegister x86::int32For: codegen);
            x86::sub: (instruction resultRegister x86::int32For: codegen) with: (instruction secondOperandRegister x86::int32For: codegen)
    }.

MIR::Operation::Int32BitAnd
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerAluInt32RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::mov: (instruction resultRegister x86::int32For: codegen) src: (instruction firstOperandRegister x86::int32For: codegen);
            x86::and: (instruction resultRegister x86::int32For: codegen) with: (instruction secondOperandRegister x86::int32For: codegen)
    }.

MIR::Operation::Int32BitOr
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerAluInt32RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::mov: (instruction resultRegister x86::int32For: codegen) src: (instruction firstOperandRegister x86::int32For: codegen);
            x86::or: (instruction resultRegister x86::int32For: codegen) with: (instruction secondOperandRegister x86::int32For: codegen)
    }.

MIR::Operation::Int32BitXor
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerAluInt32RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::mov: (instruction resultRegister x86::int32For: codegen) src: (instruction firstOperandRegister x86::int32For: codegen);
            x86::xor: (instruction resultRegister x86::int32For: codegen) with: (instruction secondOperandRegister x86::int32For: codegen)
    }.

MIR::Operation::Int32Compare
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerAluInt16RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::mov: (instruction resultRegister x86::int32For: codegen) src: (instruction firstOperandRegister x86::int32For: codegen);
            x86::sub: (instruction resultRegister x86::int16For: codegen) with: (instruction secondOperandRegister x86::int16For: codegen).
    }.

MIR::Operation::Int64Negate
    forTarget: #x86_64 registerConstraintsWith: x86::integerAluUnaryInt64RegisterConstraints;
    forTarget: #x86_64 generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::mov: (instruction resultRegister x86::int64For: codegen) src: (instruction firstOperandRegister x86::int64For: codegen);
            x86::neg: (instruction resultRegister x86::int64For: codegen)
    }.

MIR::Operation::Int64HighBit
    forTarget: #x86_64 registerConstraintsWith: x86::integerAluUnaryInt64RegisterConstraints;
    forTarget: #x86_64 generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::lzcnt: (instruction resultRegister x86::int64For: codegen) with: (instruction firstOperandRegister x86::int64For: codegen);
            x86::neg: (instruction resultRegister x86::int64For: codegen);
            x86::add: (instruction resultRegister x86::int64For: codegen) with: 64u8 asAsmImmediate

    }.

MIR::Operation::Int64BitNot
    forTarget: #x86_64 registerConstraintsWith: x86::integerAluUnaryInt64RegisterConstraints;
    forTarget: #x86_64 generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::mov: (instruction resultRegister x86::int64For: codegen) src: (instruction firstOperandRegister x86::int64For: codegen);
            x86::not: (instruction resultRegister x86::int64For: codegen)
    }.

MIR::Operation::Int64Add
    forTarget: #x86_64 registerConstraintsWith: x86::integerAluInt64RegisterConstraints;
    forTarget: #x86_64 generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::mov: (instruction resultRegister x86::int64For: codegen) src: (instruction firstOperandRegister x86::int64For: codegen);
            x86::add: (instruction resultRegister x86::int64For: codegen) with: (instruction secondOperandRegister x86::immediateS32OrInt64For: codegen)
    }.

MIR::Operation::Int64Sub
    forTarget: #x86_64 registerConstraintsWith: x86::integerAluInt64RegisterConstraints;
    forTarget: #x86_64 generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::mov: (instruction resultRegister x86::int64For: codegen) src: (instruction firstOperandRegister x86::int64For: codegen);
            x86::sub: (instruction resultRegister x86::int64For: codegen) with: (instruction secondOperandRegister x86::immediateS32OrInt64For: codegen)
    }.

MIR::Operation::Int64BitAnd
    forTarget: #x86_64 registerConstraintsWith: x86::integerAluInt64RegisterConstraints;
    forTarget: #x86_64 generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::mov: (instruction resultRegister x86::int64For: codegen) src: (instruction firstOperandRegister x86::int64For: codegen);
            x86::and: (instruction resultRegister x86::int64For: codegen) with: (instruction secondOperandRegister x86::immediateS32OrInt64For: codegen)
    }.

MIR::Operation::Int64BitOr
    forTarget: #x86_64 registerConstraintsWith: x86::integerAluInt64RegisterConstraints;
    forTarget: #x86_64 generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::mov: (instruction resultRegister x86::int64For: codegen) src: (instruction firstOperandRegister x86::int64For: codegen);
            x86::or: (instruction resultRegister x86::int64For: codegen) with: (instruction secondOperandRegister x86::immediateS32OrInt64For: codegen)
    }.

MIR::Operation::Int64BitXor
    forTarget: #x86_64 registerConstraintsWith: x86::integerAluInt64RegisterConstraints;
    forTarget: #x86_64 generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::mov: (instruction resultRegister x86::int64For: codegen) src: (instruction firstOperandRegister x86::int64For: codegen);
            x86::xor: (instruction resultRegister x86::int64For: codegen) with: (instruction secondOperandRegister x86::immediateS32OrInt64For: codegen)
    }.

MIR::Operation::Int64Compare
    forTarget: #x86_64 registerConstraintsWith: x86::integerAluInt64RegisterConstraints;
    forTarget: #x86_64 generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        ## TODO: Implement this properly.
        codegen textSection x86::int3
    }.

MIR::Operation::PointerAdd
    forTarget: #x86 registerConstraintsWith: x86::integerAluInt32RegisterConstraints;
    forTarget: #x86 generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::mov: (instruction resultRegister x86::int32For: codegen) src: (instruction firstOperandRegister x86::int32For: codegen);
            x86::add: (instruction resultRegister x86::int32For: codegen) with: (instruction secondOperandRegister x86::int32For: codegen)
    };
    forTarget: #x86_64 registerConstraintsWith: x86::integerAluInt64RegisterConstraints;
    forTarget: #x86_64 generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::mov: (instruction resultRegister x86::int64For: codegen) src: (instruction firstOperandRegister x86::int64For: codegen);
            x86::add: (instruction resultRegister x86::int64For: codegen) with: (instruction secondOperandRegister x86::immediateS32OrInt64For: codegen)
    }.

MIR::Operation::PointerSub
    forTarget: #x86 registerConstraintsWith: x86::integerAluInt32RegisterConstraints;
    forTarget: #x86 generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::mov: (instruction resultRegister x86::int32For: codegen) src: (instruction firstOperandRegister x86::int32For: codegen);
            x86::sub: (instruction resultRegister x86::int32For: codegen) with: (instruction secondOperandRegister x86::int32For: codegen)
    };
    forTarget: #x86_64 registerConstraintsWith: x86::integerAluInt64RegisterConstraints;
    forTarget: #x86_64 generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::mov: (instruction resultRegister x86::int64For: codegen) src: (instruction firstOperandRegister x86::int64For: codegen);
            x86::sub: (instruction resultRegister x86::int64For: codegen) with: (instruction secondOperandRegister x86::immediateS32OrInt64For: codegen)
    }.

let x86::integerMul32RegisterConstraints := {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
    allocator
        allocateRegisterOrImmediate32ForInstruction: instruction operandAt: 0sz;
        allocateRegisterOrDirectPointerForInstruction: instruction operandAt: 1sz;
        allocateRegisterForInstructionResult: instruction trySharingWithOperandAt: 0sz
}.

let x86::integerMul64RegisterConstraints := x86::integerMul32RegisterConstraints.

MIR::Operation::Int8Mul
    forTargets: #(x86 x86_64) registerConstraintsWith: {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
        allocator
            allocateRegisterOrImmediate32ForInstruction: instruction operandAt: 0sz;
            allocateRegister8OrDirectPointerForInstruction: instruction operandAt: 1sz;
            allocateRegister8ForInstructionResult: instruction trySharingWithOperandAt: 0sz
    };
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::mov: (instruction resultRegister x86::int32For: codegen) src: (instruction firstOperandRegister x86::int32For: codegen);
            x86::imul: (instruction resultRegister x86::int8For: codegen) with: (instruction secondOperandRegister x86::int8For: codegen)
    }.

MIR::Operation::Int16Mul
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerMul32RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::mov: (instruction resultRegister x86::int32For: codegen) src: (instruction firstOperandRegister x86::int32For: codegen);
            x86::imul: (instruction resultRegister x86::int16For: codegen) with: (instruction secondOperandRegister x86::int16For: codegen)
    }.

MIR::Operation::Int32Mul
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerMul32RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::mov: (instruction resultRegister x86::int32For: codegen) src: (instruction firstOperandRegister x86::int32For: codegen);
            x86::imul: (instruction resultRegister x86::int32For: codegen) with: (instruction secondOperandRegister x86::int32For: codegen)
    }.

MIR::Operation::Int64Mul
    forTarget: #x86_64 registerConstraintsWith: x86::integerMul64RegisterConstraints;
    forTarget: #x86_64 generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::mov: (instruction resultRegister x86::int64For: codegen) src: (instruction firstOperandRegister x86::int64For: codegen);
            x86::imul: (instruction resultRegister x86::int64For: codegen) with: (instruction secondOperandRegister x86::int64For: codegen)
    }.

MIR::Operation::PointerMul
    forTarget: #x86 registerConstraintsWith: x86::integerMul32RegisterConstraints;
    forTarget: #x86 generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::mov: (instruction resultRegister x86::int32For: codegen) src: (instruction firstOperandRegister x86::int32For: codegen);
            x86::imul: (instruction resultRegister x86::int32For: codegen) with: (instruction secondOperandRegister x86::int32For: codegen)
    };
    forTarget: #x86_64 registerConstraintsWith: x86::integerMul64RegisterConstraints;
    forTarget: #x86_64 generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::mov: (instruction resultRegister x86::int64For: codegen) src: (instruction firstOperandRegister x86::int64For: codegen);
            x86::imul: (instruction resultRegister x86::int64For: codegen) with: (instruction secondOperandRegister x86::int64For: codegen)
    }.

MIR::Operation::Int8UDiv
    forTarget: #x86 registerConstraintsWith: {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
        allocator
            allocateRegister: MIR::X86::EAX forInstruction: instruction operandAt: 0sz;
            allocateRegister: MIR::X86::EAX forInstructionResult: instruction;
            allocateRegister8ForInstruction: instruction operandAt: 1sz
    };
    forTarget: #x86_64 registerConstraintsWith: {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
        allocator
            allocateRegister: MIR::X86_64::RAX forInstruction: instruction operandAt: 0sz;
            allocateRegister: MIR::X86_64::RAX forInstructionResult: instruction;
            allocateRegister8ForInstruction: instruction operandAt: 1sz
    };
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::div: (instruction secondOperandRegister x86::int8For: codegen)
    }.

MIR::Operation::Int8URem
    forTarget: #x86 registerConstraintsWith: {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
        allocator
            allocateRegister: MIR::X86::EAX forInstruction: instruction operandAt: 0sz;
            allocateRegister: MIR::X86::EAX forInstructionResult: instruction;
            allocateRegister8ForInstruction: instruction operandAt: 1sz
    };
    forTarget: #x86_64 registerConstraintsWith: {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
        allocator
            allocateRegister: MIR::X86_64::RAX forInstruction: instruction operandAt: 0sz;
            allocateRegister: MIR::X86_64::RAX forInstructionResult: instruction;
            allocateRegister8ForInstruction: instruction operandAt: 1sz
    };
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::div: (instruction secondOperandRegister x86::int8For: codegen);
            x86::mov: X86::AL src: X86::AH
    }.

MIR::Operation::Int8SDiv
    forTarget: #x86 registerConstraintsWith: {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
        allocator
            allocateRegister: MIR::X86::EAX forInstruction: instruction operandAt: 0sz;
            allocateRegister: MIR::X86::EAX forInstructionResult: instruction;
            allocateRegister8ForInstruction: instruction operandAt: 1sz
    };
    forTarget: #x86_64 registerConstraintsWith: {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
        allocator
            allocateRegister: MIR::X86_64::RAX forInstruction: instruction operandAt: 0sz;
            allocateRegister: MIR::X86_64::RAX forInstructionResult: instruction;
            allocateRegister8ForInstruction: instruction operandAt: 1sz
    };
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::idiv: (instruction secondOperandRegister x86::int8For: codegen)
    }.

MIR::Operation::Int8SRem
    forTarget: #x86 registerConstraintsWith: {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
        allocator
            allocateRegister: MIR::X86::EAX forInstruction: instruction operandAt: 0sz;
            allocateRegister: MIR::X86::EAX forInstructionResult: instruction;
            allocateRegister8ForInstruction: instruction operandAt: 1sz
    };
    forTarget: #x86_64 registerConstraintsWith: {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
        allocator
            allocateRegister: MIR::X86_64::RAX forInstruction: instruction operandAt: 0sz;
            allocateRegister: MIR::X86_64::RAX forInstructionResult: instruction;
            allocateRegister8ForInstruction: instruction operandAt: 1sz
    };
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::idiv: (instruction secondOperandRegister x86::int8For: codegen);
            x86::mov: X86::AL src: X86::AH
    }.

MIR::Operation::Int16UDiv
    forTarget: #x86 registerConstraintsWith: {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
        instruction scratchRegisterCount: 1sz.
        allocator
            allocateRegister: MIR::X86::EAX forInstruction: instruction operandAt: 0sz;
            allocateRegister: MIR::X86::EDX forInstruction: instruction scratchAt: 0sz;
            allocateRegister: MIR::X86::EAX forInstructionResult: instruction;
            allocateRegisterForInstruction: instruction operandAt: 1sz
    };
    forTarget: #x86_64 registerConstraintsWith: {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
        instruction scratchRegisterCount: 1sz.
        allocator
            allocateRegister: MIR::X86_64::RAX forInstruction: instruction operandAt: 0sz;
            allocateRegister: MIR::X86_64::RDX forInstruction: instruction scratchAt: 0sz;
            allocateRegister: MIR::X86_64::RAX forInstructionResult: instruction;
            allocateRegisterForInstruction: instruction operandAt: 1sz
    };
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::xor: X86::DX with: X86::DX;
            x86::div: (instruction secondOperandRegister x86::int16For: codegen)
    }.

MIR::Operation::Int16URem
    forTarget: #x86 registerConstraintsWith: {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
        instruction scratchRegisterCount: 1sz.
        allocator
            allocateRegister: MIR::X86::EAX forInstruction: instruction operandAt: 0sz;
            allocateRegister: MIR::X86::EDX forInstruction: instruction scratchAt: 0sz;
            allocateRegister: MIR::X86::EDX forInstructionResult: instruction;
            allocateRegisterForInstruction: instruction operandAt: 1sz
    };
    forTarget: #x86_64 registerConstraintsWith: {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
        instruction scratchRegisterCount: 1sz.
        allocator
            allocateRegister: MIR::X86_64::RAX forInstruction: instruction operandAt: 0sz;
            allocateRegister: MIR::X86_64::RDX forInstruction: instruction scratchAt: 0sz;
            allocateRegister: MIR::X86_64::RDX forInstructionResult: instruction;
            allocateRegisterForInstruction: instruction operandAt: 1sz
    };
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::xor: X86::DX with: X86::DX;
            x86::div: (instruction secondOperandRegister x86::int16For: codegen)
    }.

MIR::Operation::Int16SDiv
    forTarget: #x86 registerConstraintsWith: {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
        instruction scratchRegisterCount: 1sz.
        allocator
            allocateRegister: MIR::X86::EAX forInstruction: instruction operandAt: 0sz;
            allocateRegister: MIR::X86::EDX forInstruction: instruction scratchAt: 0sz;
            allocateRegister: MIR::X86::EAX forInstructionResult: instruction;
            allocateRegisterForInstruction: instruction operandAt: 1sz
    };
    forTarget: #x86_64 registerConstraintsWith: {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
        instruction scratchRegisterCount: 1sz.
        allocator
            allocateRegister: MIR::X86_64::RAX forInstruction: instruction operandAt: 0sz;
            allocateRegister: MIR::X86_64::RDX forInstruction: instruction scratchAt: 0sz;
            allocateRegister: MIR::X86_64::RAX forInstructionResult: instruction;
            allocateRegisterForInstruction: instruction operandAt: 1sz
    };
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::cwd;
            x86::div: (instruction secondOperandRegister x86::int16For: codegen)
    }.

MIR::Operation::Int16SRem
    forTarget: #x86 registerConstraintsWith: {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
        instruction scratchRegisterCount: 1sz.
        allocator
            allocateRegister: MIR::X86::EAX forInstruction: instruction operandAt: 0sz;
            allocateRegister: MIR::X86::EDX forInstruction: instruction scratchAt: 0sz;
            allocateRegister: MIR::X86::EDX forInstructionResult: instruction;
            allocateRegisterForInstruction: instruction operandAt: 1sz
    };
    forTarget: #x86_64 registerConstraintsWith: {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
        instruction scratchRegisterCount: 1sz.
        allocator
            allocateRegister: MIR::X86_64::RAX forInstruction: instruction operandAt: 0sz;
            allocateRegister: MIR::X86_64::RDX forInstruction: instruction scratchAt: 0sz;
            allocateRegister: MIR::X86_64::RDX forInstructionResult: instruction;
            allocateRegisterForInstruction: instruction operandAt: 1sz
    };
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::cwd;
            x86::div: (instruction secondOperandRegister x86::int16For: codegen)
    }.

MIR::Operation::Int32UDiv
    forTarget: #x86 registerConstraintsWith: {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
        instruction scratchRegisterCount: 1sz.
        allocator
            allocateRegister: MIR::X86::EAX forInstruction: instruction operandAt: 0sz;
            allocateRegister: MIR::X86::EDX forInstruction: instruction scratchAt: 0sz;
            allocateRegister: MIR::X86::EAX forInstructionResult: instruction;
            allocateRegisterForInstruction: instruction operandAt: 1sz
    };
    forTarget: #x86_64 registerConstraintsWith: {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
        instruction scratchRegisterCount: 1sz.
        allocator
            allocateRegister: MIR::X86_64::RAX forInstruction: instruction operandAt: 0sz;
            allocateRegister: MIR::X86_64::RDX forInstruction: instruction scratchAt: 0sz;
            allocateRegister: MIR::X86_64::RAX forInstructionResult: instruction;
            allocateRegisterForInstruction: instruction operandAt: 1sz
    };
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::xor: X86::EDX with: X86::EDX;
            x86::div: (instruction secondOperandRegister x86::int32For: codegen)
    }.

MIR::Operation::Int32URem
    forTarget: #x86 registerConstraintsWith: {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
        instruction scratchRegisterCount: 1sz.
        allocator
            allocateRegister: MIR::X86::EAX forInstruction: instruction operandAt: 0sz;
            allocateRegister: MIR::X86::EDX forInstruction: instruction scratchAt: 0sz;
            allocateRegister: MIR::X86::EDX forInstructionResult: instruction;
            allocateRegisterForInstruction: instruction operandAt: 1sz
    };
    forTarget: #x86_64 registerConstraintsWith: {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
        instruction scratchRegisterCount: 1sz.
        allocator
            allocateRegister: MIR::X86_64::RAX forInstruction: instruction operandAt: 0sz;
            allocateRegister: MIR::X86_64::RDX forInstruction: instruction scratchAt: 0sz;
            allocateRegister: MIR::X86_64::RDX forInstructionResult: instruction;
            allocateRegisterForInstruction: instruction operandAt: 1sz
    };
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::xor: X86::EDX with: X86::EDX;
            x86::div: (instruction secondOperandRegister x86::int32For: codegen)
    }.

MIR::Operation::Int32SDiv
    forTarget: #x86 registerConstraintsWith: {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
        instruction scratchRegisterCount: 1sz.
        allocator
            allocateRegister: MIR::X86::EAX forInstruction: instruction operandAt: 0sz;
            allocateRegister: MIR::X86::EDX forInstruction: instruction scratchAt: 0sz;
            allocateRegister: MIR::X86::EAX forInstructionResult: instruction;
            allocateRegisterForInstruction: instruction operandAt: 1sz
    };
    forTarget: #x86_64 registerConstraintsWith: {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
        instruction scratchRegisterCount: 1sz.
        allocator
            allocateRegister: MIR::X86_64::RAX forInstruction: instruction operandAt: 0sz;
            allocateRegister: MIR::X86_64::RDX forInstruction: instruction scratchAt: 0sz;
            allocateRegister: MIR::X86_64::RAX forInstructionResult: instruction;
            allocateRegisterForInstruction: instruction operandAt: 1sz
    };
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::cdq;
            x86::idiv: (instruction secondOperandRegister x86::int32For: codegen)
    }.

MIR::Operation::Int32SRem
    forTarget: #x86 registerConstraintsWith: {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
        instruction scratchRegisterCount: 1sz.
        allocator
            allocateRegister: MIR::X86::EAX forInstruction: instruction operandAt: 0sz;
            allocateRegister: MIR::X86::EDX forInstruction: instruction scratchAt: 0sz;
            allocateRegisterForInstruction: instruction operandAt: 1sz;
            allocateRegister: MIR::X86::EDX forInstructionResult: instruction
    };
    forTarget: #x86_64 registerConstraintsWith: {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
        instruction scratchRegisterCount: 1sz.
        allocator
            allocateRegister: MIR::X86_64::RAX forInstruction: instruction operandAt: 0sz;
            allocateRegister: MIR::X86_64::RDX forInstruction: instruction scratchAt: 0sz;
            allocateRegisterForInstruction: instruction operandAt: 1sz;
            allocateRegister: MIR::X86_64::RDX forInstructionResult: instruction
    };
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::cdq;
            x86::idiv: (instruction secondOperandRegister x86::int32For: codegen)
    }.

MIR::Operation::Int64UDiv
    forTarget: #x86_64 registerConstraintsWith: {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
        instruction scratchRegisterCount: 1sz.
        allocator
            allocateRegister: MIR::X86_64::RAX forInstruction: instruction operandAt: 0sz;
            allocateRegister: MIR::X86_64::RDX forInstruction: instruction scratchAt: 0sz;
            allocateRegister: MIR::X86_64::RAX forInstructionResult: instruction;
            allocateRegisterForInstruction: instruction operandAt: 1sz
    };
    forTarget: #x86_64 generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::xor: X86::RDX with: X86::RDX;
            x86::div: (instruction secondOperandRegister x86::int64For: codegen)
    }.

MIR::Operation::Int64URem
    forTarget: #x86_64 registerConstraintsWith: {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
        instruction scratchRegisterCount: 1sz.
        allocator
            allocateRegister: MIR::X86_64::RAX forInstruction: instruction operandAt: 0sz;
            allocateRegister: MIR::X86_64::RDX forInstruction: instruction scratchAt: 0sz;
            allocateRegister: MIR::X86_64::RDX forInstructionResult: instruction;
            allocateRegisterForInstruction: instruction operandAt: 1sz
    };
    forTarget: #x86_64 generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::xor: X86::RDX with: X86::RDX;
            x86::div: (instruction secondOperandRegister x86::int64For: codegen)
    }.

MIR::Operation::Int64SDiv
    forTarget: #x86_64 registerConstraintsWith: {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
        instruction scratchRegisterCount: 1sz.
        allocator
            allocateRegister: MIR::X86_64::RAX forInstruction: instruction operandAt: 0sz;
            allocateRegister: MIR::X86_64::RDX forInstruction: instruction scratchAt: 0sz;
            allocateRegister: MIR::X86_64::RAX forInstructionResult: instruction;
            allocateRegisterForInstruction: instruction operandAt: 1sz
    };
    forTarget: #x86_64 generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::cqo;
            x86::idiv: (instruction secondOperandRegister x86::int64For: codegen)
    }.

MIR::Operation::Int64SRem
    forTarget: #x86_64 registerConstraintsWith: {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
        instruction scratchRegisterCount: 1sz.
        allocator
            allocateRegister: MIR::X86_64::RAX forInstruction: instruction operandAt: 0sz;
            allocateRegister: MIR::X86_64::RDX forInstruction: instruction scratchAt: 0sz;
            allocateRegister: MIR::X86_64::RDX forInstructionResult: instruction;
            allocateRegisterForInstruction: instruction operandAt: 1sz
    };
    forTarget: #x86_64 generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::cqo;
            x86::idiv: (instruction secondOperandRegister x86::int64For: codegen)
    }.

let x86::integerShift8RegisterConstraints := {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
    allocator
        allocateRegister: MIR::X86::ECX orImmediateU8ForInstruction: instruction operandAt: 1sz;
        allocateRegisterOrImmediate32ForInstruction: instruction operandAt: 0sz;
        allocateRegister8ForInstructionResult: instruction.
}.

let x86::integerShiftRegisterConstraints := {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
    allocator
        allocateRegister: MIR::X86::ECX orImmediateU8ForInstruction: instruction operandAt: 1sz;
        allocateRegisterOrImmediate32ForInstruction: instruction operandAt: 0sz;
        allocateRegisterForInstructionResult: instruction trySharingWithOperandAt: 0sz
}.

let x86_64::integerShiftRegisterConstraints := {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
    allocator
        allocateRegister: MIR::X86_64::RCX orImmediateU8ForInstruction: instruction operandAt: 1sz;
        allocateRegisterOrImmediate64ForInstruction: instruction operandAt: 0sz;
        allocateRegisterForInstructionResult: instruction trySharingWithOperandAt: 0sz
}.

MIR::Operation::Int8ArithmeticShiftRight
    forTarget: #x86 registerConstraintsWith: x86::integerShift8RegisterConstraints;
    forTarget: #x86_64 registerConstraintsWith: x86_64::integerShiftRegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::mov: (instruction resultRegister x86::int32For: codegen) src: (instruction firstOperandRegister x86::int32For: codegen);
            x86::sar: (instruction resultRegister x86::int8For: codegen) with: (instruction secondOperandRegister x86::int8For: codegen)
    }.

MIR::Operation::Int8LogicalShiftLeft
    forTarget: #x86 registerConstraintsWith: x86::integerShift8RegisterConstraints;
    forTarget: #x86_64 registerConstraintsWith: x86_64::integerShiftRegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::mov: (instruction resultRegister x86::int32For: codegen) src: (instruction firstOperandRegister x86::int32For: codegen);
            x86::sal: (instruction resultRegister x86::int8For: codegen) with: (instruction secondOperandRegister x86::int8For: codegen)
    }.

MIR::Operation::Int8LogicalShiftRight
    forTarget: #x86 registerConstraintsWith: x86::integerShift8RegisterConstraints;
    forTarget: #x86_64 registerConstraintsWith: x86_64::integerShiftRegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::mov: (instruction resultRegister x86::int32For: codegen) src: (instruction firstOperandRegister x86::int32For: codegen);
            x86::shr: (instruction resultRegister x86::int16For: codegen) with: (instruction secondOperandRegister x86::int8For: codegen)
    }.

MIR::Operation::Int16ArithmeticShiftRight
    forTarget: #x86 registerConstraintsWith: x86::integerShiftRegisterConstraints;
    forTarget: #x86_64 registerConstraintsWith: x86_64::integerShiftRegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::mov: (instruction resultRegister x86::int32For: codegen) src: (instruction firstOperandRegister x86::int32For: codegen);
            x86::sar: (instruction resultRegister x86::int16For: codegen) with: (instruction secondOperandRegister x86::int8For: codegen)
    }.

MIR::Operation::Int16LogicalShiftLeft
    forTarget: #x86 registerConstraintsWith: x86::integerShiftRegisterConstraints;
    forTarget: #x86_64 registerConstraintsWith: x86_64::integerShiftRegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::mov: (instruction resultRegister x86::int32For: codegen) src: (instruction firstOperandRegister x86::int32For: codegen);
            x86::sal: (instruction resultRegister x86::int16For: codegen) with: (instruction secondOperandRegister x86::int8For: codegen)
    }.

MIR::Operation::Int16LogicalShiftRight
    forTarget: #x86 registerConstraintsWith: x86::integerShiftRegisterConstraints;
    forTarget: #x86_64 registerConstraintsWith: x86_64::integerShiftRegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::mov: (instruction resultRegister x86::int32For: codegen) src: (instruction firstOperandRegister x86::int32For: codegen);
            x86::shr: (instruction resultRegister x86::int16For: codegen) with: (instruction secondOperandRegister x86::int8For: codegen)
    }.

MIR::Operation::Int32ArithmeticShiftRight
    forTarget: #x86 registerConstraintsWith: x86::integerShiftRegisterConstraints;
    forTarget: #x86_64 registerConstraintsWith: x86_64::integerShiftRegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::mov: (instruction resultRegister x86::int32For: codegen) src: (instruction firstOperandRegister x86::int32For: codegen);
            x86::sar: (instruction resultRegister x86::int32For: codegen) with: (instruction secondOperandRegister x86::int8For: codegen)
    }.

MIR::Operation::Int32LogicalShiftLeft
    forTarget: #x86 registerConstraintsWith: x86::integerShiftRegisterConstraints;
    forTarget: #x86_64 registerConstraintsWith: x86_64::integerShiftRegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::mov: (instruction resultRegister x86::int32For: codegen) src: (instruction firstOperandRegister x86::int32For: codegen);
            x86::sal: (instruction resultRegister x86::int32For: codegen) with: (instruction secondOperandRegister x86::int8For: codegen)
    }.

MIR::Operation::Int32LogicalShiftRight
    forTarget: #x86 registerConstraintsWith: x86::integerShiftRegisterConstraints;
    forTarget: #x86_64 registerConstraintsWith: x86_64::integerShiftRegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::mov: (instruction resultRegister x86::int32For: codegen) src: (instruction firstOperandRegister x86::int32For: codegen);
            x86::shr: (instruction resultRegister x86::int32For: codegen) with: (instruction secondOperandRegister x86::int8For: codegen)
    }.

MIR::Operation::Int64ArithmeticShiftRight
    forTarget: #x86_64 registerConstraintsWith: x86_64::integerShiftRegisterConstraints;
    forTarget: #x86_64 generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::mov: (instruction resultRegister x86::int64For: codegen) src: (instruction firstOperandRegister x86::int64For: codegen);
            x86::sar: (instruction resultRegister x86::int64For: codegen) with: (instruction secondOperandRegister x86::int8For: codegen)
    }.

MIR::Operation::Int64LogicalShiftLeft
    forTarget: #x86_64 registerConstraintsWith: x86_64::integerShiftRegisterConstraints;
    forTarget: #x86_64 generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::mov: (instruction resultRegister x86::int64For: codegen) src: (instruction firstOperandRegister x86::int64For: codegen);
            x86::sal: (instruction resultRegister x86::int64For: codegen) with: (instruction secondOperandRegister x86::int8For: codegen)
    }.

MIR::Operation::Int64LogicalShiftRight
    forTarget: #x86_64 registerConstraintsWith: x86_64::integerShiftRegisterConstraints;
    forTarget: #x86_64 generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::mov: (instruction resultRegister x86::int64For: codegen) src: (instruction firstOperandRegister x86::int64For: codegen);
            x86::shr: (instruction resultRegister x86::int64For: codegen) with: (instruction secondOperandRegister x86::int8For: codegen)
    }.


let x86::integerComparisonInt8RegisterConstraints := {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
    allocator
        allocateRegisterForInstruction: instruction operandAt: 0sz;
        allocateRegisterImmediate8OrDirectPointerForInstruction: instruction operandAt: 1sz;
        allocateRegisterForInstructionResult: instruction
}.

MIR::Operation::Int8Equals
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerComparisonInt8RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::xor: (instruction resultRegister x86::int32For: codegen) with: (instruction resultRegister x86::int32For: codegen);
            x86::cmp: (instruction firstOperandRegister x86::int8For: codegen) with: (instruction secondOperandRegister x86::int8For: codegen);
            x86::sete: (instruction resultRegister x86::int8For: codegen)
    }.

MIR::Operation::Int8NotEquals
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerComparisonInt8RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::xor: (instruction resultRegister x86::int32For: codegen) with: (instruction resultRegister x86::int32For: codegen);
            x86::cmp: (instruction firstOperandRegister x86::int8For: codegen) with: (instruction secondOperandRegister x86::int8For: codegen);
            x86::setne: (instruction resultRegister x86::int8For: codegen)
    }.

MIR::Operation::Int8LessThan
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerComparisonInt8RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::xor: (instruction resultRegister x86::int32For: codegen) with: (instruction resultRegister x86::int32For: codegen);
            x86::cmp: (instruction firstOperandRegister x86::int8For: codegen) with: (instruction secondOperandRegister x86::int8For: codegen);
            x86::setl: (instruction resultRegister x86::int8For: codegen)
    }.

MIR::Operation::Int8LessOrEquals
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerComparisonInt8RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::xor: (instruction resultRegister x86::int32For: codegen) with: (instruction resultRegister x86::int32For: codegen);
            x86::cmp: (instruction firstOperandRegister x86::int8For: codegen) with: (instruction secondOperandRegister x86::int8For: codegen);
            x86::setle: (instruction resultRegister x86::int8For: codegen)
    }.

MIR::Operation::Int8GreaterThan
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerComparisonInt8RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::xor: (instruction resultRegister x86::int32For: codegen) with: (instruction resultRegister x86::int32For: codegen);
            x86::cmp: (instruction firstOperandRegister x86::int8For: codegen) with: (instruction secondOperandRegister x86::int8For: codegen);
            x86::setg: (instruction resultRegister x86::int8For: codegen)
    }.

MIR::Operation::Int8GreaterOrEquals
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerComparisonInt8RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::xor: (instruction resultRegister x86::int32For: codegen) with: (instruction resultRegister x86::int32For: codegen);
            x86::cmp: (instruction firstOperandRegister x86::int8For: codegen) with: (instruction secondOperandRegister x86::int8For: codegen);
            x86::setge: (instruction resultRegister x86::int8For: codegen)
    }.

MIR::Operation::UInt8LessThan
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerComparisonInt8RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::xor: (instruction resultRegister x86::int32For: codegen) with: (instruction resultRegister x86::int32For: codegen);
            x86::cmp: (instruction firstOperandRegister x86::int8For: codegen) with: (instruction secondOperandRegister x86::int8For: codegen);
            x86::setb: (instruction resultRegister x86::int8For: codegen)
    }.

MIR::Operation::UInt8LessOrEquals
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerComparisonInt8RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::xor: (instruction resultRegister x86::int32For: codegen) with: (instruction resultRegister x86::int32For: codegen);
            x86::cmp: (instruction firstOperandRegister x86::int8For: codegen) with: (instruction secondOperandRegister x86::int8For: codegen);
            x86::setbe: (instruction resultRegister x86::int8For: codegen)
    }.

MIR::Operation::UInt8GreaterThan
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerComparisonInt8RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::xor: (instruction resultRegister x86::int32For: codegen) with: (instruction resultRegister x86::int32For: codegen);
            x86::cmp: (instruction firstOperandRegister x86::int8For: codegen) with: (instruction secondOperandRegister x86::int8For: codegen);
            x86::seta: (instruction resultRegister x86::int8For: codegen)
    }.

MIR::Operation::UInt8GreaterOrEquals
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerComparisonInt8RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::xor: (instruction resultRegister x86::int32For: codegen) with: (instruction resultRegister x86::int32For: codegen);
            x86::cmp: (instruction firstOperandRegister x86::int8For: codegen) with: (instruction secondOperandRegister x86::int8For: codegen);
            x86::setae: (instruction resultRegister x86::int8For: codegen)
    }.

let x86::integerComparisonBranchInt8RegisterConstraints := {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
    allocator
        allocateRegisterForInstruction: instruction operandAt: 0sz;
        allocateRegisterImmediate8OrDirectPointerForInstruction: instruction operandAt: 1sz;
        allocateRegisterOrRelativeImmediate32ForInstruction: instruction operandAt: 2sz;
        allocateRegisterOrRelativeImmediate32ForInstruction: instruction operandAt: 3sz
}.

MIR::Operation::Int8EqualsBranch
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerComparisonBranchInt8RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::cmp: (instruction firstOperandRegister x86::int8For: codegen) with: (instruction secondOperandRegister x86::int8For: codegen);
            x86::jnz: (instruction fourthOperandRegister x86::relCall32OrInt32For: codegen);
            x86::jmp: (instruction thirdOperandRegister x86::relCall32OrInt32For: codegen)
    }.

MIR::Operation::Int8NotEqualsBranch
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerComparisonBranchInt8RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::cmp: (instruction firstOperandRegister x86::int8For: codegen) with: (instruction secondOperandRegister x86::int8For: codegen);
            x86::jz: (instruction fourthOperandRegister x86::relCall32OrInt32For: codegen);
            x86::jmp: (instruction thirdOperandRegister x86::relCall32OrInt32For: codegen)
    }.

MIR::Operation::Int8LessThanBranch
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerComparisonBranchInt8RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::cmp: (instruction firstOperandRegister x86::int8For: codegen) with: (instruction secondOperandRegister x86::int8For: codegen);
            x86::jge: (instruction fourthOperandRegister x86::relCall32OrInt32For: codegen);
            x86::jmp: (instruction thirdOperandRegister x86::relCall32OrInt32For: codegen)
    }.

MIR::Operation::Int8LessOrEqualsBranch
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerComparisonBranchInt8RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::cmp: (instruction firstOperandRegister x86::int8For: codegen) with: (instruction secondOperandRegister x86::int8For: codegen);
            x86::jg: (instruction fourthOperandRegister x86::relCall32OrInt32For: codegen);
            x86::jmp: (instruction thirdOperandRegister x86::relCall32OrInt32For: codegen)
    }.

MIR::Operation::Int8GreaterThanBranch
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerComparisonBranchInt8RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::cmp: (instruction firstOperandRegister x86::int8For: codegen) with: (instruction secondOperandRegister x86::int8For: codegen);
            x86::jle: (instruction fourthOperandRegister x86::relCall32OrInt32For: codegen);
            x86::jmp: (instruction thirdOperandRegister x86::relCall32OrInt32For: codegen)
    }.

MIR::Operation::Int8GreaterOrEqualsBranch
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerComparisonBranchInt8RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::cmp: (instruction firstOperandRegister x86::int8For: codegen) with: (instruction secondOperandRegister x86::int8For: codegen);
            x86::jl: (instruction fourthOperandRegister x86::relCall32OrInt32For: codegen);
            x86::jmp: (instruction thirdOperandRegister x86::relCall32OrInt32For: codegen)
    }.

MIR::Operation::Int8LessThanBranch
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerComparisonBranchInt8RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::cmp: (instruction firstOperandRegister x86::int8For: codegen) with: (instruction secondOperandRegister x86::int8For: codegen);
            x86::jge: (instruction fourthOperandRegister x86::relCall32OrInt32For: codegen);
            x86::jmp: (instruction thirdOperandRegister x86::relCall32OrInt32For: codegen)
    }.

MIR::Operation::Int8LessOrEqualsBranch
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerComparisonBranchInt8RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::cmp: (instruction firstOperandRegister x86::int8For: codegen) with: (instruction secondOperandRegister x86::int8For: codegen);
            x86::jg: (instruction fourthOperandRegister x86::relCall32OrInt32For: codegen);
            x86::jmp: (instruction thirdOperandRegister x86::relCall32OrInt32For: codegen)
    }.

MIR::Operation::Int8GreaterThanBranch
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerComparisonBranchInt8RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::cmp: (instruction firstOperandRegister x86::int8For: codegen) with: (instruction secondOperandRegister x86::int8For: codegen);
            x86::jle: (instruction fourthOperandRegister x86::relCall32OrInt32For: codegen);
            x86::jmp: (instruction thirdOperandRegister x86::relCall32OrInt32For: codegen)
    }.

MIR::Operation::Int8GreaterOrEqualsBranch
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerComparisonBranchInt8RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::cmp: (instruction firstOperandRegister x86::int8For: codegen) with: (instruction secondOperandRegister x86::int8For: codegen);
            x86::jl: (instruction fourthOperandRegister x86::relCall32OrInt32For: codegen);
            x86::jmp: (instruction thirdOperandRegister x86::relCall32OrInt32For: codegen)
    }.

MIR::Operation::UInt8LessThanBranch
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerComparisonBranchInt8RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::cmp: (instruction firstOperandRegister x86::int8For: codegen) with: (instruction secondOperandRegister x86::int8For: codegen);
            x86::jae: (instruction fourthOperandRegister x86::relCall32OrInt32For: codegen);
            x86::jmp: (instruction thirdOperandRegister x86::relCall32OrInt32For: codegen)
    }.

MIR::Operation::UInt8LessOrEqualsBranch
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerComparisonBranchInt8RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::cmp: (instruction firstOperandRegister x86::int8For: codegen) with: (instruction secondOperandRegister x86::int8For: codegen);
            x86::ja: (instruction fourthOperandRegister x86::relCall32OrInt32For: codegen);
            x86::jmp: (instruction thirdOperandRegister x86::relCall32OrInt32For: codegen)
    }.

MIR::Operation::UInt8GreaterThanBranch
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerComparisonBranchInt8RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::cmp: (instruction firstOperandRegister x86::int8For: codegen) with: (instruction secondOperandRegister x86::int8For: codegen);
            x86::jbe: (instruction fourthOperandRegister x86::relCall32OrInt32For: codegen);
            x86::jmp: (instruction thirdOperandRegister x86::relCall32OrInt32For: codegen)
    }.

MIR::Operation::UInt8GreaterOrEqualsBranch
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerComparisonBranchInt8RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::cmp: (instruction firstOperandRegister x86::int8For: codegen) with: (instruction secondOperandRegister x86::int8For: codegen);
            x86::jb: (instruction fourthOperandRegister x86::relCall32OrInt32For: codegen);
            x86::jmp: (instruction thirdOperandRegister x86::relCall32OrInt32For: codegen)
    }.

let x86::integerComparisonInt16RegisterConstraints := {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
    allocator
        allocateRegisterForInstruction: instruction operandAt: 0sz;
        allocateRegisterImmediate16OrDirectPointerForInstruction: instruction operandAt: 1sz;
        allocateRegisterForInstructionResult: instruction
}.

MIR::Operation::Int16Equals
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerComparisonInt16RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::xor: (instruction resultRegister x86::int32For: codegen) with: (instruction resultRegister x86::int32For: codegen);
            x86::cmp: (instruction firstOperandRegister x86::int16For: codegen) with: (instruction secondOperandRegister x86::int16For: codegen);
            x86::sete: (instruction resultRegister x86::int8For: codegen)
    }.

MIR::Operation::Int16NotEquals
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerComparisonInt16RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::xor: (instruction resultRegister x86::int32For: codegen) with: (instruction resultRegister x86::int32For: codegen);
            x86::cmp: (instruction firstOperandRegister x86::int16For: codegen) with: (instruction secondOperandRegister x86::int16For: codegen);
            x86::setne: (instruction resultRegister x86::int8For: codegen)
    }.

MIR::Operation::Int16LessThan
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerComparisonInt16RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::xor: (instruction resultRegister x86::int32For: codegen) with: (instruction resultRegister x86::int32For: codegen);
            x86::cmp: (instruction firstOperandRegister x86::int16For: codegen) with: (instruction secondOperandRegister x86::int16For: codegen);
            x86::setl: (instruction resultRegister x86::int8For: codegen)
    }.

MIR::Operation::Int16LessOrEquals
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerComparisonInt16RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::xor: (instruction resultRegister x86::int32For: codegen) with: (instruction resultRegister x86::int32For: codegen);
            x86::cmp: (instruction firstOperandRegister x86::int16For: codegen) with: (instruction secondOperandRegister x86::int16For: codegen);
            x86::setle: (instruction resultRegister x86::int8For: codegen)
    }.

MIR::Operation::Int16GreaterThan
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerComparisonInt16RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::xor: (instruction resultRegister x86::int32For: codegen) with: (instruction resultRegister x86::int32For: codegen);
            x86::cmp: (instruction firstOperandRegister x86::int16For: codegen) with: (instruction secondOperandRegister x86::int16For: codegen);
            x86::setg: (instruction resultRegister x86::int8For: codegen)
    }.

MIR::Operation::Int16GreaterOrEquals
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerComparisonInt16RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::xor: (instruction resultRegister x86::int32For: codegen) with: (instruction resultRegister x86::int32For: codegen);
            x86::cmp: (instruction firstOperandRegister x86::int16For: codegen) with: (instruction secondOperandRegister x86::int16For: codegen);
            x86::setge: (instruction resultRegister x86::int8For: codegen)
    }.

MIR::Operation::UInt16LessThan
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerComparisonInt16RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::xor: (instruction resultRegister x86::int32For: codegen) with: (instruction resultRegister x86::int32For: codegen);
            x86::cmp: (instruction firstOperandRegister x86::int16For: codegen) with: (instruction secondOperandRegister x86::int16For: codegen);
            x86::setb: (instruction resultRegister x86::int8For: codegen)
    }.

MIR::Operation::UInt16LessOrEquals
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerComparisonInt16RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::xor: (instruction resultRegister x86::int32For: codegen) with: (instruction resultRegister x86::int32For: codegen);
            x86::cmp: (instruction firstOperandRegister x86::int16For: codegen) with: (instruction secondOperandRegister x86::int16For: codegen);
            x86::setbe: (instruction resultRegister x86::int8For: codegen)
    }.

MIR::Operation::UInt16GreaterThan
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerComparisonInt16RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::xor: (instruction resultRegister x86::int32For: codegen) with: (instruction resultRegister x86::int32For: codegen);
            x86::cmp: (instruction firstOperandRegister x86::int16For: codegen) with: (instruction secondOperandRegister x86::int16For: codegen);
            x86::seta: (instruction resultRegister x86::int8For: codegen)
    }.

MIR::Operation::UInt16GreaterOrEquals
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerComparisonInt16RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::xor: (instruction resultRegister x86::int32For: codegen) with: (instruction resultRegister x86::int32For: codegen);
            x86::cmp: (instruction firstOperandRegister x86::int16For: codegen) with: (instruction secondOperandRegister x86::int16For: codegen);
            x86::setae: (instruction resultRegister x86::int8For: codegen)
    }.

let x86::integerComparisonBranchInt16RegisterConstraints := {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
    allocator
        allocateRegisterForInstruction: instruction operandAt: 0sz;
        allocateRegisterImmediate16OrDirectPointerForInstruction: instruction operandAt: 1sz;
        allocateRegisterOrRelativeImmediate32ForInstruction: instruction operandAt: 2sz;
        allocateRegisterOrRelativeImmediate32ForInstruction: instruction operandAt: 3sz
}.

MIR::Operation::Int16EqualsBranch
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerComparisonBranchInt16RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::cmp: (instruction firstOperandRegister x86::int16For: codegen) with: (instruction secondOperandRegister x86::int16For: codegen);
            x86::jnz: (instruction fourthOperandRegister x86::relCall32OrInt32For: codegen);
            x86::jmp: (instruction thirdOperandRegister x86::relCall32OrInt32For: codegen)
    }.

MIR::Operation::Int16NotEqualsBranch
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerComparisonBranchInt16RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::cmp: (instruction firstOperandRegister x86::int16For: codegen) with: (instruction secondOperandRegister x86::int16For: codegen);
            x86::jz: (instruction fourthOperandRegister x86::relCall32OrInt32For: codegen);
            x86::jmp: (instruction thirdOperandRegister x86::relCall32OrInt32For: codegen)
    }.

MIR::Operation::Int16LessThanBranch
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerComparisonBranchInt16RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::cmp: (instruction firstOperandRegister x86::int16For: codegen) with: (instruction secondOperandRegister x86::int16For: codegen);
            x86::jge: (instruction fourthOperandRegister x86::relCall32OrInt32For: codegen);
            x86::jmp: (instruction thirdOperandRegister x86::relCall32OrInt32For: codegen)
    }.

MIR::Operation::Int16LessOrEqualsBranch
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerComparisonBranchInt16RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::cmp: (instruction firstOperandRegister x86::int16For: codegen) with: (instruction secondOperandRegister x86::int16For: codegen);
            x86::jg: (instruction fourthOperandRegister x86::relCall32OrInt32For: codegen);
            x86::jmp: (instruction thirdOperandRegister x86::relCall32OrInt32For: codegen)
    }.

MIR::Operation::Int16GreaterThanBranch
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerComparisonBranchInt16RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::cmp: (instruction firstOperandRegister x86::int16For: codegen) with: (instruction secondOperandRegister x86::int16For: codegen);
            x86::jle: (instruction fourthOperandRegister x86::relCall32OrInt32For: codegen);
            x86::jmp: (instruction thirdOperandRegister x86::relCall32OrInt32For: codegen)
    }.

MIR::Operation::Int16GreaterOrEqualsBranch
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerComparisonBranchInt16RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::cmp: (instruction firstOperandRegister x86::int16For: codegen) with: (instruction secondOperandRegister x86::int16For: codegen);
            x86::jl: (instruction fourthOperandRegister x86::relCall32OrInt32For: codegen);
            x86::jmp: (instruction thirdOperandRegister x86::relCall32OrInt32For: codegen)
    }.

MIR::Operation::Int16LessThanBranch
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerComparisonBranchInt16RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::cmp: (instruction firstOperandRegister x86::int16For: codegen) with: (instruction secondOperandRegister x86::int16For: codegen);
            x86::jge: (instruction fourthOperandRegister x86::relCall32OrInt32For: codegen);
            x86::jmp: (instruction thirdOperandRegister x86::relCall32OrInt32For: codegen)
    }.

MIR::Operation::Int16LessOrEqualsBranch
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerComparisonBranchInt16RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::cmp: (instruction firstOperandRegister x86::int16For: codegen) with: (instruction secondOperandRegister x86::int16For: codegen);
            x86::jg: (instruction fourthOperandRegister x86::relCall32OrInt32For: codegen);
            x86::jmp: (instruction thirdOperandRegister x86::relCall32OrInt32For: codegen)
    }.

MIR::Operation::Int16GreaterThanBranch
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerComparisonBranchInt16RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::cmp: (instruction firstOperandRegister x86::int16For: codegen) with: (instruction secondOperandRegister x86::int16For: codegen);
            x86::jle: (instruction fourthOperandRegister x86::relCall32OrInt32For: codegen);
            x86::jmp: (instruction thirdOperandRegister x86::relCall32OrInt32For: codegen)
    }.

MIR::Operation::Int16GreaterOrEqualsBranch
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerComparisonBranchInt16RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::cmp: (instruction firstOperandRegister x86::int16For: codegen) with: (instruction secondOperandRegister x86::int16For: codegen);
            x86::jl: (instruction fourthOperandRegister x86::relCall32OrInt32For: codegen);
            x86::jmp: (instruction thirdOperandRegister x86::relCall32OrInt32For: codegen)
    }.

MIR::Operation::UInt16LessThanBranch
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerComparisonBranchInt16RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::cmp: (instruction firstOperandRegister x86::int16For: codegen) with: (instruction secondOperandRegister x86::int16For: codegen);
            x86::jae: (instruction fourthOperandRegister x86::relCall32OrInt32For: codegen);
            x86::jmp: (instruction thirdOperandRegister x86::relCall32OrInt32For: codegen)
    }.

MIR::Operation::UInt16LessOrEqualsBranch
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerComparisonBranchInt16RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::cmp: (instruction firstOperandRegister x86::int16For: codegen) with: (instruction secondOperandRegister x86::int16For: codegen);
            x86::ja: (instruction fourthOperandRegister x86::relCall32OrInt32For: codegen);
            x86::jmp: (instruction thirdOperandRegister x86::relCall32OrInt32For: codegen)
    }.

MIR::Operation::UInt16GreaterThanBranch
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerComparisonBranchInt16RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::cmp: (instruction firstOperandRegister x86::int16For: codegen) with: (instruction secondOperandRegister x86::int16For: codegen);
            x86::jbe: (instruction fourthOperandRegister x86::relCall32OrInt32For: codegen);
            x86::jmp: (instruction thirdOperandRegister x86::relCall32OrInt32For: codegen)
    }.

MIR::Operation::UInt16GreaterOrEqualsBranch
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerComparisonBranchInt16RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::cmp: (instruction firstOperandRegister x86::int16For: codegen) with: (instruction secondOperandRegister x86::int16For: codegen);
            x86::jb: (instruction fourthOperandRegister x86::relCall32OrInt32For: codegen);
            x86::jmp: (instruction thirdOperandRegister x86::relCall32OrInt32For: codegen)
    }.

let x86::integerComparisonInt32RegisterConstraints := {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
    allocator
        allocateRegisterForInstruction: instruction operandAt: 0sz;
        allocateRegisterImmediate32OrDirectPointerForInstruction: instruction operandAt: 1sz;
        allocateRegisterForInstructionResult: instruction
}.

MIR::Operation::Int32Equals
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerComparisonInt32RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::xor: (instruction resultRegister x86::int32For: codegen) with: (instruction resultRegister x86::int32For: codegen);
            x86::cmp: (instruction firstOperandRegister x86::int32For: codegen) with: (instruction secondOperandRegister x86::int32For: codegen);
            x86::sete: (instruction resultRegister x86::int8For: codegen)
    }.

MIR::Operation::Int32NotEquals
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerComparisonInt32RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::xor: (instruction resultRegister x86::int32For: codegen) with: (instruction resultRegister x86::int32For: codegen);
            x86::cmp: (instruction firstOperandRegister x86::int32For: codegen) with: (instruction secondOperandRegister x86::int32For: codegen);
            x86::setne: (instruction resultRegister x86::int8For: codegen)
    }.

MIR::Operation::Int32LessThan
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerComparisonInt32RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::xor: (instruction resultRegister x86::int32For: codegen) with: (instruction resultRegister x86::int32For: codegen);
            x86::cmp: (instruction firstOperandRegister x86::int32For: codegen) with: (instruction secondOperandRegister x86::int32For: codegen);
            x86::setl: (instruction resultRegister x86::int8For: codegen)
    }.

MIR::Operation::Int32LessOrEquals
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerComparisonInt32RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::xor: (instruction resultRegister x86::int32For: codegen) with: (instruction resultRegister x86::int32For: codegen);
            x86::cmp: (instruction firstOperandRegister x86::int32For: codegen) with: (instruction secondOperandRegister x86::int32For: codegen);
            x86::setle: (instruction resultRegister x86::int8For: codegen)
    }.

MIR::Operation::Int32GreaterThan
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerComparisonInt32RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::xor: (instruction resultRegister x86::int32For: codegen) with: (instruction resultRegister x86::int32For: codegen);
            x86::cmp: (instruction firstOperandRegister x86::int32For: codegen) with: (instruction secondOperandRegister x86::int32For: codegen);
            x86::setg: (instruction resultRegister x86::int8For: codegen)
    }.

MIR::Operation::Int32GreaterOrEquals
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerComparisonInt32RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::xor: (instruction resultRegister x86::int32For: codegen) with: (instruction resultRegister x86::int32For: codegen);
            x86::cmp: (instruction firstOperandRegister x86::int32For: codegen) with: (instruction secondOperandRegister x86::int32For: codegen);
            x86::setge: (instruction resultRegister x86::int8For: codegen)
    }.

MIR::Operation::UInt32LessThan
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerComparisonInt32RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::xor: (instruction resultRegister x86::int32For: codegen) with: (instruction resultRegister x86::int32For: codegen);
            x86::cmp: (instruction firstOperandRegister x86::int32For: codegen) with: (instruction secondOperandRegister x86::int32For: codegen);
            x86::setb: (instruction resultRegister x86::int8For: codegen)
    }.

MIR::Operation::UInt32LessOrEquals
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerComparisonInt32RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::xor: (instruction resultRegister x86::int32For: codegen) with: (instruction resultRegister x86::int32For: codegen);
            x86::cmp: (instruction firstOperandRegister x86::int32For: codegen) with: (instruction secondOperandRegister x86::int32For: codegen);
            x86::setbe: (instruction resultRegister x86::int8For: codegen)
    }.

MIR::Operation::UInt32GreaterThan
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerComparisonInt32RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::xor: (instruction resultRegister x86::int32For: codegen) with: (instruction resultRegister x86::int32For: codegen);
            x86::cmp: (instruction firstOperandRegister x86::int32For: codegen) with: (instruction secondOperandRegister x86::int32For: codegen);
            x86::seta: (instruction resultRegister x86::int8For: codegen)
    }.

MIR::Operation::UInt32GreaterOrEquals
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerComparisonInt32RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::xor: (instruction resultRegister x86::int32For: codegen) with: (instruction resultRegister x86::int32For: codegen);
            x86::cmp: (instruction firstOperandRegister x86::int32For: codegen) with: (instruction secondOperandRegister x86::int32For: codegen);
            x86::setae: (instruction resultRegister x86::int8For: codegen)
    }.

let x86::integerComparisonBranchInt32RegisterConstraints := {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
    allocator
        allocateRegisterForInstruction: instruction operandAt: 0sz;
        allocateRegisterImmediate32OrDirectPointerForInstruction: instruction operandAt: 1sz;
        allocateRegisterOrRelativeImmediate32ForInstruction: instruction operandAt: 2sz;
        allocateRegisterOrRelativeImmediate32ForInstruction: instruction operandAt: 3sz
}.

MIR::Operation::Int32EqualsBranch
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerComparisonBranchInt32RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::cmp: (instruction firstOperandRegister x86::int32For: codegen) with: (instruction secondOperandRegister x86::int32For: codegen);
            x86::jnz: (instruction fourthOperandRegister x86::relCall32OrInt32For: codegen);
            x86::jmp: (instruction thirdOperandRegister x86::relCall32OrInt32For: codegen)
    }.

MIR::Operation::Int32NotEqualsBranch
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerComparisonBranchInt32RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::cmp: (instruction firstOperandRegister x86::int32For: codegen) with: (instruction secondOperandRegister x86::int32For: codegen);
            x86::jz: (instruction fourthOperandRegister x86::relCall32OrInt32For: codegen);
            x86::jmp: (instruction thirdOperandRegister x86::relCall32OrInt32For: codegen)
    }.

MIR::Operation::Int32LessThanBranch
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerComparisonBranchInt32RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::cmp: (instruction firstOperandRegister x86::int32For: codegen) with: (instruction secondOperandRegister x86::int32For: codegen);
            x86::jge: (instruction fourthOperandRegister x86::relCall32OrInt32For: codegen);
            x86::jmp: (instruction thirdOperandRegister x86::relCall32OrInt32For: codegen)
    }.

MIR::Operation::Int32LessOrEqualsBranch
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerComparisonBranchInt32RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::cmp: (instruction firstOperandRegister x86::int32For: codegen) with: (instruction secondOperandRegister x86::int32For: codegen);
            x86::jg: (instruction fourthOperandRegister x86::relCall32OrInt32For: codegen);
            x86::jmp: (instruction thirdOperandRegister x86::relCall32OrInt32For: codegen)
    }.

MIR::Operation::Int32GreaterThanBranch
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerComparisonBranchInt32RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::cmp: (instruction firstOperandRegister x86::int32For: codegen) with: (instruction secondOperandRegister x86::int32For: codegen);
            x86::jle: (instruction fourthOperandRegister x86::relCall32OrInt32For: codegen);
            x86::jmp: (instruction thirdOperandRegister x86::relCall32OrInt32For: codegen)
    }.

MIR::Operation::Int32GreaterOrEqualsBranch
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerComparisonBranchInt32RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::cmp: (instruction firstOperandRegister x86::int32For: codegen) with: (instruction secondOperandRegister x86::int32For: codegen);
            x86::jl: (instruction fourthOperandRegister x86::relCall32OrInt32For: codegen);
            x86::jmp: (instruction thirdOperandRegister x86::relCall32OrInt32For: codegen)
    }.

MIR::Operation::Int32LessThanBranch
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerComparisonBranchInt32RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::cmp: (instruction firstOperandRegister x86::int32For: codegen) with: (instruction secondOperandRegister x86::int32For: codegen);
            x86::jge: (instruction fourthOperandRegister x86::relCall32OrInt32For: codegen);
            x86::jmp: (instruction thirdOperandRegister x86::relCall32OrInt32For: codegen)
    }.

MIR::Operation::Int32LessOrEqualsBranch
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerComparisonBranchInt32RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::cmp: (instruction firstOperandRegister x86::int32For: codegen) with: (instruction secondOperandRegister x86::int32For: codegen);
            x86::jg: (instruction fourthOperandRegister x86::relCall32OrInt32For: codegen);
            x86::jmp: (instruction thirdOperandRegister x86::relCall32OrInt32For: codegen)
    }.

MIR::Operation::Int32GreaterThanBranch
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerComparisonBranchInt32RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::cmp: (instruction firstOperandRegister x86::int32For: codegen) with: (instruction secondOperandRegister x86::int32For: codegen);
            x86::jle: (instruction fourthOperandRegister x86::relCall32OrInt32For: codegen);
            x86::jmp: (instruction thirdOperandRegister x86::relCall32OrInt32For: codegen)
    }.

MIR::Operation::Int32GreaterOrEqualsBranch
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerComparisonBranchInt32RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::cmp: (instruction firstOperandRegister x86::int32For: codegen) with: (instruction secondOperandRegister x86::int32For: codegen);
            x86::jl: (instruction fourthOperandRegister x86::relCall32OrInt32For: codegen);
            x86::jmp: (instruction thirdOperandRegister x86::relCall32OrInt32For: codegen)
    }.

MIR::Operation::UInt32LessThanBranch
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerComparisonBranchInt32RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::cmp: (instruction firstOperandRegister x86::int32For: codegen) with: (instruction secondOperandRegister x86::int32For: codegen);
            x86::jae: (instruction fourthOperandRegister x86::relCall32OrInt32For: codegen);
            x86::jmp: (instruction thirdOperandRegister x86::relCall32OrInt32For: codegen)
    }.

MIR::Operation::UInt32LessOrEqualsBranch
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerComparisonBranchInt32RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::cmp: (instruction firstOperandRegister x86::int32For: codegen) with: (instruction secondOperandRegister x86::int32For: codegen);
            x86::ja: (instruction fourthOperandRegister x86::relCall32OrInt32For: codegen);
            x86::jmp: (instruction thirdOperandRegister x86::relCall32OrInt32For: codegen)
    }.

MIR::Operation::UInt32GreaterThanBranch
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerComparisonBranchInt32RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::cmp: (instruction firstOperandRegister x86::int32For: codegen) with: (instruction secondOperandRegister x86::int32For: codegen);
            x86::jbe: (instruction fourthOperandRegister x86::relCall32OrInt32For: codegen);
            x86::jmp: (instruction thirdOperandRegister x86::relCall32OrInt32For: codegen)
    }.

MIR::Operation::UInt32GreaterOrEqualsBranch
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::integerComparisonBranchInt32RegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::cmp: (instruction firstOperandRegister x86::int32For: codegen) with: (instruction secondOperandRegister x86::int32For: codegen);
            x86::jb: (instruction fourthOperandRegister x86::relCall32OrInt32For: codegen);
            x86::jmp: (instruction thirdOperandRegister x86::relCall32OrInt32For: codegen)
    }.

## Int64 comparisons
let x86::integerComparisonInt64RegisterConstraints := {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
    allocator
        allocateRegisterForInstruction: instruction operandAt: 0sz;
        allocateRegisterImmediateS32OrDirectPointerForInstruction: instruction operandAt: 1sz;
        allocateRegisterForInstructionResult: instruction
}.

MIR::Operation::Int64Equals
    forTarget: #x86_64 registerConstraintsWith: x86::integerComparisonInt64RegisterConstraints;
    forTarget: #x86_64 generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::xor: (instruction resultRegister x86::int32For: codegen) with: (instruction resultRegister x86::int32For: codegen);
            x86::cmp: (instruction firstOperandRegister x86::int64For: codegen) with: (instruction secondOperandRegister x86::int64For: codegen);
            x86::sete: (instruction resultRegister x86::int8For: codegen)
    }.

MIR::Operation::Int64NotEquals
    forTarget: #x86_64 registerConstraintsWith: x86::integerComparisonInt64RegisterConstraints;
    forTarget: #x86_64 generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::xor: (instruction resultRegister x86::int32For: codegen) with: (instruction resultRegister x86::int32For: codegen);
            x86::cmp: (instruction firstOperandRegister x86::int64For: codegen) with: (instruction secondOperandRegister x86::int64For: codegen);
            x86::setne: (instruction resultRegister x86::int8For: codegen)
    }.

MIR::Operation::Int64LessThan
    forTarget: #x86_64 registerConstraintsWith: x86::integerComparisonInt64RegisterConstraints;
    forTarget: #x86_64 generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::xor: (instruction resultRegister x86::int32For: codegen) with: (instruction resultRegister x86::int32For: codegen);
            x86::cmp: (instruction firstOperandRegister x86::int64For: codegen) with: (instruction secondOperandRegister x86::int64For: codegen);
            x86::setl: (instruction resultRegister x86::int8For: codegen)
    }.

MIR::Operation::Int64LessOrEquals
    forTarget: #x86_64 registerConstraintsWith: x86::integerComparisonInt64RegisterConstraints;
    forTarget: #x86_64 generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::xor: (instruction resultRegister x86::int32For: codegen) with: (instruction resultRegister x86::int32For: codegen);
            x86::cmp: (instruction firstOperandRegister x86::int64For: codegen) with: (instruction secondOperandRegister x86::int64For: codegen);
            x86::setle: (instruction resultRegister x86::int8For: codegen)
    }.

MIR::Operation::Int64GreaterThan
    forTarget: #x86_64 registerConstraintsWith: x86::integerComparisonInt64RegisterConstraints;
    forTarget: #x86_64 generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::xor: (instruction resultRegister x86::int32For: codegen) with: (instruction resultRegister x86::int32For: codegen);
            x86::cmp: (instruction firstOperandRegister x86::int64For: codegen) with: (instruction secondOperandRegister x86::int64For: codegen);
            x86::setg: (instruction resultRegister x86::int8For: codegen)
    }.

MIR::Operation::Int64GreaterOrEquals
    forTarget: #x86_64 registerConstraintsWith: x86::integerComparisonInt64RegisterConstraints;
    forTarget: #x86_64 generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::xor: (instruction resultRegister x86::int32For: codegen) with: (instruction resultRegister x86::int32For: codegen);
            x86::cmp: (instruction firstOperandRegister x86::int64For: codegen) with: (instruction secondOperandRegister x86::int64For: codegen);
            x86::setge: (instruction resultRegister x86::int8For: codegen)
    }.

MIR::Operation::UInt64LessThan
    forTarget: #x86_64 registerConstraintsWith: x86::integerComparisonInt64RegisterConstraints;
    forTarget: #x86_64 generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::xor: (instruction resultRegister x86::int32For: codegen) with: (instruction resultRegister x86::int32For: codegen);
            x86::cmp: (instruction firstOperandRegister x86::int64For: codegen) with: (instruction secondOperandRegister x86::int64For: codegen);
            x86::setb: (instruction resultRegister x86::int8For: codegen)
    }.

MIR::Operation::UInt64LessOrEquals
    forTarget: #x86_64 registerConstraintsWith: x86::integerComparisonInt64RegisterConstraints;
    forTarget: #x86_64 generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::xor: (instruction resultRegister x86::int32For: codegen) with: (instruction resultRegister x86::int32For: codegen);
            x86::cmp: (instruction firstOperandRegister x86::int64For: codegen) with: (instruction secondOperandRegister x86::int64For: codegen);
            x86::setbe: (instruction resultRegister x86::int8For: codegen)
    }.

MIR::Operation::UInt64GreaterThan
    forTarget: #x86_64 registerConstraintsWith: x86::integerComparisonInt64RegisterConstraints;
    forTarget: #x86_64 generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::xor: (instruction resultRegister x86::int32For: codegen) with: (instruction resultRegister x86::int32For: codegen);
            x86::cmp: (instruction firstOperandRegister x86::int64For: codegen) with: (instruction secondOperandRegister x86::int64For: codegen);
            x86::seta: (instruction resultRegister x86::int8For: codegen)
    }.

MIR::Operation::UInt64GreaterOrEquals
    forTarget: #x86_64 registerConstraintsWith: x86::integerComparisonInt64RegisterConstraints;
    forTarget: #x86_64 generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::xor: (instruction resultRegister x86::int32For: codegen) with: (instruction resultRegister x86::int32For: codegen);
            x86::cmp: (instruction firstOperandRegister x86::int64For: codegen) with: (instruction secondOperandRegister x86::int64For: codegen);
            x86::setae: (instruction resultRegister x86::int8For: codegen)
    }.

MIR::Operation::PointerEquals
    forTarget: #x86 registerConstraintsWith: x86::integerComparisonInt32RegisterConstraints;
    forTarget: #x86 generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::xor: (instruction resultRegister x86::int32For: codegen) with: (instruction resultRegister x86::int32For: codegen);
            x86::cmp: (instruction firstOperandRegister x86::int32For: codegen) with: (instruction secondOperandRegister x86::int32For: codegen);
            x86::sete: (instruction resultRegister x86::int8For: codegen)
    };
    forTarget: #x86_64 registerConstraintsWith: x86::integerComparisonInt64RegisterConstraints;
    forTarget: #x86_64 generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::xor: (instruction resultRegister x86::int32For: codegen) with: (instruction resultRegister x86::int32For: codegen);
            x86::cmp: (instruction firstOperandRegister x86::int64For: codegen) with: (instruction secondOperandRegister x86::int64For: codegen);
            x86::sete: (instruction resultRegister x86::int8For: codegen)
    }.

MIR::Operation::PointerNotEquals
    forTarget: #x86 registerConstraintsWith: x86::integerComparisonInt32RegisterConstraints;
    forTarget: #x86 generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::xor: (instruction resultRegister x86::int32For: codegen) with: (instruction resultRegister x86::int32For: codegen);
            x86::cmp: (instruction firstOperandRegister x86::int32For: codegen) with: (instruction secondOperandRegister x86::int32For: codegen);
            x86::setne: (instruction resultRegister x86::int8For: codegen)
    };
    forTarget: #x86_64 registerConstraintsWith: x86::integerComparisonInt64RegisterConstraints;
    forTarget: #x86_64 generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::xor: (instruction resultRegister x86::int32For: codegen) with: (instruction resultRegister x86::int32For: codegen);
            x86::cmp: (instruction firstOperandRegister x86::int64For: codegen) with: (instruction secondOperandRegister x86::int64For: codegen);
            x86::setne: (instruction resultRegister x86::int8For: codegen)
    }.

let x86::integerComparisonBranchInt64RegisterConstraints := {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
    allocator
        allocateRegisterForInstruction: instruction operandAt: 0sz;
        allocateRegisterImmediateS32OrDirectPointerForInstruction: instruction operandAt: 1sz;
        allocateRegisterOrRelativeImmediate32ForInstruction: instruction operandAt: 2sz;
        allocateRegisterOrRelativeImmediate32ForInstruction: instruction operandAt: 3sz
}.

MIR::Operation::Int64EqualsBranch
    forTarget: #x86_64 registerConstraintsWith: x86::integerComparisonBranchInt64RegisterConstraints;
    forTarget: #x86_64 generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::cmp: (instruction firstOperandRegister x86::int64For: codegen) with: (instruction secondOperandRegister x86::immediateS32OrInt64For: codegen);
            x86::jnz: (instruction fourthOperandRegister x86::relCall32OrInt32For: codegen);
            x86::jmp: (instruction thirdOperandRegister x86::relCall32OrInt32For: codegen)
    }.

MIR::Operation::Int64NotEqualsBranch
    forTarget: #x86_64 registerConstraintsWith: x86::integerComparisonBranchInt64RegisterConstraints;
    forTarget: #x86_64 generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::cmp: (instruction firstOperandRegister x86::int64For: codegen) with: (instruction secondOperandRegister x86::immediateS32OrInt64For: codegen);
            x86::jz: (instruction fourthOperandRegister x86::relCall32OrInt32For: codegen);
            x86::jmp: (instruction thirdOperandRegister x86::relCall32OrInt32For: codegen)
    }.

MIR::Operation::Int64LessThanBranch
    forTarget: #x86_64 registerConstraintsWith: x86::integerComparisonBranchInt64RegisterConstraints;
    forTarget: #x86_64 generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::cmp: (instruction firstOperandRegister x86::int64For: codegen) with: (instruction secondOperandRegister x86::immediateS32OrInt64For: codegen);
            x86::jge: (instruction fourthOperandRegister x86::relCall32OrInt32For: codegen);
            x86::jmp: (instruction thirdOperandRegister x86::relCall32OrInt32For: codegen)
    }.

MIR::Operation::Int64LessOrEqualsBranch
    forTarget: #x86_64 registerConstraintsWith: x86::integerComparisonBranchInt64RegisterConstraints;
    forTarget: #x86_64 generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::cmp: (instruction firstOperandRegister x86::int64For: codegen) with: (instruction secondOperandRegister x86::immediateS32OrInt64For: codegen);
            x86::jg: (instruction fourthOperandRegister x86::relCall32OrInt32For: codegen);
            x86::jmp: (instruction thirdOperandRegister x86::relCall32OrInt32For: codegen)
    }.

MIR::Operation::Int64GreaterThanBranch
    forTarget: #x86_64 registerConstraintsWith: x86::integerComparisonBranchInt64RegisterConstraints;
    forTarget: #x86_64 generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::cmp: (instruction firstOperandRegister x86::int64For: codegen) with: (instruction secondOperandRegister x86::immediateS32OrInt64For: codegen);
            x86::jle: (instruction fourthOperandRegister x86::relCall32OrInt32For: codegen);
            x86::jmp: (instruction thirdOperandRegister x86::relCall32OrInt32For: codegen)
    }.

MIR::Operation::Int64GreaterOrEqualsBranch
    forTarget: #x86_64 registerConstraintsWith: x86::integerComparisonBranchInt64RegisterConstraints;
    forTarget: #x86_64 generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::cmp: (instruction firstOperandRegister x86::int64For: codegen) with: (instruction secondOperandRegister x86::immediateS32OrInt64For: codegen);
            x86::jl: (instruction fourthOperandRegister x86::relCall32OrInt32For: codegen);
            x86::jmp: (instruction thirdOperandRegister x86::relCall32OrInt32For: codegen)
    }.

MIR::Operation::Int64LessThanBranch
    forTarget: #x86_64 registerConstraintsWith: x86::integerComparisonBranchInt64RegisterConstraints;
    forTarget: #x86_64 generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::cmp: (instruction firstOperandRegister x86::int64For: codegen) with: (instruction secondOperandRegister x86::immediateS32OrInt64For: codegen);
            x86::jge: (instruction fourthOperandRegister x86::relCall32OrInt32For: codegen);
            x86::jmp: (instruction thirdOperandRegister x86::relCall32OrInt32For: codegen)
    }.

MIR::Operation::Int64LessOrEqualsBranch
    forTarget: #x86_64 registerConstraintsWith: x86::integerComparisonBranchInt64RegisterConstraints;
    forTarget: #x86_64 generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::cmp: (instruction firstOperandRegister x86::int64For: codegen) with: (instruction secondOperandRegister x86::immediateS32OrInt64For: codegen);
            x86::jg: (instruction fourthOperandRegister x86::relCall32OrInt32For: codegen);
            x86::jmp: (instruction thirdOperandRegister x86::relCall32OrInt32For: codegen)
    }.

MIR::Operation::Int64GreaterThanBranch
    forTarget: #x86_64 registerConstraintsWith: x86::integerComparisonBranchInt64RegisterConstraints;
    forTarget: #x86_64 generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::cmp: (instruction firstOperandRegister x86::int64For: codegen) with: (instruction secondOperandRegister x86::immediateS32OrInt64For: codegen);
            x86::jle: (instruction fourthOperandRegister x86::relCall32OrInt32For: codegen);
            x86::jmp: (instruction thirdOperandRegister x86::relCall32OrInt32For: codegen)
    }.

MIR::Operation::Int64GreaterOrEqualsBranch
    forTarget: #x86_64 registerConstraintsWith: x86::integerComparisonBranchInt64RegisterConstraints;
    forTarget: #x86_64 generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::cmp: (instruction firstOperandRegister x86::int64For: codegen) with: (instruction secondOperandRegister x86::immediateS32OrInt64For: codegen);
            x86::jl: (instruction fourthOperandRegister x86::relCall32OrInt32For: codegen);
            x86::jmp: (instruction thirdOperandRegister x86::relCall32OrInt32For: codegen)
    }.

MIR::Operation::UInt64LessThanBranch
    forTarget: #x86_64 registerConstraintsWith: x86::integerComparisonBranchInt64RegisterConstraints;
    forTarget: #x86_64 generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::cmp: (instruction firstOperandRegister x86::int64For: codegen) with: (instruction secondOperandRegister x86::immediateS32OrInt64For: codegen);
            x86::jae: (instruction fourthOperandRegister x86::relCall32OrInt32For: codegen);
            x86::jmp: (instruction thirdOperandRegister x86::relCall32OrInt32For: codegen)
    }.

MIR::Operation::UInt64LessOrEqualsBranch
    forTarget: #x86_64 registerConstraintsWith: x86::integerComparisonBranchInt64RegisterConstraints;
    forTarget: #x86_64 generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::cmp: (instruction firstOperandRegister x86::int64For: codegen) with: (instruction secondOperandRegister x86::immediateS32OrInt64For: codegen);
            x86::ja: (instruction fourthOperandRegister x86::relCall32OrInt32For: codegen);
            x86::jmp: (instruction thirdOperandRegister x86::relCall32OrInt32For: codegen)
    }.

MIR::Operation::UInt64GreaterThanBranch
    forTarget: #x86_64 registerConstraintsWith: x86::integerComparisonBranchInt64RegisterConstraints;
    forTarget: #x86_64 generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::cmp: (instruction firstOperandRegister x86::int64For: codegen) with: (instruction secondOperandRegister x86::immediateS32OrInt64For: codegen);
            x86::jbe: (instruction fourthOperandRegister x86::relCall32OrInt32For: codegen);
            x86::jmp: (instruction thirdOperandRegister x86::relCall32OrInt32For: codegen)
    }.

MIR::Operation::UInt64GreaterOrEqualsBranch
    forTarget: #x86_64 registerConstraintsWith: x86::integerComparisonBranchInt64RegisterConstraints;
    forTarget: #x86_64 generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::cmp: (instruction firstOperandRegister x86::int64For: codegen) with: (instruction secondOperandRegister x86::immediateS32OrInt64For: codegen);
            x86::jb: (instruction fourthOperandRegister x86::relCall32OrInt32For: codegen);
            x86::jmp: (instruction thirdOperandRegister x86::relCall32OrInt32For: codegen)
    }.

MIR::Operation::PointerEqualsBranch
    forTarget: #x86 registerConstraintsWith: x86::integerComparisonBranchInt32RegisterConstraints;
    forTarget: #x86 generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::cmp: (instruction firstOperandRegister x86::int32For: codegen) with: (instruction secondOperandRegister x86::int32For: codegen);
            x86::jnz: (instruction fourthOperandRegister x86::relCall32OrInt32For: codegen);
            x86::jmp: (instruction thirdOperandRegister x86::relCall32OrInt32For: codegen)
    };
    forTarget: #x86_64 registerConstraintsWith: x86::integerComparisonBranchInt64RegisterConstraints;
    forTarget: #x86_64 generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::cmp: (instruction firstOperandRegister x86::int64For: codegen) with: (instruction secondOperandRegister x86::immediateS32OrInt64For: codegen);
            x86::jnz: (instruction fourthOperandRegister x86::relCall32OrInt32For: codegen);
            x86::jmp: (instruction thirdOperandRegister x86::relCall32OrInt32For: codegen)
    }.

MIR::Operation::PointerNotEqualsBranch
    forTarget: #x86 registerConstraintsWith: x86::integerComparisonBranchInt32RegisterConstraints;
    forTarget: #x86 generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::cmp: (instruction firstOperandRegister x86::int32For: codegen) with: (instruction secondOperandRegister x86::int32For: codegen);
            x86::jz: (instruction fourthOperandRegister x86::relCall32OrInt32For: codegen);
            x86::jmp: (instruction thirdOperandRegister x86::relCall32OrInt32For: codegen)
    };
    forTarget: #x86_64 registerConstraintsWith: x86::integerComparisonBranchInt64RegisterConstraints;
    forTarget: #x86_64 generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::cmp: (instruction firstOperandRegister x86::int64For: codegen) with: (instruction secondOperandRegister x86::immediateS32OrInt64For: codegen);
            x86::jz: (instruction fourthOperandRegister x86::relCall32OrInt32For: codegen);
            x86::jmp: (instruction thirdOperandRegister x86::relCall32OrInt32For: codegen)
    }.

let x86::moveIntegerRegisterConstraints := {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
    allocator
        allocateRegisterImmediate32OrDirectPointerForInstruction: instruction operandAt: 0sz;
        allocateRegisterForInstructionResult: instruction trySharingWithOperandAt: 0sz
}.

let x86::moveIntegerRegister16Constraints := {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
    allocator
        allocateRegisterOrImmediate16ForInstruction: instruction operandAt: 0sz;
        allocateRegisterForInstructionResult: instruction trySharingWithOperandAt: 0sz
}.

let x86::moveIntegerRegister8Constraints := {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
    allocator
        allocateRegisterOrImmediate8ForInstruction: instruction operandAt: 0sz;
        allocateRegister8ForInstructionResult: instruction trySharingWithOperandAt: 0sz
}.

let x86::extendIntegerRegisterConstraints := {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
    allocator
        allocateRegisterForInstruction: instruction operandAt: 0sz;
        allocateRegisterForInstructionResult: instruction trySharingWithOperandAt: 0sz
}.

let x86::extendIntegerRegister8Constraints := {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
    allocator
        allocateRegister8ForInstruction: instruction operandAt: 0sz;
        allocateRegisterForInstructionResult: instruction trySharingWithOperandAt: 0sz
}.


MIR::Operation::MoveInt8
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::moveIntegerRegister8Constraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection x86::mov: (instruction resultRegister x86::int32For: codegen) src: (instruction firstOperandRegister x86::int32For: codegen)
    }.

MIR::Operation::MoveInt16
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::moveIntegerRegister16Constraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection x86::mov: (instruction resultRegister x86::int32For: codegen) src: (instruction firstOperandRegister x86::int32For: codegen)
    }.

MIR::Operation::MoveInt32
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::moveIntegerRegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection x86::mov: (instruction resultRegister x86::int32For: codegen) src: (instruction firstOperandRegister x86::int32For: codegen)
    }.

MIR::Operation::MoveInt64
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::moveIntegerRegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection x86::mov: (instruction resultRegister x86::int64For: codegen) src: (instruction firstOperandRegister x86::int64For: codegen)
    }.

MIR::Operation::MovePointer
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::moveIntegerRegisterConstraints;
    forTarget: #x86 generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection x86::mov: (instruction resultRegister x86::int32For: codegen) src: (instruction firstOperandRegister x86::int32For: codegen)
    };
    forTarget: #x86_64 generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection x86::mov: (instruction resultRegister x86::int64For: codegen) src: (instruction firstOperandRegister x86::int64For: codegen)
    }.

MIR::Operation::MoveStruct
    forTarget: #x86_64 registerConstraintsWith: {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
        instruction scratchRegisterCount: 1sz.
        allocator
            allocateCloberredRegister: MIR::X86_64::RDI forInstructionResultPointer: instruction;
            allocateCloberredRegister: MIR::X86_64::RSI forInstruction: instruction operandPointerAt: 0sz;
            allocateRegister: MIR::X86_64::RCX forInstruction: instruction scratchAt: 0sz
    };
    forTarget: #x86_64 generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::mov: X86::RCX src: instruction operands first size asUInt64 asAsmImmediate;
            x86::rep; x86::movsb
    }.

let x86::phiIntegerRegisterConstraints := {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
    allocator allocateRegisterForInstructionResult: instruction
}.

let x86::phiIntegerRegister8Constraints := {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
    allocator allocateRegister8ForInstructionResult: instruction
}.

MIR::Operation::PhiInt8
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::phiIntegerRegister8Constraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |}.

MIR::Operation::PhiInt16
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::phiIntegerRegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |}.

MIR::Operation::PhiInt32
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::phiIntegerRegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |}.

MIR::Operation::PhiInt64
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::phiIntegerRegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |}.

MIR::Operation::PhiPointer
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::phiIntegerRegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |}.

MIR::Operation::PhiStruct
    forTarget: #(x86 x86_64) registerConstraintsWith: {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |};
    forTarget: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |}.

let x86::loadPointerRegisterContraints := {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
    allocator
        allocateRegisterOrImmediate32PointerForInstruction: instruction operandAt: 0sz;
        allocateImmediate32ForInstruction: instruction operandAt: 1sz;
        allocateRegisterForInstructionResult: instruction
}.

MIR::Operation::LoadInt8
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::loadPointerRegisterContraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection x86::movsx: (instruction resultRegister x86::int32For: codegen) src: (instruction firstOperandRegister x86::int8PointerWithOffset: instruction secondOperandRegister for: codegen)
    }.

MIR::Operation::LoadUInt8
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::loadPointerRegisterContraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection x86::movzx: (instruction resultRegister x86::int32For: codegen) src: (instruction firstOperandRegister x86::int8PointerWithOffset: instruction secondOperandRegister for: codegen)
    }.

MIR::Operation::LoadInt16
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::loadPointerRegisterContraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection x86::movsx: (instruction resultRegister x86::int32For: codegen) src: (instruction firstOperandRegister x86::int16PointerWithOffset: instruction secondOperandRegister for: codegen)
    }.

MIR::Operation::LoadUInt16
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::loadPointerRegisterContraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection x86::movzx: (instruction resultRegister x86::int32For: codegen) src: (instruction firstOperandRegister x86::int16PointerWithOffset: instruction secondOperandRegister for: codegen)
    }.

MIR::Operation::LoadInt32
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::loadPointerRegisterContraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection x86::mov: (instruction resultRegister x86::int32For: codegen) src: (instruction firstOperandRegister x86::int32PointerWithOffset: instruction secondOperandRegister for: codegen)
    }.

MIR::Operation::LoadUInt32
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::loadPointerRegisterContraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection x86::mov: (instruction resultRegister x86::int32For: codegen) src: (instruction firstOperandRegister x86::int32PointerWithOffset: instruction secondOperandRegister for: codegen)
    }.

MIR::Operation::LoadInt64
    forTarget: #x86_64 registerConstraintsWith: x86::loadPointerRegisterContraints;
    forTarget: #x86_64 generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection x86::mov: (instruction resultRegister x86::int64For: codegen) src: (instruction firstOperandRegister x86::int64PointerWithOffset: instruction secondOperandRegister for: codegen)
    }.

MIR::Operation::LoadUInt64
    forTarget: #x86_64 registerConstraintsWith: x86::loadPointerRegisterContraints;
    forTarget: #x86_64 generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection x86::mov: (instruction resultRegister x86::int64For: codegen) src: (instruction firstOperandRegister x86::int64PointerWithOffset: instruction secondOperandRegister for: codegen)
    }.

MIR::Operation::LoadPointer
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::loadPointerRegisterContraints;
    forTarget: #x86_64 generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection x86::mov: (instruction resultRegister x86::int32For: codegen) src: (instruction firstOperandRegister x86::int32PointerWithOffset: instruction secondOperandRegister for: codegen)
    };
    forTarget: #x86_64 generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection x86::mov: (instruction resultRegister x86::int64For: codegen) src: (instruction firstOperandRegister x86::int64PointerWithOffset: instruction secondOperandRegister for: codegen)
    }.

MIR::Operation::LoadStruct
    forTarget: #x86_64 registerConstraintsWith: {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
        instruction scratchRegisterCount: 1sz.
        allocator
            allocateCloberredRegister: MIR::X86_64::RDI forInstructionResultPointer: instruction;
            allocateCloberredRegister: MIR::X86_64::RSI forInstruction: instruction operandAt: 0sz;
            allocateImmediate32ForInstruction: instruction operandAt: 1sz;
            allocateRegister: MIR::X86_64::RCX forInstruction: instruction scratchAt: 0sz
    };
    forTarget: #x86_64 generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::mov: X86::RCX src: instruction operands first size asUInt64 asAsmImmediate;
            x86::add: X86::RSI with: (instruction secondOperandRegister x86::immediate32For: codegen);
            x86::rep; x86::movsb
    }.

let x86::storePointerRegisterContraints := {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
    allocator
        allocateRegisterOrImmediate32ForInstruction: instruction operandAt: 0sz;
        allocateRegisterOrImmediate32PointerForInstruction: instruction operandAt: 1sz;
        allocateImmediate32ForInstruction: instruction operandAt: 2sz
}.

MIR::Operation::StoreInt8
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::storePointerRegisterContraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection x86::mov: (instruction secondOperandRegister x86::int8PointerWithOffset: instruction thirdOperandRegister for: codegen) src: (instruction firstOperandRegister x86::int8For: codegen)
    }.

MIR::Operation::StoreInt16
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::storePointerRegisterContraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection x86::mov: (instruction secondOperandRegister x86::int16PointerWithOffset: instruction thirdOperandRegister for: codegen) src: (instruction firstOperandRegister x86::int16For: codegen)
    }.

MIR::Operation::StoreInt32
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::storePointerRegisterContraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection x86::mov: (instruction secondOperandRegister x86::int32PointerWithOffset: instruction thirdOperandRegister for: codegen) src: (instruction firstOperandRegister x86::int32For: codegen)
    }.

MIR::Operation::StoreInt64
    forTarget: #x86_64 registerConstraintsWith: x86::storePointerRegisterContraints;
    forTarget: #x86_64 generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection x86::mov: (instruction secondOperandRegister x86::int64PointerWithOffset: instruction thirdOperandRegister for: codegen) src: (instruction firstOperandRegister x86::int64For: codegen)
    }.

MIR::Operation::StorePointer
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::storePointerRegisterContraints;
    forTarget: #x86 generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection x86::mov: (instruction secondOperandRegister x86::int32PointerWithOffset: instruction thirdOperandRegister for: codegen) src: (instruction firstOperandRegister x86::int32For: codegen)
    };
    forTarget: #x86_64 generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection x86::mov: (instruction secondOperandRegister x86::int64PointerWithOffset: instruction thirdOperandRegister for: codegen) src: (instruction firstOperandRegister x86::int64For: codegen)
    }.

MIR::Operation::StoreStruct
    forTarget: #x86_64 registerConstraintsWith: {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
        instruction scratchRegisterCount: 1sz.
        allocator
            allocateCloberredRegister: MIR::X86_64::RSI forInstruction: instruction operandPointerAt: 0sz;
            allocateCloberredRegister: MIR::X86_64::RDI forInstruction: instruction operandAt: 1sz;
            allocateImmediate32ForInstruction: instruction operandAt: 2sz;
            allocateRegister: MIR::X86_64::RCX forInstruction: instruction scratchAt: 0sz
    };
    forTarget: #x86_64 generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::mov: X86::RCX src: instruction operands first size asUInt64 asAsmImmediate;
            x86::add: X86::RDI with: (instruction thirdOperandRegister x86::immediate32For: codegen);
            x86::rep; x86::movsb
    }.

MIR::Operation::Memcpy
    forTarget: #x86_64 registerConstraintsWith: {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
        allocator
            allocateCloberredRegister: MIR::X86_64::RDI forInstruction: instruction operandAt: 0sz;
            allocateCloberredRegister: MIR::X86_64::RSI forInstruction: instruction operandAt: 1sz;
            allocateCloberredRegister: MIR::X86_64::RCX forInstruction: instruction operandAt: 2sz.
    };
    forTarget: #x86_64 generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::rep; x86::movsb
    }.

MIR::Operation::Memset
    forTarget: #x86_64 registerConstraintsWith: {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
        allocator
            allocateCloberredRegister: MIR::X86_64::RDI forInstruction: instruction operandAt: 0sz;
            allocateRegister: MIR::X86_64::RAX forInstruction: instruction operandAt: 1sz;
            allocateCloberredRegister: MIR::X86_64::RCX forInstruction: instruction operandAt: 2sz.
    };
    forTarget: #x86_64 generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::rep; x86::stosb
    }.

MIR::Operation::TruncateInt64ToInt32
    forTarget: #x86_64 registerConstraintsWith: x86::moveIntegerRegisterConstraints;
    forTarget: #x86_64 generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection x86::mov: (instruction resultRegister x86::int32For: codegen) src: (instruction firstOperandRegister x86::int32For: codegen)
    }.

MIR::Operation::TruncateInt64ToInt16
    forTarget: #x86_64 registerConstraintsWith: x86::moveIntegerRegisterConstraints;
    forTarget: #x86_64 generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection x86::mov: (instruction resultRegister x86::int16For: codegen) src: (instruction firstOperandRegister x86::int16For: codegen)
    }.

MIR::Operation::TruncateInt64ToInt8
    forTarget: #x86_64 registerConstraintsWith: x86::moveIntegerRegister8Constraints;
    forTarget: #x86_64 generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection x86::mov: (instruction resultRegister x86::int8For: codegen) src: (instruction firstOperandRegister x86::int8For: codegen)
    }.

MIR::Operation::TruncateInt32ToInt16
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::moveIntegerRegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection x86::mov: (instruction resultRegister x86::int16For: codegen) src: (instruction firstOperandRegister x86::int16For: codegen)
    }.

MIR::Operation::TruncateInt32ToInt8
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::moveIntegerRegister8Constraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection x86::mov: (instruction resultRegister x86::int8For: codegen) src: (instruction firstOperandRegister x86::int8For: codegen)
    }.

MIR::Operation::TruncateInt16ToInt8
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::moveIntegerRegister8Constraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection x86::mov: (instruction resultRegister x86::int16For: codegen) src: (instruction firstOperandRegister x86::int16For: codegen)
    }.

MIR::Operation::SignExtendInt32ToInt64
    forTarget: #x86_64 registerConstraintsWith: x86::extendIntegerRegisterConstraints;
    forTarget: #x86_64 generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection x86::movsxd: (instruction resultRegister x86::int64For: codegen) src: (instruction firstOperandRegister x86::int32For: codegen)
    }.

MIR::Operation::SignExtendInt16ToInt64
    forTarget: #x86_64 registerConstraintsWith: x86::extendIntegerRegisterConstraints;
    forTarget: #x86_64 generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection x86::movsx: (instruction resultRegister x86::int64For: codegen) src: (instruction firstOperandRegister x86::int16For: codegen)
    }.

MIR::Operation::SignExtendInt8ToInt64
    forTarget: #x86_64 registerConstraintsWith: x86::extendIntegerRegister8Constraints;
    forTarget: #x86_64 generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection x86::movsx: (instruction resultRegister x86::int64For: codegen) src: (instruction firstOperandRegister x86::int8For: codegen)
    }.

MIR::Operation::SignExtendInt16ToInt32
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::extendIntegerRegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection x86::movsx: (instruction resultRegister x86::int32For: codegen) src: (instruction firstOperandRegister x86::int16For: codegen)
    }.

MIR::Operation::SignExtendInt8ToInt32
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::extendIntegerRegister8Constraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection x86::movsx: (instruction resultRegister x86::int32For: codegen) src: (instruction firstOperandRegister x86::int8For: codegen)
    }.

MIR::Operation::SignExtendInt8ToInt16
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::extendIntegerRegister8Constraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection x86::movsx: (instruction resultRegister x86::int16For: codegen) src: (instruction firstOperandRegister x86::int8For: codegen)
    }.

MIR::Operation::ZeroExtendInt32ToInt64
    forTarget: #x86_64 registerConstraintsWith: x86::extendIntegerRegisterConstraints;
    forTarget: #x86_64 generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection x86::direct::mov: (instruction resultRegister x86::int32For: codegen) src: (instruction firstOperandRegister x86::int32For: codegen)
    }.

MIR::Operation::ZeroExtendInt16ToInt64
    forTarget: #x86_64 registerConstraintsWith: x86::extendIntegerRegisterConstraints;
    forTarget: #x86_64 generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection x86::movzx: (instruction resultRegister x86::int64For: codegen) src: (instruction firstOperandRegister x86::int16For: codegen)
    }.

MIR::Operation::ZeroExtendInt8ToInt64
    forTarget: #x86_64 registerConstraintsWith: x86::extendIntegerRegister8Constraints;
    forTarget: #x86_64 generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection x86::movzx: (instruction resultRegister x86::int64For: codegen) src: (instruction firstOperandRegister x86::int8For: codegen)
    }.

MIR::Operation::ZeroExtendInt16ToInt32
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::extendIntegerRegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection x86::movzx: (instruction resultRegister x86::int32For: codegen) src: (instruction firstOperandRegister x86::int16For: codegen)
    }.

MIR::Operation::ZeroExtendInt8ToInt32
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::extendIntegerRegister8Constraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection x86::movzx: (instruction resultRegister x86::int32For: codegen) src: (instruction firstOperandRegister x86::int8For: codegen)
    }.

MIR::Operation::ZeroExtendInt8ToInt16
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::extendIntegerRegister8Constraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection x86::movzx: (instruction resultRegister x86::int16For: codegen) src: (instruction firstOperandRegister x86::int8For: codegen)
    }.

let x86::vectorMoveRegisterConstraints := {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
    allocator
        allocateRegisterOrMemoryForInstruction: instruction operandAt: 0sz;
        allocateRegisterForInstructionResult: instruction trySharingWithOperandAt: 0sz
}.

let x86::vectorPhiRegisterConstraints := {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
    allocator allocateRegisterForInstructionResult: instruction
}.

let x86::vectorStorePointerRegisterContraints := {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
    allocator
        allocateRegisterOrImmediate32ForInstruction: instruction operandAt: 1sz;
        allocateImmediate32ForInstruction: instruction operandAt: 2sz;
        allocateRegisterForInstruction: instruction operandAt: 0sz
}.

MIR::Operation::MoveFloat32
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::vectorMoveRegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection x86::movss: (instruction resultRegister x86::float32For: codegen) src: (instruction firstOperandRegister x86::float32For: codegen)
    }.

MIR::Operation::MoveFloat64
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::vectorMoveRegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection x86::movsd: (instruction resultRegister x86::float64For: codegen) src: (instruction firstOperandRegister x86::float64For: codegen)
    }.

MIR::Operation::PhiFloat32
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::vectorPhiRegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |}.

MIR::Operation::PhiFloat64
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::vectorPhiRegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |}.

MIR::Operation::LoadFloat32
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::loadPointerRegisterContraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection x86::movss: (instruction resultRegister x86::float32For: codegen) src: (instruction firstOperandRegister x86::float32PointerWithOffset: instruction secondOperandRegister for: codegen)
    }.

MIR::Operation::LoadFloat64
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::loadPointerRegisterContraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection x86::movsd: (instruction resultRegister x86::float64For: codegen) src: (instruction firstOperandRegister x86::float64PointerWithOffset: instruction secondOperandRegister for: codegen)
    }.

MIR::Operation::StoreFloat32
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::vectorStorePointerRegisterContraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection x86::movss: (instruction secondOperandRegister x86::float32PointerWithOffset: instruction thirdOperandRegister for: codegen) src: (instruction firstOperandRegister x86::float32For: codegen)
    }.

MIR::Operation::StoreFloat64
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::vectorStorePointerRegisterContraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection x86::movsd: (instruction secondOperandRegister x86::float64PointerWithOffset: instruction thirdOperandRegister for: codegen) src: (instruction firstOperandRegister x86::float64For: codegen)
    }.

let x86::vectorUnaryAluRegisterConstraints := {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
    allocator
        allocateRegisterOrMemoryForInstruction: instruction operandAt: 0sz;
        allocateRegisterForInstructionResult: instruction trySharingWithOperandAt: 0sz
}.

let x86::vectorAluRegisterConstraints := {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
    allocator
        allocateRegisterOrMemoryForInstruction: instruction operandAt: 0sz;
        allocateRegisterOrMemoryForInstruction: instruction operandAt: 1sz;
        allocateRegisterForInstructionResult: instruction trySharingWithOperandAt: 0sz
}.

let x86::vectorScalarComparisonRegisterConstraints := {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
    allocator
        allocateRegisterForInstruction: instruction operandAt: 0sz;
        allocateRegisterOrMemoryForInstruction: instruction operandAt: 1sz;
        allocateRegisterForInstructionResult: instruction
}.

let x86::vectorScalarComparisonBranchRegisterConstraints := {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
    allocator
        allocateRegisterOrMemoryForInstruction: instruction operandAt: 1sz;
        allocateRegisterOrRelativeImmediate32ForInstruction: instruction operandAt: 2sz;
        allocateRegisterOrRelativeImmediate32ForInstruction: instruction operandAt: 3sz;
        allocateRegisterForInstruction: instruction operandAt: 0sz
}.

MIR::Operation::Float32Add
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::vectorAluRegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::movss: (instruction resultRegister x86::float32For: codegen) src: (instruction firstOperandRegister x86::float32For: codegen);
            x86::addss: (instruction resultRegister x86::float32For: codegen) with: (instruction secondOperandRegister x86::float32For: codegen).
    }.

MIR::Operation::Float32Negate
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::vectorUnaryAluRegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::xorps: (instruction resultRegister x86::float32For: codegen) with: (instruction resultRegister x86::float32For: codegen);
            x86::subss: (instruction resultRegister x86::float32For: codegen) with: (instruction firstOperandRegister x86::float32For: codegen).
    }.

MIR::Operation::Float32Sub
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::vectorAluRegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::movss: (instruction resultRegister x86::float32For: codegen) src: (instruction firstOperandRegister x86::float32For: codegen);
            x86::subss: (instruction resultRegister x86::float32For: codegen) with: (instruction secondOperandRegister x86::float32For: codegen).
    }.

MIR::Operation::Float32Mul
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::vectorAluRegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::movss: (instruction resultRegister x86::float32For: codegen) src: (instruction firstOperandRegister x86::float32For: codegen);
            x86::mulss: (instruction resultRegister x86::float32For: codegen) with: (instruction secondOperandRegister x86::float32For: codegen).
    }.

MIR::Operation::Float32Div
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::vectorAluRegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::movss: (instruction resultRegister x86::float32For: codegen) src: (instruction firstOperandRegister x86::float32For: codegen);
            x86::divss: (instruction resultRegister x86::float32For: codegen) with: (instruction secondOperandRegister x86::float32For: codegen).
    }.

MIR::Operation::Float32Sqrt
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::vectorUnaryAluRegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::sqrtss: (instruction resultRegister x86::float32For: codegen) with: (instruction firstOperandRegister x86::float32For: codegen).
    }.

MIR::Operation::Float32UnorderedCompare
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::vectorScalarComparisonRegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        ## TODO: Implement this properly.
        codegen textSection x86::int3
    }.

MIR::Operation::Float32UnorderedEquals
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::vectorScalarComparisonRegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::xor: (instruction resultRegister x86::int32For: codegen) with: (instruction resultRegister x86::int32For: codegen);
            x86::ucomiss: (instruction firstOperandRegister x86::float32For: codegen) src: (instruction secondOperandRegister x86::float32For: codegen);
            x86::sete: (instruction resultRegister x86::int8For: codegen)
    }.

MIR::Operation::Float32UnorderedNotEquals
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::vectorScalarComparisonRegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::xor: (instruction resultRegister x86::int32For: codegen) with: (instruction resultRegister x86::int32For: codegen);
            x86::ucomiss: (instruction firstOperandRegister x86::float32For: codegen) src: (instruction secondOperandRegister x86::float32For: codegen);
            x86::setne: (instruction resultRegister x86::int8For: codegen)
    }.

MIR::Operation::Float32UnorderedLessThan
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::vectorScalarComparisonRegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::xor: (instruction resultRegister x86::int32For: codegen) with: (instruction resultRegister x86::int32For: codegen);
            x86::ucomiss: (instruction firstOperandRegister x86::float32For: codegen) src: (instruction secondOperandRegister x86::float32For: codegen);
            x86::setl: (instruction resultRegister x86::int8For: codegen)
    }.

MIR::Operation::Float32UnorderedLessOrEquals
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::vectorScalarComparisonRegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::xor: (instruction resultRegister x86::int32For: codegen) with: (instruction resultRegister x86::int32For: codegen);
            x86::ucomiss: (instruction firstOperandRegister x86::float32For: codegen) src: (instruction secondOperandRegister x86::float32For: codegen);
            x86::setle: (instruction resultRegister x86::int8For: codegen)
    }.

MIR::Operation::Float32UnorderedGreaterThan
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::vectorScalarComparisonRegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::xor: (instruction resultRegister x86::int32For: codegen) with: (instruction resultRegister x86::int32For: codegen);
            x86::ucomiss: (instruction firstOperandRegister x86::float32For: codegen) src: (instruction secondOperandRegister x86::float32For: codegen);
            x86::setg: (instruction resultRegister x86::int8For: codegen)
    }.

MIR::Operation::Float32UnorderedGreaterOrEquals
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::vectorScalarComparisonRegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::xor: (instruction resultRegister x86::int32For: codegen) with: (instruction resultRegister x86::int32For: codegen);
            x86::ucomiss: (instruction firstOperandRegister x86::float32For: codegen) src: (instruction secondOperandRegister x86::float32For: codegen);
            x86::setge: (instruction resultRegister x86::int8For: codegen)
    }.

MIR::Operation::Float32UnorderedEqualsBranch
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::vectorScalarComparisonBranchRegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::ucomiss: (instruction firstOperandRegister x86::float32For: codegen) src: (instruction secondOperandRegister x86::float32For: codegen);
            x86::jnz: (instruction fourthOperandRegister x86::relCall32OrInt32For: codegen);
            x86::jmp: (instruction thirdOperandRegister x86::relCall32OrInt32For: codegen)
    }.

MIR::Operation::Float32UnorderedNotEqualsBranch
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::vectorScalarComparisonBranchRegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::ucomiss: (instruction firstOperandRegister x86::float32For: codegen) src: (instruction secondOperandRegister x86::float32For: codegen);
            x86::jz: (instruction fourthOperandRegister x86::relCall32OrInt32For: codegen);
            x86::jmp: (instruction thirdOperandRegister x86::relCall32OrInt32For: codegen)
    }.

MIR::Operation::Float32UnorderedLessThanBranch
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::vectorScalarComparisonBranchRegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::ucomiss: (instruction firstOperandRegister x86::float32For: codegen) src: (instruction secondOperandRegister x86::float32For: codegen);
            x86::jge: (instruction fourthOperandRegister x86::relCall32OrInt32For: codegen);
            x86::jmp: (instruction thirdOperandRegister x86::relCall32OrInt32For: codegen)
    }.
MIR::Operation::Float32UnorderedLessOrEqualsBranch
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::vectorScalarComparisonBranchRegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::ucomiss: (instruction firstOperandRegister x86::float32For: codegen) src: (instruction secondOperandRegister x86::float32For: codegen);
            x86::jg: (instruction fourthOperandRegister x86::relCall32OrInt32For: codegen);
            x86::jmp: (instruction thirdOperandRegister x86::relCall32OrInt32For: codegen)
    }.

MIR::Operation::Float32UnorderedGreaterThanBranch
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::vectorScalarComparisonBranchRegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::ucomiss: (instruction firstOperandRegister x86::float32For: codegen) src: (instruction secondOperandRegister x86::float32For: codegen);
            x86::jle: (instruction fourthOperandRegister x86::relCall32OrInt32For: codegen);
            x86::jmp: (instruction thirdOperandRegister x86::relCall32OrInt32For: codegen)
    }.
MIR::Operation::Float32UnorderedGreaterOrEqualsBranch
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::vectorScalarComparisonBranchRegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::ucomiss: (instruction firstOperandRegister x86::float32For: codegen) src: (instruction secondOperandRegister x86::float32For: codegen);
            x86::jl: (instruction fourthOperandRegister x86::relCall32OrInt32For: codegen);
            x86::jmp: (instruction thirdOperandRegister x86::relCall32OrInt32For: codegen)
    }.

MIR::Operation::Float64Add
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::vectorAluRegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::movsd: (instruction resultRegister x86::float64For: codegen) src: (instruction firstOperandRegister x86::float64For: codegen);
            x86::addsd: (instruction resultRegister x86::float64For: codegen) with: (instruction secondOperandRegister x86::float64For: codegen).
    }.

MIR::Operation::Float64Negate
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::vectorUnaryAluRegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::xorpd: (instruction resultRegister x86::float64For: codegen) with: (instruction resultRegister x86::float64For: codegen);
            x86::subsd: (instruction resultRegister x86::float64For: codegen) with: (instruction firstOperandRegister x86::float64For: codegen).
    }.

MIR::Operation::Float64Sub
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::vectorAluRegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::movsd: (instruction resultRegister x86::float64For: codegen) src: (instruction firstOperandRegister x86::float64For: codegen);
            x86::subsd: (instruction resultRegister x86::float64For: codegen) with: (instruction secondOperandRegister x86::float64For: codegen).
    }.

MIR::Operation::Float64Mul
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::vectorAluRegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::movsd: (instruction resultRegister x86::float64For: codegen) src: (instruction firstOperandRegister x86::float64For: codegen);
            x86::mulsd: (instruction resultRegister x86::float64For: codegen) with: (instruction secondOperandRegister x86::float64For: codegen).
    }.

MIR::Operation::Float64Div
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::vectorAluRegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::movsd: (instruction resultRegister x86::float64For: codegen) src: (instruction firstOperandRegister x86::float64For: codegen);
            x86::divsd: (instruction resultRegister x86::float64For: codegen) with: (instruction secondOperandRegister x86::float64For: codegen).
    }.

MIR::Operation::Float64Sqrt
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::vectorUnaryAluRegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::addsd: (instruction resultRegister x86::float64For: codegen) with: (instruction firstOperandRegister x86::float64For: codegen).
    }.

MIR::Operation::Float64UnorderedCompare
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::vectorScalarComparisonRegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        ## TODO: Implement this properly.
        codegen textSection x86::int3
    }.

MIR::Operation::Float64UnorderedEquals
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::vectorScalarComparisonRegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::ucomisd: (instruction firstOperandRegister x86::float64For: codegen) src: (instruction secondOperandRegister x86::float64For: codegen);
            x86::sete: (instruction resultRegister x86::int8For: codegen)
    }.

MIR::Operation::Float64UnorderedNotEquals
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::vectorScalarComparisonRegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::ucomisd: (instruction firstOperandRegister x86::float64For: codegen) src: (instruction secondOperandRegister x86::float64For: codegen);
            x86::setne: (instruction resultRegister x86::int8For: codegen)
    }.

MIR::Operation::Float64UnorderedLessThan
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::vectorScalarComparisonRegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::ucomisd: (instruction firstOperandRegister x86::float64For: codegen) src: (instruction secondOperandRegister x86::float64For: codegen);
            x86::setl: (instruction resultRegister x86::int8For: codegen)
    }.

MIR::Operation::Float64UnorderedLessOrEquals
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::vectorScalarComparisonRegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::ucomisd: (instruction firstOperandRegister x86::float64For: codegen) src: (instruction secondOperandRegister x86::float64For: codegen);
            x86::setle: (instruction resultRegister x86::int8For: codegen)
    }.

MIR::Operation::Float64UnorderedGreaterThan
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::vectorScalarComparisonRegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::ucomisd: (instruction firstOperandRegister x86::float64For: codegen) src: (instruction secondOperandRegister x86::float64For: codegen);
            x86::setg: (instruction resultRegister x86::int8For: codegen)
    }.

MIR::Operation::Float64UnorderedGreaterOrEquals
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::vectorScalarComparisonRegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::ucomisd: (instruction firstOperandRegister x86::float64For: codegen) src: (instruction secondOperandRegister x86::float64For: codegen);
            x86::setge: (instruction resultRegister x86::int8For: codegen)
    }.

MIR::Operation::Float64UnorderedEqualsBranch
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::vectorScalarComparisonBranchRegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::ucomisd: (instruction firstOperandRegister x86::float64For: codegen) src: (instruction secondOperandRegister x86::float64For: codegen);
            x86::jnz: (instruction fourthOperandRegister x86::relCall32OrInt32For: codegen);
            x86::jmp: (instruction thirdOperandRegister x86::relCall32OrInt32For: codegen)
    }.

MIR::Operation::Float64UnorderedNotEqualsBranch
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::vectorScalarComparisonBranchRegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::ucomisd: (instruction firstOperandRegister x86::float64For: codegen) src: (instruction secondOperandRegister x86::float64For: codegen);
            x86::jz: (instruction fourthOperandRegister x86::relCall32OrInt32For: codegen);
            x86::jmp: (instruction thirdOperandRegister x86::relCall32OrInt32For: codegen)
    }.

MIR::Operation::Float64UnorderedLessThanBranch
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::vectorScalarComparisonBranchRegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::ucomisd: (instruction firstOperandRegister x86::float64For: codegen) src: (instruction secondOperandRegister x86::float64For: codegen);
            x86::jge: (instruction fourthOperandRegister x86::relCall32OrInt32For: codegen);
            x86::jmp: (instruction thirdOperandRegister x86::relCall32OrInt32For: codegen)
    }.
MIR::Operation::Float64UnorderedLessOrEqualsBranch
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::vectorScalarComparisonBranchRegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::ucomisd: (instruction firstOperandRegister x86::float64For: codegen) src: (instruction secondOperandRegister x86::float64For: codegen);
            x86::jg: (instruction fourthOperandRegister x86::relCall32OrInt32For: codegen);
            x86::jmp: (instruction thirdOperandRegister x86::relCall32OrInt32For: codegen)
    }.

MIR::Operation::Float64UnorderedGreaterThanBranch
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::vectorScalarComparisonBranchRegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::ucomisd: (instruction firstOperandRegister x86::float64For: codegen) src: (instruction secondOperandRegister x86::float64For: codegen);
            x86::jle: (instruction fourthOperandRegister x86::relCall32OrInt32For: codegen);
            x86::jmp: (instruction thirdOperandRegister x86::relCall32OrInt32For: codegen)
    }.
MIR::Operation::Float64UnorderedGreaterOrEqualsBranch
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::vectorScalarComparisonBranchRegisterConstraints;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::ucomisd: (instruction firstOperandRegister x86::float64For: codegen) src: (instruction secondOperandRegister x86::float64For: codegen);
            x86::jl: (instruction fourthOperandRegister x86::relCall32OrInt32For: codegen);
            x86::jmp: (instruction thirdOperandRegister x86::relCall32OrInt32For: codegen)
    }.

let x86::vectorScalarIntegerConversionRegisterConstrations := {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
    allocator
        allocateRegisterOrMemoryForInstruction: instruction operandAt: 0sz;
        allocateRegisterForInstructionResult: instruction
}.

let x86::vectorScalarInteger8WithExtensionConversionRegisterConstrations := {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
    allocator
        allocateRegister8ForInstruction: instruction operandAt: 0sz;
        allocateRegisterForInstructionResult: instruction
}.

let x86::vectorScalarIntegerWithExtensionConversionRegisterConstrations := {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
    allocator
        allocateRegisterForInstruction: instruction operandAt: 0sz;
        allocateRegisterForInstructionResult: instruction
}.

MIR::Operation::Float32ToFloat64
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::vectorScalarIntegerConversionRegisterConstrations;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection x86::cvtss2sd: (instruction resultRegister x86::float64For: codegen) src: (instruction firstOperandRegister x86::float32For: codegen)
    }.

MIR::Operation::Float32ToInt8
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::vectorScalarIntegerConversionRegisterConstrations;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection x86::cvtss2si: (instruction resultRegister x86::int32For: codegen) src: (instruction firstOperandRegister x86::float32For: codegen)
    }.

MIR::Operation::Float32ToUInt8
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::vectorScalarIntegerConversionRegisterConstrations;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection x86::cvtss2si: (instruction resultRegister x86::int32For: codegen) src: (instruction firstOperandRegister x86::float32For: codegen)
    }.

MIR::Operation::Float32ToInt16
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::vectorScalarIntegerConversionRegisterConstrations;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection x86::cvtss2si: (instruction resultRegister x86::int32For: codegen) src: (instruction firstOperandRegister x86::float32For: codegen)
    }.

MIR::Operation::Float32ToUInt16
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::vectorScalarIntegerConversionRegisterConstrations;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection x86::cvtss2si: (instruction resultRegister x86::int32For: codegen) src: (instruction firstOperandRegister x86::float32For: codegen)
    }.

MIR::Operation::Float32ToInt32
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::vectorScalarIntegerConversionRegisterConstrations;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection x86::cvtss2si: (instruction resultRegister x86::int32For: codegen) src: (instruction firstOperandRegister x86::float32For: codegen)
    }.

MIR::Operation::Float32ToUInt32
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::vectorScalarIntegerConversionRegisterConstrations;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection x86::cvtss2si: (instruction resultRegister x86::int32For: codegen) src: (instruction firstOperandRegister x86::float32For: codegen)
    }.

MIR::Operation::Float32ToIEEEUInt32
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::vectorScalarIntegerConversionRegisterConstrations;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection x86::movd: (instruction resultRegister x86::int32For: codegen) src: (instruction firstOperandRegister x86::float32For: codegen)
    }.

MIR::Operation::Float32ToInt64
    forTarget: #x86_64 registerConstraintsWith: x86::vectorScalarIntegerConversionRegisterConstrations;
    forTarget: #x86_64 generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection x86::cvtss2si: (instruction resultRegister x86::int64For: codegen) src: (instruction firstOperandRegister x86::float32For: codegen)
    }.

MIR::Operation::Float32ToUInt64
    forTarget: #x86_64 registerConstraintsWith: x86::vectorScalarIntegerConversionRegisterConstrations;
    forTarget: #x86_64 generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection x86::cvtss2si: (instruction resultRegister x86::int64For: codegen) src: (instruction firstOperandRegister x86::float32For: codegen)
    }.

MIR::Operation::Float64ToFloat32
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::vectorScalarIntegerConversionRegisterConstrations;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection x86::cvtsd2ss: (instruction resultRegister x86::float32For: codegen) src: (instruction firstOperandRegister x86::float64For: codegen)
    }.

MIR::Operation::Float64ToInt8
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::vectorScalarIntegerConversionRegisterConstrations;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection x86::cvtsd2si: (instruction resultRegister x86::int32For: codegen) src: (instruction firstOperandRegister x86::float64For: codegen)
    }.

MIR::Operation::Float64ToUInt8
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::vectorScalarIntegerConversionRegisterConstrations;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection x86::cvtsd2si: (instruction resultRegister x86::int32For: codegen) src: (instruction firstOperandRegister x86::float64For: codegen)
    }.

MIR::Operation::Float64ToInt16
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::vectorScalarIntegerConversionRegisterConstrations;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection x86::cvtsd2si: (instruction resultRegister x86::int32For: codegen) src: (instruction firstOperandRegister x86::float64For: codegen)
    }.

MIR::Operation::Float64ToUInt16
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::vectorScalarIntegerConversionRegisterConstrations;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection x86::cvtsd2si: (instruction resultRegister x86::int32For: codegen) src: (instruction firstOperandRegister x86::float64For: codegen)
    }.

MIR::Operation::Float64ToInt32
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::vectorScalarIntegerConversionRegisterConstrations;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection x86::cvtsd2si: (instruction resultRegister x86::int32For: codegen) src: (instruction firstOperandRegister x86::float64For: codegen)
    }.

MIR::Operation::Float64ToUInt32
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::vectorScalarIntegerConversionRegisterConstrations;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection x86::cvtsd2si: (instruction resultRegister x86::int32For: codegen) src: (instruction firstOperandRegister x86::float64For: codegen)
    }.

MIR::Operation::Float64ToInt64
    forTarget: #x86_64 registerConstraintsWith: x86::vectorScalarIntegerConversionRegisterConstrations;
    forTarget: #x86_64 generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection x86::cvtsd2si: (instruction resultRegister x86::int64For: codegen) src: (instruction firstOperandRegister x86::float64For: codegen)
    }.

MIR::Operation::Float64ToUInt64
    forTarget: #x86_64 registerConstraintsWith: x86::vectorScalarIntegerConversionRegisterConstrations;
    forTarget: #x86_64 generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection x86::cvtsd2si: (instruction resultRegister x86::int64For: codegen) src: (instruction firstOperandRegister x86::float64For: codegen)
    }.

MIR::Operation::Float64ToIEEEUInt64
    forTarget: #x86_64 registerConstraintsWith: x86::vectorScalarIntegerConversionRegisterConstrations;
    forTarget: #x86_64 generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection x86::movq: (instruction resultRegister x86::int64For: codegen) src: (instruction firstOperandRegister x86::float32For: codegen)
    }.

MIR::Operation::Int8ToFloat32
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::vectorScalarInteger8WithExtensionConversionRegisterConstrations;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::movsx: (instruction firstOperandRegister x86::int32For: codegen) src: (instruction firstOperandRegister x86::int8For: codegen);
            x86::cvtsi2ss: (instruction resultRegister x86::float32For: codegen) src: (instruction firstOperandRegister x86::int32For: codegen)
    }.

MIR::Operation::Int8ToFloat64
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::vectorScalarInteger8WithExtensionConversionRegisterConstrations;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::movsx: (instruction firstOperandRegister x86::int32For: codegen) src: (instruction firstOperandRegister x86::int8For: codegen);
            x86::cvtsi2sd: (instruction resultRegister x86::float64For: codegen) src: (instruction firstOperandRegister x86::int32For: codegen)
    }.

MIR::Operation::UInt8ToFloat32
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::vectorScalarInteger8WithExtensionConversionRegisterConstrations;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::movzx: (instruction firstOperandRegister x86::int32For: codegen) src: (instruction firstOperandRegister x86::int8For: codegen);
            x86::cvtsi2ss: (instruction resultRegister x86::float32For: codegen) src: (instruction firstOperandRegister x86::int32For: codegen)
    }.

MIR::Operation::UInt8ToFloat64
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::vectorScalarInteger8WithExtensionConversionRegisterConstrations;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::movzx: (instruction firstOperandRegister x86::int32For: codegen) src: (instruction firstOperandRegister x86::int8For: codegen);
            x86::cvtsi2sd: (instruction resultRegister x86::float64For: codegen) src: (instruction firstOperandRegister x86::int32For: codegen)
    }.

MIR::Operation::Int16ToFloat32
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::vectorScalarIntegerWithExtensionConversionRegisterConstrations;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::movsx: (instruction firstOperandRegister x86::int32For: codegen) src: (instruction firstOperandRegister x86::int16For: codegen);
            x86::cvtsi2ss: (instruction resultRegister x86::float32For: codegen) src: (instruction firstOperandRegister x86::int32For: codegen)
    }.

MIR::Operation::Int16ToFloat64
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::vectorScalarIntegerWithExtensionConversionRegisterConstrations;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::movsx: (instruction firstOperandRegister x86::int32For: codegen) src: (instruction firstOperandRegister x86::int16For: codegen);
            x86::cvtsi2sd: (instruction resultRegister x86::float64For: codegen) src: (instruction firstOperandRegister x86::int32For: codegen)
    }.

MIR::Operation::UInt16ToFloat32
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::vectorScalarIntegerWithExtensionConversionRegisterConstrations;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::movzx: (instruction firstOperandRegister x86::int32For: codegen) src: (instruction firstOperandRegister x86::int16For: codegen);
            x86::cvtsi2ss: (instruction resultRegister x86::float32For: codegen) src: (instruction firstOperandRegister x86::int32For: codegen)
    }.

MIR::Operation::UInt16ToFloat64
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::vectorScalarIntegerWithExtensionConversionRegisterConstrations;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::movzx: (instruction firstOperandRegister x86::int32For: codegen) src: (instruction firstOperandRegister x86::int16For: codegen);
            x86::cvtsi2sd: (instruction resultRegister x86::float64For: codegen) src: (instruction firstOperandRegister x86::int32For: codegen)
    }.

MIR::Operation::Int32ToFloat32
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::vectorScalarIntegerConversionRegisterConstrations;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection x86::cvtsi2ss: (instruction resultRegister x86::float32For: codegen) src: (instruction firstOperandRegister x86::int32For: codegen)
    }.

MIR::Operation::Int32ToFloat64
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::vectorScalarIntegerConversionRegisterConstrations;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection x86::cvtsi2sd: (instruction resultRegister x86::float64For: codegen) src: (instruction firstOperandRegister x86::int32For: codegen)
    }.

MIR::Operation::UInt32ToFloat32
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::vectorScalarIntegerConversionRegisterConstrations;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection x86::cvtsi2ss: (instruction resultRegister x86::float32For: codegen) src: (instruction firstOperandRegister x86::int32For: codegen)
    }.

MIR::Operation::IEEEUInt32ToFloat32
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::vectorScalarIntegerConversionRegisterConstrations;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection x86::movd: (instruction resultRegister x86::float32For: codegen) src: (instruction firstOperandRegister x86::int32For: codegen)
    }.

MIR::Operation::UInt32ToFloat64
    forTargets: #(x86 x86_64) registerConstraintsWith: x86::vectorScalarIntegerConversionRegisterConstrations;
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection x86::cvtsi2sd: (instruction resultRegister x86::float64For: codegen) src: (instruction firstOperandRegister x86::int32For: codegen)
    }.

MIR::Operation::Int64ToFloat32
    forTarget: #x86_64 registerConstraintsWith: x86::vectorScalarIntegerConversionRegisterConstrations;
    forTarget: #x86_64 generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection x86::cvtsi2ss: (instruction resultRegister x86::float32For: codegen) src: (instruction firstOperandRegister x86::int64For: codegen)
    }.

MIR::Operation::Int64ToFloat64
    forTarget: #x86_64 registerConstraintsWith: x86::vectorScalarIntegerConversionRegisterConstrations;
    forTarget: #x86_64 generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection x86::cvtsi2sd: (instruction resultRegister x86::float64For: codegen) src: (instruction firstOperandRegister x86::int64For: codegen)
    }.

MIR::Operation::UInt64ToFloat32
    forTarget: #x86_64 registerConstraintsWith: x86::vectorScalarIntegerConversionRegisterConstrations;
    forTarget: #x86_64 generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection x86::cvtsi2ss: (instruction resultRegister x86::float32For: codegen) src: (instruction firstOperandRegister x86::int64For: codegen)
    }.

MIR::Operation::UInt64ToFloat64
    forTarget: #x86_64 registerConstraintsWith: x86::vectorScalarIntegerConversionRegisterConstrations;
    forTarget: #x86_64 generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection x86::cvtsi2sd: (instruction resultRegister x86::float64For: codegen) src: (instruction firstOperandRegister x86::int64For: codegen)
    }.

MIR::Operation::IEEEUInt64ToFloat64
    forTarget: #x86_64 registerConstraintsWith: x86::vectorScalarIntegerConversionRegisterConstrations;
    forTarget: #x86_64 generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection x86::movq: (instruction resultRegister x86::float64For: codegen) src: (instruction firstOperandRegister x86::int64For: codegen)
    }.

MIR::Operation::Branch
    forTargets: #(x86 x86_64) registerConstraintsWith: {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
        allocator allocateRegisterOrRelativeImmediate32ForInstruction: instruction operandAt: 0sz
    };
    forTarget: #x86 generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection x86::jmp: (instruction firstOperandRegister x86::relCall32OrInt32For: codegen)
    };
    forTarget: #x86_64 generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection x86::jmp: (instruction firstOperandRegister x86::relCall32OrInt64For: codegen)
    }.

MIR::Operation::ConditionalBranch
    forTargets: #(x86 x86_64) registerConstraintsWith: {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
        allocator
            allocateRegisterForInstruction: instruction operandAt: 0sz;
            allocateRegisterOrRelativeImmediate32ForInstruction: instruction operandAt: 1sz;
            allocateRegisterOrRelativeImmediate32ForInstruction: instruction operandAt: 2sz
    };
    forTarget: #x86 generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::test: (instruction firstOperandRegister x86::int8For: codegen) with: (instruction firstOperandRegister x86::int8For: codegen);
            x86::jz: (instruction thirdOperandRegister x86::relCall32OrInt32For: codegen);
            x86::jmp: (instruction secondOperandRegister x86::relCall32OrInt32For: codegen)
    };
    forTarget: #x86_64 generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection
            x86::test: (instruction firstOperandRegister x86::int8For: codegen) with: (instruction firstOperandRegister x86::int8For: codegen);
            x86::jz: (instruction thirdOperandRegister x86::relCall32OrInt64For: codegen);
            x86::jmp: (instruction secondOperandRegister x86::relCall32OrInt64For: codegen)
    }.

MIR::Operation::CallInt8
    forTargets: #(x86 x86_64) registerConstraintsWith: {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
        instruction callingConvention registerConstraintsOfCallInt8: instruction with: allocator
    };
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        instruction callingConvention asm::generateCallInt8: instruction with: codegen
    }.

MIR::Operation::CallInt16
    forTargets: #(x86 x86_64) registerConstraintsWith: {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
        instruction callingConvention registerConstraintsOfCallInt16: instruction with: allocator
    };
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        instruction callingConvention asm::generateCallInt16: instruction with: codegen
    }.

MIR::Operation::CallInt32
    forTargets: #(x86 x86_64) registerConstraintsWith: {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
        instruction callingConvention registerConstraintsOfCallInt32: instruction with: allocator
    };
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        instruction callingConvention asm::generateCallInt32: instruction with: codegen
    }.

MIR::Operation::CallInt64
    forTargets: #(x86 x86_64) registerConstraintsWith: {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
        instruction callingConvention registerConstraintsOfCallInt64: instruction with: allocator
    };
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        instruction callingConvention asm::generateCallInt64: instruction with: codegen
    }.

MIR::Operation::CallPointer
    forTargets: #(x86 x86_64) registerConstraintsWith: {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
        instruction callingConvention registerConstraintsOfCallPointer: instruction with: allocator
    };
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        instruction callingConvention asm::generateCallPointer: instruction with: codegen
    }.

MIR::Operation::CallFloat32
    forTargets: #(x86 x86_64) registerConstraintsWith: {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
        instruction callingConvention registerConstraintsOfCallFloat32: instruction with: allocator
    };
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        instruction callingConvention asm::generateCallFloat32: instruction with: codegen
    }.

MIR::Operation::CallFloat64
    forTargets: #(x86 x86_64) registerConstraintsWith: {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
        instruction callingConvention registerConstraintsOfCallFloat64: instruction with: allocator
    };
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        instruction callingConvention asm::generateCallFloat64: instruction with: codegen
    }.

MIR::Operation::CallStruct
    forTargets: #(x86 x86_64) registerConstraintsWith: {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
        instruction callingConvention registerConstraintsOfCallStruct: instruction with: allocator
    };
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        instruction callingConvention asm::generateCallStruct: instruction with: codegen
    }.

MIR::Operation::CallVoid
    forTargets: #(x86 x86_64) registerConstraintsWith: {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
        instruction callingConvention registerConstraintsOfCallVoid: instruction with: allocator
    };
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        instruction callingConvention asm::generateCallVoid: instruction with: codegen
    }.

MIR::Operation::ReturnInt8
    forTarget: #x86 registerConstraintsWith: {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
        allocator allocateRegister: MIR::X86::EAX forInstruction: instruction operandAt: 0sz
    };
    forTarget: #x86_64 registerConstraintsWith: {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
        allocator allocateRegister: MIR::X86_64::RAX forInstruction: instruction operandAt: 0sz
    };
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen emitEpilogue.
        codegen textSection x86::ret.
        codegen stackFrameLayout hasRequiredConstruction ifTrue: (codegen textSection cfiEndEpilogue).
    }.

MIR::Operation::ReturnInt16
    forTarget: #x86 registerConstraintsWith: {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
        allocator allocateRegister: MIR::X86::EAX forInstruction: instruction operandAt: 0sz
    };
    forTarget: #x86_64 registerConstraintsWith: {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
        allocator allocateRegister: MIR::X86_64::RAX forInstruction: instruction operandAt: 0sz
    };
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen emitEpilogue.
        codegen textSection x86::ret.
        codegen stackFrameLayout hasRequiredConstruction ifTrue: (codegen textSection cfiEndEpilogue).
    }.

MIR::Operation::ReturnInt32
    forTarget: #x86 registerConstraintsWith: {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
        allocator allocateRegister: MIR::X86::EAX forInstruction: instruction operandAt: 0sz
    };
    forTarget: #x86_64 registerConstraintsWith: {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
        allocator allocateRegister: MIR::X86_64::RAX forInstruction: instruction operandAt: 0sz
    };
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen emitEpilogue.
        codegen textSection x86::ret.
        codegen stackFrameLayout hasRequiredConstruction ifTrue: (codegen textSection cfiEndEpilogue).
    }.

MIR::Operation::ReturnPointer
    forTarget: #x86 registerConstraintsWith: {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
        allocator allocateRegister: MIR::X86::EAX forInstruction: instruction operandAt: 0sz
    };
    forTarget: #x86_64 registerConstraintsWith: {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
        allocator allocateRegister: MIR::X86_64::RAX forInstruction: instruction operandAt: 0sz
    };
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen emitEpilogue.
        codegen textSection x86::ret.
        codegen stackFrameLayout hasRequiredConstruction ifTrue: (codegen textSection cfiEndEpilogue).
    }.

MIR::Operation::ReturnInt64
    forTarget: #x86_64 registerConstraintsWith: {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
        allocator allocateRegister: MIR::X86_64::RAX forInstruction: instruction operandAt: 0sz
    };
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen emitEpilogue.
        codegen textSection x86::ret.
        codegen stackFrameLayout hasRequiredConstruction ifTrue: (codegen textSection cfiEndEpilogue).
    }.

MIR::Operation::ReturnFloat32
    forTarget: #x86 registerConstraintsWith: {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
        allocator allocateRegister: MIR::X86::XMM0 forInstruction: instruction operandAt: 0sz
    };
    forTarget: #x86_64 registerConstraintsWith: {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
        allocator allocateRegister: MIR::X86::XMM0 forInstruction: instruction operandAt: 0sz
    };
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen emitEpilogue.
        codegen textSection x86::ret.
        codegen stackFrameLayout hasRequiredConstruction ifTrue: (codegen textSection cfiEndEpilogue).
    }.

MIR::Operation::ReturnFloat64
    forTarget: #x86 registerConstraintsWith: {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
        allocator allocateRegister: MIR::X86::XMM0 forInstruction: instruction operandAt: 0sz
    };
    forTarget: #x86_64 registerConstraintsWith: {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
        allocator allocateRegister: MIR::X86::XMM0 forInstruction: instruction operandAt: 0sz
    };
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen emitEpilogue.
        codegen textSection x86::ret.
        codegen stackFrameLayout hasRequiredConstruction ifTrue: (codegen textSection cfiEndEpilogue).
    }.

MIR::Operation::ReturnStruct
    forTargets: #(x86 x86_64) registerConstraintsWith: {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void |
        allocator allocateMemoryForInstruction: instruction operandAt: 0sz
    };
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen emitEpilogue.
        codegen textSection x86::ret.
        codegen stackFrameLayout hasRequiredConstruction ifTrue: (codegen textSection cfiEndEpilogue).
    }.

MIR::Operation::ReturnVoid
    forTargets: #(x86 x86_64) registerConstraintsWith: {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void | };
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen emitEpilogue.
        codegen textSection x86::ret.
        codegen stackFrameLayout hasRequiredConstruction ifTrue: (codegen textSection cfiEndEpilogue).
    }.

MIR::Operation::Trap
    forTargets: #(x86 x86_64) registerConstraintsWith: {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void | };
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection x86::int3
    }.

MIR::Operation::UnreachableTrap
    forTargets: #(x86 x86_64) registerConstraintsWith: {:(MIRInstruction)instruction :(MIRRegisterAllocator)allocator :: Void | };
    forTargets: #(x86 x86_64) generateWith: {:(MIRInstruction)instruction :(MIRFunctionAsmCodeGenerator)codegen :: Void |
        codegen textSection x86::ud2
    }.

AsmX86CompilationTarget extend: {
    public method asMirCompilationTarget => MIRX86CompilationTarget
        := MIRX86CompilationTarget new asmCompilationTarget: self; yourself
}.

AsmX86_64CompilationTarget extend: {
    public method asMirCompilationTarget => MIRX86_64CompilationTarget
        := MIRX86_64CompilationTarget new asmCompilationTarget: self; yourself.
}.
