public class AsmX86Instruction superclass: AsmStreamElement.
public final class AsmX86RegisterAddress superclass: AsmRegisterAddress.

let X86NopPatterns := #(
    #[16r90]
    #[16r66 16r90]                        ##2 - xchg ax ax (o16 nop)
    #[16r0f 16r1f 16r00]                         ##3 - nop(3)
    #[16r0f 16r1f 16r40 16r00]                   ##4 - nop(4)
    #[16r0f 16r1f 16r44 16r00 16r00]             ##5 - nop(5)
    #[16r66 16r0f 16r1f 16r44 16r00 16r00]       ##6 - nop(6)
    #[16r0f 16r1f 16r80 16r00 16r00 16r00 16r00] ##7 - nop(7)
    #[16r0f 16r1f 16r84 16r00 16r00 16r00 16r00  ##8 - nop(8)
        16r00]
    #[16r66 16r0f 16r1f 16r84 16r00 16r00 16r00  ##9 - nop(9)
        16r00 16r00]
    #[16r66 16r2e 16r0f 16r1f 16r84 16r00 16r00  ##10 - o16 cs nop
        16r00 16r00 16r00]
    #[16r66 16r66 16r2e 16r0f 16r1f 16r84 16r00  ##11 - 2x o16 cs nop
        16r00 16r00 16r00 16r00]
    #[16r66 16r66 16r66 16r2e 16r0f 16r1f 16r84  ##12 - 3x o16 cs nop
        16r00 16r00 16r00 16r00 16r00]
    #[16r66 16r66 16r66 16r66 16r2e 16r0f 16r1f  ##13 - 4x o16 cs nop
        16r84 16r00 16r00 16r00 16r00 16r00]
    #[16r66 16r66 16r66 16r66 16r66 16r2e 16r0f  ##14 - 5x o16 cs nop
        16r1f 16r84 16r00 16r00 16r00 16r00 16r00]
    #[16r66 16r66 16r66 16r66 16r66 16r66 16r2e  ##15 - 6x o16 cs nop
        16r0f 16r1f 16r84 16r00 16r00 16r00 16r00 16r00]
).

public abstract class AsmAbstractX86CompilationTarget superclass: AsmCompilationTarget; definition: {
    public override method padCodeSectionData: (data: ByteArray) at: (offset: Size) size: (size: Size) unreachable: (unreachable: Boolean) ::=> Void := {
        let writeOffset mutable := offset.
        let endWriteOffset := writeOffset + size.

        unreachable ifTrue: {
            while: writeOffset < endWriteOffset do: (
                data at: writeOffset put: 16rCC u8 ## X86: Int3
            ) continueWith: (writeOffset := writeOffset + 1sz).

        } ifFalse: {
            let remainingSize mutable := size.
            while: (remainingSize > 0sz) do: {
                let paddingPattern => ByteArray := X86NopPatterns at: (remainingSize min: X86NopPatterns size) - 1sz.
                let paddingPatternSize := paddingPattern size.
                data replaceBytesFrom: writeOffset count: paddingPatternSize with: paddingPattern.
                remainingSize := remainingSize - paddingPatternSize.
                writeOffset := writeOffset + paddingPatternSize
            }.
        }.
    }.
}.

public final class AsmX86CompilationTarget superclass: AsmAbstractX86CompilationTarget; definition: {
    public override method pointerSize => Size
        := 4sz.

    public override method indirectBranchTargetAlignment => Size
        := 16sz.

    public override method uintPointerType => Type
        := UInt32.

    public override method elfMachine => UInt16
        := Elf::Machine::I386.

    public override method coffMachine => UInt16
        := Coff::ImageFileMachine::I386.

    public override method machoCPUType => Int32
        := MachO::CPUType::I386.

    public override method machoCPUSubtype => Int32
        := MachO::CPUSubtype::X86::All.

    public override method usesElfRelStyleRelocations => Boolean
        := true.

    public override method convertRelocationIntoElf32Rel: (relocation: AsmObjectCodeRelocation) withSymbolTable: (symbolTable: Elf32::SymbolTable) ::=> Elf32::Rel
        := relocation convertIntoX86RelWithSymbolTable: symbolTable.

    public override method convertCoffRelocationTypeOf: (relocation: AsmObjectCodeRelocation) ::=> UInt16
        := relocation x86::coffRelocationType.
}.

public final class AsmX86_64CompilationTarget superclass: AsmAbstractX86CompilationTarget; definition: {
    public override method pointerSize => Size
        := 8sz.

    public override method uintPointerType => Type
        := UInt64.

    public override method indirectBranchTargetAlignment => Size
        := 16sz.

    public override method elfMachine => UInt16
        := Elf::Machine::X86_64.

    public override method coffMachine => UInt16
        := Coff::ImageFileMachine::AMD64.

    public override method machoCPUType => Int32
        := MachO::CPUType::X86_64.

    public override method machoCPUSubtype => Int32
        := MachO::CPUSubtype::X86::All.

    public override method usesElfRelStyleRelocations => Boolean
        := false.

    public override method dwarf::returnAddressRegister => UInt8 := 16u8. ## rip
    public override method dwarf::stackPointerRegister => UInt8 := 7u8. ## rsp
    public override method dwarf::framePointerRegister => UInt8 := 6u8. ## rbp

    public override method convertRelocationIntoElf64Rela: (relocation: AsmObjectCodeRelocation) withSymbolTable: (symbolTable: Elf64::SymbolTable) ::=> Elf64::Rela
        := relocation convertIntoX86_64RelaWithSymbolTable: symbolTable.

    public override method convertCoffRelocationTypeOf: (relocation: AsmObjectCodeRelocation) ::=> UInt16
        := relocation x86_64::coffRelocationType.
}.

AsmCompilationTarget extend: {
    __Meta__ extend: {
        public method x86 => AsmX86CompilationTarget
            := AsmX86CompilationTarget new.

        public method x86_64 => AsmX86_64CompilationTarget
            := AsmX86_64CompilationTarget new.

        public method default => AsmCompilationTarget
            := self x86_64.
    }.
}.

AsmInstructionOperand extend: {
    public virtual method x86::isByteRegister => Boolean := false.
    public virtual method x86::isWordRegister => Boolean := false.
    public virtual method x86::isRegisterAddress => Boolean := false.

    public virtual method x86::isRegisterAL => Boolean := false.
    public virtual method x86::isRegisterAX => Boolean := false.
    public virtual method x86::isRegisterCL => Boolean := false.

    public virtual method x86::valueLow => UInt8
        := self error: "Not a x86 register.".

    public virtual method x86::rexRegBit => UInt8 := 0u8.
    public virtual method x86::rexBaseBit => UInt8 := 0u8.
    public virtual method x86::rexIndexBit => UInt8 := 0u8.

    public virtual method x86::rexByteRequired => Boolean := false.

    public virtual method x86::encodeModRMWithRegOpcode: (opcode: UInt8) immediateSize: (immediateSize: Size)
        longMode: (longMode: Boolean) into: (codeStream: AsmObjectCodeStream) ::=> Void
        := self subclassResponsibility.

    public method x86::encodeModRMWithReg: (reg: AsmInstructionOperand) immediateSize: (immediateSize: Size)
        longMode: (longMode: Boolean) into: (codeStream: AsmObjectCodeStream) ::=> Void := {
        self x86::encodeModRMWithRegOpcode: reg x86::valueLow immediateSize: immediateSize longMode: longMode into: codeStream
    }.
}.

public class AsmX86Register superclass: AsmRegister; definition: {
    public field name => Symbol.
    public field value => UInt8.
    public field dwarf::value32 => UInt32.
    public field dwarf::value64 => UInt32.

    __Meta__ definition: {
        public method name: (name: Symbol) value: (value: UInt8) dwarf32: (dwarf32: UInt32) dwarf64: (dwarf64: UInt32) ::=> self
            := self new name: name; value: value; dwarf::value32: dwarf32; dwarf::value64: dwarf64; yourself.

        public method name: (name: Symbol) value: (value: UInt8) dwarf64: (dwarf64: UInt32) ::=> self
            := self new name: name; value: value; dwarf::value32: -1u32; dwarf::value64: dwarf64; yourself.
    }.

    public override method dwarf::registerNumberForTarget: (compilationTarget: AsmCompilationTarget) ::=> UInt32
        := compilationTarget pointerSize = 8sz
            ifTrue: dwarf::value64
            ifFalse: dwarf::value32.

    public override method x86::valueLow => UInt8
        := value & 7u8.

    public method isHighRegister => Boolean
        := value >= 8u8.

    public method isLowRegister => Boolean
        := value < 8u8.

    public override method x86::rexRegBit => UInt8
        := if: self isHighRegister then: 1u8 else: 0u8.

    public override method x86::rexBaseBit => UInt8
        := if: self isHighRegister then: 1u8 else: 0u8.

    public override method printOn: (stream: Stream) ::=> Void := {
        stream string: name
    }.

    public override method x86::encodeModRMWithRegOpcode: (opcode: UInt8) immediateSize: (immediateSize: Size)
        longMode: (longMode: Boolean) into: (codeStream: AsmObjectCodeStream) ::=> Void := {
        codeStream nextPut: ((3u8 << 6u8) | (opcode << 3u8)) | self x86::valueLow
    }.

    public method * (scale: UInt8) ::=> AsmX86RegisterAddress
        := AsmX86RegisterAddress new
            index: self;
            scale: scale;
            yourself.
}.

AsmX86RegisterAddress definition: {
    public field scaleShift => UInt8.
    public field size => Size.

    public field base => AsmX86Register.
    public field index => AsmX86Register.
    public field displacement => AsmImmediate.

    __Meta__ definition: {
        public method size: (size: UInt8) displacement: (displacement: AsmImmediate) ::=> self
            := self new
                size: size asSize;
                displacement: displacement;
                yourself.

        public method base: (base: AsmX86Register) size: (size: UInt8) displacement: (displacement: AsmImmediate) ::=> self
            := self new
                base: base;
                size: size asSize;
                displacement: displacement;
                yourself.
    }.

    public override method x86::isRegisterAddress => Boolean
        := true.

    public override method x86::rexBaseBit => UInt8
        := base ifNil: 0u8 ifNotNil: base x86::rexRegBit.

    public override method x86::rexIndexBit => UInt8
        := index ifNil: 0u8 ifNotNil: index x86::rexRegBit.

    __Meta__ definition: {
        public method base: (base: AsmX86Register) size: (size: UInt8) ::=> self
            := self new base: base; size: size asSize; yourself.
    }.

    let sizeNameTable := #{
        1sz : "byte ptr".
        2sz : "word ptr".
        4sz : "dword ptr".
        8sz : "qword ptr".
        16sz : "oword ptr".
    }.

    public method scale => UInt8
        := 1u8 << scaleShift.

    public method scale: (scale: UInt8) ::=> Void := {
        scale = 1u8 ifTrue: (scaleShift := 0u8).
        scale = 2u8 ifTrue: (scaleShift := 1u8).
        scale = 4u8 ifTrue: (scaleShift := 2u8).
    }.

    public method needsSibByte => Boolean
        := (base isNotNil && (base x86::valueLow = #* ESP *# 4u8)) || index isNotNil.

    public method hasSmallDisplacement => Boolean
        := displacement isNil || displacement isImmediateSigned8.

    public override method x86::encodeModRMWithRegOpcode: (opcode: UInt8) immediateSize: (immediateSize: Size)
        longMode: (longMode: Boolean) into: (codeStream: AsmObjectCodeStream) ::=> Void := {

        let needsSib := self needsSibByte.
        let sibByte mutable := 0u8.

        needsSib ifTrue: {
            let baseValue := base ifNil: (5u8) ifNotNil: (base x86::valueLow).
            let indexValue := index ifNil: (4u8) ifNotNil: (index x86::valueLow).
            sibByte := (scaleShift << 6u8) | (indexValue << 3u8) | baseValue.
        }.

        let hasDisplacement mutable := false.
        let hasSmallDisplacement mutable := false.
        let modBaseValue mutable := 0u8.
        let mod mutable := 0u8.

        needsSib && (base x86::valueLow = #* EBP *# 5u8) ifTrue: {
            hasDisplacement := true.
            hasSmallDisplacement := self hasSmallDisplacement.
            mod := hasSmallDisplacement ifTrue: 1u8 ifFalse: 2u8
        } ifFalse: {
            displacement isNil && (base x86::valueLow ~= 5u8) ifTrue: {
                mod := 0u8
            } ifFalse: {
                hasDisplacement := true.
                hasSmallDisplacement := self hasSmallDisplacement.
                mod := hasSmallDisplacement ifTrue: 1u8 ifFalse: 2u8.
                base isNil && hasSmallDisplacement not && needsSib not ifTrue: (mod := 0u8)
            }
        }.

        needsSib ifTrue: {
            modBaseValue := 4u8
        } ifFalse: {
            base ifNotNil: {
                modBaseValue := base x86::valueLow
            } ifNil: {
                hasSmallDisplacement := false.
                self assert: displacement isNotNil.
                modBaseValue := 5u8
            }
        }.

        codeStream nextPut: (mod << 6u8) | (opcode << 3u8) | modBaseValue.
        needsSib ifTrue: (codeStream nextPut: sibByte).

        hasDisplacement ifTrue: {
            hasSmallDisplacement ifTrue: {
                displacement ifNil: {
                    codeStream nextPut: 0u8
                } ifNotNil: {
                    codeStream nextPutInt8: displacement asImmediateSigned8Value
                }.
            } ifFalse: {
                (mod = 0u8) && longMode ifTrue: {
                    codeStream nextPutIPRelativeI32: displacement extraOffset: immediateSize asInt32 + 4i32
                } ifFalse: {
                    codeStream nextPutImmediate32: displacement
                }
            }
        }.
    }.

    public method + (nextComponent: AsmInstructionOperand) ::=> SelfType := {
        nextComponent x86::isRegisterAddress ifTrue: {
            let nextRegisterAddress := nextComponent downCastTo: AsmX86RegisterAddress.
            self copy
                index: nextRegisterAddress index;
                scaleShift: nextRegisterAddress scaleShift;
                displacement: nextRegisterAddress displacement;
                yourself
        } ifFalse: {
            self copy
                displacement: (nextComponent downCastTo: AsmImmediate);
                yourself
        }
    }.

    public override method printOn: (stream: Stream) ::=> Void := {
        stream nextPutAll: ((sizeNameTable atOrNil: size) ifNil: "struct"); nextPutAll: " [".
        let hasPrevious mutable := false.
        base ifNotNil: {
            stream print: base.
            hasPrevious := true.
        }.
        index ifNotNil: {
            hasPrevious ifTrue: (stream nextPutAll: " + ").
            stream print: index; nextPut: '*'c8; print: self scale.
            hasPrevious := true.
        }.
        displacement ifNotNil: {
            hasPrevious ifTrue: (stream nextPutAll: " + ").
            stream print: displacement.
        }.

        stream nextPutAll: "]".
    }.
}.

AsmSymbol extend: {
    public method x86::bytePtr => AsmRegisterAddress
        := AsmX86RegisterAddress size: 1u8 displacement: self dword.

    public method x86::wordPtr => AsmRegisterAddress
        := AsmX86RegisterAddress size: 2u8 displacement: self dword.

    public method x86::dwordPtr => AsmRegisterAddress
        := AsmX86RegisterAddress size: 4u8 displacement: self dword.

    public method x86::qwordPtr => AsmRegisterAddress
        := AsmX86RegisterAddress size: 8u8 displacement: self dword.
}.

public class AsmX86IntRegister superclass: AsmX86Register; definition: {
    public override method x86::isWordRegister => Boolean := true.

    public override method x86::isRegisterAL => Boolean := (self size = 1sz) && (value = 0u8).
    public override method x86::isRegisterAX => Boolean := (self size ~= 1sz) && (value = 0u8).
    public override method x86::isRegisterCL => Boolean := (self size = 1sz) && (value = 1u8).

    public method x86::byte => AsmX86RegisterAddress
        := AsmX86RegisterAddress base: self size: 1u8.

    public method x86::word => AsmX86RegisterAddress
        := AsmX86RegisterAddress base: self size: 2u8.

    public method x86::dword => AsmX86RegisterAddress
        := AsmX86RegisterAddress base: self size: 4u8.

    public method x86::qword => AsmX86RegisterAddress
        := AsmX86RegisterAddress base: self size: 8u8.
}.

public class AsmX86Int8Register superclass: AsmX86IntRegister; definition: {
    public override method x86::isByteRegister => Boolean := true.
    public override method x86::isWordRegister => Boolean := false.

    public override method size => Size := 1sz.
}.

public class AsmX86Int8RexRegister superclass: AsmX86Int8Register; definition: {
    public override method x86::rexByteRequired => Boolean
        := value >= 4u8.
}.

public class AsmX86Int16Register superclass: AsmX86IntRegister; definition: {
    public override method size => Size := 2sz.
}.

public class AsmX86Int32Register superclass: AsmX86IntRegister; definition: {
    public override method size => Size := 4sz.
}.

public class AsmX86Int64Register superclass: AsmX86IntRegister; definition: {
    public override method size => Size := 8sz.
}.

public class AsmX86VectorRegister superclass: AsmX86Register; definition: {
    public override method size => Size := 16sz.

    public override method isVectorRegister => Boolean := true.
    public override method isVectorRegisterOrRegisterAddress => Boolean := true.
}.

public global X86::AL := AsmX86Int8Register name: #AL value: 0u8 dwarf32: 0u32 dwarf64: 0u32.
public global X86::CL := AsmX86Int8Register name: #CL value: 1u8 dwarf32: 1u32 dwarf64: 1u32.
public global X86::DL := AsmX86Int8Register name: #DL value: 2u8 dwarf32: 2u32 dwarf64: 2u32.
public global X86::BL := AsmX86Int8Register name: #BL value: 3u8 dwarf32: 3u32 dwarf64: 3u32.
public global X86::AH := AsmX86Int8Register name: #AH value: 4u8 dwarf32: 0u32 dwarf64: 0u32.
public global X86::CH := AsmX86Int8Register name: #CH value: 5u8 dwarf32: 1u32 dwarf64: 1u32.
public global X86::DH := AsmX86Int8Register name: #DH value: 6u8 dwarf32: 2u32 dwarf64: 2u32.
public global X86::BH := AsmX86Int8Register name: #BH value: 7u8 dwarf32: 3u32 dwarf64: 3u32.

public global X86::RAXB := AsmX86Int8RexRegister name: #RAXB value: 0u8  dwarf32: 0u32 dwarf64: 0u32.
public global X86::RCXB := AsmX86Int8RexRegister name: #RCXB value: 1u8  dwarf32: 1u32 dwarf64: 1u32.
public global X86::RDXB := AsmX86Int8RexRegister name: #RDXB value: 2u8  dwarf32: 2u32 dwarf64: 2u32.
public global X86::RBXB := AsmX86Int8RexRegister name: #RBXB value: 3u8  dwarf32: 3u32 dwarf64: 3u32.
public global X86::RSPB := AsmX86Int8RexRegister name: #RSPB value: 4u8  dwarf32: 4u32 dwarf64: 7u32.
public global X86::RBPB := AsmX86Int8RexRegister name: #RBPB value: 5u8  dwarf32: 5u32 dwarf64: 6u32.
public global X86::RSIB := AsmX86Int8RexRegister name: #RSIB value: 6u8  dwarf32: 6u32 dwarf64: 4u32.
public global X86::RDIB := AsmX86Int8RexRegister name: #RDIB value: 7u8  dwarf32: 7u32 dwarf64: 5u32.
public global X86::R8B := AsmX86Int8RexRegister  name: #R8B  value: 8u8  dwarf64: 8u32.
public global X86::R9B := AsmX86Int8RexRegister  name: #R9B  value: 9u8  dwarf64: 9u32.
public global X86::R10B := AsmX86Int8RexRegister name: #R10B value: 10u8 dwarf64: 10u32.
public global X86::R11B := AsmX86Int8RexRegister name: #R11B value: 11u8 dwarf64: 11u32.
public global X86::R12B := AsmX86Int8RexRegister name: #R12B value: 12u8 dwarf64: 12u32.
public global X86::R13B := AsmX86Int8RexRegister name: #R13B value: 13u8 dwarf64: 13u32.
public global X86::R14B := AsmX86Int8RexRegister name: #R14B value: 14u8 dwarf64: 14u32.
public global X86::R15B := AsmX86Int8RexRegister name: #R15B value: 15u8 dwarf64: 15u32.

public global X86::AX := AsmX86Int16Register   name: #AX   value:  0u8 dwarf32: 0u32 dwarf64: 0u32.
public global X86::CX := AsmX86Int16Register   name: #CX   value:  1u8 dwarf32: 1u32 dwarf64: 1u32.
public global X86::DX := AsmX86Int16Register   name: #DX   value:  2u8 dwarf32: 2u32 dwarf64: 2u32.
public global X86::BX := AsmX86Int16Register   name: #BX   value:  3u8 dwarf32: 3u32 dwarf64: 3u32.
public global X86::SP := AsmX86Int16Register   name: #SP   value:  4u8 dwarf32: 4u32 dwarf64: 7u32.
public global X86::BP := AsmX86Int16Register   name: #BP   value:  5u8 dwarf32: 5u32 dwarf64: 6u32.
public global X86::SI := AsmX86Int16Register   name: #SI   value:  6u8 dwarf32: 6u32 dwarf64: 4u32.
public global X86::DI := AsmX86Int16Register   name: #DI   value:  7u8 dwarf32: 7u32 dwarf64: 5u32.
public global X86::R8W := AsmX86Int16Register  name: #R8W  value:  8u8 dwarf64: 8u32.
public global X86::R9W := AsmX86Int16Register  name: #R9W  value:  9u8 dwarf64: 9u32.
public global X86::R10W := AsmX86Int16Register name: #R10W value: 10u8 dwarf64: 10u32.
public global X86::R11W := AsmX86Int16Register name: #R11W value: 11u8 dwarf64: 11u32.
public global X86::R12W := AsmX86Int16Register name: #R12W value: 12u8 dwarf64: 12u32.
public global X86::R13W := AsmX86Int16Register name: #R13W value: 13u8 dwarf64: 13u32.
public global X86::R14W := AsmX86Int16Register name: #R14W value: 14u8 dwarf64: 14u32.
public global X86::R15W := AsmX86Int16Register name: #R15W value: 15u8 dwarf64: 15u32.

public global X86::EAX := AsmX86Int32Register  name: #EAX  value:  0u8 dwarf32: 0u32 dwarf64: 0u32.
public global X86::ECX := AsmX86Int32Register  name: #ECX  value:  1u8 dwarf32: 1u32 dwarf64: 1u32.
public global X86::EDX := AsmX86Int32Register  name: #EDX  value:  2u8 dwarf32: 2u32 dwarf64: 2u32.
public global X86::EBX := AsmX86Int32Register  name: #EBX  value:  3u8 dwarf32: 3u32 dwarf64: 3u32.
public global X86::ESP := AsmX86Int32Register  name: #ESP  value:  4u8 dwarf32: 4u32 dwarf64: 7u32.
public global X86::EBP := AsmX86Int32Register  name: #EBP  value:  5u8 dwarf32: 5u32 dwarf64: 6u32.
public global X86::ESI := AsmX86Int32Register  name: #ESI  value:  6u8 dwarf32: 6u32 dwarf64: 4u32.
public global X86::EDI := AsmX86Int32Register  name: #EDI  value:  7u8 dwarf32: 7u32 dwarf64: 5u32.
public global X86::R8D := AsmX86Int32Register  name: #R8D  value:  8u8 dwarf64: 8u32.
public global X86::R9D := AsmX86Int32Register  name: #R9D  value:  9u8 dwarf64: 9u32.
public global X86::R10D := AsmX86Int32Register name: #R10D value: 10u8 dwarf64: 10u32.
public global X86::R11D := AsmX86Int32Register name: #R11D value: 11u8 dwarf64: 11u32.
public global X86::R12D := AsmX86Int32Register name: #R12D value: 12u8 dwarf64: 12u32.
public global X86::R13D := AsmX86Int32Register name: #R13D value: 13u8 dwarf64: 13u32.
public global X86::R14D := AsmX86Int32Register name: #R14D value: 14u8 dwarf64: 14u32.
public global X86::R15D := AsmX86Int32Register name: #R15D value: 15u8 dwarf64: 15u32.

public global X86::RAX := AsmX86Int64Register name: #RAX value:  0u8 dwarf32: 0u32 dwarf64: 0u32.
public global X86::RCX := AsmX86Int64Register name: #RCX value:  1u8 dwarf32: 1u32 dwarf64: 1u32.
public global X86::RDX := AsmX86Int64Register name: #RDX value:  2u8 dwarf32: 2u32 dwarf64: 2u32.
public global X86::RBX := AsmX86Int64Register name: #RBX value:  3u8 dwarf32: 3u32 dwarf64: 3u32.
public global X86::RSP := AsmX86Int64Register name: #RSP value:  4u8 dwarf32: 4u32 dwarf64: 7u32.
public global X86::RBP := AsmX86Int64Register name: #RBP value:  5u8 dwarf32: 5u32 dwarf64: 6u32.
public global X86::RSI := AsmX86Int64Register name: #RSI value:  6u8 dwarf32: 6u32 dwarf64: 4u32.
public global X86::RDI := AsmX86Int64Register name: #RDI value:  7u8 dwarf32: 7u32 dwarf64: 5u32.
public global X86::R8 := AsmX86Int64Register  name: #R8  value:  8u8 dwarf64: 8u32.
public global X86::R9 := AsmX86Int64Register  name: #R9  value:  9u8 dwarf64: 9u32.
public global X86::R10 := AsmX86Int64Register name: #R10 value: 10u8 dwarf64: 10u32.
public global X86::R11 := AsmX86Int64Register name: #R11 value: 11u8 dwarf64: 11u32.
public global X86::R12 := AsmX86Int64Register name: #R12 value: 12u8 dwarf64: 12u32.
public global X86::R13 := AsmX86Int64Register name: #R13 value: 13u8 dwarf64: 13u32.
public global X86::R14 := AsmX86Int64Register name: #R14 value: 14u8 dwarf64: 14u32.
public global X86::R15 := AsmX86Int64Register name: #R15 value: 15u8 dwarf64: 15u32.

public global X86::XMM0 := AsmX86VectorRegister  name: #XMM0  value:  0u8 dwarf32: 21u32 dwarf64: 17u32.
public global X86::XMM1 := AsmX86VectorRegister  name: #XMM1  value:  1u8 dwarf32: 22u32 dwarf64: 18u32.
public global X86::XMM2 := AsmX86VectorRegister  name: #XMM2  value:  2u8 dwarf32: 23u32 dwarf64: 19u32.
public global X86::XMM3 := AsmX86VectorRegister  name: #XMM3  value:  3u8 dwarf32: 24u32 dwarf64: 20u32.
public global X86::XMM4 := AsmX86VectorRegister  name: #XMM4  value:  4u8 dwarf32: 25u32 dwarf64: 21u32.
public global X86::XMM5 := AsmX86VectorRegister  name: #XMM5  value:  5u8 dwarf32: 26u32 dwarf64: 22u32.
public global X86::XMM6 := AsmX86VectorRegister  name: #XMM6  value:  6u8 dwarf32: 27u32 dwarf64: 23u32.
public global X86::XMM7 := AsmX86VectorRegister  name: #XMM7  value:  7u8 dwarf32: 28u32 dwarf64: 24u32.
public global X86::XMM8 := AsmX86VectorRegister  name: #XMM8  value:  8u8 dwarf64: 25u32.
public global X86::XMM9 := AsmX86VectorRegister  name: #XMM9  value:  9u8 dwarf64: 26u32.
public global X86::XMM10 := AsmX86VectorRegister name: #XMM10 value: 10u8 dwarf64: 27u32.
public global X86::XMM11 := AsmX86VectorRegister name: #XMM11 value: 11u8 dwarf64: 28u32.
public global X86::XMM12 := AsmX86VectorRegister name: #XMM12 value: 12u8 dwarf64: 29u32.
public global X86::XMM13 := AsmX86VectorRegister name: #XMM13 value: 13u8 dwarf64: 30u32.
public global X86::XMM14 := AsmX86VectorRegister name: #XMM14 value: 14u8 dwarf64: 31u32.
public global X86::XMM15 := AsmX86VectorRegister name: #XMM15 value: 15u8 dwarf64: 32u32.

public final class AsmX86InstructionDefinition superclass: Object; definition: {
    public field mnemonic => Symbol.
    public field operandNames => Array.
    public field description => String.
    public field alternatives => Array.
}.

public final class AsmX86InstructionTemplate superclass: Object; definition: {
    public field when => ((AsmX86InstructionTemplate, AsmX86Instruction) => Boolean).
    public field whenIfShortDistance => ((AsmX86InstructionTemplate, AsmX86Instruction) => Boolean).
    public field writeWith => ((AsmX86InstructionTemplate, AsmX86Instruction, AsmObjectCodeStream) => Void).

    public field mandatoryPrefix => ByteArray.
    public field opcode => ByteArray.
    public field registerOpcode => UInt8.

    public override method initialize => Void := {
        mandatoryPrefix := #[].
        opcode := #[].
        registerOpcode := 0u8.
    }.

    public method parseDescription: (description: Array) ::=> Void := {
        mandatoryPrefix := description second.
        opcode := description third.
        description size >= 4sz ifTrue: (registerOpcode := description fourth u8).
    }.

    public method canWriteInstruction: (instruction: AsmX86Instruction) ::=> Boolean
        := when(self, instruction).

    public method canWriteInstructionIfShort: (instruction: AsmX86Instruction) ::=> Boolean
        := (whenIfShortDistance ~~ nil) && whenIfShortDistance(self, instruction).

    public method writeInstruction: (instruction: AsmX86Instruction) onObjectCodeStream: (stream: AsmObjectCodeStream) ::=> Void
        := writeWith(self, instruction, stream).
}.

AsmObjectCodeStream definition: {
    public method nextPutX86RexSize: (operandSize: Size) rm: (rm: AsmInstructionOperand) reg: (reg: AsmInstructionOperand) ::=> Void := {
        let wBit := if: operandSize = 8sz then: 1u8 else: 0u8.
        let regBit := reg x86::rexRegBit.
        let baseBit := rm x86::rexBaseBit.
        let indexBit := rm x86::rexIndexBit.

        let lowBits := ((wBit << 3u8) | (regBit << 2u8)) | ((indexBit << 1u8) | (baseBit)).
        (lowBits ~= 0u8) || ((operandSize = 1sz) && self isInX86LongMode && (reg x86::rexByteRequired || rm x86::rexByteRequired)) ifTrue: { 
            self assert: self isInX86LongMode.
            self nextPut: 16r40 u8 | lowBits
        }
    }.

    public method nextPutX86RexSize: (operandSize: Size) ::=> Void := {
        let wBit := if: operandSize = 8sz then: 1u8 else: 0u8.
        let lowBits := (wBit << 3u8).
        (lowBits ~= 0u8) ifTrue: { 
            self assert: self isInX86LongMode.
            self nextPut: 16r40 u8 | lowBits
        }
    }.

    public method nextPutX86RexSize: (operandSize: Size) rm: (rm: AsmInstructionOperand) ::=> Void := {
        let wBit := if: operandSize = 8sz then: 1u8 else: 0u8.
        let baseBit := rm x86::rexBaseBit.
        let indexBit := rm x86::rexIndexBit.

        let lowBits := (wBit << 3u8) | ((indexBit << 1u8) | (baseBit)).
        (lowBits ~= 0u8) || ((operandSize = 1sz) && self isInX86LongMode && rm x86::rexByteRequired)  ifTrue: { 
            self assert: self isInX86LongMode.
            self nextPut: 16r40 u8 | lowBits
        }
    }.

    public method nextPutX86RexRM: (rm: AsmInstructionOperand) reg: (reg: AsmInstructionOperand) ::=> Void := {
        let regBit := reg x86::rexRegBit.
        let baseBit := rm x86::rexBaseBit.
        let indexBit := rm x86::rexIndexBit.

        let lowBits := (regBit << 2u8) | (indexBit << 1u8) | (baseBit).
        (lowBits ~= 0u8) ifTrue: { 
            self assert: self isInX86LongMode.
            self nextPut: 16r40 u8 | lowBits
        }
    }.

    public method nextPutX86SizeOverride: (operandSize: Size) ::=> Void := {
        operandSize = 2sz ifTrue: {
            self nextPut: 16r66 u8
        }.
    }.

    public method nextPutX86RexRM: (rm: AsmInstructionOperand) ::=> Void := {
        let baseBit := rm x86::rexBaseBit.
        let indexBit := rm x86::rexIndexBit.
        let lowBits := (indexBit << 1u8) | baseBit.

        lowBits ~= 0u8 || (self isInX86LongMode && rm x86::rexByteRequired) ifTrue: {
            self assert: self isInX86LongMode.
            self nextPut: 16r40 u8 | lowBits
        }
    }.

    public method nextPutX86Opcode: (opcode: UInt8) plusRegister: (register: AsmInstructionOperand) ::=> Void := {
        self nextPut: opcode + register x86::valueLow
    }.

    public method nextPutX86ModRM: (rm: AsmInstructionOperand) reg: (register: AsmInstructionOperand) immediateSize: (immediateSize: Size) ::=> Void := {
        rm x86::encodeModRMWithReg: register immediateSize: immediateSize longMode: self isInX86LongMode into: self
    }.

    public method nextPutX86ModRM: (rm: AsmInstructionOperand) reg: (register: AsmInstructionOperand) ::=> Void
        := self nextPutX86ModRM: rm reg: register immediateSize: 0sz.

    public method nextPutX86ModRM: (rm: AsmInstructionOperand) regOpcode: (opcode: UInt8) immediateSize: (immediateSize: Size) ::=> Void := {
        rm x86::encodeModRMWithRegOpcode: opcode immediateSize: immediateSize longMode: self isInX86LongMode into: self
    }.

    public method nextPutX86ModRM: (rm: AsmInstructionOperand) regOpcode: (opcode: UInt8) ::=> Void
        := self nextPutX86ModRM: rm regOpcode: opcode immediateSize: 0sz.

    public method nextPutX86ImmediateWord: (immediate: AsmInstructionOperand) withSize: (operandSize: Size) ::=> Void
        := self nextPutImmediate: immediate withSize: (operandSize min: 4sz).

}.

AsmX86Instruction definition: {
    public field definition => AsmX86InstructionDefinition.
    public field activeAlternative => AsmX86InstructionTemplate.
    public field longAlternative => AsmX86InstructionTemplate.
    public field shortAlternative => AsmX86InstructionTemplate.

    public abstract method operandCount => Size
        := self subclassResponsibility.

    public abstract method firstOperand => AsmInstructionOperand
        := self error: "Operand not present.".

    public abstract method secondOperand => AsmInstructionOperand
        := self error: "Operand not present.".

    public override method selectEncodingAlternatives => Void := {
        definition alternatives do: {:(AsmX86InstructionTemplate)eachAlternative :: Void |
            shortAlternative isNil && (eachAlternative canWriteInstructionIfShort: self) ifTrue: {
                shortAlternative := eachAlternative.
            }.
            longAlternative isNil && (eachAlternative canWriteInstruction: self) ifTrue: {
                longAlternative := eachAlternative.
            }.
        }.

        activeAlternative := longAlternative.
        activeAlternative ifNil: {
            self error: "Failed to select encoding alternative for: " -- self fullPrintString
        }

        ## TODO: Add support for the different spanning options.
    }.

    public override method writeOnObjectCodeStream: (stream: AsmObjectCodeStream) ::=> Void := {
        self assert: activeAlternative isNotNil.
        activeAlternative writeInstruction: self onObjectCodeStream: stream
    }.
}.

public final class AsmX86InstructionWithoutOperands superclass: AsmX86Instruction; definition: {
    public override method fullPrintOn: (stream: Stream) ::=> Void := {
        stream string: definition mnemonic.
        self printDebugInfoOn: stream.
    }.

    public override method operandCount => Size := 0sz.
}.

public final class AsmX86InstructionWithSingleOperand superclass: AsmX86Instruction; definition: {
    public field firstOperand => AsmInstructionOperand.

    public override method operandCount => Size := 1sz.

    public override method fullPrintOn: (stream: Stream) ::=> Void := {
        stream string: definition mnemonic; space; print: firstOperand.
        self printDebugInfoOn: stream.
    }.
}.

public final class AsmX86InstructionWithTwoOperands superclass: AsmX86Instruction; definition: {
    public field firstOperand => AsmInstructionOperand.
    public field secondOperand => AsmInstructionOperand.

    public override method operandCount => Size := 2sz.

    public override method fullPrintOn: (stream: Stream) ::=> Void := {
        stream string: definition mnemonic; space; print: firstOperand; nextPutAll: ", "; print: secondOperand.
        self printDebugInfoOn: stream.
    }.
}.

AsmX86InstructionDefinition definition: {
    public method generateStreamBuilderMethod => Void := {
        let selectorBuilder := StringStream new.
        let directSelectorBuilder := StringStream new.
        selectorBuilder nextPutAll: "x86::"; string: mnemonic.
        directSelectorBuilder nextPutAll: "x86::direct::"; string: mnemonic.
        operandNames doWithIndex: {:(Symbol)operandName :(Size)index :: Void |
            if: index ~= 0sz then: {
                selectorBuilder string: operandName.
                directSelectorBuilder string: operandName.
            }.

            selectorBuilder nextPut: ':'c8.
            directSelectorBuilder nextPut: ':'c8.
        }.

        let selector := selectorBuilder asSymbol.
        let directSelector := directSelectorBuilder asSymbol.
        let operandCount := operandNames size.

        ## Zero operand case.
        if: operandCount = 0sz then: {
            let method := {:(AsmStreamBuilder)builder :: AsmX86InstructionWithoutOperands |
                builder addElement: (AsmX86InstructionWithoutOperands new
                    definition: self;
                    yourself)
            } recompileAndOptimize.

            AsmStreamBuilder
                withSelector: directSelector addMethod: method;
                withSelector: selector addMethod: method
        }.

        ## Single operand case.
        if: operandCount = 1sz then: {
            let method := {:(AsmStreamBuilder)builder :(AsmInstructionOperand)operand :: AsmX86InstructionWithSingleOperand |
                builder addElement: (AsmX86InstructionWithSingleOperand new
                    definition: self;
                    firstOperand: operand;
                    yourself)
            } recompileAndOptimize.

            AsmStreamBuilder
                withSelector: directSelector addMethod: method;
                withSelector: selector addMethod: method.
        }.

        ## Two operand case.
        if: operandCount = 2sz then: {
            let method := {:(AsmStreamBuilder)builder :(AsmInstructionOperand)firstOperand :(AsmInstructionOperand)secondOperand :: AsmX86InstructionWithTwoOperands |
                builder addElement: (AsmX86InstructionWithTwoOperands new
                    definition: self;
                    firstOperand: firstOperand;
                    secondOperand: secondOperand;
                    yourself)
            } recompileAndOptimize.

            AsmStreamBuilder
                withSelector: directSelector addMethod: method;
                withSelector: selector addMethod: method.
        }.
    }.
}.

let instructionTemplateTable := #{
    Op: (AsmX86InstructionTemplate new
        when: {:(AsmX86InstructionTemplate)templ :(AsmX86Instruction)instruction :: Boolean | 
            instruction operandCount = 0sz
        };
        writeWith: {:(AsmX86InstructionTemplate)templ :(AsmX86Instruction)instruction :(AsmObjectCodeStream)stream :: Void |
            stream nextPutAll: templ mandatoryPrefix; nextPutAll: templ opcode.
        };
        yourself).
    OpALI8: (AsmX86InstructionTemplate new
        when: {:(AsmX86InstructionTemplate)templ :(AsmX86Instruction)instruction :: Boolean | 
            (instruction operandCount = 2sz) &&
            instruction firstOperand x86::isRegisterAL &&
            instruction secondOperand isImmediate
        };
        writeWith: {:(AsmX86InstructionTemplate)templ :(AsmX86Instruction)instruction :(AsmObjectCodeStream)stream :: Void |
            stream
                nextPutAll: templ mandatoryPrefix;
                nextPutAll: templ opcode;
                nextPutImmediate: instruction secondOperand withSize: 1sz.
        };
        yourself).

    OpAXIw: (AsmX86InstructionTemplate new
        when: {:(AsmX86InstructionTemplate)templ :(AsmX86Instruction)instruction :: Boolean | 
            (instruction operandCount = 2sz) &&
            instruction firstOperand x86::isRegisterAX &&
            instruction secondOperand isImmediate
        };
        writeWith: {:(AsmX86InstructionTemplate)templ :(AsmX86Instruction)instruction :(AsmObjectCodeStream)stream :: Void |
            let register := instruction firstOperand.
            stream
                nextPutAll: templ mandatoryPrefix;
                nextPutX86SizeOverride: register size;
                nextPutX86RexSize: register size;
                nextPutAll: templ opcode;
                nextPutX86ImmediateWord: instruction secondOperand withSize: register size.
        };
        yourself).

    OpBranch32: (AsmX86InstructionTemplate new
        when: {:(AsmX86InstructionTemplate)templ :(AsmX86Instruction)instruction :: Boolean | 
            (instruction operandCount = 1sz) && instruction firstOperand isImmediate
        };
        writeWith: {:(AsmX86InstructionTemplate)templ :(AsmX86Instruction)instruction :(AsmObjectCodeStream)stream :: Void |
            stream nextPutAll: templ mandatoryPrefix; nextPutAll: templ opcode.
            stream nextPutIPRelativeI32: instruction firstOperand
        };
        yourself).
    OpS8: (AsmX86InstructionTemplate new
        when: {:(AsmX86InstructionTemplate)templ :(AsmX86Instruction)instruction :: Boolean | 
            (instruction operandCount = 1sz) && instruction firstOperand isImmediateSigned8
        };
        writeWith: {:(AsmX86InstructionTemplate)templ :(AsmX86Instruction)instruction :(AsmObjectCodeStream)stream :: Void |
            stream nextPutAll: templ mandatoryPrefix; nextPutAll: templ opcode; nextPutInt8: instruction firstOperand asImmediateSigned8Value
        };
        yourself).
    OpIw: (AsmX86InstructionTemplate new
        when: {:(AsmX86InstructionTemplate)templ :(AsmX86Instruction)instruction :: Boolean | 
            (instruction operandCount = 1sz) && instruction firstOperand isImmediate
        };
        writeWith: {:(AsmX86InstructionTemplate)templ :(AsmX86Instruction)instruction :(AsmObjectCodeStream)stream :: Void |
            stream
                nextPutAll: templ mandatoryPrefix;
                nextPutAll: templ opcode;
                nextPutX86ImmediateWord: instruction firstOperand withSize: 4sz
        };
        yourself).
    OppR: (AsmX86InstructionTemplate new
        when: {:(AsmX86InstructionTemplate)templ :(AsmX86Instruction)instruction :: Boolean | 
            (instruction operandCount = 1sz) && instruction firstOperand x86::isWordRegister
        };
        writeWith: {:(AsmX86InstructionTemplate)templ :(AsmX86Instruction)instruction :(AsmObjectCodeStream)stream :: Void |
            let register := instruction firstOperand.
            stream 
                nextPutAll: templ mandatoryPrefix;
                nextPutX86RexRM: register;
                nextPutX86Opcode: templ opcode first plusRegister: register.
        };
        yourself).
    OppRwIww: (AsmX86InstructionTemplate new
        when: {:(AsmX86InstructionTemplate)templ :(AsmX86Instruction)instruction :: Boolean | 
            (instruction operandCount = 2sz) &&
            instruction firstOperand x86::isWordRegister &&
            instruction secondOperand isImmediate &&
            (instruction firstOperand size = instruction secondOperand size)
        };
        writeWith: {:(AsmX86InstructionTemplate)templ :(AsmX86Instruction)instruction :(AsmObjectCodeStream)stream :: Void |
            let register := instruction firstOperand.
            let immediate := instruction secondOperand.
            stream 
                nextPutAll: templ mandatoryPrefix;
                nextPutX86SizeOverride: register size;
                nextPutX86RexSize: register size rm: register;
                nextPutX86Opcode: templ opcode first plusRegister: register;
                nextPutImmediate: immediate withSize: register size
        };
        yourself).

    OppRbIb: (AsmX86InstructionTemplate new
        when: {:(AsmX86InstructionTemplate)templ :(AsmX86Instruction)instruction :: Boolean | 
            (instruction operandCount = 2sz) &&
            instruction firstOperand isRegister &&
            (instruction firstOperand size = 1sz) &&
            instruction secondOperand isImmediate8
        };
        writeWith: {:(AsmX86InstructionTemplate)templ :(AsmX86Instruction)instruction :(AsmObjectCodeStream)stream :: Void |
            let register := instruction firstOperand.
            let immediate := instruction secondOperand.
            stream 
                nextPutAll: templ mandatoryPrefix;
                nextPutX86RexRM: register;
                nextPutX86Opcode: templ opcode first plusRegister: register;
                nextPutImmediate: immediate withSize: 1sz
        };
        yourself).

    OpRmbIb: (AsmX86InstructionTemplate new
        when: {:(AsmX86InstructionTemplate)templ :(AsmX86Instruction)instruction :: Boolean |
            (instruction operandCount = 2sz) &&
            instruction firstOperand isRegisterOrRegisterAddress && 
            (instruction firstOperand size = 1sz) && 
            instruction secondOperand isImmediate8
        };
        writeWith: {:(AsmX86InstructionTemplate)templ :(AsmX86Instruction)instruction :(AsmObjectCodeStream)stream :: Void |
            let registerAddress := instruction firstOperand.
            let immediate := instruction secondOperand.
            let operandSize := registerAddress size.
            stream 
                nextPutAll: templ mandatoryPrefix;
                nextPutX86RexSize: operandSize rm: registerAddress;
                nextPutAll: templ opcode;
                nextPutX86ModRM: registerAddress regOpcode: templ registerOpcode immediateSize: 1sz;
                nextPutImmediate: immediate withSize: 1sz
        };
        yourself).

    OpRmwS8: (AsmX86InstructionTemplate new
        when: {:(AsmX86InstructionTemplate)templ :(AsmX86Instruction)instruction :: Boolean |
            (instruction operandCount = 2sz) &&
                instruction firstOperand isRegisterOrRegisterAddress && 
                instruction secondOperand isImmediateSigned8
        };
        writeWith: {:(AsmX86InstructionTemplate)templ :(AsmX86Instruction)instruction :(AsmObjectCodeStream)stream :: Void |
            let registerAddress := instruction firstOperand.
            let immediate := instruction secondOperand asImmediateSigned8Value.
            let operandSize := registerAddress size.
            stream 
                nextPutAll: templ mandatoryPrefix;
                nextPutX86SizeOverride: operandSize;
                nextPutX86RexSize: operandSize rm: registerAddress;
                nextPutAll: templ opcode;
                nextPutX86ModRM: registerAddress regOpcode: templ registerOpcode immediateSize: 1sz;
                nextPutInt8: immediate
        };
        yourself).
    OpRmbI_1: (AsmX86InstructionTemplate new
        when: {:(AsmX86InstructionTemplate)templ :(AsmX86Instruction)instruction :: Boolean |
            (instruction operandCount = 2sz) &&
            instruction firstOperand isRegisterOrRegisterAddress &&
            (instruction firstOperand size = 1sz) &&
            instruction secondOperand isImmediateValue1
        };
        writeWith: {:(AsmX86InstructionTemplate)templ :(AsmX86Instruction)instruction :(AsmObjectCodeStream)stream :: Void |
            let registerAddress := instruction firstOperand.
            let operandSize := registerAddress size.
            stream 
                nextPutAll: templ mandatoryPrefix;
                nextPutX86SizeOverride: operandSize;
                nextPutX86RexSize: operandSize rm: registerAddress;
                nextPutAll: templ opcode;
                nextPutX86ModRM: registerAddress regOpcode: templ registerOpcode.
        };
        yourself).
    OpRmbIb: (AsmX86InstructionTemplate new
        when: {:(AsmX86InstructionTemplate)templ :(AsmX86Instruction)instruction :: Boolean |
            (instruction operandCount = 2sz) &&
            instruction firstOperand isRegisterOrRegisterAddress &&
            (instruction firstOperand size = 1sz) &&
            instruction secondOperand isImmediate8
        };
        writeWith: {:(AsmX86InstructionTemplate)templ :(AsmX86Instruction)instruction :(AsmObjectCodeStream)stream :: Void |
            let registerAddress := instruction firstOperand.
            let immediate := instruction secondOperand.
            let operandSize := registerAddress size.
            stream 
                nextPutAll: templ mandatoryPrefix;
                nextPutX86SizeOverride: operandSize;
                nextPutX86RexSize: operandSize rm: registerAddress;
                nextPutAll: templ opcode;
                nextPutX86ModRM: registerAddress regOpcode: templ registerOpcode immediateSize: 1sz;
                nextPutImmediate: immediate withSize: 1sz
        };
        yourself).
    OpRmbCL: (AsmX86InstructionTemplate new
        when: {:(AsmX86InstructionTemplate)templ :(AsmX86Instruction)instruction :: Boolean |
            (instruction operandCount = 2sz) &&
            instruction firstOperand isRegisterOrRegisterAddress &&
            (instruction firstOperand size = 1sz) &&
            instruction secondOperand x86::isRegisterCL
        };
        writeWith: {:(AsmX86InstructionTemplate)templ :(AsmX86Instruction)instruction :(AsmObjectCodeStream)stream :: Void |
            let registerAddress := instruction firstOperand.
            let operandSize := registerAddress size.
            stream 
                nextPutAll: templ mandatoryPrefix;
                nextPutX86SizeOverride: operandSize;
                nextPutX86RexSize: operandSize rm: registerAddress;
                nextPutAll: templ opcode;
                nextPutX86ModRM: registerAddress regOpcode: templ registerOpcode.
        };
        yourself).

    OpRmwI_1: (AsmX86InstructionTemplate new
        when: {:(AsmX86InstructionTemplate)templ :(AsmX86Instruction)instruction :: Boolean |
            (instruction operandCount = 2sz) &&
            instruction firstOperand isRegisterOrRegisterAddress && 
            instruction secondOperand isImmediateValue1
        };
        writeWith: {:(AsmX86InstructionTemplate)templ :(AsmX86Instruction)instruction :(AsmObjectCodeStream)stream :: Void |
            let registerAddress := instruction firstOperand.
            let operandSize := registerAddress size.
            stream 
                nextPutAll: templ mandatoryPrefix;
                nextPutX86SizeOverride: operandSize;
                nextPutX86RexSize: operandSize rm: registerAddress;
                nextPutAll: templ opcode;
                nextPutX86ModRM: registerAddress regOpcode: templ registerOpcode.
        };
        yourself).
    OpRmwIb: (AsmX86InstructionTemplate new
        when: {:(AsmX86InstructionTemplate)templ :(AsmX86Instruction)instruction :: Boolean |
            (instruction operandCount = 2sz) &&
            instruction firstOperand isRegisterOrRegisterAddress && 
            instruction secondOperand isImmediate8
        };
        writeWith: {:(AsmX86InstructionTemplate)templ :(AsmX86Instruction)instruction :(AsmObjectCodeStream)stream :: Void |
            let registerAddress := instruction firstOperand.
            let immediate := instruction secondOperand.
            let operandSize := registerAddress size.
            stream 
                nextPutAll: templ mandatoryPrefix;
                nextPutX86SizeOverride: operandSize;
                nextPutX86RexSize: operandSize rm: registerAddress;
                nextPutAll: templ opcode;
                nextPutX86ModRM: registerAddress regOpcode: templ registerOpcode immediateSize: 1sz;
                nextPutImmediate: immediate withSize: 1sz
        };
        yourself).
    OpRmwCL: (AsmX86InstructionTemplate new
        when: {:(AsmX86InstructionTemplate)templ :(AsmX86Instruction)instruction :: Boolean |
            (instruction operandCount = 2sz) &&
            instruction firstOperand isRegisterOrRegisterAddress && 
            instruction secondOperand x86::isRegisterCL
        };
        writeWith: {:(AsmX86InstructionTemplate)templ :(AsmX86Instruction)instruction :(AsmObjectCodeStream)stream :: Void |
            let registerAddress := instruction firstOperand.
            let operandSize := registerAddress size.
            stream 
                nextPutAll: templ mandatoryPrefix;
                nextPutX86SizeOverride: operandSize;
                nextPutX86RexSize: operandSize rm: registerAddress;
                nextPutAll: templ opcode;
                nextPutX86ModRM: registerAddress regOpcode: templ registerOpcode.
        };
        yourself).
    OpRmbOp: (AsmX86InstructionTemplate new
        when: {:(AsmX86InstructionTemplate)templ :(AsmX86Instruction)instruction :: Boolean |
            (instruction operandCount = 1sz) &&
            instruction firstOperand isRegisterOrRegisterAddress &&
            (instruction firstOperand size = 1sz)
        };
        writeWith: {:(AsmX86InstructionTemplate)templ :(AsmX86Instruction)instruction :(AsmObjectCodeStream)stream :: Void |
            let registerAddress := instruction firstOperand.
            let operandSize := registerAddress size.
            stream 
                nextPutAll: templ mandatoryPrefix;
                nextPutX86RexSize: operandSize rm: registerAddress;
                nextPutAll: templ opcode;
                nextPutX86ModRM: registerAddress regOpcode: templ registerOpcode.
        };
        yourself).
    OpRmwOp: (AsmX86InstructionTemplate new
        when: {:(AsmX86InstructionTemplate)templ :(AsmX86Instruction)instruction :: Boolean |
            (instruction operandCount = 1sz) &&
            instruction firstOperand isRegisterOrRegisterAddress
        };
        writeWith: {:(AsmX86InstructionTemplate)templ :(AsmX86Instruction)instruction :(AsmObjectCodeStream)stream :: Void |
            let registerAddress := instruction firstOperand.
            let operandSize := registerAddress size.
            stream 
                nextPutAll: templ mandatoryPrefix;
                nextPutX86SizeOverride: operandSize;
                nextPutX86RexSize: operandSize rm: registerAddress;
                nextPutAll: templ opcode;
                nextPutX86ModRM: registerAddress regOpcode: templ registerOpcode.
        };
        yourself).
    OpRmwIw: (AsmX86InstructionTemplate new
        when: {:(AsmX86InstructionTemplate)templ :(AsmX86Instruction)instruction :: Boolean |
            (instruction operandCount = 2sz) &&
            instruction firstOperand isRegisterOrRegisterAddress && 
            instruction secondOperand isImmediate32
        };
        writeWith: {:(AsmX86InstructionTemplate)templ :(AsmX86Instruction)instruction :(AsmObjectCodeStream)stream :: Void |
            let registerAddress := instruction firstOperand.
            let immediate := instruction secondOperand.
            let operandSize := registerAddress size.
            stream 
                nextPutAll: templ mandatoryPrefix;
                nextPutX86SizeOverride: operandSize;
                nextPutX86RexSize: operandSize rm: registerAddress;
                nextPutAll: templ opcode;
                nextPutX86ModRM: registerAddress regOpcode: templ registerOpcode immediateSize: immediate size;
                nextPutX86ImmediateWord: immediate withSize: operandSize
        };
        yourself).
    OpRmqIsd: (AsmX86InstructionTemplate new
        when: {:(AsmX86InstructionTemplate)templ :(AsmX86Instruction)instruction :: Boolean |
            (instruction operandCount = 2sz) &&
            instruction firstOperand isRegisterOrRegisterAddress && 
            (instruction firstOperand size = 8sz) &&
            instruction secondOperand isImmediateSigned32
        };
        writeWith: {:(AsmX86InstructionTemplate)templ :(AsmX86Instruction)instruction :(AsmObjectCodeStream)stream :: Void |
            let registerAddress := instruction firstOperand.
            let immediate := instruction secondOperand.
            let operandSize := registerAddress size.
            stream 
                nextPutAll: templ mandatoryPrefix;
                nextPutX86RexSize: operandSize rm: registerAddress;
                nextPutAll: templ opcode;
                nextPutX86ModRM: registerAddress regOpcode: templ registerOpcode immediateSize: immediate size;
                nextPutX86ImmediateWord: immediate withSize: operandSize
        };
        yourself).

    OpRmbRb: (AsmX86InstructionTemplate new
        when: {:(AsmX86InstructionTemplate)templ :(AsmX86Instruction)instruction :: Boolean | 
            (instruction operandCount = 2sz) &&
            instruction firstOperand isRegisterOrRegisterAddress && 
            (instruction firstOperand size = 1sz) &&
            instruction secondOperand isRegister &&
            (instruction secondOperand size = 1sz)
        };
        writeWith: {:(AsmX86InstructionTemplate)templ :(AsmX86Instruction)instruction :(AsmObjectCodeStream)stream :: Void |
            let registerAddress := instruction firstOperand.
            let register := instruction secondOperand.
            let operandSize := register size.
            stream 
                nextPutAll: templ mandatoryPrefix;
                nextPutX86RexSize: operandSize rm: registerAddress reg: register;
                nextPutAll: templ opcode;
                nextPutX86ModRM: registerAddress reg: register
        };
        yourself).

    OpRmwRw: (AsmX86InstructionTemplate new
        when: {:(AsmX86InstructionTemplate)templ :(AsmX86Instruction)instruction :: Boolean | 
            (instruction operandCount = 2sz) &&
            instruction firstOperand isRegisterOrRegisterAddress && 
            instruction secondOperand isRegister
        };
        writeWith: {:(AsmX86InstructionTemplate)templ :(AsmX86Instruction)instruction :(AsmObjectCodeStream)stream :: Void |
            let registerAddress := instruction firstOperand.
            let register := instruction secondOperand.
            let operandSize := register size.
            stream 
                nextPutAll: templ mandatoryPrefix;
                nextPutX86SizeOverride: operandSize;
                nextPutX86RexSize: operandSize rm: registerAddress reg: register;
                nextPutAll: templ opcode;
                nextPutX86ModRM: registerAddress reg: register
        };
        yourself).

    OpRbRmb: (AsmX86InstructionTemplate new
        when: {:(AsmX86InstructionTemplate)templ :(AsmX86Instruction)instruction :: Boolean | 
            (instruction operandCount = 2sz) &&
            instruction firstOperand isRegister && 
            (instruction firstOperand size = 1sz) &&
            instruction secondOperand isRegisterOrRegisterAddress &&
            (instruction secondOperand size = 1sz)
        };
        writeWith: {:(AsmX86InstructionTemplate)templ :(AsmX86Instruction)instruction :(AsmObjectCodeStream)stream :: Void |
            let register := instruction firstOperand.
            let registerAddress := instruction secondOperand.
            let operandSize := register size.
            stream 
                nextPutAll: templ mandatoryPrefix;
                nextPutX86RexSize: operandSize rm: registerAddress reg: register;
                nextPutAll: templ opcode;
                nextPutX86ModRM: registerAddress reg: register
        };
        yourself).

    OpRwRmb: (AsmX86InstructionTemplate new
        when: {:(AsmX86InstructionTemplate)templ :(AsmX86Instruction)instruction :: Boolean | 
            (instruction operandCount = 2sz) &&
            instruction firstOperand isRegister && 
            instruction secondOperand isRegisterOrRegisterAddress &&
            (instruction secondOperand size = 1sz)
        };
        writeWith: {:(AsmX86InstructionTemplate)templ :(AsmX86Instruction)instruction :(AsmObjectCodeStream)stream :: Void |
            let register := instruction firstOperand.
            let registerAddress := instruction secondOperand.
            let operandSize := register size.
            stream 
                nextPutAll: templ mandatoryPrefix;
                nextPutX86RexSize: operandSize rm: registerAddress reg: register;
                nextPutAll: templ opcode;
                nextPutX86ModRM: registerAddress reg: register
        };
        yourself).

    OpRwRmw: (AsmX86InstructionTemplate new
        when: {:(AsmX86InstructionTemplate)templ :(AsmX86Instruction)instruction :: Boolean | 
            (instruction operandCount = 2sz) &&
                instruction firstOperand isRegister && 
                instruction secondOperand isRegisterOrRegisterAddress
        };
        writeWith: {:(AsmX86InstructionTemplate)templ :(AsmX86Instruction)instruction :(AsmObjectCodeStream)stream :: Void |
            let register := instruction firstOperand.
            let registerAddress := instruction secondOperand.
            let operandSize := register size.
            stream 
                nextPutAll: templ mandatoryPrefix;
                nextPutX86SizeOverride: operandSize;
                nextPutX86RexSize: operandSize rm: registerAddress reg: register;
                nextPutAll: templ opcode;
                nextPutX86ModRM: registerAddress reg: register
        };
        yourself).

    OpRm: (AsmX86InstructionTemplate new
        when: {:(AsmX86InstructionTemplate)templ :(AsmX86Instruction)instruction :: Boolean | 
            (instruction operandCount = 1sz) &&
                instruction firstOperand isRegisterOrRegisterAddress
        };
        writeWith: {:(AsmX86InstructionTemplate)templ :(AsmX86Instruction)instruction :(AsmObjectCodeStream)stream :: Void |
            let registerAddress := instruction firstOperand.
            let operandSize := registerAddress size.
            stream 
                nextPutAll: templ mandatoryPrefix;
                nextPutX86SizeOverride: operandSize;
                nextPutX86RexRM: registerAddress;
                nextPutAll: templ opcode;
                nextPutX86ModRM: registerAddress regOpcode: templ registerOpcode
        };
        yourself).

    OpRxRmx: (AsmX86InstructionTemplate new
        when: {:(AsmX86InstructionTemplate)templ :(AsmX86Instruction)instruction :: Boolean | 
            (instruction operandCount = 2sz) &&
                instruction firstOperand isVectorRegister && 
                instruction secondOperand isVectorRegisterOrRegisterAddress
        };
        writeWith: {:(AsmX86InstructionTemplate)templ :(AsmX86Instruction)instruction :(AsmObjectCodeStream)stream :: Void |
            let register := instruction firstOperand.
            let registerAddress := instruction secondOperand.
            stream 
                nextPutAll: templ mandatoryPrefix;
                nextPutX86RexRM: registerAddress reg: register;
                nextPutAll: templ opcode;
                nextPutX86ModRM: registerAddress reg: register
        };
        yourself).
    OpRmxRx: (AsmX86InstructionTemplate new
        when: {:(AsmX86InstructionTemplate)templ :(AsmX86Instruction)instruction :: Boolean | 
            (instruction operandCount = 2sz) &&
                instruction firstOperand isVectorRegisterOrRegisterAddress && 
                instruction secondOperand isVectorRegister
        };
        writeWith: {:(AsmX86InstructionTemplate)templ :(AsmX86Instruction)instruction :(AsmObjectCodeStream)stream :: Void |
            let register := instruction secondOperand.
            let registerAddress := instruction firstOperand.
            stream 
                nextPutAll: templ mandatoryPrefix;
                nextPutX86RexRM: registerAddress reg: register;
                nextPutAll: templ opcode;
                nextPutX86ModRM: registerAddress reg: register
        };
        yourself).

    OpRxRmw: (AsmX86InstructionTemplate new
        when: {:(AsmX86InstructionTemplate)templ :(AsmX86Instruction)instruction :: Boolean | 
            (instruction operandCount = 2sz) &&
                instruction firstOperand isVectorRegister && 
                instruction secondOperand isRegisterOrRegisterAddress
        };
        writeWith: {:(AsmX86InstructionTemplate)templ :(AsmX86Instruction)instruction :(AsmObjectCodeStream)stream :: Void |
            let register := instruction firstOperand.
            let registerAddress := instruction secondOperand.
            let operandSize := registerAddress size.
            stream 
                nextPutAll: templ mandatoryPrefix;
                nextPutX86SizeOverride: operandSize;
                nextPutX86RexSize: operandSize rm: registerAddress reg: register;
                nextPutAll: templ opcode;
                nextPutX86ModRM: registerAddress reg: register
        };
        yourself).
    OpRmwRx: (AsmX86InstructionTemplate new
        when: {:(AsmX86InstructionTemplate)templ :(AsmX86Instruction)instruction :: Boolean | 
            (instruction operandCount = 2sz) &&
                instruction firstOperand isRegisterOrRegisterAddress && 
                instruction secondOperand isVectorRegister
        };
        writeWith: {:(AsmX86InstructionTemplate)templ :(AsmX86Instruction)instruction :(AsmObjectCodeStream)stream :: Void |
            let register := instruction secondOperand.
            let registerAddress := instruction firstOperand.
            let operandSize := registerAddress size.
            stream 
                nextPutAll: templ mandatoryPrefix;
                nextPutX86SizeOverride: operandSize;
                nextPutX86RexSize: operandSize rm: registerAddress reg: register;
                nextPutAll: templ opcode;
                nextPutX86ModRM: registerAddress reg: register
        };
        yourself).
    OpRwRmx: (AsmX86InstructionTemplate new
        when: {:(AsmX86InstructionTemplate)templ :(AsmX86Instruction)instruction :: Boolean | 
            (instruction operandCount = 2sz) &&
                instruction firstOperand isRegister && 
                instruction secondOperand isVectorRegisterOrRegisterAddress
        };
        writeWith: {:(AsmX86InstructionTemplate)templ :(AsmX86Instruction)instruction :(AsmObjectCodeStream)stream :: Void |
            let register := instruction firstOperand.
            let registerAddress := instruction secondOperand.
            let operandSize := register size.
            stream 
                nextPutAll: templ mandatoryPrefix;
                nextPutX86SizeOverride: operandSize;
                nextPutX86RexSize: operandSize rm: registerAddress reg: register;
                nextPutAll: templ opcode;
                nextPutX86ModRM: registerAddress reg: register
        };
        yourself).
}.

AsmObjectCodeRelocation extend: {
    public abstract method convertIntoX86RelWithSymbolTable: (symbolTable: Elf32::SymbolTable) ::=> Elf32::Rel
        := self subclassResponsibility.

    public abstract method convertIntoX86_64RelaWithSymbolTable: (symbolTable: Elf64::SymbolTable) ::=> Elf64::Rela
        := self subclassResponsibility.

    public abstract method x86::coffRelocationType => UInt16
        := self subclassResponsibility.

    public abstract method x86_64::coffRelocationType => UInt16
        := self subclassResponsibility.
}.

AsmObjectCodeRelocationRelativeInt32 extend: {
    public override method convertIntoX86RelWithSymbolTable: (symbolTable: Elf32::SymbolTable) ::=> Elf32::Rel
        := Elf32::Rel new
            offset: offset asUInt32;
            symbol: (symbolTable indexOfSymbol: symbol) type: Elf::I386::Rel::PC32;
            yourself.

    public override method convertIntoX86_64RelaWithSymbolTable: (symbolTable: Elf64::SymbolTable) ::=> Elf64::Rela
        := Elf64::Rela new
            offset: offset asUInt64;
            symbol: (symbolTable indexOfSymbol: symbol) type: Elf::X86_64::Rel::PC32;
            addend: addend asInt64 + symbol privateAddend;
            yourself.

    public override method x86::coffRelocationType => UInt16
        := Coff::RelocationType::I386::Rel32.

    public override method x86_64::coffRelocationType => UInt16
        := Coff::RelocationType::AMD64::Rel32.
}.

AsmObjectCodeRelocationRelativeInt32AtPLT extend: {
    public override method convertIntoX86_64RelaWithSymbolTable: (symbolTable: Elf64::SymbolTable) ::=> Elf64::Rela
        := Elf64::Rela new
            offset: offset asUInt64;
            symbol: (symbolTable indexOfSymbol: symbol) type: Elf::X86_64::Rel::PLT32;
            addend: addend asInt64 + symbol privateAddend;
            yourself.
}.

AsmObjectCodeRelocationRelativeInt32AtGOT extend: {
    public override method convertIntoX86_64RelaWithSymbolTable: (symbolTable: Elf64::SymbolTable) ::=> Elf64::Rela
        := Elf64::Rela new
            offset: offset asUInt64;
            symbol: (symbolTable indexOfSymbol: symbol) type: Elf::X86_64::Rel::GOTPCREL;
            addend: addend asInt64 + symbol privateAddend;
            yourself.
}.

AsmObjectCodeRelocationAbsoluteInt64 extend: {
    public override method convertIntoX86_64RelaWithSymbolTable: (symbolTable: Elf64::SymbolTable) ::=> Elf64::Rela
        := Elf64::Rela new
            offset: offset asUInt64;
            symbol: (symbolTable indexOfSymbol: symbol) type: Elf::X86_64::Rel::A64;
            addend: addend asInt64 + symbol privateAddend;
            yourself.
}.

AsmObjectCodeRelocationSectionRelativeInt64 extend: {
    public override method convertIntoX86_64RelaWithSymbolTable: (symbolTable: Elf64::SymbolTable) ::=> Elf64::Rela
        := Elf64::Rela new
            offset: offset asUInt64;
            symbol: (symbolTable indexOfSymbol: symbol) type: Elf::X86_64::Rel::A64;
            addend: addend asInt64 + symbol privateAddend;
            yourself.
}.

let instructionDefinitionTable := #(
    (adc (dst with) "Integer addition with carry."
        (OpALI8 #[] #[16r14])
        (OpAXIw #[] #[16r15])

        (OpRmbIb #[] #[16r80] 2)

        (OpRmwS8 #[] #[16r83] 2)
        (OpRmwIw #[] #[16r81] 2)

		(OpRmbRb #[] #[16r10])
		(OpRmwRw #[] #[16r11])
		(OpRbRmb #[] #[16r12])
		(OpRwRmw #[] #[16r13])
    )

    (add (dst with) "Integer addition."
        (OpALI8 #[] #[16r04])
        (OpAXIw #[] #[16r05])

        (OpRmbIb #[] #[16r80] 0)

        (OpRmwS8 #[] #[16r83] 0)
        (OpRmwIw #[] #[16r81] 0)

		(OpRmbRb #[] #[16r00])
		(OpRmwRw #[] #[16r01])
		(OpRbRmb #[] #[16r02])
		(OpRwRmw #[] #[16r03])
    )

    (and (dst with) "Integer bitwise and."
        (OpALI8 #[] #[16r24])
        (OpAXIw #[] #[16r25])

        (OpRmbIb #[] #[16r80] 4)

        (OpRmwS8 #[] #[16r83] 4)
        (OpRmwIw #[] #[16r81] 4)

		(OpRmbRb #[] #[16r20])
		(OpRmwRw #[] #[16r21])
		(OpRbRmb #[] #[16r22])
		(OpRwRmw #[] #[16r23])
    )

    (call (target) "Call the function in the specified address."
        (OpBranch32 #[] #[16rE8])
        (OpRm #[] #[16rFF] 2)
    )

    (cwd () "Sign extend AX into DX."
        (Op #[] #[16r66 16r99])
    )

    (cdq () "Sign extend EAX into EDX."
        (Op #[] #[16r99])
    )

    (cqo () "Sign extend RAX into RDX."
        (Op #[] #[16r48 16r99])
    )

    (cmp (op with) "Compares by subtracting the specified values."
        (OpALI8 #[] #[16r3C])
        (OpAXIw #[] #[16r3D])

        (OpRmbIb #[] #[16r80] 7)

        (OpRmwS8 #[] #[16r83] 7)
        (OpRmwIw #[] #[16r81] 7)

		(OpRmbRb #[] #[16r38])
		(OpRmwRw #[] #[16r39])
		(OpRbRmb #[] #[16r3A])
		(OpRwRmw #[] #[16r3B])
    )

    (div (div) "Unsigned integer division"
		(OpRmbOp #[] #[16rF6] 6)
        (OpRmwOp #[] #[16rF7] 6)
    )

    (endbr32 () "Ends indirect branch in 32 mode"
        (Op #[] #[16rF3 16r0F 16r1E 16rFB])
    )

    (endbr64 () "Ends indirect branch in 64 mode"
        (Op #[] #[16rF3 16r0F 16r1E 16rFA])
    )

    (idiv (div) "Signed integer division"
		(OpRmbOp #[] #[16rF6] 7)
        (OpRmwOp #[] #[16rF7] 7)
    )

    (imul (dst with) "Integer multiplication"
		(OpRwRmw #[] #[16r0F 16rAF])
    )

    (lea (dst src) "Load effective address."
        (OpRwRmw #[] #[16r8D])
    )

	(lock () "Lock prefix"
		(Op #[] #[16rF0])
	)

    (neg (dst) "Two complement negation"
        (OpRmbOp #[] #[16rF6] 3)
        (OpRmwOp #[] #[16rF7] 3)
    )

    (not (dst) "Bitwise not"
        (OpRmbOp #[] #[16rF6] 2)
        (OpRmwOp #[] #[16rF7] 2)
    )

    (nop () "No operation"
        (Op #[] #[16r90])
    )

    (mov (dst src) "Move values"
		(OppRbIb #[] #[16rB0] 0)
		(OpRmqIsd #[] #[16rC7] 0)
		(OppRwIww #[] #[16rB8])
		(OpRmbIb #[] #[16rC6] 0)
		(OpRmwIw #[] #[16rC7] 0)

        (OpRmbRb #[] #[16r88])
        (OpRmwRw #[] #[16r89])
        (OpRbRmb #[] #[16r8A])
        (OpRwRmw #[] #[16r8B])
    )

	(movsb () "Move data from string into string"
		(Op #[] #[16rA4])
	)

    (movsx (dst src) "Move with sign extension"
		(OpRwRmb #[] #[16r0F 16rBE])
		(OpRwRmw #[] #[16r0F 16rBF])
    )
    (movsxd (dst src) "Move with sign extension into double-word"
		(OpRwRmw #[] #[16r63])
    )
    (movzx (dst src) "Move with zero extension"
		(OpRwRmb #[] #[16r0F 16rB6])
		(OpRwRmw #[] #[16r0F 16rB7])
    )

    (jmp (target) "Jumps into the specified address"
        (OpBranch32 #[] #[16rE9])
        (OpRm #[] #[16rFF] 4)
    )

    (jb (target) "Jumps into the specified address, if below"
        (OpBranch32 #[] #[16r0F 16r82])
    )

    (jae (target) "Jumps into the specified address, if above or equals"
        (OpBranch32 #[] #[16r0F 16r83])
    )

    (jz (target) "Jumps into the specified address, if zero"
        (OpBranch32 #[] #[16r0F 16r84])
    )

    (jnz (target) "Jumps into the specified address, if not zero"
        (OpBranch32 #[] #[16r0F 16r85])
    )

    (jbe (target) "Jumps into the specified address, if below or equals"
        (OpBranch32 #[] #[16r0F 16r86])
    )

    (ja (target) "Jumps into the specified address, if above"
        (OpBranch32 #[] #[16r0F 16r87])
    )

    (jl (target) "Jumps into the specified address, if less"
        (OpBranch32 #[] #[16r0F 16r8C])
    )

    (jge (target) "Jumps into the specified address, if greater or equals"
        (OpBranch32 #[] #[16r0F 16r8D])
    )

    (jle (target) "Jumps into the specified address, if less"
        (OpBranch32 #[] #[16r0F 16r8E])
    )

    (jg (target) "Jumps into the specified address, if greater"
        (OpBranch32 #[] #[16r0F 16r8F])
    )

    (int (number) "Software interruption"
        ##(OpI8 #[] #[16rCD])
    )

    (lzcnt (dst with) "Count leading zeros"
		(OpRwRmw #[16rF3] #[16r0F 16rBD])
    )

	(lock () "Lock prefix"
		(Op #[] #[16rF0])
	)

    (int3 () "Software interruption 3 (Breakpoint)"
        (Op #[] #[16rCC])
    )

    (or (dst with) "Integer bitwise or."
        (OpALI8 #[] #[16r0C])
        (OpAXIw #[] #[16r0D])

        (OpRmbIb #[] #[16r80] 1)

        (OpRmwS8 #[] #[16r83] 1)
        (OpRmwIw #[] #[16r81] 1)

		(OpRmbRb #[] #[16r08])
		(OpRmwRw #[] #[16r09])
		(OpRbRmb #[] #[16r0A])
		(OpRwRmw #[] #[16r0B])
    )

    (pop (dst) "Pops a value from the stack"
        (OppR #[] #[16r58])
    )

    (push (src) "Pushes a value onto the stack"
        (OppR #[] #[16r50])
        (OpRm #[] #[16rFF] 6)
		(OpS8 #[] #[16r6A])
		(OpIw #[] #[16r68])
    )

	(rep () "Rep prefix"
		(Op #[] #[16rF3])
	)

    (ret () "Return from function"
        (Op #[] #[16rC3])
    )

    (sete (dst) "Set byte on equals"
        (OpRm #[] #[16r0F 16r94])
    )
    (setne (dst) "Set byte on not equals"
        (OpRm #[] #[16r0F 16r95])
    )
    (setg (dst) "Set byte on greater than"
        (OpRm #[] #[16r0F 16r9F])
    )
    (setge (dst) "Set byte on greater equals"
        (OpRm #[] #[16r0F 16r9D])
    )
    (setl (dst) "Set byte on less than"
        (OpRm #[] #[16r0F 16r9C])
    )
    (setle (dst) "Set byte on less equals"
        (OpRm #[] #[16r0F 16r9E])
    )
    (seta (dst) "Set byte on above"
        (OpRm #[] #[16r0F 16r97])
    )
    (setae (dst) "Set byte on above equals"
        (OpRm #[] #[16r0F 16r93])
    )
    (setb (dst) "Set byte on below"
        (OpRm #[] #[16r0F 16r92])
    )
    (setbe (dst) "Set byte on below equals"
        (OpRm #[] #[16r0F 16r96])
    )

    (sbb (dst with) "Integer subtraction with borrow"
        (OpALI8 #[] #[16r1C])
        (OpAXIw #[] #[16r1D])

        (OpRmbIb #[] #[16r80] 3)

        (OpRmwS8 #[] #[16r83] 3)
        (OpRmwIw #[] #[16r81] 3)

		(OpRmbRb #[] #[16r18])
		(OpRmwRw #[] #[16r19])
		(OpRbRmb #[] #[16r1A])
		(OpRwRmw #[] #[16r1B])
    )

	(stosb () "Store string"
		(Op #[] #[16rAA])
	)

    (sub (dst with) "Integer subtraction"
        (OpALI8 #[] #[16r2C])
        (OpAXIw #[] #[16r2D])

        (OpRmbIb #[] #[16r80] 5)

        (OpRmwS8 #[] #[16r83] 5)
        (OpRmwIw #[] #[16r81] 5)

		(OpRmbRb #[] #[16r28])
		(OpRmwRw #[] #[16r29])
		(OpRbRmb #[] #[16r2A])
		(OpRwRmw #[] #[16r2B])
    )

    (rcl (dst with) "Rotate with carry left"
        (OpRmbI_1 #[] #[16rD0] 2)
        (OpRmbIb #[] #[16rC0] 2)
        (OpRmbCL #[] #[16rD2] 2)

        (OpRmwI_1 #[] #[16rD1] 2)
        (OpRmwIb #[] #[16rC1] 2)
        (OpRmwCL #[] #[16rD3] 2)
    )

    (rcr (dst with) "Rotate with carry right"
        (OpRmbI_1 #[] #[16rD0] 3)
        (OpRmbIb #[] #[16rC0] 3)
        (OpRmbCL #[] #[16rD2] 3)

        (OpRmwI_1 #[] #[16rD1] 3)
        (OpRmwIb #[] #[16rC1] 3)
        (OpRmwCL #[] #[16rD3] 3)
    )

    (rol (dst with) "Rotate left"
        (OpRmbI_1 #[] #[16rD0] 0)
        (OpRmbIb #[] #[16rC0] 0)
        (OpRmbCL #[] #[16rD2] 0)

        (OpRmwI_1 #[] #[16rD1] 0)
        (OpRmwIb #[] #[16rC1] 0)
        (OpRmwCL #[] #[16rD3] 0)
    )

    (ror (dst with) "Rotate right"
        (OpRmbI_1 #[] #[16rD0] 1)
        (OpRmbIb #[] #[16rC0] 1)
        (OpRmbCL #[] #[16rD2] 1)

        (OpRmwI_1 #[] #[16rD1] 1)
        (OpRmwIb #[] #[16rC1] 1)
        (OpRmwCL #[] #[16rD3] 1)
    )

    (sal (dst with) "Logical shift left"
        (OpRmbI_1 #[] #[16rD0] 4)
        (OpRmbIb #[] #[16rC0] 4)
        (OpRmbCL #[] #[16rD2] 4)

        (OpRmwI_1 #[] #[16rD1] 4)
        (OpRmwIb #[] #[16rC1] 4)
        (OpRmwCL #[] #[16rD3] 4)
    )

    (shr (dst with) "Logical shift right"
        (OpRmbI_1 #[] #[16rD0] 5)
        (OpRmbIb #[] #[16rC0] 5)
        (OpRmbCL #[] #[16rD2] 5)

        (OpRmwI_1 #[] #[16rD1] 5)
        (OpRmwIb #[] #[16rC1] 5)
        (OpRmwCL #[] #[16rD3] 5)
    )

    (sar (dst with) "Arithmetic shift right"
        (OpRmbI_1 #[] #[16rD0] 7)
        (OpRmbIb #[] #[16rC0] 7)
        (OpRmbCL #[] #[16rD2] 7)

        (OpRmwI_1 #[] #[16rD1] 7)
        (OpRmwIb #[] #[16rC1] 7)
        (OpRmwCL #[] #[16rD3] 7)
    )

    (test (op with) "Compares with a bitwise and"
        (OpALI8 #[] #[16rA8])
        (OpAXIw #[] #[16rA9])

		(OpRmbIb #[] #[16rF6] 0)
		(OpRmwIw #[] #[16rF7] 0)

        (OpRmbRb #[] #[16r84])
        (OpRmwRw #[] #[16r85])
        (OpRbRmb #[] #[16r84])
        (OpRwRmw #[] #[16r85])
    )

    (tzcnt (dst with) "Count trailing zeros"
		(OpRwRmw #[16rF3] #[16r0F 16rBC])
    )

    (ud2 () "Undefined. Raise invalid opcode exception."
        (Op #[] #[16r0F 16r0B])
    )

    (xadd (dst with) "Exchange and add"
		(OpRmbRb #[] #[16r0F 16rC0])
		(OpRmwRw #[] #[16r0F 16rC1])
    )

    (xchg (dst with) "Exchange"
		(OppR #[] #[16r90])
		(OpRmbRb #[] #[16r86])
		(OpRmwRw #[] #[16r87])

		(OpRbRmb #[] #[16r86])
		(OpRwRmw #[] #[16r87])
    )

    (xor (dst with) "Integer exclusive or."
        (OpALI8 #[] #[16r34])
        (OpAXIw #[] #[16r35])

        (OpRmwS8 #[] #[16r83] 6)
        (OpRmwIw #[] #[16r81] 6)

		(OpRmbRb #[] #[16r30])
		(OpRmwRw #[] #[16r31])
		(OpRbRmb #[] #[16r32])
		(OpRwRmw #[] #[16r33])
    )

    ## SSE instructions
    (addpd (dst with) "Add packed double"
        (OpRxRmx #[16r66] #[16r0f 16r58])
    )
    (addps (dst with) "Add packed single"
        (OpRxRmx #[] #[16r0f 16r58])
    )
    (addsd (dst with) "Add scalar double"
        (OpRxRmx #[16rf2] #[16r0f 16r58])
    )
    (addss (dst with) "Add scalar single"
        (OpRxRmx #[16rf3] #[16r0f 16r58])
    )

    (cvtsd2si (dst src) "Convert scalar double into scalar integer"
        (OpRwRmx #[16rF2] #[16r0f 16r2D])
    )
    (cvtsd2ss (dst src) "Convert scalar double into scalar single"
        (OpRxRmx #[16rF2] #[16r0f 16r5A])
    )
    (cvtsi2sd (dst src) "Convert scalar integer into scalar double"
        (OpRxRmw #[16rF2] #[16r0f 16r2A])
    )
    (cvtsi2ss (dst src) "Convert scalar integer into scalar single"
        (OpRxRmw #[16rF3] #[16r0f 16r2A])
    )
    (cvtss2sd (dst src) "Convert scalar single into scalar double"
        (OpRxRmx #[16rF3] #[16r0f 16r5A])
    )
    (cvtss2si (dst src) "Convert scalar single into scalar integer"
        (OpRwRmx #[16rF3] #[16r0f 16r2d])
    )

    (cvttss2si (dst src) "Convert scalar single into scalar integer with truncation"
        (OpRwRmx #[16rF3] #[16r0f 16r2c])
    )
    (cvttsd2si (dst src) "Convert scalar double into scalar integer with truncation"
        (OpRwRmx #[16rF2] #[16r0f 16r2c])
    )

    (andpd (dst with) "And packed double"
        (OpRxRmx #[16r66] #[16r0f 16r54])
    )
    (andps (dst with) "And packed single"
        (OpRxRmx #[] #[16r0f 16r54])
    )

    (andnpd (dst with) "And not packed double"
        (OpRxRmx #[16r66] #[16r0f 16r55])
    )
    (andnps (dst with) "And not packed single"
        (OpRxRmx #[] #[16r0f 16r55])
    )


    (divpd (dst with) "Divide packed double"
        (OpRxRmx #[16r66] #[16r0f 16r5e])
    )
    (divps (dst with) "Divide packed single"
        (OpRxRmx #[] #[16r0f 16r5e])
    )
    (divsd (dst with) "Divide scalar double"
        (OpRxRmx #[16rf2] #[16r0f 16r5e])
    )
    (divss (dst with) "Divide scalar single"
        (OpRxRmx #[16rf3] #[16r0f 16r5e])
    )

    (movapd (dst src) "Move aligned packed double"
        (OpRxRmx #[16r66] #[16r0f 16r28])
        (OpRmxRx #[16r66] #[16r0f 16r29])
    )
    (movaps (dst src) "Move aligned packed single"
        (OpRxRmx #[] #[16r0f 16r28])
        (OpRmxRx #[] #[16r0f 16r29])
    )
    (movsd (dst src) "Move scalar double"
        (OpRxRmx #[16rf2] #[16r0f 16r10])
        (OpRmxRx #[16rf2] #[16r0f 16r11])
    )
    (movss (dst src) "Move scalar single"
        (OpRxRmx #[16rf3] #[16r0f 16r10])
        (OpRmxRx #[16rf3] #[16r0f 16r11])
    )

    (movd (dst src) "Move double-word"
        (OpRxRmw #[16r66] #[16r0f 16r6E])
        (OpRmwRx #[16r66] #[16r0f 16r7E])
    )
    (movq (dst src) "Move quad-word"
        (OpRxRmw #[16r66] #[16r0f 16r6E])
        (OpRmwRx #[16r66] #[16r0f 16r7E])
    )

    (maxpd (dst with) "Maximum packed double"
        (OpRxRmx #[16r66] #[16r0f 16r5F])
    )
    (maxps (dst with) "Maximum packed single"
        (OpRxRmx #[] #[16r0f 16r5F])
    )
    (maxsd (dst with) "Maximum scalar double"
        (OpRxRmx #[16rf2] #[16r0f 16r5F])
    )
    (maxss (dst with) "Maximum scalar single"
        (OpRxRmx #[16rf3] #[16r0f 16r5F])
    )

    (minpd (dst with) "Minimum packed double"
        (OpRxRmx #[16r66] #[16r0f 16r5D])
    )
    (minps (dst with) "Minimum packed single"
        (OpRxRmx #[] #[16r0f 16r5D])
    )
    (minsd (dst with) "Minimum scalar double"
        (OpRxRmx #[16rf2] #[16r0f 16r5D])
    )
    (minss (dst with) "Minimum scalar single"
        (OpRxRmx #[16rf3] #[16r0f 16r5D])
    )

    (mulpd (dst with) "Multiply packed double"
        (OpRxRmx #[16r66] #[16r0f 16r59])
    )
    (mulps (dst with) "Multiply packed single"
        (OpRxRmx #[] #[16r0f 16r59])
    )
    (mulsd (dst with) "Multiply scalar double"
        (OpRxRmx #[16rf2] #[16r0f 16r59])
    )
    (mulss (dst with) "Multiply scalar single"
        (OpRxRmx #[16rf3] #[16r0f 16r59])
    )

    (orpd (dst with) "Or packed double"
        (OpRxRmx #[16r66] #[16r0f 16r56])
    )
    (orps (dst with) "Or packed single"
        (OpRxRmx #[] #[16r0f 16r56])
    )

    (sqrtpd (dst with) "Sqrt packed double"
        (OpRxRmx #[16r66] #[16r0f 16r51])
    )
    (sqrtps (dst with) "Sqrt packed single"
        (OpRxRmx #[] #[16r0f 16r51])
    )
    (sqrtsd (dst with) "Sqrt scalar double"
        (OpRxRmx #[16rf2] #[16r0f 16r51])
    )
    (sqrtss (dst with) "Sqrt scalar single"
        (OpRxRmx #[16rf3] #[16r0f 16r51])
    )

    (subpd (dst with) "Subtract packed double"
        (OpRxRmx #[16r66] #[16r0f 16r5c])
    )
    (subps (dst with) "Subtract packed single"
        (OpRxRmx #[] #[16r0f 16r5c])
    )
    (subsd (dst with) "Subtract scalar double"
        (OpRxRmx #[16rf2] #[16r0f 16r5c])
    )
    (subss (dst with) "Subtract scalar single"
        (OpRxRmx #[16rf3] #[16r0f 16r5c])
    )

    (ucomisd (dst src) "Compare scalar double and set eflags"
        (OpRxRmx #[16r66] #[16r0f 16r2E])
    )
    (ucomiss (dst src) "Compare scalar single and set eflags"
        (OpRxRmx #[] #[16r0f 16r2E])
    )

    (xorpd (dst with) "Xor packed double"
        (OpRxRmx #[16r66] #[16r0f 16r57])
    )
    (xorps (dst with) "Xor packed single"
        (OpRxRmx #[] #[16r0f 16r57])
    )
).

public global AsmX86InstructionDefinition::Table := Dictionary new.

instructionDefinitionTable do: {:instructionDescription :: Void |
    let mnemonic := instructionDescription first.
    let operandNames := instructionDescription second.
    let description := instructionDescription third.
    let alternatives := instructionDescription allButFirst: 3.
    let parsedAlternatives := alternatives collect: {:(Array)alternativeDescription :: AsmX86InstructionTemplate |
        let alternativeName := alternativeDescription first.
        let instructionTemplate := instructionTemplateTable at: alternativeName.
        instructionTemplate copy
            parseDescription: alternativeDescription;
            yourself
    }.
    let definition := AsmX86InstructionDefinition new
        mnemonic: mnemonic;
        operandNames: operandNames;
        description: description;
        alternatives: parsedAlternatives;
        yourself.

    definition generateStreamBuilderMethod.
    AsmX86InstructionDefinition::Table at: definition mnemonic put: definition.
}.

AsmStreamBuilder extend: {
    public method x86::add: (destination: AsmInstructionOperand) with: (operand: AsmInstructionOperand) ::=> AsmX86InstructionWithTwoOperands := {
        operand isImmediateValue0
            ifFalse: (self x86::direct::add: destination with: operand)
            ifTrue: (nil)        
    }.

    public method x86::sub: (destination: AsmInstructionOperand) with: (operand: AsmInstructionOperand) ::=> AsmX86InstructionWithTwoOperands := {
        operand isImmediateValue0
            ifFalse: (self x86::direct::sub: destination with: operand)
            ifTrue: (nil)        
    }.

    public method x86::mov: (destination: AsmInstructionOperand) src: (source: AsmInstructionOperand) ::=> AsmX86InstructionWithTwoOperands := {
        destination ~= source
            ifTrue: (self x86::direct::mov: destination src: source)
            ifFalse: (nil)        
    }.
}.
