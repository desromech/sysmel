   
public abstract class TACRegisterAllocator superclass: Object; definition: {
    public field compilationTarget => TACCompilationTarget.

    public abstract method allocateRegistersIn: (function: TACFunction) withTarget: (target: TACCompilationTarget) ::=> Void
        := self subclassResponsibility.

    public abstract method allocateRegister: (register: TACPhysicalLocation) forInstructionResult: (instruction: TACInstruction) ::=> Void
        := self subclassResponsibility.

    public abstract method allocateRegister: (register: TACPhysicalLocation) forInstruction: (instruction: TACInstruction) operandAt: (operandIndex: Size) ::=> Void
        := self subclassResponsibility.

    public abstract method allocateRegisterForInstructionResult: (instruction: TACInstruction) ::=> Void
        := self subclassResponsibility.

    public abstract method allocateRegisterForInstruction: (instruction: TACInstruction) operandAt: (operandIndex: Size) ::=> Void
        := self subclassResponsibility.

    public virtual method allocateRegisterOrImmediate32ForInstruction: (instruction: TACInstruction) operandAt: (operandIndex: Size) ::=> Void := {
        let operand := instruction operands at: operandIndex.
        operand isImmediate32 ifTrue: {
            instruction operandRegisters at: operandIndex put: (TACPhysicalLocationImmediate for: operand)
        } ifFalse: {
            self allocateRegisterForInstruction: instruction operandAt: operandIndex
        }
    }.

    public virtual method allocateRegisterOrRelativeImmediate32ForInstruction: (instruction: TACInstruction) operandAt: (operandIndex: Size) ::=> Void := {
        let operand := instruction operands at: operandIndex.
        operand isRelativeImmediate32 ifTrue: {
            instruction operandRegisters at: operandIndex put: (TACPhysicalLocationImmediate for: operand)
        } ifFalse: {
            self allocateRegisterForInstruction: instruction operandAt: operandIndex
        }
    }.

    public abstract method allocateIntegerRegister ::=> TACPhysicalLocation
        := self subclassResponsibility.

    public abstract method allocateFloatRegister ::=> TACPhysicalLocation
        := self subclassResponsibility.

    public abstract method allocateVectorRegister ::=> TACPhysicalLocation
        := self subclassResponsibility.

    public method markActiveRegister: (register: TACPhysicalLocation) ::=> Void := {
        register markActiveWithRegisterAllocator: self
    }.

    public abstract method markActiveIntegerRegister: (register: TACPhysicalIntegerRegister) ::=> Void
        := self subclassResponsibility.

    public abstract method markActiveFloatRegister: (register: TACPhysicalFloatRegister) ::=> Void
        := self subclassResponsibility.

    public abstract method markActiveVectorRegister: (register: TACPhysicalVectorRegister) ::=> Void
        := self subclassResponsibility.
}.

TACPhysicalLocation extend: {
    __Meta__ extend: {
        public method allocateRegisterWith: (registerAllocator: TACRegisterAllocator) ::=> TACPhysicalLocation
            := registerAllocator allocateIntegerRegister.
    }.

    public abstract method markActiveWithRegisterAllocator: (registerAllocator: TACRegisterAllocator) ::=> Void
        := self subclassResponsibility.
}.

TACPhysicalIntegerRegister extend: {
    public override method markActiveWithRegisterAllocator: (registerAllocator: TACRegisterAllocator) ::=> Void := {
        registerAllocator markActiveIntegerRegister: self
    }.
}.

TACPhysicalFloatRegister extend: {
    __Meta__ extend: {
        public method allocateRegisterWith: (registerAllocator: TACRegisterAllocator) ::=> TACPhysicalLocation
            := registerAllocator allocateFloatRegister.
    }.

    public override method markActiveWithRegisterAllocator: (registerAllocator: TACRegisterAllocator) ::=> Void := {
        registerAllocator markActiveFloatRegister: self
    }.
}.

TACPhysicalVectorRegister extend: {
    __Meta__ extend: {
        public method allocateRegisterWith: (registerAllocator: TACRegisterAllocator) ::=> TACPhysicalLocation
            := registerAllocator allocateVectorRegister.
    }.

    public override method markActiveWithRegisterAllocator: (registerAllocator: TACRegisterAllocator) ::=> Void := {
        registerAllocator markActiveVectorRegister: self
    }.
}.

TACOperation extend: {
    public method forTarget: (target: Symbol) registerConstraintsWith: (registerAssignmentBlock: (TACInstruction, TACRegisterAllocator) => Void) ::=> Void := {
        perTargetRegisterConstraints at: target put: registerAssignmentBlock
    }.

    public method forTargets: (targets: Array) registerConstraintsWith: (registerAssignmentBlock: (TACInstruction, TACRegisterAllocator) => Void) ::=> Void := {
        targets do: {:(Symbol)eachTarget :: Void |
            self forTarget: eachTarget registerConstraintsWith: registerAssignmentBlock
        }
    }.

    public method computeRegisterConstraintsOf: (instruction: TACInstruction) with: (registerAllocator: TACRegisterAllocator) ::=> Void := {
        let targetName := registerAllocator compilationTarget name.
        (perTargetRegisterConstraints at: targetName
            ifAbsent: {:: Void |
            self error: "Missing register constraints for TAC operation '" -- name printString -- "' in " -- targetName -- "."
        }) (instruction, registerAllocator)
    }.
}.

TACCallingConvention extend: {
    public abstract method registerConstraintsOfCallInt32: (instruction: TACInstruction) with: (registerAllocator: TACRegisterAllocator) ::=> Void
        := self subclassResponsibility.

    public abstract method registerConstraintsOfCallInt64: (instruction: TACInstruction) with: (registerAllocator: TACRegisterAllocator) ::=> Void
        := self subclassResponsibility.

    public abstract method registerConstraintsOfCallFloat32: (instruction: TACInstruction) with: (registerAllocator: TACRegisterAllocator) ::=> Void
        := self subclassResponsibility.

    public abstract method registerConstraintsOfCallFloat64: (instruction: TACInstruction) with: (registerAllocator: TACRegisterAllocator) ::=> Void
        := self subclassResponsibility.

    public abstract method registerConstraintsOfCallStruct: (instruction: TACInstruction) with: (registerAllocator: TACRegisterAllocator) ::=> Void
        := self subclassResponsibility.

    public abstract method registerConstraintsOfCallVoid: (instruction: TACInstruction) with: (registerAllocator: TACRegisterAllocator) ::=> Void
        := self subclassResponsibility.
}.

public final class TACRegisterAllocationFile superclass: Object; definition: {
    public field registers => Array.
    public field usedRegisters => Array.
    public field activeRegisters => Array.

    __Meta__ definition: {
        public method for: (registers: Array) ::=> self
            := self new
                registers: registers;
                usedRegisters: ((Array new: registers size)
                    atAllPut: false;
                    yourself);
                activeRegisters: ((Array new: registers size)
                    atAllPut: false;
                    yourself);
                yourself

    }.

    public method reset => Void := {
        activeRegisters atAllPut: false
    }.

    public method markActiveRegister: (usedRegister: TACPhysicalLocation) ::=> Void := {
        let foundIndex := registers indexOf: usedRegister.
        self assert: foundIndex >= 0iptr.
        
        let index := foundIndex asSize.
        activeRegisters at: index put: true.
        usedRegisters at: index put: true.
    }.

    public method allocate => TACPhysicalLocation := {
        let nextRegisterIndex := usedRegisters indexOf: false.
        self assert: nextRegisterIndex >= 0iptr.

        let index := nextRegisterIndex asSize.
        activeRegisters at: index put: true.
        usedRegisters at: index put: true.
        registers at: index
    }.
}.

public final class TACTrivialRegisterAllocator superclass: TACRegisterAllocator; definition: {
    protected field integerRegisterFile => TACRegisterAllocationFile.
    protected field floatRegisterFile => TACRegisterAllocationFile.
    protected field vectorRegisterFile => TACRegisterAllocationFile.

    public override method allocateRegistersIn: (function: TACFunction) withTarget: (target: TACCompilationTarget) ::=> Void := {
        compilationTarget := target.

        integerRegisterFile := TACRegisterAllocationFile for: target allocableIntegerRegisters.

        function instructionsDo: {:(TACInstruction)instruction :: Void |
            self allocateInstructionRegisters: instruction
        }
    }.

    public method allocateInstructionRegisters: (instruction: TACInstruction) ::=> Void := {
        instruction resetRegisterAllocation.
        instruction operation computeRegisterConstraintsOf: instruction with: self
    }.

    public override method allocateRegisterForInstructionResult: (instruction: TACInstruction) ::=> Void := {
        instruction result ifNotNil: {
            instruction resultRegister: (self allocateRegisterForOperand: instruction result)
        }
    }.

    public override method allocateRegister: (register: TACPhysicalLocation) forInstructionResult: (instruction: TACInstruction) ::=> Void := {
        instruction resultRegister: register.
        register markActiveWithRegisterAllocator: self.
    }.

    public override method allocateRegister: (register: TACPhysicalLocation) forInstruction: (instruction: TACInstruction) operandAt: (operandIndex: Size) ::=> Void := {
        instruction operandRegisters at: operandIndex put: register.
        register markActiveWithRegisterAllocator: self.
    }.

    public override method allocateRegisterForInstruction: (instruction: TACInstruction) operandAt: (operandIndex: Size) ::=> Void := {
        let register :=
            (operandIndex == 0sz) &&
            (instruction resultRegister isNotNil) &&
            (instruction result physicalLocationClass == instruction operands first physicalLocationClass)
            ifTrue: (instruction resultRegister)
            ifFalse: (self allocateRegisterForOperand: (instruction operands at: operandIndex)).
        instruction operandRegisters at: operandIndex put: register
    }.
    
    public method allocateRegisterForOperand: (operand: TACValue) ::=> TACPhysicalLocation := {
        operand physicalLocationClass allocateRegisterWith: self
    }.

    public override method allocateIntegerRegister ::=> TACPhysicalLocation
        := integerRegisterFile allocate.

    public override method markActiveIntegerRegister: (register: TACPhysicalIntegerRegister) ::=> Void := {
        integerRegisterFile markActiveRegister: register
    }.

    public override method allocateFloatRegister ::=> TACPhysicalLocation
        := floatRegisterFile allocate.

    public override method markActiveFloatRegister: (register: TACPhysicalFloatRegister) ::=> Void := {
        floatRegisterFile markActiveRegister: register
    }.

    public override method allocateVectorRegister ::=> TACPhysicalLocation
        := vectorRegisterFile allocate.

    public override method markActiveVectorRegister: (register: TACPhysicalVectorRegister) ::=> Void := {
        vectorRegisterFile markActiveRegister: register
    }.
}.
