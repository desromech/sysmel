   
public abstract class TACRegisterAllocator superclass: Object; definition: {
    public field compilationTarget => TACCompilationTarget.

    public abstract method allocateRegistersIn: (function: TACFunction) withTarget: (target: TACCompilationTarget) ::=> Void
        := self subclassResponsibility.

    public abstract method allocateRegister: (register: TACPhysicalLocation) forInstructionResult: (instruction: TACInstruction) ::=> Void
        := self subclassResponsibility.

    public abstract method allocateRegister: (register: TACPhysicalLocation) forInstructionResultPointer: (instruction: TACInstruction) ::=> Void
        := self subclassResponsibility.

    public abstract method allocateRegister: (register: TACPhysicalLocation) forInstruction: (instruction: TACInstruction) operandAt: (operandIndex: Size) ::=> Void
        := self subclassResponsibility.

    public abstract method allocateRegister: (register: TACPhysicalLocation) forInstruction: (instruction: TACInstruction) operandPointerAt: (operandIndex: Size) ::=> Void
        := self subclassResponsibility.

    public abstract method allocateRegister: (register: TACPhysicalLocation) forInstruction: (instruction: TACInstruction) scratchAt: (operandIndex: Size) ::=> Void
        := self subclassResponsibility.

    public abstract method allocateRegisterForInstructionResult: (instruction: TACInstruction) ::=> Void
        := self subclassResponsibility.

    public abstract method allocateRegisterForInstruction: (instruction: TACInstruction) operandAt: (operandIndex: Size) ::=> Void
        := self subclassResponsibility.

    public abstract method allocateRegister8ForInstructionResult: (instruction: TACInstruction) ::=> Void
        := self subclassResponsibility.

    public abstract method allocateRegister8ForInstruction: (instruction: TACInstruction) operandAt: (operandIndex: Size) ::=> Void
        := self subclassResponsibility.

    public virtual method allocateRegister: (requiredRegister: TACPhysicalLocation) orImmediateU8ForInstruction: (instruction: TACInstruction) operandAt: (operandIndex: Size) ::=> Void := {
        let operand := instruction operands at: operandIndex.
        operand isImmediateU8 ifTrue: {
            instruction operandRegisters at: operandIndex put: (TACPhysicalLocationImmediate for: operand)
        } ifFalse: {
            self allocateRegister: requiredRegister forInstruction: instruction operandAt: operandIndex
        }
    }.

    public virtual method allocateRegisterOrImmediate8ForInstruction: (instruction: TACInstruction) operandAt: (operandIndex: Size) ::=> Void := {
        let operand := instruction operands at: operandIndex.
        operand isImmediate8 ifTrue: {
            instruction operandRegisters at: operandIndex put: (TACPhysicalLocationImmediate for: operand)
        } ifFalse: {
            self allocateRegisterForInstruction: instruction operandAt: operandIndex
        }
    }.

    public virtual method allocateRegisterOrImmediate16ForInstruction: (instruction: TACInstruction) operandAt: (operandIndex: Size) ::=> Void := {
        let operand := instruction operands at: operandIndex.
        operand isImmediate16 ifTrue: {
            instruction operandRegisters at: operandIndex put: (TACPhysicalLocationImmediate for: operand)
        } ifFalse: {
            self allocateRegisterForInstruction: instruction operandAt: operandIndex
        }
    }.

    public virtual method allocateRegisterOrImmediate32ForInstruction: (instruction: TACInstruction) operandAt: (operandIndex: Size) ::=> Void := {
        let operand := instruction operands at: operandIndex.
        operand isImmediate32 ifTrue: {
            instruction operandRegisters at: operandIndex put: (TACPhysicalLocationImmediate for: operand)
        } ifFalse: {
            self allocateRegisterForInstruction: instruction operandAt: operandIndex
        }
    }.

    public virtual method allocateRegisterOrImmediate64ForInstruction: (instruction: TACInstruction) operandAt: (operandIndex: Size) ::=> Void := {
        let operand := instruction operands at: operandIndex.
        operand isImmediate64 ifTrue: {
            instruction operandRegisters at: operandIndex put: (TACPhysicalLocationImmediate for: operand)
        } ifFalse: {
            self allocateRegisterForInstruction: instruction operandAt: operandIndex
        }
    }.

    public virtual method allocateRegisterOrImmediateS32ForInstruction: (instruction: TACInstruction) operandAt: (operandIndex: Size) ::=> Void := {
        let operand := instruction operands at: operandIndex.
        operand isImmediateS32 ifTrue: {
            instruction operandRegisters at: operandIndex put: (TACPhysicalLocationImmediate for: operand)
        } ifFalse: {
            self allocateRegisterForInstruction: instruction operandAt: operandIndex
        }
    }.

    public virtual method allocateImmediate32ForInstruction: (instruction: TACInstruction) operandAt: (operandIndex: Size) ::=> Void := {
        let operand := instruction operands at: operandIndex.
        operand isImmediate32 ifTrue: {
            instruction operandRegisters at: operandIndex put: (TACPhysicalLocationImmediate for: operand)
        } ifFalse: {
            self error: "An immediate32 operand is required here."
        }
    }.

    public virtual method allocateRegisterOrRelativeImmediate32ForInstruction: (instruction: TACInstruction) operandAt: (operandIndex: Size) ::=> Void := {
        let operand := instruction operands at: operandIndex.
        operand isRelativeImmediate32 ifTrue: {
            instruction operandRegisters at: operandIndex put: (TACPhysicalLocationImmediate for: operand)
        } ifFalse: {
            self allocateRegisterForInstruction: instruction operandAt: operandIndex
        }
    }.

    public virtual method allocateMemoryForInstruction: (instruction: TACInstruction) operandAt: (operandIndex: Size) ::=> Void := {
        instruction operandRegisters at: operandIndex put: TACPhysicalLocationMemory uniqueInstance
    }.

    public virtual method allocateMemoryForInstructionResult: (instruction: TACInstruction) ::=> Void := {
        instruction resultRegister: TACPhysicalLocationMemory uniqueInstance
    }.

    public abstract method allocateIntegerRegisterForValue: (value: TACValue) ::=> TACPhysicalLocation
        := self subclassResponsibility.

    public abstract method allocateIntegerRegister8ForValue: (value: TACValue) ::=> TACPhysicalLocation
        := self subclassResponsibility.

    public abstract method allocateFloatRegisterForValue: (value: TACValue) ::=> TACPhysicalLocation
        := self subclassResponsibility.

    public abstract method allocateVectorRegisterForValue: (value: TACValue) ::=> TACPhysicalLocation
        := self subclassResponsibility.

    public method makeActiveRegister: (register: TACPhysicalLocation) withValue: (value: TACValue) ::=> Void := {
        register makeActiveWithValue: value inRegisterAllocator: self
    }.

    public method makeActiveRegister: (register: TACPhysicalLocation) withValuePointer: (value: TACValue) ::=> Void := {
        register makeActiveWithValuePointer: value inRegisterAllocator: self
    }.

    public method makeActiveRegister: (register: TACPhysicalLocation) withResultValue: (value: TACValue) ::=> Void := {
        register makeActiveWithResultValue: value inRegisterAllocator: self
    }.

    public abstract method makeActiveIntegerRegister: (register: TACPhysicalIntegerRegister) withValue: (value: TACValue) ::=> Void
        := self subclassResponsibility.

    public abstract method makeActiveIntegerRegister: (register: TACPhysicalIntegerRegister) withValuePointer: (value: TACValue) ::=> Void
        := self subclassResponsibility.

    public abstract method makeActiveIntegerRegister: (register: TACPhysicalIntegerRegister) withResultValue: (value: TACValue) ::=> Void
        := self subclassResponsibility.

    public abstract method makeActiveFloatRegister: (register: TACPhysicalFloatRegister) withValue: (value: TACValue) ::=> Void
        := self subclassResponsibility.

    public abstract method makeActiveFloatRegister: (register: TACPhysicalFloatRegister) withValuePointer: (value: TACValue) ::=> Void
        := self subclassResponsibility.

    public abstract method makeActiveFloatRegister: (register: TACPhysicalFloatRegister) withResultValue: (value: TACValue) ::=> Void
        := self subclassResponsibility.

    public abstract method makeActiveVectorRegister: (register: TACPhysicalVectorRegister) withValue: (value: TACValue) ::=> Void
        := self subclassResponsibility.

    public abstract method makeActiveVectorRegister: (register: TACPhysicalVectorRegister) withValuePointer: (value: TACValue) ::=> Void
        := self subclassResponsibility.

    public abstract method makeActiveVectorRegister: (register: TACPhysicalVectorRegister) withResultValue: (value: TACValue) ::=> Void
        := self subclassResponsibility.

    public virtual method allocateRegisterOrMemoryForInstruction: (instruction: TACInstruction) operandAt: (operandIndex: Size) ::=> Void := {
        self allocateRegisterForInstruction: instruction operandAt: operandIndex
    }.
}.

TACPhysicalLocation extend: {
    __Meta__ extend: {
        public abstract method allocateRegisterForValue: (value: TACValue) with: (registerAllocator: TACRegisterAllocator) ::=> TACPhysicalLocation
            := self subclassResponsibility.
    }.

    public abstract method makeActiveWithValue: (value: TACValue) inRegisterAllocator: (registerAllocator: TACRegisterAllocator) ::=> Void
        := self subclassResponsibility.

    public abstract method makeActiveWithValuePointer: (value: TACValue) inRegisterAllocator: (registerAllocator: TACRegisterAllocator) ::=> Void
        := self subclassResponsibility.

    public abstract method makeActiveWithResultValue: (value: TACValue) inRegisterAllocator: (registerAllocator: TACRegisterAllocator) ::=> Void
        := self subclassResponsibility.
}.

TACPhysicalIntegerRegister extend: {
    __Meta__ extend: {
        public override method allocateRegisterForValue: (value: TACValue) with: (registerAllocator: TACRegisterAllocator) ::=> TACPhysicalLocation
            := registerAllocator allocateIntegerRegisterForValue: value.
    }.

    public override method makeActiveWithValue: (value: TACValue) inRegisterAllocator: (registerAllocator: TACRegisterAllocator) ::=> Void := {
        registerAllocator makeActiveIntegerRegister: self withValue: value
    }.

    public override method makeActiveWithValuePointer: (value: TACValue) inRegisterAllocator: (registerAllocator: TACRegisterAllocator) ::=> Void := {
        registerAllocator makeActiveIntegerRegister: self withValuePointer: value
    }.

    public override method makeActiveWithResultValue: (value: TACValue) inRegisterAllocator: (registerAllocator: TACRegisterAllocator) ::=> Void := {
        registerAllocator makeActiveIntegerRegister: self withResultValue: value
    }.
}.

TACPhysicalFloatRegister extend: {
    __Meta__ extend: {
        public override method allocateRegisterForValue: (value: TACValue) with: (registerAllocator: TACRegisterAllocator) ::=> TACPhysicalLocation
            := registerAllocator allocateFloatRegisterForValue: value.
    }.

    public override method makeActiveWithValue: (value: TACValue) inRegisterAllocator: (registerAllocator: TACRegisterAllocator) ::=> Void := {
        registerAllocator makeActiveFloatRegister: self withValue: value
    }.

    public override method makeActiveWithValuePointer: (value: TACValue) inRegisterAllocator: (registerAllocator: TACRegisterAllocator) ::=> Void := {
        registerAllocator makeActiveFloatRegister: self withValuePointer: value
    }.

    public override method makeActiveWithResultValue: (value: TACValue) inRegisterAllocator: (registerAllocator: TACRegisterAllocator) ::=> Void := {
        registerAllocator makeActiveFloatRegister: self withResultValue: value
    }.
}.

TACPhysicalVectorRegister extend: {
    __Meta__ extend: {
        public override method allocateRegisterForValue: (value: TACValue) with: (registerAllocator: TACRegisterAllocator) ::=> TACPhysicalLocation
            := registerAllocator allocateVectorRegisterForValue: value.
    }.

    public override method makeActiveWithValue: (value: TACValue) inRegisterAllocator: (registerAllocator: TACRegisterAllocator) ::=> Void := {
        registerAllocator makeActiveVectorRegister: self withValue: value
    }.

    public override method makeActiveWithValuePointer: (value: TACValue) inRegisterAllocator: (registerAllocator: TACRegisterAllocator) ::=> Void := {
        registerAllocator makeActiveVectorRegister: self withValuePointer: value
    }.

    public override method makeActiveWithResultValue: (value: TACValue) inRegisterAllocator: (registerAllocator: TACRegisterAllocator) ::=> Void := {
        registerAllocator makeActiveVectorRegister: self withResultValue: value
    }.
}.

public class TACInstructionLoadValueInRegisterOperation superclass: TACInstructionSurroundingOperation; definition: {
    public field value => TACValue.
    public field register => TACPhysicalLocation.
}.

public class TACInstructionStoreValueInRegisterOperation superclass: TACInstructionSurroundingOperation; definition: {
    public field value => TACLocalVariable.
    public field register => TACPhysicalLocation.
}.

public class TACInstructionMoveRegisterOperation superclass: TACInstructionSurroundingOperation; definition: {
    public field sourceRegister => TACPhysicalLocation.
    public field destinationRegister => TACPhysicalLocation.
}.

TACOperation extend: {
    public method forTarget: (target: Symbol) registerConstraintsWith: (registerAssignmentBlock: (TACInstruction, TACRegisterAllocator) => Void) ::=> Void := {
        perTargetRegisterConstraints at: target put: registerAssignmentBlock
    }.

    public method forTargets: (targets: Array) registerConstraintsWith: (registerAssignmentBlock: (TACInstruction, TACRegisterAllocator) => Void) ::=> Void := {
        targets do: {:(Symbol)eachTarget :: Void |
            self forTarget: eachTarget registerConstraintsWith: registerAssignmentBlock
        }
    }.

    public method computeRegisterConstraintsOf: (instruction: TACInstruction) with: (registerAllocator: TACRegisterAllocator) ::=> Void := {
        let targetName := registerAllocator compilationTarget name.
        (perTargetRegisterConstraints at: targetName
            ifAbsent: {:: Void |
            self error: "Missing register constraints for TAC operation '" -- name printString -- "' in " -- targetName asString -- "."
        }) (instruction, registerAllocator)
    }.
}.

TACCallingConvention extend: {
    public abstract method registerConstraintsOfCallInt8: (instruction: TACInstruction) with: (registerAllocator: TACRegisterAllocator) ::=> Void
        := self subclassResponsibility.

    public abstract method registerConstraintsOfCallInt16: (instruction: TACInstruction) with: (registerAllocator: TACRegisterAllocator) ::=> Void
        := self subclassResponsibility.

    public abstract method registerConstraintsOfCallInt32: (instruction: TACInstruction) with: (registerAllocator: TACRegisterAllocator) ::=> Void
        := self subclassResponsibility.

    public abstract method registerConstraintsOfCallInt64: (instruction: TACInstruction) with: (registerAllocator: TACRegisterAllocator) ::=> Void
        := self subclassResponsibility.

    public abstract method registerConstraintsOfCallFloat32: (instruction: TACInstruction) with: (registerAllocator: TACRegisterAllocator) ::=> Void
        := self subclassResponsibility.

    public abstract method registerConstraintsOfCallFloat64: (instruction: TACInstruction) with: (registerAllocator: TACRegisterAllocator) ::=> Void
        := self subclassResponsibility.

    public abstract method registerConstraintsOfCallStruct: (instruction: TACInstruction) with: (registerAllocator: TACRegisterAllocator) ::=> Void
        := self subclassResponsibility.

    public abstract method registerConstraintsOfCallVoid: (instruction: TACInstruction) with: (registerAllocator: TACRegisterAllocator) ::=> Void
        := self subclassResponsibility.
}.

public final class TACRegisterAllocationFile superclass: Object; definition: {
    public field registers => Array.
    public field usedRegisters => Array.
    public field activeRegisters => Array.
    public field spillOperations => OrderedCollection.
    public field unspillOperations => OrderedCollection.
    public field storeOperations => OrderedCollection.

    __Meta__ definition: {
        public method for: (registers: Array) ::=> self
            := self new
                registers: registers;
                usedRegisters: ((Array new: registers size)
                    atAllPut: false;
                    yourself);
                activeRegisters: ((Array new: registers size)
                    atAllPut: false;
                    yourself);
                yourself

    }.

    public override method initialize => Void := {
        super initialize.
        spillOperations := OrderedCollection new.
        unspillOperations := OrderedCollection new.
        storeOperations := OrderedCollection new.
    }.

    public method reset => Void := {
        activeRegisters atAllPut: false.
    }.

    public method resetOperations => Void := {
        spillOperations removeAll.
        unspillOperations removeAll.
        storeOperations removeAll.
    }.

    public method preOperations => Array
        := spillOperations asArray -- unspillOperations asArray.

    public method postOperations => Array
        := storeOperations asArray.

    public method makeActiveRegister: (usedRegister: TACPhysicalLocation) ::=> Void
        := self makeActiveRegister: usedRegister withValue: nil.

    public method makeActiveRegister: (usedRegister: TACPhysicalLocation) withValue: (value: TACValue) ::=> Void := {
        let foundIndex := registers indexOf: usedRegister.
        self assert: foundIndex >= 0iptr.
        
        let index := foundIndex asSize.
        activeRegisters at: index put: true.
        usedRegisters at: index put: true.
    }.

    public method makeActiveRegister: (usedRegister: TACPhysicalLocation) withValuePointer: (value: TACValue) ::=> Void
        := self makeActiveRegister: usedRegister withValue: value.

    public method makeActiveRegister: (usedRegister: TACPhysicalLocation) withResultValue: (value: TACValue) ::=> Void
        := self makeActiveRegister: usedRegister withValue: value.

    public method allocate => TACPhysicalLocation := {
        let nextRegisterIndex := activeRegisters indexOf: false.
        self assert: nextRegisterIndex >= 0iptr.

        let index := nextRegisterIndex asSize.
        activeRegisters at: index put: true.
        usedRegisters at: index put: true.
        registers at: index
    }.

    public method allocateForByte => TACPhysicalLocation := {
        let result := self allocate.
        self assert: result canBeUsedForByte.
        result
    }.

    public method allocateForValue: (value: TACValue) ::=> TACPhysicalLocation
        := self allocate.

    public method allocateForByteValue: (value: TACValue) ::=> TACPhysicalLocation
        := self allocateForByte.

    public method allocateForCaptureVector => TACPhysicalLocation
        := self allocate.
}.

public final class TACSimpleRegisterAllocator superclass: TACRegisterAllocator; definition: {
    protected field integerRegisterFile => TACRegisterAllocationFile.
    protected field floatRegisterFile => TACRegisterAllocationFile.
    protected field vectorRegisterFile => TACRegisterAllocationFile.

    public override method allocateRegistersIn: (function: TACFunction) withTarget: (target: TACCompilationTarget) ::=> Void := {
        compilationTarget := target.

        integerRegisterFile := TACRegisterAllocationFile for: target allocableIntegerRegisters.
        vectorRegisterFile := TACRegisterAllocationFile for: target allocableVectorRegisters.
        target usesVectorRegistersForFloatOperations ifTrue: {
            floatRegisterFile := vectorRegisterFile
        } ifFalse: {
            floatRegisterFile := TACRegisterAllocationFile for: target allocableFloatRegisters.
        }.

        function basicBlocksDo: {:(TACBasicBlock)basicBlock :: Void |
            self allocateRegistersInBasicBlock: basicBlock
        }
    }.

    public method allocateRegistersInBasicBlock: (basicBlock: TACBasicBlock) ::=> Void := {
        basicBlock instructionsDo: {:(TACInstruction)instruction :: Void |
            self allocateInstructionRegisters: instruction
        }
    }.

    public method allocateInstructionRegisters: (instruction: TACInstruction) ::=> Void := {
        instruction isDebug ifTrue: {
            ## FIXME: Avoid requiring this spilling.
            instruction operands first markSpillingRequired.
            return: void.
        }.

        self resetRegisterFiles.
        self resetRegisterFilesInstructionOperations.
        instruction resetRegisterAllocation.
        instruction operation computeRegisterConstraintsOf: instruction with: self.
        instruction usesCapture ifTrue: {
            instruction captureVectorPointerRegister: integerRegisterFile allocateForCaptureVector
        }.
    }.

    public method resetRegisterFiles => Void := {
        integerRegisterFile reset.
        floatRegisterFile ifNotNil: (floatRegisterFile reset).
        vectorRegisterFile ifNotNil: (vectorRegisterFile reset).
    }.

    public method resetRegisterFilesInstructionOperations => Void := {
        integerRegisterFile resetOperations.
        floatRegisterFile ifNotNil: (floatRegisterFile resetOperations).
        vectorRegisterFile ifNotNil: (vectorRegisterFile resetOperations).
    }.

    public override method allocateRegisterForInstructionResult: (instruction: TACInstruction) ::=> Void := {
        let result := instruction result.
        result ifNotNil: {
            instruction resultRegister: (self allocateRegisterForOperand: result).
            result markSpillingRequired
        }
    }.

    public override method allocateRegister8ForInstructionResult: (instruction: TACInstruction) ::=> Void := {
        let result := instruction result.
        result ifNotNil: {
            instruction resultRegister: (self allocateRegister8ForOperand: result).
            result markSpillingRequired
        }
    }.

    public override method allocateRegister: (register: TACPhysicalLocation) forInstructionResult: (instruction: TACInstruction) ::=> Void := {
        instruction resultRegister: register.
        instruction result markSpillingRequired.
        self makeActiveRegister: register withResultValue: instruction result.
    }.

    public override method allocateRegister: (register: TACPhysicalLocation) forInstructionResultPointer: (instruction: TACInstruction) ::=> Void := {
        instruction resultRegister: (TACPhysicalLocationRegisterWithPointer new register: register; yourself).
        instruction result markSpillingRequired.
        self makeActiveRegister: register withValuePointer: instruction result.
    }.

    public override method allocateRegister: (register: TACPhysicalLocation) forInstruction: (instruction: TACInstruction) operandAt: (operandIndex: Size) ::=> Void := {
        instruction operandRegisters at: operandIndex put: register.
        let operand => TACValue := instruction operands at: operandIndex.
        operand markSpillingRequired.
        self makeActiveRegister: register withValue: operand
    }.

    public override method allocateRegister: (register: TACPhysicalLocation) forInstruction: (instruction: TACInstruction) operandPointerAt: (operandIndex: Size) ::=> Void := {
        instruction operandRegisters at: operandIndex put: (TACPhysicalLocationRegisterWithPointer new register: register; yourself).
        let operand => TACValue := instruction operands at: operandIndex.
        operand markSpillingRequired.
        self makeActiveRegister: register withValuePointer: operand
    }.

    public override method allocateRegister: (register: TACPhysicalLocation) forInstruction: (instruction: TACInstruction) scratchAt: (scratchIndex: Size) ::=> Void := {
        ##instruction scratchRegisters at: scratchIndex put: register.
        self makeActiveRegister: register withValue: nil
    }.

    public override method allocateRegisterForInstruction: (instruction: TACInstruction) operandAt: (operandIndex: Size) ::=> Void := {
        let operand => TACValue := instruction operands at: operandIndex.
        let register :=
            (operandIndex == 0sz) &&
            (instruction resultRegister isNotNil) &&
            (instruction result physicalLocationClass == instruction operands first physicalLocationClass)
            ifTrue: (instruction resultRegister)
            ifFalse: (self allocateRegisterForOperand: operand).
        instruction operandRegisters at: operandIndex put: register.
        operand markSpillingRequired.
    }.
    
    public override method allocateRegister8ForInstruction: (instruction: TACInstruction) operandAt: (operandIndex: Size) ::=> Void := {
        let operand => TACValue  := instruction operands at: operandIndex.
        let register :=
            (operandIndex == 0sz) &&
            (instruction resultRegister isNotNil) &&
            (instruction result physicalLocationClass == instruction operands first physicalLocationClass)
            ifTrue: (instruction resultRegister)
            ifFalse: (self allocateRegister8ForOperand: operand).
        instruction operandRegisters at: operandIndex put: register.
        operand markSpillingRequired.
    }.

    public method allocateRegisterForOperand: (operand: TACValue) ::=> TACPhysicalLocation := {
        operand physicalLocationClass allocateRegisterForValue: operand with: self
    }.

    public method allocateRegister8ForOperand: (operand: TACValue) ::=> TACPhysicalLocation
        := self allocateIntegerRegister8ForValue: operand.

    public override method allocateIntegerRegisterForValue: (value: TACValue) ::=> TACPhysicalLocation
        := integerRegisterFile allocateForValue: value.

    public override method allocateIntegerRegister8ForValue: (value: TACValue) ::=> TACPhysicalLocation
        := integerRegisterFile allocateForByteValue: value.

    public override method makeActiveIntegerRegister: (register: TACPhysicalIntegerRegister) withValue: (value: TACValue) ::=> Void := {
        integerRegisterFile makeActiveRegister: register withValue: value
    }.

    public override method makeActiveIntegerRegister: (register: TACPhysicalIntegerRegister) withValuePointer: (value: TACValue) ::=> Void := {
        integerRegisterFile makeActiveRegister: register withValuePointer: value
    }.

    public override method makeActiveIntegerRegister: (register: TACPhysicalIntegerRegister) withResultValue: (value: TACValue) ::=> Void := {
        integerRegisterFile makeActiveRegister: register withResultValue: value
    }.

    public override method allocateFloatRegisterForValue: (value: TACValue) ::=> TACPhysicalLocation
        := floatRegisterFile allocateForValue: value.

    public override method makeActiveFloatRegister: (register: TACPhysicalFloatRegister) withValue: (value: TACValue) ::=> Void := {
        floatRegisterFile makeActiveRegister: register withValue: value
    }.

    public override method makeActiveFloatRegister: (register: TACPhysicalFloatRegister) withValuePointer: (value: TACValue) ::=> Void := {
        floatRegisterFile makeActiveRegister: register withValuePointer: value
    }.

    public override method makeActiveFloatRegister: (register: TACPhysicalFloatRegister) withResultValue: (value: TACValue) ::=> Void := {
        floatRegisterFile makeActiveRegister: register withResultValue: value
    }.

    public override method allocateVectorRegisterForValue: (value: TACValue) ::=> TACPhysicalLocation
        := vectorRegisterFile allocateForValue: value.

    public override method makeActiveVectorRegister: (register: TACPhysicalVectorRegister) withValue: (value: TACValue) ::=> Void := {
        vectorRegisterFile makeActiveRegister: register withValue: value
    }.

    public override method makeActiveVectorRegister: (register: TACPhysicalVectorRegister) withValuePointer: (value: TACValue) ::=> Void := {
        vectorRegisterFile makeActiveRegister: register withValuePointer: value
    }.

    public override method makeActiveVectorRegister: (register: TACPhysicalVectorRegister) withResultValue: (value: TACValue) ::=> Void := {
        vectorRegisterFile makeActiveRegister: register withResultValue: value
    }.
}.
