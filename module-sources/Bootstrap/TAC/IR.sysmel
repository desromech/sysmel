let PrintingDebugInfo := false.

public abstract class TACCompilationTarget superclass: Object.
public abstract class TACCallingConvention superclass: Object.
public abstract class TACValue superclass: Object.
public final class TACInstruction superclass: TACValue.

public abstract class TACPhysicalLocation superclass: Object; definition: {
    public virtual method isMemory => Boolean := false.
    public virtual method isImmediate => Boolean := false.
    public virtual method isRegister => Boolean := false.
    public virtual method isIntegerRegister => Boolean := false.
    public virtual method isFloatRegister => Boolean := false.
    public virtual method isVectorRegister => Boolean := false.
}.

public abstract class TACPhysicalLocationMemory superclass: TACPhysicalLocation; definition: {
    public virtual method isMemory => Boolean := true.

    __Meta__ definition: {
        let singleton := TACPhysicalLocationMemory new.
        public method uniqueInstance => TACPhysicalLocationMemory
            := singleton.
    }
}.

public abstract class TACPhysicalLocationRegister superclass: TACPhysicalLocation; definition: {
    public virtual method isRegister => Boolean := true.
}.

public abstract class TACPhysicalIntegerRegister superclass: TACPhysicalLocationRegister; definition: {
    public virtual method isIntegerRegister => Boolean := true.
}.

public abstract class TACPhysicalFloatRegister superclass: TACPhysicalLocationRegister; definition: {
    public virtual method isFloatRegister => Boolean := true.
}.

public abstract class TACPhysicalVectorRegister superclass: TACPhysicalLocationRegister; definition: {
    public virtual method isVectorRegister => Boolean := true.
}.

public class TACPhysicalLocationImmediate superclass: TACPhysicalLocation; definition: {
    public field value => TACValue.

    __Meta__ definition: {
        public method for: (value: TACValue) ::=> self
            := self new value: value; yourself
    }.

    public virtual method isImmediate => Boolean := true.
}.

Type extend: {
    public virtual method valueSizeForTacTarget: (target: TACCompilationTarget) ::=> Size
        := target pointerSize.

    public virtual method valueAlignmentForTacTarget: (target: TACCompilationTarget) ::=> Size
        := target pointerAlignment.

    public virtual method valueTacPhysicalLocationClass => TACPhysicalLocation class
        := TACPhysicalIntegerRegister.

    public virtual method valueIsSignedExtended => Boolean := false.
}.

ValueType extend: {
    public override method valueSizeForTacTarget: (target: TACCompilationTarget) ::=> Size
        := self valueSize.

    public override method valueAlignmentForTacTarget: (target: TACCompilationTarget) ::=> Size
        := self valueAlignment.

}.

Int8 class extend: {
    public override method valueIsSignedExtended => Boolean := true.
}.

Int16 class extend: {
    public override method valueIsSignedExtended => Boolean := true.
}.

Int32 class extend: {
    public override method valueIsSignedExtended => Boolean := true.
}.

Int64 class extend: {
    public override method valueIsSignedExtended => Boolean := true.
}.

Float32 class extend: {
    public override method valueTacPhysicalLocationClass => TACPhysicalLocation class
        := TACPhysicalFloatRegister.
}.

Float64 class extend: {
    public override method valueTacPhysicalLocationClass => TACPhysicalLocation class
        := TACPhysicalFloatRegister.
}.

TACValue definition: {
    public field debugSourcePosition => SourcePosition.
    public field debugSourceNode => ASTNode.
    public field debugSourceEnvironment => Environment.
    public field sourceProgramEntity => ProgramEntity.

    public virtual method type => Type
        := self subclassResponsibility.

    public virtual method physicalLocationClass => TACPhysicalLocation class
        := self subclassResponsibility.

    public virtual method size => UInt64
        := self subclassResponsibility.

    public virtual method alignment => UInt64
        := self subclassResponsibility.

    public virtual method isSignedExtended => Boolean := false.
    public virtual method isFloatingPoint => Boolean := false.
    public virtual method isVector => Boolean := false.

    public virtual method isProgramEntity => Boolean := false.
    public virtual method isFunction => Boolean := false.
    public virtual method isLocalVariable => Boolean := false.

    public virtual method isVariable => Boolean := false.
    public virtual method isArgumentVariable => Boolean := false.
    public virtual method isCaptureVariable => Boolean := false.
    public virtual method isTemporaryVariable => Boolean := false.
    public virtual method isGlobalVariable => Boolean := false.

    public virtual method isConstant => Boolean := false.
    public virtual method isConstantInt8 => Boolean := false.
    public virtual method isConstantUInt8 => Boolean := false.
    public virtual method isConstantInt16 => Boolean := false.
    public virtual method isConstantUInt16 => Boolean := false.
    public virtual method isConstantInt32 => Boolean := false.
    public virtual method isConstantUInt32 => Boolean := false.
    public virtual method isConstantInt64 => Boolean := false.
    public virtual method isConstantUInt64 => Boolean := false.
    public virtual method isConstantFloat => Boolean := false.
    public virtual method isConstantFloat32 => Boolean := false.
    public virtual method isConstantFloat64 => Boolean := false.

    public virtual method isImmediateValue1 => Boolean := false.

    public virtual method isImmediate8 => Boolean := false.
    public virtual method isImmediate16 => Boolean := false.
    public virtual method isImmediate32 => Boolean := false.
    public virtual method isImmediateS32 => Boolean := false.
    public virtual method isImmediate64 => Boolean := self isImmediate32.
    public virtual method isRelativeImmediate32 => Boolean := false.

    public virtual method isImmediateU8 => Boolean := false.

    public virtual method getConstantValue64 => Int64
        := self error: "Not an immediate 64 constant".

    public virtual method markUsageAt: (usageIndex: UInt32) ::=> Void := {}.
    public virtual method markWriteAt: (writeIndex: UInt32) ::=> Void := {}.
    public virtual method markSpillingRequired ::=> Void := {}.

    public virtual method isLastUsedIn: (instruction: TACInstruction) ::=> Boolean := false.

    public method printDebugInfoOn: (stream: Stream) ::=> Void := {
        debugSourcePosition isNotNil && PrintingDebugInfo ifTrue: {
            stream space; nextPutAll: "# at"; print: debugSourcePosition
        }
    }.
}.

public final class TACBasicBlock superclass: TACValue.

public abstract class TACProgramEntity superclass: TACValue; definition: {
    public field name => Symbol.
    public field compilationTarget => TACCompilationTarget.
    public field exportedSymbols => Array.

    public override method isProgramEntity => Boolean := true.

    public virtual method callingConvention => TACCallingConvention
        := self error: "Not a function with a defined calling convention.".

    public override method initialize => Void := {
        exportedSymbols := #().
    }.

    public method addExportedSymbols: (extraSymbols: Array) ::=> Void := {
        exportedSymbols := exportedSymbols -- extraSymbols
    }.
}.

public abstract class TACImportedProgramEntity superclass: TACProgramEntity; definition: {
    public field callingConvention => TACCallingConvention.
    public field alternativeSymbols => Array.

    public override method physicalLocationClass => TACPhysicalLocation class
        := TACPhysicalIntegerRegister.
}.

public final class TACImportedVariable superclass: TACImportedProgramEntity; definition: {
    public field type => Type.
    public field size => UInt64.
    public field alignment => UInt64.
    public field physicalLocationClass => TACPhysicalLocation class.
}.

public final class TACImportedFunction superclass: TACImportedProgramEntity; definition: {
    public override method physicalLocationClass => TACPhysicalLocation class
        := TACPhysicalIntegerRegister.

    public override method isRelativeImmediate32 => Boolean := true.

    public override method printOn: (stream: Stream) ::=> Void := {
        stream nextPutAll: "importedFunction".
        name ifNotNil: (stream space; string: name).
    }.

    public override method fullPrintOn: (stream: Stream) ::=> Void := {
        stream print: self; nextPutAll: " [".
        alternativeSymbols doWithIndex: {:each :(Size)index :: Void |
            index > 0sz ifTrue: (stream nextPutAll: ", ").
            stream string: each.
        }.
        stream nextPut: ']'.
        self printDebugInfoOn: stream.
    }.
}.

public abstract class TACVariable superclass: TACProgramEntity; definition: {
    public field type => Type.
    public field size => UInt64.
    public field alignment => UInt64.
    public field physicalLocationClass => TACPhysicalLocation class.
    public field isSignedExtended => Boolean.
    public field isGCRoot => Boolean.

    public override method isVariable => Boolean := true.
}.

public final class TACLocalVariable superclass: TACVariable; definition: {
    public field offset => Int64.
    public field index => UInt32.
    public field registerAssignment => TACPhysicalLocation.

    public field needsSpilling => Boolean.
    public field firstUsageIndex => Int32.
    public field lastUsageIndex => Int32.
    public field firstWriteIndex => Int32.
    public field lastWriteIndex => Int32.

    public field sourceBinding => SymbolBinding.

    public override method markSpillingRequired ::=> Void := {
        needsSpilling := true.
    }.

    public method needsStackAllocation => Boolean
        := needsSpilling || registerAssignment isNil.

    public override method isLocalVariable => Boolean := true.

    public method resetLiveRange => Void := {
        firstUsageIndex := -1i32.
        lastUsageIndex := -1i32.
        firstWriteIndex := -1i32.
        lastWriteIndex := -1i32.
    }.

    public virtual method markUsageAt: (usageIndex: UInt32) ::=> Void := {
        firstUsageIndex < 0i32 ifTrue: (firstWriteIndex := usageIndex asInt32).
        lastUsageIndex := usageIndex asInt32
    }.

    public virtual method markWriteAt: (writeIndex: UInt32) ::=> Void := {
        firstWriteIndex < 0i32 ifTrue: (firstWriteIndex := writeIndex asInt32).
        lastWriteIndex := writeIndex asInt32
    }.

    public override method isLastUsedIn: (instruction: TACInstruction) ::=> Boolean
        := lastUsageIndex = instruction index asInt32.
}.

public final class TACArgumentVariable superclass: TACLocalVariable; definition: {
    public field passingRegister => TACPhysicalLocation.

    public override method isArgumentVariable => Boolean := true.

    public override method printOn: (stream: Stream) ::=> Void := {
        stream nextPut: 'a'; print: index.
        name ifNotNil: (stream space; string: name)
    }.
}.

public final class TACCaptureVariable superclass: TACLocalVariable; definition: {
    public override method isCaptureVariable => Boolean := true.

    public override method printOn: (stream: Stream) ::=> Void := {
        stream nextPut: 'c'; print: index.
        name ifNotNil: (stream space; string: name)
    }.
}.

public final class TACTemporaryVariable superclass: TACLocalVariable; definition: {
    public override method isTemporaryVariable => Boolean := true.

    public override method printOn: (stream: Stream) ::=> Void := {
        stream nextPut: 't'; print: index.
        name ifNotNil: (stream space; string: name)
    }.
}.

public final class TACGlobalVariable superclass: TACVariable; definition: {
    public override method isGlobalVariable => Boolean := true.

    public override method printOn: (stream: Stream) ::=> Void := {
        stream nextPutAll: "global".
        name ifNotNil: (stream space; string: name).
    }.

    public override method fullPrintOn: (stream: Stream) ::=> Void := {
        stream print: self; nextPutAll: " => "; print: type.
        self printDebugInfoOn: stream.
    }.
}.

public abstract class TACConstant superclass: TACValue; definition: {
    public override method isConstant => Boolean := true.
}.

public abstract class TACConstantInteger superclass: TACValue; definition: {
    public override method isConstant => Boolean := true.

    public override method physicalLocationClass => TACPhysicalLocation class
        := TACPhysicalIntegerRegister.
}.

public final class TACGenericObjectPointerConstant superclass: TACConstant; definition: {
    public field object => Untyped.
    public field size => Size.
    public field alignment => Size.
    public field type => Type.

    public override method physicalLocationClass => TACPhysicalLocation class
        := TACPhysicalIntegerRegister.

    public override method printOn: (stream: Stream) ::=> Void := {
        stream nextPutAll: "genericObjectPointerConstant("; print: object; nextPut: ')'
    }.
}.

public final class TACStringLiteralPointerConstant superclass: TACConstant; definition: {
    public field string => String.
    public field size => Size.
    public field alignment => Size.
    public field type => Type.
    public field nullTerminated => Boolean.

    public override method printOn: (stream: Stream) ::=> Void := {
        stream nextPutAll: "stringLiteralPointerConstant("; print: string; nextPut: ')'
    }.
}.

public final class TACConstantInt8 superclass: TACConstantInteger; definition: {
    public field value => Int8.

    public override method isSignedExtended => Boolean := true.
    public override method isConstantInt8 => Boolean := true.
    public override method isImmediate8 => Boolean := true.
    public override method isImmediateU8 => Boolean := value >= 0i8.
    public override method isImmediate16 => Boolean := true.
    public override method isImmediate32 => Boolean := true.

    public override method type => Type := Int8.
    public override method size => UInt64 := 1u64.
    public override method alignment => UInt64 := 1u64.

    public override method getConstantValue64 => Int64 := value asInt64.

    public override method printOn: (stream: Stream) ::=> Void := {
        stream print: value; nextPutAll: "i8"
    }.

    Int8 extend: {
        public method asTacConstant => TACConstantInt8
            := TACConstantInt8 new value: self; yourself
    }
}.

public final class TACConstantUInt8 superclass: TACConstantInteger; definition: {
    public field value => UInt8.

    public override method isConstantUInt8 => Boolean := true.
    public override method isImmediate8 => Boolean := true.
    public override method isImmediateU8 => Boolean := true.
    public override method isImmediate16 => Boolean := true.
    public override method isImmediate32 => Boolean := true.

    public override method type => Type := UInt8.
    public override method size => UInt64 := 1u64.
    public override method alignment => UInt64 := 1u64.
    
    public override method getConstantValue64 => Int64 := value asInt64.

    public override method printOn: (stream: Stream) ::=> Void := {
        stream print: value; nextPutAll: "u8"
    }.

    UInt8 extend: {
        public method asTacConstant => TACConstantUInt8
            := TACConstantUInt8 new value: self; yourself
    }
}.

public final class TACConstantInt16 superclass: TACConstantInteger; definition: {
    public field value => Int16.

    public override method isSignedExtended => Boolean := true.
    public override method isConstantInt16 => Boolean := true.
    public override method isImmediateU8 => Boolean := (0i16 <= value) && (value <= 16rff i16).
    public override method isImmediate16 => Boolean := true.
    public override method isImmediate32 => Boolean := true.

    public override method type => Type := Int16.
    public override method size => UInt64 := 2u64.
    public override method alignment => UInt64 := 2u64.

    public override method getConstantValue64 => Int64 := value asInt64.

    public override method printOn: (stream: Stream) ::=> Void := {
        stream print: value; nextPutAll: "i16"
    }.

    Int16 extend: {
        public method asTacConstant => TACConstantInt16
            := TACConstantInt16 new value: self; yourself
    }
}.

public final class TACConstantUInt16 superclass: TACConstantInteger; definition: {
    public field value => UInt16.

    public override method isConstantUInt16 => Boolean := true.
    public override method isImmediateU8 => Boolean := value <= 16rff u16.
    public override method isImmediate16 => Boolean := true.
    public override method isImmediate32 => Boolean := true.

    public override method type => Type := UInt16.
    public override method size => UInt64 := 2u64.
    public override method alignment => UInt64 := 2u64.

    public override method getConstantValue64 => Int64 := value asInt64.

    public override method printOn: (stream: Stream) ::=> Void := {
        stream print: value; nextPutAll: "u16"
    }.

    UInt16 extend: {
        public method asTacConstant => TACConstantUInt16
            := TACConstantUInt16 new value: self; yourself
    }
}.

public final class TACConstantInt32 superclass: TACConstantInteger; definition: {
    public field value => Int32.

    public override method isSignedExtended => Boolean := true.
    public override method isConstantInt32 => Boolean := true.
    public override method isImmediateU8 => Boolean := (0i32 <= value) && (value <= 16rff i32).
    public override method isImmediate32 => Boolean := true.
    public override method isImmediateS32 => Boolean := true.

    public override method type => Type := Int32.
    public override method size => UInt64 := 4u64.
    public override method alignment => UInt64 := 4u64.

    public override method getConstantValue64 => Int64 := value asInt64.

    public override method printOn: (stream: Stream) ::=> Void := {
        stream print: value; nextPutAll: "i32"
    }.

    Int32 extend: {
        public method asTacConstant => TACConstantInt32
            := TACConstantInt32 new value: self; yourself
    }
}.

public final class TACConstantUInt32 superclass: TACConstantInteger; definition: {
    public field value => UInt32.

    public override method isConstantUInt32 => Boolean := true.
    public override method isImmediateU8 => Boolean := value <= 16rff u32.
    public override method isImmediate32 => Boolean := true.
    public override method isImmediateS32 => Boolean := value <= 16r7FFFFFFF u32.

    public override method type => Type := UInt32.
    public override method size => UInt64 := 4u64.
    public override method alignment => UInt64 := 4u64.

    public override method getConstantValue64 => Int64 := value asInt64.

    public override method printOn: (stream: Stream) ::=> Void := {
        stream print: value; nextPutAll: "u32"
    }.

    UInt32 extend: {
        public method asTacConstant => TACConstantUInt32
            := TACConstantUInt32 new value: self; yourself
    }
}.

public final class TACConstantInt64 superclass: TACConstantInteger; definition: {
    public field value => Int64.

    public override method isSignedExtended => Boolean := true.
    public override method isConstantInt64 => Boolean := true.
    public override method isImmediate64 => Boolean := true.
    public override method isImmediateU8 => Boolean := (0i64 <= value) && (value <= 16rff i64).
    public override method isImmediateS32 => Boolean := value asInt32 asInt64 = value.

    public override method type => Type := Int64.
    public override method alignment => UInt64 := 8u64.
    public override method size => UInt64 := 8u64.
    
    public override method getConstantValue64 => Int64 := value.

    public override method printOn: (stream: Stream) ::=> Void := {
        stream print: value; nextPutAll: "i64"
    }.

    Int64 extend: {
        public method asTacConstant => TACConstantInt64
            := TACConstantInt64 new value: self; yourself
    }
}.

public final class TACConstantUInt64 superclass: TACConstantInteger; definition: {
    public field value => UInt64.

    public override method isConstantUInt64 => Boolean := true.
    public override method isImmediateU8 => Boolean := value <= 16rff u64.
    public override method isImmediateS32 => Boolean := value asInt32 asInt64 asUInt64 = value.
    public override method isImmediate64 => Boolean := true.

    public override method getConstantValue64 => Int64 := value asInt64.

    public override method type => Type := UInt64.
    public override method alignment => UInt64 := 8u64.
    public override method size => UInt64 := 8u64.

    public override method printOn: (stream: Stream) ::=> Void := {
        stream print: value; nextPutAll: "u64"
    }.

    UInt64 extend: {
        public method asTacConstant => TACConstantUInt64
            := TACConstantUInt64 new value: self; yourself
    }.
}.

public final class TACConstantFloatingPoint superclass: TACConstant; definition: {
    public override method isFloatingPoint => Boolean := true.
    public override method isConstantFloat => Boolean := true.

    public override method physicalLocationClass => TACPhysicalLocation class
        := TACPhysicalFloatRegister.
}.

public final class TACConstantFloat32 superclass: TACConstantFloatingPoint; definition: {
    public field value => Float32.

    public override method isConstantFloat32 => Boolean := true.
    public override method isImmediate32 => Boolean := true.

    public override method type => Type := Float32.
    public override method alignment => UInt64 := 4u64.
    public override method size => UInt64 := 4u64.

    public override method printOn: (stream: Stream) ::=> Void := {
        stream print: value; nextPutAll: "f32"
    }.

    Float32 extend: {
        public method asTacConstant => TACConstantFloat32
            := TACConstantFloat32 new value: self; yourself
    }.
}.

public final class TACConstantFloat64 superclass: TACConstantFloatingPoint; definition: {
    public field value => Float64.

    public override method isConstantFloat64 => Boolean := true.
    public override method isImmediate64 => Boolean := true.

    public override method type => Type := Float64.
    public override method alignment => UInt64 := 8u64.
    public override method size => UInt64 := 8u64.

    public override method printOn: (stream: Stream) ::=> Void := {
        stream print: value; nextPutAll: "f64"
    }.

    Float64 extend: {
        public method asTacConstant => TACConstantFloat64
            := TACConstantFloat64 new value: self; yourself
    }.
}.

public final class TACOperation superclass: Object; definition: {
    public field name => Symbol.
    public field isTerminator => Boolean.
    public field isDebug => Boolean.

    protected field perTargetCodeGenerators => IdentityDictionary.
    protected field perTargetRegisterConstraints => IdentityDictionary.

    __Meta__ definition: {
        public method named: (name: Symbol) ::=> self
            := self new name: name; yourself.

        public method terminatorNamed: (name: Symbol) ::=> self
            := self new name: name; isTerminator: true; yourself.

        public method debugNamed: (name: Symbol) ::=> self
            := self new name: name; isDebug: true; yourself.
    }.

    public override method initialize => Void := {
        perTargetCodeGenerators := IdentityDictionary new.
        perTargetRegisterConstraints := IdentityDictionary new.
    }.

    public override method printOn: (stream: Stream) ::=> Void := {
        stream string: name
    }.
}.

TACInstruction definition: {
    public field previous => TACInstruction.
    public field next => TACInstruction.

    public field index => UInt32.

    public field operation => TACOperation.
    public field result => TACValue.
    public field operands => Array.

    public field resultRegister => TACPhysicalLocation.
    public field operandRegisters => Array.
    public field scratchRegisters => Array.

    public field callingConvention => TACCallingConvention.

    public field sourceBinding => SymbolBinding.

    public override method initialize => Void := {
        super initialize.
        operands := #().
    }.

    public method isTerminator => Boolean
        := operation isTerminator.

    public method isDebug => Boolean
        := operation isDebug.

    public override method fullPrintOn: (stream: Stream) ::=> Void := {
        result ifNotNil: (stream print: result; nextPutAll: " := ").
        stream print: operation.
        operands doWithIndex: {:(TACValue)eachOperand :(Size)index :: Void |
            index = 0sz
                ifTrue: (stream space)
                ifFalse: (stream nextPutAll: ", ").
            stream print: eachOperand
        }.
        self printDebugInfoOn: stream.
    }.

    public method markLiveRange => Void := {
        result ifNotNil: (result markWriteAt: index).
        operands do: {:(TACValue)value :: Void |
            value markUsageAt: index
        }
    }.

    public method resetRegisterAllocation => Void := {
        resultRegister := nil.
        operandRegisters := operands size > 0sz ifTrue: (Array new: operands size) ifFalse: #().
        scratchRegisters := #().
    }.

    public method firstOperandRegister => TACPhysicalLocation := operandRegisters first.
    public method secondOperandRegister => TACPhysicalLocation := operandRegisters second.
    public method thirdOperandRegister => TACPhysicalLocation := operandRegisters third.
    public method fourthOperandRegister => TACPhysicalLocation := operandRegisters fourth.

    public method firstScratchRegister => TACPhysicalLocation := scratchRegisters first.
    public method secondScratchRegister => TACPhysicalLocation := scratchRegisters first.
}.

public global TAC::Operation::Branch := TACOperation terminatorNamed: #branch.
public global TAC::Operation::ConditionalBranch := TACOperation terminatorNamed: #condBranch.

public global TAC::Operation::MoveInt8 := TACOperation named: #moveInt8.
public global TAC::Operation::MoveInt16 := TACOperation named: #moveInt16.
public global TAC::Operation::MoveInt32 := TACOperation named: #moveInt32.
public global TAC::Operation::MoveInt64 := TACOperation named: #moveInt64.
public global TAC::Operation::MoveFloat32 := TACOperation named: #moveFloat32.
public global TAC::Operation::MoveFloat64 := TACOperation named: #moveFloat64.
public global TAC::Operation::MoveStruct := TACOperation named: #moveStruct.

public global TAC::Operation::LoadInt8 := TACOperation named: #loadInt8.
public global TAC::Operation::LoadInt16 := TACOperation named: #loadInt16.
public global TAC::Operation::LoadInt32 := TACOperation named: #loadInt32.
public global TAC::Operation::LoadInt64 := TACOperation named: #loadInt64.
public global TAC::Operation::LoadUInt8 := TACOperation named: #loadUInt8.
public global TAC::Operation::LoadUInt16 := TACOperation named: #loadUInt16.
public global TAC::Operation::LoadUInt32 := TACOperation named: #loadUInt32.
public global TAC::Operation::LoadUInt64 := TACOperation named: #loadUInt64.
public global TAC::Operation::LoadFloat32 := TACOperation named: #loadFloat32.
public global TAC::Operation::LoadFloat64 := TACOperation named: #loadFloat64.
public global TAC::Operation::LoadStruct := TACOperation named: #loadStruct.

public global TAC::Operation::StoreInt8 := TACOperation named: #storeInt8.
public global TAC::Operation::StoreInt16 := TACOperation named: #storeInt16.
public global TAC::Operation::StoreInt32 := TACOperation named: #storeInt32.
public global TAC::Operation::StoreInt64 := TACOperation named: #storeInt64.
public global TAC::Operation::StoreFloat32 := TACOperation named: #storeFloat32.
public global TAC::Operation::StoreFloat64 := TACOperation named: #storeFloat64.
public global TAC::Operation::StoreStruct := TACOperation named: #storeStruct.

public global TAC::Operation::CallInt8 := TACOperation named: #callInt8.
public global TAC::Operation::CallInt16 := TACOperation named: #callInt16.
public global TAC::Operation::CallInt32 := TACOperation named: #callInt32.
public global TAC::Operation::CallInt64 := TACOperation named: #callInt64.
public global TAC::Operation::CallFloat32 := TACOperation named: #callFloat32.
public global TAC::Operation::CallFloat64 := TACOperation named: #callFloat64.
public global TAC::Operation::CallStruct := TACOperation named: #callStruct.
public global TAC::Operation::CallVoid := TACOperation named: #callVoid.

public global TAC::Operation::ReturnInt8 := TACOperation terminatorNamed: #returnInt8.
public global TAC::Operation::ReturnInt16 := TACOperation terminatorNamed: #returnInt16.
public global TAC::Operation::ReturnInt32 := TACOperation terminatorNamed: #returnInt32.
public global TAC::Operation::ReturnInt64 := TACOperation terminatorNamed: #returnInt64.
public global TAC::Operation::ReturnFloat32 := TACOperation terminatorNamed: #returnFloat32.
public global TAC::Operation::ReturnFloat64 := TACOperation terminatorNamed: #returnFloat64.
public global TAC::Operation::ReturnStruct := TACOperation terminatorNamed: #returnStruct.
public global TAC::Operation::ReturnVoid := TACOperation terminatorNamed: #returnVoid.

public global TAC::Operation::Trap := TACOperation named: #trap.
public global TAC::Operation::UnreachableTrap := TACOperation terminatorNamed: #unreachableTrap.

public global TAC::Operation::DebugSetBindingValue := TACOperation debugNamed: #debugSetBindingValue.
public global TAC::Operation::DebugSetMutableBindingValue := TACOperation debugNamed: #debugSetMutableBindingValue.

TACBasicBlock definition: {
    public field name => Symbol.
    public field index => UInt32.

    public field previous => TACBasicBlock.
    public field next => TACBasicBlock.

    public field firstInstruction => TACInstruction.
    public field lastInstruction => TACInstruction.

    public override method physicalLocationClass => TACPhysicalLocation class
        := TACPhysicalIntegerRegister.

    public override method isRelativeImmediate32 => Boolean := true.


    public method addInstruction: (instruction: TACInstruction) before: (position: TACInstruction) ::=> Void := {
        let before := position ifNotNil: position previous ifNil: lastInstruction.
        let after := position.

        ## Do not add instructions after a terminator.
        before isNotNil && before isTerminator ifTrue: (return: void).

        before ifNotNil: {
            before next: instruction.
            instruction previous: before.
        } ifNil: {
            firstInstruction := instruction
        }.

        after ifNotNil: {
            after previous: instruction.
            instruction next: after
        } ifNil: {
            lastInstruction := instruction
        }.
    }.

    public method addInstruction: (instruction: TACInstruction) ::=> Void := {
        self addInstruction: instruction before: nil
    }.

    public method instructionsDo: aBlock ::=> Void := {
        let position mutable := firstInstruction.
        while: (position isNotNil) do: {
            let nextPosition := position next.
            aBlock(position).
            position := nextPosition
        }
    }.

    public override method printOn: (stream: Stream) ::=> Void := {
        stream nextPut: '@'; print: index.
        name ifNotNil: (stream nextPut: ':'; string: name)
    }.

    public override method fullPrintOn: (stream: Stream) ::=> Void := {
        stream print: self; nextPut: ':'.
        self printDebugInfoOn: stream.
        stream nl.
        self instructionsDo: {:(TACBasicBlock)each :: Void |
            stream nextPutAll: "    "; fullPrint: each; nl
        }.
    }.
}.

public final class TACFunction superclass: TACProgramEntity; definition: {
    public field callingConvention => TACCallingConvention.

    public field arguments => Array.
    public field captures => Array.
    public field temporaries => OrderedCollection.

    public field firstBasicBlock => TACBasicBlock.
    public field lastBasicBlock => TACBasicBlock.

    public field debugIsTrampoline => Boolean.

    public override method isFunction => Boolean := true.

    public override method physicalLocationClass => TACPhysicalLocation class
        := TACPhysicalIntegerRegister.

    public override method isRelativeImmediate32 => Boolean := true.

    public override method initialize => Void := {
        super initialize.
        arguments := #().
        captures := #().
        temporaries := OrderedCollection new
    }.

    public method addTemporary: (temporary: TACTemporaryVariable) ::=> TACTemporaryVariable := {
        temporaries add: temporary.
        temporary
    }.

    public method newArgument: (name: Symbol) withType: (type: Type) sourceBinding: (sourceBinding: SymbolBinding)::=> TACArgumentVariable
        := TACArgumentVariable new
            name: name;
            type: type;
            size: (type valueSizeForTacTarget: compilationTarget) asUInt64;
            alignment: (type valueAlignmentForTacTarget: compilationTarget) asUInt64;
            isGCRoot: type isGarbageCollectedPointerType;
            physicalLocationClass: type valueTacPhysicalLocationClass;
            sourceBinding: sourceBinding;
            yourself.

    public method newArgument: (name: Symbol) withType: (type: Type) ::=> TACArgumentVariable
        := self newArgument: name withType: type sourceBinding: nil.

    public method newArgumentWithType: (type: Type) ::=> TACArgumentVariable
        := self newArgument: nil withType: type.

    public method newCapture: (name: Symbol) withType: (type: Type) ::=> TACCaptureVariable
        := TACCaptureVariable new
            name: name;
            type: type;
            size: (type valueSizeForTacTarget: compilationTarget) asUInt64;
            alignment: (type valueAlignmentForTacTarget: compilationTarget) asUInt64;
            isGCRoot: type isGarbageCollectedPointerType;
            physicalLocationClass: type valueTacPhysicalLocationClass;
            yourself.

    public method newCaptureWithType: (type: Type) ::=> TACCaptureVariable
        := self newCapture: nil withType: type.

    public method newTemporary: (name: Symbol) withType: (type: Type) ::=> TACTemporaryVariable
        := self addTemporary: (TACTemporaryVariable new
            name: name;
            type: type;
            size: (type valueSizeForTacTarget: compilationTarget) asUInt64;
            alignment: (type valueAlignmentForTacTarget: compilationTarget) asUInt64;
            isGCRoot: type isGarbageCollectedPointerType;
            physicalLocationClass: type valueTacPhysicalLocationClass;
            yourself).

    public method newTemporaryWithType: (type: Type) ::=> TACTemporaryVariable
        := self newTemporary: nil withType: type.

    public method newTemporaryUInt8 => TACTemporaryVariable
        := self newTemporaryWithType: UInt8.

    public method newTemporaryInt8 => TACTemporaryVariable
        := self newTemporaryWithType: Int8.

    public method newTemporaryUInt16 => TACTemporaryVariable
        := self newTemporaryWithType: UInt16.

    public method newTemporaryInt16 => TACTemporaryVariable
        := self newTemporaryWithType: Int8.

    public method newTemporaryUInt32 => TACTemporaryVariable
        := self newTemporaryWithType: UInt32.

    public method newTemporaryInt32 => TACTemporaryVariable
        := self newTemporaryWithType: Int32.

    public method newTemporaryUInt64 => TACTemporaryVariable
        := self newTemporaryWithType: UInt64.

    public method newTemporaryInt64 => TACTemporaryVariable
        := self newTemporaryWithType: Int64.

    public method newTemporaryUIntPointer => TACTemporaryVariable
        := compilationTarget pointerSize = 8sz
            ifTrue: (self newTemporaryUInt64)
            ifFalse: (self newTemporaryUInt32).

    public method newTemporaryIntPointer => TACTemporaryVariable
        := compilationTarget pointerSize = 8sz
            ifTrue: (self newTemporaryInt64)
            ifFalse: (self newTemporaryInt32).

    public method newTemporaryFloat32 => TACTemporaryVariable
        := self newTemporaryWithType: Float32.

    public method newTemporaryFloat64 => TACTemporaryVariable
        := self newTemporaryWithType: Float64.

    public method addBasicBlock: (basicBlock: TACBasicBlock) before: (position: TACBasicBlock) ::=> Void := {
        let before := position ifNotNil: position previous ifNil: lastBasicBlock.
        let after := position.

        before ifNotNil: {
            before next: basicBlock.
            basicBlock previous: before.
        } ifNil: {
            firstBasicBlock := basicBlock
        }.

        after ifNotNil: {
            after previous: basicBlock.
            basicBlock next: after
        } ifNil: {
            lastBasicBlock := basicBlock
        }.
    }.

    public method addBasicBlock: (basicBlock: TACBasicBlock) ::=> Void := {
        self addBasicBlock: basicBlock before: nil
    }.

    public method basicBlocksDo: (aBlock: (TACBasicBlock) => Void) ::=> Void := {
        let position mutable := firstBasicBlock.
        while: (position isNotNil) do: {
            let nextPosition := position next.
            aBlock(position).
            position := nextPosition
        }
    }.

    public method enumerateBlocks => Void := {
        let index mutable := 0u32.
        self basicBlocksDo: {:(TACBasicBlock)each :: Void |
            each index: index.
            index := index + 1u32.
        }.
    }.

    public method instructionsDo: (aBlock: (TACInstruction) => Void) ::=> Void := {
        self basicBlocksDo: {:(TACBasicBlock)each :: Void |
            each instructionsDo: aBlock
        }.
    }.

    public method enumerateInstructions => Void := {
        let index mutable := 1u32.
        self instructionsDo: {:(TACInstruction)each :: Void |
            each index: index.
            index := index + 1u32
        }
    }.

    public method allLocalVariablesDo: (aBlock: (TACLocalVariable) => Void) ::=> Void := {
        arguments do: aBlock.
        captures do: aBlock.
        temporaries do: aBlock.
    }.

    public method enumerateLocals => Void := {
        let index mutable := 0u32.
        self allLocalVariablesDo: {:(TACLocalVariable)each :: Void |
            each index: index.
            index := index + 1u32
        }
    }.

    public method computeLiveRanges => Void := {
        self enumerateInstructions.
        self allLocalVariablesDo: {:(TACLocalVariable)eachLocal :: Void |
            eachLocal resetLiveRange
        }.
        self instructionsDo: {:(TACInstruction)eachInstruction :: Void |
            eachInstruction markLiveRange
        }.
    }.

    public override method printOn: (stream: Stream) ::=> Void := {
        stream nextPutAll: "function".
        name ifNotNil: (stream space; string: name).
    }.

    public override method fullPrintOn: (stream: Stream) ::=> Void := {
        stream print: self; nextPutAll: " {".
        self printDebugInfoOn: stream.
        stream nl.
        self enumerateBlocks; enumerateLocals.
        self basicBlocksDo: {:(TACBasicBlock)each :: Void |
            stream fullPrint: each
        }.
        stream nextPut: '}'; nl.
    }.
}.

public final class TACBlockBuilder superclass: Object; definition: {
    public field block => TACBasicBlock.
    public field function => TACFunction.

    ## Debugging information
    public field debugSourcePosition => SourcePosition.
    public field debugSourceNode => ASTNode.
    public field debugSourceEnvironment => Environment.

    public method addInstruction: (instruction: TACInstruction) ::=> TACInstruction := {
        block addInstruction: instruction.
        instruction
            debugSourcePosition: debugSourcePosition;
            debugSourceNode: debugSourceNode;
            debugSourceEnvironment: debugSourceEnvironment.
        instruction
    }.

    public method temporaryUInt8 => TACTemporaryVariable := function newTemporaryUInt8.
    public method temporaryInt8 => TACTemporaryVariable := function newTemporaryInt8.
    public method temporaryUInt16 => TACTemporaryVariable := function newTemporaryUInt16.
    public method temporaryInt16 => TACTemporaryVariable := function newTemporaryInt16.
    public method temporaryUInt32 => TACTemporaryVariable := function newTemporaryUInt32.
    public method temporaryInt32 => TACTemporaryVariable := function newTemporaryInt32.
    public method temporaryUInt64 => TACTemporaryVariable := function newTemporaryUInt64.
    public method temporaryInt64 => TACTemporaryVariable := function newTemporaryInt64.
    public method temporaryUIntPointer => TACTemporaryVariable := function newTemporaryUIntPointer.
    public method temporaryFloat32 => TACTemporaryVariable := function newTemporaryFloat32.
    public method temporaryFloat64 => TACTemporaryVariable := function newTemporaryFloat64.

    public method compilationTarget => TACCompilationTarget := function compilationTarget.
    public method pointerSize => Size := function compilationTarget pointerSize.
    public method uintPointerType => Type := function compilationTarget uintPointerType.
    public method has64BitsPointers => Boolean := self pointerSize = 8sz.

    public method operation: (operation: TACOperation) ::=> TACInstruction
        := self addInstruction: (TACInstruction new operation: operation; yourself).

    public method operation: (operation: TACOperation) withOperands: (operands: Array) result: (result: TACValue) ::=> TACInstruction := {
        self assert: (operands allSatisfy: {:each :: Boolean | each isNotNil}).
        self addInstruction: (TACInstruction new operation: operation; operands: operands; result: result; yourself)
    }.

    public method operation: (operation: TACOperation) withOperands: (operands: Array) ::=> TACInstruction
        := self operation: operation withOperands: operands result: nil.

    public method operation: (operation: TACOperation) with: (operand: TACValue) ::=> TACInstruction
        := self operation: operation withOperands: (Array with: operand).

    public method operation: (operation: TACOperation) with: (operand: TACValue) result: (result: TACValue)::=> TACInstruction
        := self operation: operation withOperands: (Array with: operand) result: result.

    public method operation: (operation: TACOperation) with: (firstOperand: TACValue) with: (secondOperand: TACValue) ::=> TACInstruction
        := self operation: operation withOperands: (Array with: firstOperand with: secondOperand)..

    public method operation: (operation: TACOperation) with: (firstOperand: TACValue) with: (secondOperand: TACValue) result: (result: TACValue) ::=> TACInstruction
        := self operation: operation withOperands: (Array with: firstOperand with: secondOperand) result: result.

    public method operation: (operation: TACOperation) with: (firstOperand: TACValue) with: (secondOperand: TACValue) with: (thirdOperand: TACValue) ::=> TACInstruction
        := self operation: operation withOperands: (Array with: firstOperand with: secondOperand with: thirdOperand).

    public method operation: (operation: TACOperation) with: (firstOperand: TACValue) with: (secondOperand: TACValue) with: (thirdOperand: TACValue) with: (fourthOperand: TACValue) ::=> TACInstruction
        := self operation: operation withOperands: (Array with: firstOperand with: secondOperand with: thirdOperand with: fourthOperand).

    public method branch: (destination: TACValue) ::=> TACInstruction
        := self operation: TAC::Operation::Branch with: destination.

    public method when: (condition: TACValue) branchIfTrue: (trueDestination: TACValue) branchIfFalse: (falseDestination: TACValue) ::=> TACInstruction
        := self operation: TAC::Operation::ConditionalBranch with: condition with: trueDestination with: falseDestination.

    public method call: (function: TACValue) operation: (callOperation: TACOperation) convention: (callingConvention: TACCallingConvention) arguments: (arguments: Array) result: (result: TACValue) ::=> TACInstruction
        := self addInstruction: (TACInstruction new
            operation: callOperation;
            operands: (Array with: function) -- arguments;
            callingConvention: callingConvention;
            result: result;
            yourself).

    public method callInt8: (function: TACValue) convention: (callingConvention: TACCallingConvention) arguments: (arguments: Array) result: (result: TACValue) ::=> TACInstruction
        := self call: function operation: TAC::Operation::CallInt8 convention: callingConvention arguments: arguments result: result.

    public method callInt8: (function: TACValue) arguments: (arguments: Array) result: (result: TACValue) ::=> TACInstruction
        := self callInt8: function convention: self compilationTarget defaultCallingConvention arguments: arguments result: result.

    public method callInt16: (function: TACValue) convention: (callingConvention: TACCallingConvention) arguments: (arguments: Array) result: (result: TACValue) ::=> TACInstruction
        := self call: function operation: TAC::Operation::CallInt16 convention: callingConvention arguments: arguments result: result.

    public method callInt16: (function: TACValue) arguments: (arguments: Array) result: (result: TACValue) ::=> TACInstruction
        := self callInt16: function convention: self compilationTarget defaultCallingConvention arguments: arguments result: result.

    public method callInt32: (function: TACValue) convention: (callingConvention: TACCallingConvention) arguments: (arguments: Array) result: (result: TACValue) ::=> TACInstruction
        := self call: function operation: TAC::Operation::CallInt32 convention: callingConvention arguments: arguments result: result.

    public method callInt32: (function: TACValue) arguments: (arguments: Array) result: (result: TACValue) ::=> TACInstruction
        := self callInt32: function convention: self compilationTarget defaultCallingConvention arguments: arguments result: result.

    public method callInt64: (function: TACValue) convention: (callingConvention: TACCallingConvention) arguments: (arguments: Array) result: (result: TACValue) ::=> TACInstruction
        := self call: function operation: TAC::Operation::CallInt64 convention: callingConvention arguments: arguments result: result.

    public method callInt64: (function: TACValue) arguments: (arguments: Array) result: (result: TACValue) ::=> TACInstruction
        := self callInt64: function convention: self compilationTarget defaultCallingConvention arguments: arguments result: result.

    public method callPointer: (function: TACValue) convention: (callingConvention: TACCallingConvention) arguments: (arguments: Array) result: (result: TACValue) ::=> TACInstruction
        := self call: function
            operation: (self has64BitsPointers ifTrue: (TAC::Operation::CallInt64) ifFalse: (TAC::Operation::CallInt32))
            convention: self compilationTarget defaultCallingConvention arguments: arguments result: result.

    public method callPointer: (function: TACValue) arguments: (arguments: Array) result: (result: TACValue) ::=> TACInstruction
        := self callPointer: function convention: self compilationTarget defaultCallingConvention arguments: arguments result: result.

    public method callPointer: (function: TACValue) with: (firstArgument: TACValue) result: (result: TACValue) ::=> TACInstruction
        := self callPointer: function arguments: (Array with: firstArgument) result: result.

    public method callPointer: (function: TACValue) with: (firstArgument: TACValue) with: (secondArgument: TACValue) result: (result: TACValue) ::=> TACInstruction
        := self callPointer: function arguments: (Array with: firstArgument with: secondArgument) result: result.

    public method callPointer: (function: TACValue) with: (firstArgument: TACValue) with: (secondArgument: TACValue) with: (thirdArgument: TACValue) result: (result: TACValue) ::=> TACInstruction
        := self callPointer: function arguments: (Array with: firstArgument with: secondArgument with: thirdArgument) result: result.

    public method callFloat32: (function: TACValue) convention: (callingConvention: TACCallingConvention) arguments: (arguments: Array) result: (result: TACValue) ::=> TACInstruction
        := self call: function operation: TAC::Operation::CallFloat32 convention: callingConvention arguments: arguments result: result.

    public method callFloat32: (function: TACValue) arguments: (arguments: Array) result: (result: TACValue) ::=> TACInstruction
        := self callFloat32: function convention: self compilationTarget defaultCallingConvention arguments: arguments result: result.

    public method callFloat64: (function: TACValue) convention: (callingConvention: TACCallingConvention) arguments: (arguments: Array) result: (result: TACValue) ::=> TACInstruction
        := self call: function operation: TAC::Operation::CallFloat64 convention: callingConvention arguments: arguments result: result.

    public method callFloat64: (function: TACValue) arguments: (arguments: Array) result: (result: TACValue) ::=> TACInstruction
        := self callFloat64: function convention: self compilationTarget defaultCallingConvention arguments: arguments result: result.

    public method callStruct: (function: TACValue) convention: (callingConvention: TACCallingConvention) arguments: (arguments: Array) result: (result: TACValue) ::=> TACInstruction
        := self call: function operation: TAC::Operation::CallStruct convention: callingConvention arguments: arguments result: result.

    public method callStruct: (function: TACValue) arguments: (arguments: Array) result: (result: TACValue) ::=> TACInstruction
        := self callStruct: function convention: self compilationTarget defaultCallingConvention arguments: arguments result: result.

    public method callVoid: (function: TACValue) convention: (callingConvention: TACCallingConvention) arguments: (arguments: Array) ::=> TACInstruction
        := self call: function operation: TAC::Operation::CallVoid convention: callingConvention arguments: arguments result: nil.

    public method callVoid: (function: TACValue) arguments: (arguments: Array) ::=> TACInstruction
        := self callVoid: function convention: self compilationTarget defaultCallingConvention arguments: arguments.

    public method callVoid: (function: TACValue) with: (firstArgument: TACValue) ::=> TACInstruction
        := self callVoid: function arguments: (Array with: firstArgument).

    public method callVoid: (function: TACValue) with: (firstArgument: TACValue) with: (secondArgument: TACValue) ::=> TACInstruction
        := self callVoid: function arguments: (Array with: firstArgument with: secondArgument).

    public method callVoid: (function: TACValue) with: (firstArgument: TACValue) with: (secondArgument: TACValue) with: (thirdArgument: TACValue) ::=> TACInstruction
        := self callVoid: function arguments: (Array with: firstArgument with: secondArgument with: thirdArgument).

    public method moveInt8: (source: TACValue) into: (destination: TACValue) ::=> TACInstruction
        := self operation: TAC::Operation::MoveInt8 with: source result: destination.

    public method moveInt16: (source: TACValue) into: (destination: TACValue) ::=> TACInstruction
        := self operation: TAC::Operation::MoveInt16 with: source result: destination.

    public method moveInt32: (source: TACValue) into: (destination: TACValue) ::=> TACInstruction
        := self operation: TAC::Operation::MoveInt32 with: source result: destination.

    public method moveInt64: (source: TACValue) into: (destination: TACValue) ::=> TACInstruction
        := self operation: TAC::Operation::MoveInt64 with: source result: destination.

    public method moveStruct: (source: TACValue) into: (destination: TACValue) ::=> TACInstruction
        := self operation: TAC::Operation::MoveStruct with: source result: destination.

    public method movePointer: (source: TACValue) into: (destination: TACValue) ::=> TACInstruction
        := self operation: (self has64BitsPointers ifTrue: (TAC::Operation::MoveInt64) ifFalse: (TAC::Operation::MoveInt32))
            with: source result: destination.

    public method moveFloat32: (source: TACValue) into: (destination: TACValue) ::=> TACInstruction
        := self operation: TAC::Operation::MoveFloat32 with: source result: destination.

    public method moveFloat64: (source: TACValue) into: (destination: TACValue) ::=> TACInstruction
        := self operation: TAC::Operation::MoveFloat64 with: source result: destination.

    public method constantOffsetImmediateFor: (constantOffset: Int64) ::=> TACValue
        := self has64BitsPointers && (constantOffset asInt32 asInt64 ~= constantOffset)
            ifTrue: (constantOffset asTacConstant)
            ifFalse: (constantOffset asInt32 asTacConstant).

    public method loadInt8: (pointer: TACValue) constantOffset: (constantOffset: Int64) into: (destination: TACValue) ::=> TACInstruction
        := self operation: TAC::Operation::LoadInt8 with: pointer with: (self constantOffsetImmediateFor: constantOffset) result: destination.

    public method loadInt16: (pointer: TACValue) constantOffset: (constantOffset: Int64) into: (destination: TACValue) ::=> TACInstruction
        := self operation: TAC::Operation::LoadInt16 with: pointer with: (self constantOffsetImmediateFor: constantOffset) result: destination.

    public method loadInt32: (pointer: TACValue) constantOffset: (constantOffset: Int64) into: (destination: TACValue) ::=> TACInstruction
        := self operation: TAC::Operation::LoadInt32 with: pointer with: (self constantOffsetImmediateFor: constantOffset) result: destination.

    public method loadInt64: (pointer: TACValue) constantOffset: (constantOffset: Int64) into: (destination: TACValue) ::=> TACInstruction
        := self operation: TAC::Operation::LoadInt64 with: pointer with: (self constantOffsetImmediateFor: constantOffset) result: destination.

    public method loadUInt8: (pointer: TACValue) constantOffset: (constantOffset: Int64) into: (destination: TACValue) ::=> TACInstruction
        := self operation: TAC::Operation::LoadUInt8 with: pointer with: (self constantOffsetImmediateFor: constantOffset) result: destination.

    public method loadUInt16: (pointer: TACValue) constantOffset: (constantOffset: Int64) into: (destination: TACValue) ::=> TACInstruction
        := self operation: TAC::Operation::LoadUInt16 with: pointer with: (self constantOffsetImmediateFor: constantOffset) result: destination.

    public method loadUInt32: (pointer: TACValue) constantOffset: (constantOffset: Int64) into: (destination: TACValue) ::=> TACInstruction
        := self operation: TAC::Operation::LoadUInt32 with: pointer with: (self constantOffsetImmediateFor: constantOffset) result: destination.

    public method loadUInt64: (pointer: TACValue) constantOffset: (constantOffset: Int64) into: (destination: TACValue) ::=> TACInstruction
        := self operation: TAC::Operation::LoadUInt64 with: pointer with: (self constantOffsetImmediateFor: constantOffset) result: destination.

    public method loadFloat32: (pointer: TACValue) constantOffset: (constantOffset: Int64) into: (destination: TACValue) ::=> TACInstruction
        := self operation: TAC::Operation::LoadFloat32 with: pointer with: (self constantOffsetImmediateFor: constantOffset) result: destination.

    public method loadFloat64: (pointer: TACValue) constantOffset: (constantOffset: Int64) into: (destination: TACValue) ::=> TACInstruction
        := self operation: TAC::Operation::LoadFloat64 with: pointer with: (self constantOffsetImmediateFor: constantOffset) result: destination.

    public method addPointer: (pointer: TACValue) with: (offset: TACValue) into: (destination: TACValue) ::=> TACInstruction
        := self has64BitsPointers
                ifTrue: (self int64Add: pointer with: offset into: destination)
                ifFalse: (self int32Add: pointer with: offset into: destination).

    public method subPointer: (pointer: TACValue) with: (offset: TACValue) into: (destination: TACValue) ::=> TACInstruction
        := self has64BitsPointers
                ifTrue: (self int64Sub: pointer with: offset into: destination)
                ifFalse: (self int32Sub: pointer with: offset into: destination).

    public method multiplyPointerIndex: (index: TACValue) with: (scale: TACValue) into: (destination: TACValue) ::=> TACInstruction
        := self has64BitsPointers
                ifTrue: (self int64Mul: index with: scale into: destination)
                ifFalse: (self int32Mul: index with: scale into: destination).

    public method multiplyPointerIndex: (index: TACValue) constantScale: (constantScale: Int64) into: (destination: TACValue) ::=> TACInstruction
        := self multiplyPointerIndex: index with: (self constantOffsetImmediateFor: constantScale) into: destination.

    public method addPointer: (pointer: TACValue) constantOffset: (constantOffset: Int64) into: (destination: TACValue) ::=> TACInstruction := {
        constantOffset = 0i64 ifTrue: {
            self movePointer: pointer into: destination
        } ifFalse: {
            self addPointer: pointer with: (self constantOffsetImmediateFor: constantOffset) into: destination
        }
    }.

    public method pointerEquals: (left: TACValue) with: (right: TACValue) into: (destination: TACValue) ::=> TACInstruction
        := self has64BitsPointers
            ifTrue: (self int64Equals: left with: right into: destination)
            ifFalse: (self int32Equals: left with: right into: destination).

    public method pointerNotEquals: (left: TACValue) with: (right: TACValue) into: (destination: TACValue) ::=> TACInstruction
        := self has64BitsPointers
            ifTrue: (self int64NotEquals: left with: right into: destination)
            ifFalse: (self int32NotEquals: left with: right into: destination).

    public method loadPointer: (pointer: TACValue) constantOffset: (constantOffset: Int64) into: (destination: TACValue) ::=> TACInstruction
        := self has64BitsPointers
            ifTrue: (self loadUInt64: pointer constantOffset: constantOffset into: destination)
            ifFalse: (self loadUInt32: pointer constantOffset: constantOffset into: destination).

    public method loadStruct: (pointer: TACValue) constantOffset: (constantOffset: Int64) into: (destination: TACValue) ::=> TACInstruction
        := self operation: TAC::Operation::LoadStruct with: pointer with: (self constantOffsetImmediateFor: constantOffset) result: destination.

    public method pointerConstantWith: (value: UInt64) ::=> TACValue
        := self has64BitsPointers
            ifTrue: (value asTacConstant)
            ifFalse: (value asUInt32 asTacConstant).

    public method storeInt8: (value: TACValue) into: (pointer: TACValue) constantOffset: (constantOffset: Int64) ::=> TACInstruction
        := self operation: TAC::Operation::StoreInt8 with: value with: pointer with: (self constantOffsetImmediateFor: constantOffset).

    public method storeInt16: (value: TACValue) into: (pointer: TACValue) constantOffset: (constantOffset: Int64) ::=> TACInstruction
        := self operation: TAC::Operation::StoreInt16 with: value with: pointer with: (self constantOffsetImmediateFor: constantOffset).

    public method storeInt32: (value: TACValue) into: (pointer: TACValue) constantOffset: (constantOffset: Int64) ::=> TACInstruction
        := self operation: TAC::Operation::StoreInt32 with: value with: pointer with: (self constantOffsetImmediateFor: constantOffset).

    public method storeInt64: (value: TACValue) into: (pointer: TACValue) constantOffset: (constantOffset: Int64) ::=> TACInstruction
        := self operation: TAC::Operation::StoreInt64 with: value with: pointer with: (self constantOffsetImmediateFor: constantOffset).

    public method storePointer: (value: TACValue) into: (pointer: TACValue) constantOffset: (constantOffset: Int64) ::=> TACInstruction
        := self has64BitsPointers
            ifTrue: (self storeInt64: value into: pointer constantOffset: constantOffset)
            ifFalse: (self storeInt32: value into: pointer constantOffset: constantOffset).

    public method storeFloat32: (value: TACValue) into: (pointer: TACValue) constantOffset: (constantOffset: Int64) ::=> TACInstruction
        := self operation: TAC::Operation::StoreFloat32 with: value with: pointer with: (self constantOffsetImmediateFor: constantOffset).

    public method storeFloat64: (value: TACValue) into: (pointer: TACValue) constantOffset: (constantOffset: Int64) ::=> TACInstruction
        := self operation: TAC::Operation::StoreFloat64 with: value with: pointer with: (self constantOffsetImmediateFor: constantOffset).

    public method storeStruct: (value: TACValue) into: (pointer: TACValue) constantOffset: (constantOffset: Int64) ::=> TACInstruction
        := self operation: TAC::Operation::StoreStruct with: value with: pointer with: (self constantOffsetImmediateFor: constantOffset).

    public method loadEffectiveAddress: (basePointer: TACValue) index: (indexValue: TACValue) constantScale: (constantScale: Int64) into: (result: TACValue) ::=> TACInstruction := {
        constantScale = 0i64 ifTrue: {
            self movePointer: basePointer into: result
        } ifFalse: {
            indexValue isImmediate64 ifTrue: {
                let constantOffset := indexValue getConstantValue64 * constantScale.
                self addPointer: basePointer constantOffset: constantOffset into: result
            } ifFalse: {
                constantScale = 1i64 ifTrue: {
                    self addPointer: basePointer with: indexValue into: result
                } ifFalse: {
                    constantScale = -1i64 ifTrue: {
                        self subPointer: basePointer with: indexValue into: result
                    } ifFalse: {
                        self multiplyPointerIndex: indexValue constantScale: constantScale into: result.
                        self addPointer: result with: basePointer into: result
                    }
                }.
            }.
        }.
    }.

    public method returnVoid ::=> TACInstruction
        := self operation: TAC::Operation::ReturnVoid.

    public method returnInt8: (value: TACValue) ::=> TACInstruction
        := self operation: TAC::Operation::ReturnInt8 with: value.

    public method returnInt16: (value: TACValue) ::=> TACInstruction
        := self operation: TAC::Operation::ReturnInt16 with: value.

    public method returnInt32: (value: TACValue) ::=> TACInstruction
        := self operation: TAC::Operation::ReturnInt32 with: value.

    public method returnInt64: (value: TACValue) ::=> TACInstruction
        := self operation: TAC::Operation::ReturnInt64 with: value.

    public method returnPointer: (value: TACValue) ::=> TACInstruction
        := self has64BitsPointers
            ifTrue: (self returnInt64: value)
            ifFalse: (self returnInt32: value).

    public method returnFloat32: (value: TACValue) ::=> TACInstruction
        := self operation: TAC::Operation::ReturnFloat32 with: value.

    public method returnFloat64: (value: TACValue) ::=> TACInstruction
        := self operation: TAC::Operation::ReturnFloat64 with: value.

    public method returnStruct: (value: TACValue) ::=> TACInstruction
        := self operation: TAC::Operation::ReturnStruct with: value.

    public method trap ::=> TACInstruction
        := self operation: TAC::Operation::Trap.

    public method unreachableTrap ::=> TACInstruction
        := self operation: TAC::Operation::UnreachableTrap.

    public method debugSetBinding: (binding: SymbolBinding) value: (value: TACValue) ::=> TACInstruction
        := self addInstruction: (TACInstruction new
            operation: TAC::Operation::DebugSetBindingValue;
            operands: (Array with: value);
            sourceBinding: binding;
            yourself).

    public method debugSetMutableBinding: (binding: SymbolBinding) value: (value: TACValue) ::=> TACInstruction
        := self addInstruction: (TACInstruction new
            operation: TAC::Operation::DebugSetMutableBindingValue;
            operands: (Array with: value);
            sourceBinding: binding;
            yourself).
}.

public final class TACFunctionBuilder superclass: Object; definition: {
    public field function => TACFunction.

    ## Debugging information
    public field debugSourcePosition => SourcePosition.
    public field debugSourceNode => ASTNode.
    public field debugSourceEnvironment => Environment.

    TACFunction extend: {
        public method build: (aBlock: (TACFunctionBuilder) => Void) ::=> Void := {
            let builder := TACFunctionBuilder new
                function: self;
                yourself.
            aBlock(builder).
        }.
    }.

    public method basicBlock: (name: Symbol) build: (aBlock: (TACBlockBuilder) => Void) ::=> Void := {
        let block := TACBasicBlock new name: name; yourself.
        function addBasicBlock: block.

        let blockBuilder := TACBlockBuilder new
            block: block;
            function: function;
            yourself.
        aBlock(blockBuilder).
        block.
    }.

    public method setValueDebugInfo: (value: TACValue) ::=> Void := {
        value
            debugSourcePosition: debugSourcePosition;
            debugSourceNode: debugSourceNode;
            debugSourceEnvironment: debugSourceEnvironment
    }.

    public method newTemporary: (name: Symbol) withType: (type: Type) ::=> TACTemporaryVariable := {
        let temporary := function newTemporary: name withType: type.
        self setValueDebugInfo: temporary.
        temporary
    }.
}.

#(
    Int8BitNot Int16BitNot Int32BitNot Int64BitNot
    Int8Negate Int16Negate Int32Negate Int64Negate

    Float32Negate Float64Negate
    Float32Sqrt Float64Sqrt

    TruncateInt64ToInt32 TruncateInt64ToInt16 TruncateInt64ToInt8
    TruncateInt32ToInt16 TruncateInt32ToInt8
    TruncateInt16ToInt8

    SignExtendInt8ToInt16 SignExtendInt8ToInt32 SignExtendInt8ToInt64
    SignExtendInt16ToInt32 SignExtendInt16ToInt64
    SignExtendInt32ToInt64

    ZeroExtendInt8ToInt16 ZeroExtendInt8ToInt32 ZeroExtendInt8ToInt64
    ZeroExtendInt16ToInt32 ZeroExtendInt16ToInt64
    ZeroExtendInt32ToInt64

    UInt8ToFloat32 Int8ToFloat32 UInt16ToFloat32 Int16ToFloat32 UInt32ToFloat32 Int32ToFloat32 UInt64ToFloat32 Int64ToFloat32
    UInt8ToFloat64 Int8ToFloat64 UInt16ToFloat64 Int16ToFloat64 UInt32ToFloat64 Int32ToFloat64 UInt64ToFloat64 Int64ToFloat64

    Float32ToFloat64 Float32ToUInt8 Float32ToInt8 Float32ToUInt16 Float32ToInt16 Float32ToUInt32 Float32ToInt32 Float32ToUInt64 Float32ToInt64
    Float64ToFloat32 Float64ToUInt8 Float64ToInt8 Float64ToUInt16 Float64ToInt16 Float64ToUInt32 Float64ToInt32 Float64ToUInt64 Float64ToInt64
    Float32ToIEEEUInt32 Float64ToIEEEUInt64 IEEEUInt32ToFloat32 IEEEUInt64ToFloat64
    
) do: {:(Symbol)operationName :: Void |
    let operationNameString := operationName asString.
    let lowerOperationNameString := operationNameString first asLowercase asString -- operationNameString allButFirst.
    let lowerOperationName := lowerOperationNameString asSymbol.
    let operation := TACOperation named: lowerOperationName.
    let globalName := ("TAC::Operation::" -- operationNameString) asSymbol.

    TACBlockBuilder
        withSelector: (lowerOperationNameString -- ":into:") asSymbol addMethod: {:(TACBlockBuilder)self :(TACValue)operand :(TACValue)result :: TACInstruction |
            self operation: operation with: operand result: result.
        }.
    __OwnerProgramEntity__ setPublicSymbol: globalName value: operation
}.

#(
    Int8Add Int16Add Int32Add Int64Add
    Int8Sub Int16Sub Int32Sub Int64Sub
    Int8Mul Int16Mul Int32Mul Int64Mul
    Int8SDiv Int16SDiv Int32SDiv Int64SDiv
    Int8UDiv Int16UDiv Int32UDiv Int64UDiv
    Int8SRem Int16SRem Int32SRem Int64SRem
    Int8URem Int16URem Int32URem Int64URem

    Int8BitAnd Int16BitAnd Int32BitAnd Int64BitAnd
    Int8BitOr Int16BitOr Int32BitOr Int64BitOr
    Int8BitXor Int16BitXor Int32BitXor Int64BitXor
    Int8ArithmeticShiftRight Int16ArithmeticShiftRight Int32ArithmeticShiftRight Int64ArithmeticShiftRight
    Int8LogicalShiftLeft Int16LogicalShiftLeft Int32LogicalShiftLeft Int64LogicalShiftLeft
    Int8LogicalShiftRight Int16LogicalShiftRight Int32LogicalShiftRight Int64LogicalShiftRight

    Int8Compare Int16Compare Int32Compare Int64Compare

    Float32Add Float64Add
    Float32Sub Float64Sub
    Float32Mul Float64Mul
    Float32Div Float64Div

    Float32UnorderedCompare Float64UnorderedCompare
) do: {:(Symbol)operationName :: Void |
    let operationNameString := operationName asString.
    let lowerOperationNameString := operationNameString first asLowercase asString -- operationNameString allButFirst.
    let lowerOperationName := lowerOperationNameString asSymbol.
    let operation := TACOperation named: lowerOperationName.
    let globalName := ("TAC::Operation::" -- operationNameString) asSymbol.

    TACBlockBuilder
        withSelector: (lowerOperationNameString -- ":with:into:") asSymbol addMethod: {:(TACBlockBuilder)self :(TACValue)left :(TACValue)right :(TACValue)result :: TACInstruction |
            self operation: operation with: left with: right result: result.
        }.
    __OwnerProgramEntity__ setPublicSymbol: globalName value: operation
}.

let ComparisonOperationToBranchMap := Dictionary new.

#(
    Int8Equals Int16Equals Int32Equals Int64Equals
    Int8NotEquals Int16NotEquals Int32NotEquals Int64NotEquals

    Int8LessThan Int16LessThan Int32LessThan Int64LessThan
    Int8LessOrEquals Int16LessOrEquals Int32LessOrEquals Int64LessOrEquals
    Int8GreaterThan Int16GreaterThan Int32GreaterThan Int64GreaterThan
    Int8GreaterOrEquals Int16GreaterOrEquals Int32GreaterOrEquals Int64GreaterOrEquals

    UInt8LessThan UInt16LessThan UInt32LessThan UInt64LessThan
    UInt8LessOrEquals UInt16LessOrEquals UInt32LessOrEquals UInt64LessOrEquals
    UInt8GreaterThan UInt16GreaterThan UInt32GreaterThan UInt64GreaterThan
    UInt8GreaterOrEquals UInt16GreaterOrEquals UInt32GreaterOrEquals UInt64GreaterOrEquals

    Float32UnorderedEquals Float64UnorderedEquals
    Float32UnorderedNotEquals Float64UnorderedNotEquals
    Float32UnorderedLessThan Float64UnorderedLessThan
    Float32UnorderedLessOrEquals Float64UnorderedLessOrEquals
    Float32UnorderedGreaterThan Float64UnorderedGreaterThan
    Float32UnorderedGreaterOrEquals Float64UnorderedGreaterOrEquals
) do: {:(Symbol)operationName :: Void |
    let operationNameString := operationName asString.
    let lowerOperationNameString := operationNameString first asLowercase asString -- operationNameString allButFirst.

    let branchOperationNameString := operationNameString -- "Branch".
    let lowerBranchOperationNameString := branchOperationNameString first asLowercase asString -- branchOperationNameString allButFirst.

    let operation := TACOperation named: lowerOperationNameString asSymbol.
    let globalName := ("TAC::Operation::" -- operationNameString) asSymbol.

    let branchOperation := TACOperation terminatorNamed: lowerBranchOperationNameString asSymbol.
    let branchGlobalName := ("TAC::Operation::" -- branchOperationNameString) asSymbol.

    TACBlockBuilder
        withSelector: (lowerOperationNameString -- ":with:into:") asSymbol addMethod: {:(TACBlockBuilder)self :(TACValue)left :(TACValue)right :(TACValue)result :: TACInstruction |
            self operation: operation with: left with: right result: result.
        };
        withSelector: (lowerOperationNameString -- ":with:branchIfTrue:branchIfFalse:") asSymbol addMethod: {:(TACBlockBuilder)self :(TACValue)left :(TACValue)right :(TACValue)trueDestination :(TACValue)falseDestination :: TACInstruction |
            self operation: branchOperation with: left with: right with: trueDestination with: falseDestination.
        }.

    ComparisonOperationToBranchMap at: operation put: branchOperation.
    __OwnerProgramEntity__
        setPublicSymbol: globalName value: operation;
        setPublicSymbol: branchGlobalName value: branchOperation
}.

TACFunction definition: {
    public method performBasicOptimizations => Void := {
        self fuseComparisonAndBranches
    }.

    public method fuseComparisonAndBranches => Void := {
        self computeLiveRanges.
        self basicBlocksDo: {:(TACBasicBlock)eachBasicBlock :: Void |
            let position mutable := eachBasicBlock firstInstruction.
            while: position isNotNil do: {
                let nextPosition mutable := position next.
                nextPosition isNotNil &&
                nextPosition operation == TAC::Operation::ConditionalBranch &&
                nextPosition operands first == position result && 
                position result isNotNil && 
                (position result isLastUsedIn: nextPosition) ifTrue: {
                    let comparisonAndBranchOperation => TACOperation := ComparisonOperationToBranchMap atOrNil: position operation.
                    comparisonAndBranchOperation ifNotNil: {
                        position
                            operation: comparisonAndBranchOperation;
                            operands: position operands -- nextPosition operands allButFirst;
                            result: nil;
                            next: nextPosition next.
                        eachBasicBlock lastInstruction == nextPosition ifTrue: {
                            eachBasicBlock lastInstruction: position
                        }.

                        nextPosition := nextPosition next
                    }.
                }.

                position := nextPosition.
            }
        }
    }.

}.
public final class TACModule superclass: TACProgramEntity; definition: {
    public field programEntities => OrderedCollection.
    public field imageObjectTrace => ImageObjectTrace.

    public override method initialize => Void := {
        super initialize.
        programEntities := OrderedCollection new.
    }.

    public method addProgramEntity: (programEntity: TACProgramEntity) ::=> Void := {
        programEntities add: programEntity
    }.

    public method build: (name: Symbol) function: (aBlock: (TACFunctionBuilder) => Void) ::=> TACFunction := {
        let function := TACFunction new
            compilationTarget: compilationTarget;
            callingConvention: compilationTarget defaultCallingConvention;
            name: name;
            yourself.
        self addProgramEntity: function.
        function build: aBlock; yourself
    }.

    public override method fullPrintOn: (stream: Stream) ::=> Void := {
        self programEntities do: {:(TACProgramEntity)each :: Void |
            stream fullPrint: each; nl
        }
    }.

    public method asTargetIR => AnyValue
        := compilationTarget generateTargetIRForTACModule: self
}.

TACCallingConvention definition: {
    public abstract method computeArgumentPassingLayoutOf: (function: TACFunction) ::=> Void
        := self subclassResponsibility.
}.

TACCompilationTarget definition: {
    public abstract method name => Symbol
        := self subclassResponsibility.

    public abstract method pointerSize => Size
        := self subclassResponsibility.

    public abstract method pointerAlignment => Size
        := self subclassResponsibility.

    public abstract method uintPointerType => Type
        := self subclassResponsibility.

    public abstract method stackFrameAlignment => Size
        := self subclassResponsibility.

    public abstract method allIntegerRegisters => Array
        := self subclassResponsibility.

    public abstract method allocableIntegerRegisters => Array
        := self subclassResponsibility.

    public abstract method allFloatRegisters => Array
        := self subclassResponsibility.

    public abstract method allocableFloatRegisters => Array
        := self subclassResponsibility.

    public abstract method allVectorRegisters => Array
        := self subclassResponsibility.

    public abstract method allocableVectorRegisters => Array
        := self subclassResponsibility.

    public abstract method usesVectorRegistersForFloatOperations => Boolean
        := self subclassResponsibility.

    public abstract method generateTargetIRForTACModule: (module: TACModule) ::=> AnyValue
        := self subclassResponsibility.

    public abstract method defaultCallingConvention => TACCallingConvention
        := self subclassResponsibility.

    public virtual method objectModel => ObjectModelVariant
        := self pointerSize = 4sz ifTrue: ObjectModelVariant32 uniqueInstance ifFalse: ObjectModelVariant64 uniqueInstance.
}.
