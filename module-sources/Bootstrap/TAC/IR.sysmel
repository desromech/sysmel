public abstract class TACCompilationTarget superclass: Object.
public abstract class TACCallingConvention superclass: Object.
public abstract class TACValue superclass: Object.

public abstract class TACPhysicalLocation superclass: Object; definition: {
    public virtual method isMemory => Boolean := false.
    public virtual method isImmediate => Boolean := false.
    public virtual method isRegister => Boolean := false.
    public virtual method isIntegerRegister => Boolean := false.
    public virtual method isFloatRegister => Boolean := false.
    public virtual method isVectorRegister => Boolean := false.
}.

public abstract class TACPhysicalLocationMemory superclass: TACPhysicalLocation; definition: {
    public virtual method isMemory => Boolean := true.

    __Meta__ definition: {
        let singleton := TACPhysicalLocationMemory new.
        public method uniqueInstance => TACPhysicalLocationMemory
            := singleton.
    }
}.

public abstract class TACPhysicalLocationRegister superclass: TACPhysicalLocation; definition: {
    public virtual method isRegister => Boolean := true.
}.

public abstract class TACPhysicalIntegerRegister superclass: TACPhysicalLocationRegister; definition: {
    public virtual method isIntegerRegister => Boolean := true.
}.

public abstract class TACPhysicalFloatRegister superclass: TACPhysicalLocationRegister; definition: {
    public virtual method isFloatRegister => Boolean := true.
}.

public abstract class TACPhysicalVectorRegister superclass: TACPhysicalLocationRegister; definition: {
    public virtual method isVectorRegister => Boolean := true.
}.

public class TACPhysicalLocationImmediate superclass: TACPhysicalLocation; definition: {
    public field value => TACValue.

    __Meta__ definition: {
        public method for: (value: TACValue) ::=> self
            := self new value: value; yourself
    }.

    public virtual method isImmediate => Boolean := true.
}.

Type extend: {
    public method valueSizeForTacTarget: (target: TACCompilationTarget) ::=> Size
        := target pointerSize.

    public method valueAlignmentForTacTarget: (target: TACCompilationTarget) ::=> Size
        := target pointerAlignment.

    public method valueTacPhysicalLocationClass => TACPhysicalLocation class
        := TACPhysicalIntegerRegister.

    public method valueIsSignedExtended => Boolean := false.
}.

ValueType extend: {
    public method valueSizeForTacTarget: (target: TACCompilationTarget) ::=> Size
        := self valueSize.

    public method valueAlignmentForTacTarget: (target: TACCompilationTarget) ::=> Size
        := self valueAlignment.

}.

Int8 class extend: {
    public method valueIsSignedExtended => Boolean := true.
}.

Int16 class extend: {
    public method valueIsSignedExtended => Boolean := true.
}.

Int32 class extend: {
    public method valueIsSignedExtended => Boolean := true.
}.

Int64 class extend: {
    public method valueIsSignedExtended => Boolean := true.
}.

Float32 class extend: {
    public method valueTacPhysicalLocationClass => TACPhysicalLocation class
        := TACPhysicalFloatRegister.
}.

Float64 class extend: {
    public method valueTacPhysicalLocationClass => TACPhysicalLocation class
        := TACPhysicalFloatRegister.
}.

TACValue definition: {
    public field debugSourcePosition => SourcePosition.
    public field debugSourceNode => ASTNode.
    public field debugSourceEnvironment => Environment.

    public virtual method type => Type
        := self subclassResponsibility.

    public virtual method physicalLocationClass => TACPhysicalLocation class
        := self subclassResponsibility.

    public virtual method size => UInt64
        := self subclassResponsibility.

    public virtual method alignment => UInt64
        := self subclassResponsibility.

    public virtual method isSignedExtended => Boolean := false.
    public virtual method isFloatingPoint => Boolean := false.
    public virtual method isVector => Boolean := false.

    public virtual method isProgramEntity => Boolean := false.
    public virtual method isFunction => Boolean := false.
    public virtual method isLocalVariable => Boolean := false.

    public virtual method isVariable => Boolean := false.
    public virtual method isArgumentVariable => Boolean := false.
    public virtual method isCaptureVariable => Boolean := false.
    public virtual method isTemporaryVariable => Boolean := false.
    public virtual method isGlobalVariable => Boolean := false.

    public virtual method isConstant => Boolean := false.
    public virtual method isConstantInt32 => Boolean := false.
    public virtual method isConstantUInt32 => Boolean := false.

    public virtual method isImmediate32 => Boolean := false.
    public virtual method isImmediate64 => Boolean := self isImmediate32.
    public virtual method isRelativeImmediate32 => Boolean := false.

    public virtual method markUsageAt: (usageIndex: UInt32) ::=> Void := {}.
    public virtual method markWriteAt: (writeIndex: UInt32) ::=> Void := {}.
    public virtual method markSpillingRequired ::=> Void := {}.
}.

public final class TACBasicBlock.

public abstract class TACProgramEntity superclass: TACValue; definition: {
    public field name => Symbol.
    public field compilationTarget => TACCompilationTarget.

    public override method isProgramEntity => Boolean := true.
}.

public abstract class TACVariable superclass: TACProgramEntity; definition: {
    public field type => Type.
    public field size => UInt64.
    public field alignment => UInt64.
    public field physicalLocationClass => TACPhysicalLocation class.
    public field isSignedExtended => Boolean.

    public override method isVariable => Boolean := true.
}.

public final class TACLocalVariable superclass: TACVariable; definition: {
    public field offset => Int64.
    public field index => UInt32.
    public field registerAssignment => TACPhysicalLocation.

    public field needsSpilling => Boolean.
    public field firstUsageIndex => Int32.
    public field lastUsageIndex => Int32.
    public field firstWriteIndex => Int32.
    public field lastWriteIndex => Int32.

    public override method markSpillingRequired ::=> Void := {
        needsSpilling := true.
    }.

    public method needsStackAllocation => Boolean
        := needsSpilling || registerAssignment isNil.

    public override method isLocalVariable => Boolean := true.

    public method resetLiveRange => Void := {
        firstUsageIndex := -1i32.
        lastUsageIndex := -1i32.
        firstWriteIndex := -1i32.
        lastWriteIndex := -1i32.
    }.

    public virtual method markUsageAt: (usageIndex: UInt32) ::=> Void := {
        firstUsageIndex < 0i32 ifTrue: (firstWriteIndex := usageIndex asInt32).
        lastUsageIndex := usageIndex asInt32
    }.

    public virtual method markWriteAt: (writeIndex: UInt32) ::=> Void := {
        firstWriteIndex < 0i32 ifTrue: (firstWriteIndex := writeIndex asInt32).
        lastWriteIndex := writeIndex asInt32
    }.
}.

public final class TACArgumentVariable superclass: TACLocalVariable; definition: {
    public field passingRegister => TACPhysicalLocation.

    public override method isArgumentVariable => Boolean := true.

    public method printOn: (stream: Stream) ::=> Void := {
        stream nextPut: 'a'; print: index.
        name ifNotNil: (stream space; nextPutAll: name)
    }.
}.

public final class TACCaptureVariable superclass: TACLocalVariable; definition: {
    public override method isCaptureVariable => Boolean := true.

    public method printOn: (stream: Stream) ::=> Void := {
        stream nextPut: 'c'; print: index.
        name ifNotNil: (stream space; nextPutAll: name)
    }.
}.

public final class TACTemporaryVariable superclass: TACLocalVariable; definition: {
    public override method isTemporaryVariable => Boolean := true.

    public method printOn: (stream: Stream) ::=> Void := {
        stream nextPut: 't'; print: index.
        name ifNotNil: (stream space; nextPutAll: name)
    }.
}.

public final class TACGlobalVariable superclass: TACVariable; definition: {
    public override method isGlobalVariable => Boolean := true.
}.

public abstract class TACConstant superclass: TACValue; definition: {
    public override method isConstant => Boolean := true.
}.

public abstract class TACConstantInteger superclass: TACValue; definition: {
    public override method isConstant => Boolean := true.

    public override method physicalLocationClass => TACPhysicalLocation class
        := TACPhysicalIntegerRegister.
}.

public abstract class TACGenericObjectPointerConstant superclass: TACConstant; definition: {
    public field object => Untyped.
    public field size => Size.
    public field alignment => Size.
    public field type => Type.
}.

public final class TACConstantInt8 superclass: TACConstantInteger; definition: {
    public field value => Int8.

    public override method isSignedExtended => Boolean := true.
    public override method isConstantInt8 => Boolean := true.
    public override method isImmediate32 => Boolean := true.

    public override method type => Type := Int8.
    public override method size => UInt64 := 1u64.
    public override method alignment => UInt64 := 1u64.

    public method printOn: (stream: Stream) ::=> Void := {
        stream print: value; nextPutAll: "i8"
    }.

    Int8 extend: {
        public method asTacConstant => TACConstantInt8
            := TACConstantInt8 new value: self; yourself
    }
}.

public final class TACConstantUInt8 superclass: TACConstantInteger; definition: {
    public field value => UInt8.

    public override method isConstantUInt8 => Boolean := true.
    public override method isImmediate32 => Boolean := true.

    public override method type => Type := UInt8.
    public override method size => UInt64 := 1u64.
    public override method alignment => UInt64 := 1u64.
    
    public method printOn: (stream: Stream) ::=> Void := {
        stream print: value; nextPutAll: "u8"
    }.

    UInt8 extend: {
        public method asTacConstant => TACConstantUInt8
            := TACConstantUInt8 new value: self; yourself
    }
}.

public final class TACConstantInt16 superclass: TACConstantInteger; definition: {
    public field value => Int16.

    public override method isSignedExtended => Boolean := true.
    public override method isConstantInt16 => Boolean := true.
    public override method isImmediate32 => Boolean := true.

    public override method type => Type := Int16.
    public override method size => UInt64 := 2u64.
    public override method alignment => UInt64 := 2u64.

    public method printOn: (stream: Stream) ::=> Void := {
        stream print: value; nextPutAll: "i16"
    }.

    Int16 extend: {
        public method asTacConstant => TACConstantInt16
            := TACConstantInt16 new value: self; yourself
    }
}.

public final class TACConstantUInt16 superclass: TACConstantInteger; definition: {
    public field value => UInt16.

    public override method isConstantUInt16 => Boolean := true.
    public override method isImmediate32 => Boolean := true.

    public override method type => Type := UInt16.
    public override method size => UInt64 := 2u64.
    public override method alignment => UInt64 := 2u64.

    public method printOn: (stream: Stream) ::=> Void := {
        stream print: value; nextPutAll: "u16"
    }.

    UInt16 extend: {
        public method asTacConstant => TACConstantUInt16
            := TACConstantUInt16 new value: self; yourself
    }
}.

public final class TACConstantInt32 superclass: TACConstantInteger; definition: {
    public field value => Int32.

    public override method isSignedExtended => Boolean := true.
    public override method isConstantInt32 => Boolean := true.
    public override method isImmediate32 => Boolean := true.

    public override method type => Type := Int32.
    public override method size => UInt64 := 4u64.
    public override method alignment => UInt64 := 4u64.

    public method printOn: (stream: Stream) ::=> Void := {
        stream print: value; nextPutAll: "i32"
    }.

    Int32 extend: {
        public method asTacConstant => TACConstantInt32
            := TACConstantInt32 new value: self; yourself
    }
}.

public final class TACConstantUInt32 superclass: TACConstantInteger; definition: {
    public field value => UInt32.

    public override method isConstantUInt32 => Boolean := true.
    public override method isImmediate32 => Boolean := true.

    public override method type => Type := UInt32.
    public override method size => UInt64 := 4u64.
    public override method alignment => UInt64 := 4u64.

    public method printOn: (stream: Stream) ::=> Void := {
        stream print: value; nextPutAll: "u32"
    }.

    UInt32 extend: {
        public method asTacConstant => TACConstantUInt32
            := TACConstantUInt32 new value: self; yourself
    }
}.

public final class TACConstantInt64 superclass: TACConstantInteger; definition: {
    public field value => Int64.

    public override method isSignedExtended => Boolean := true.
    public override method isConstantInt64 => Boolean := true.
    public override method isImmediate32 => Boolean := true.

    public override method type => Type := Int64.
    public override method alignment => UInt64 := 8u64.
    public override method size => UInt64 := 8u64.
    
    public method printOn: (stream: Stream) ::=> Void := {
        stream print: value; nextPutAll: "i64"
    }.

    Int64 extend: {
        public method asTacConstant => TACConstantInt64
            := TACConstantInt64 new value: self; yourself
    }
}.

public final class TACConstantUInt64 superclass: TACConstantInteger; definition: {
    public field value => UInt64.

    public override method isConstantUInt64 => Boolean := true.
    public override method isImmediate64 => Boolean := true.

    public override method type => Type := UInt64.
    public override method alignment => UInt64 := 8u64.
    public override method size => UInt64 := 8u64.

    public method printOn: (stream: Stream) ::=> Void := {
        stream print: value; nextPutAll: "u64"
    }.

    UInt64 extend: {
        public method asTacConstant => TACConstantUInt64
            := TACConstantUInt64 new value: self; yourself
    }.
}.

public final class TACConstantFloatingPoint superclass: TACConstant; definition: {
    public override method isFloatingPoint => Boolean := true.
    public override method isConstantFloat => Boolean := true.
}.

public final class TACConstantFloat32 superclass: TACConstantFloatingPoint; definition: {
    public field value => Float32.

    public override method isConstantFloat32 => Boolean := true.
    public override method isImmediate32 => Boolean := true.

    public override method type => Type := Float32.
    public override method alignment => UInt64 := 4u64.
    public override method size => UInt64 := 4u64.

    public method printOn: (stream: Stream) ::=> Void := {
        stream print: value; nextPutAll: "f32"
    }.

    Float32 extend: {
        public method asTacConstant => TACConstantFloat32
            := TACConstantFloat32 new value: self; yourself
    }.
}.

public final class TACConstantFloat64 superclass: TACConstantFloatingPoint; definition: {
    public field value => Float64.

    public override method isConstantFloat64 => Boolean := true.
    public override method isImmediate64 => Boolean := true.

    public override method type => Type := Float64.
    public override method alignment => UInt64 := 8u64.
    public override method size => UInt64 := 8u64.

    public method printOn: (stream: Stream) ::=> Void := {
        stream print: value; nextPutAll: "f64"
    }.

    Float64 extend: {
        public method asTacConstant => TACConstantFloat64
            := TACConstantFloat64 new value: self; yourself
    }.
}.

public final class TACOperation superclass: Object; definition: {
    public field name => Symbol.
    public field isTerminator => Boolean.

    protected field perTargetCodeGenerators => IdentityDictionary.
    protected field perTargetRegisterConstraints => IdentityDictionary.

    __Meta__ definition: {
        public method named: (name: Symbol) ::=> self
            := self new name: name; yourself.

        public method terminatorNamed: (name: Symbol) ::=> self
            := self new name: name; isTerminator: true; yourself.
    }.

    public method initialize => Void := {
        perTargetCodeGenerators := IdentityDictionary new.
        perTargetRegisterConstraints := IdentityDictionary new.
    }.

    public method printOn: (stream: Stream) ::=> Void := {
        stream nextPutAll: name
    }.
}.

public final class TACInstruction superclass: TACValue; definition: {
    public field previous => TACInstruction.
    public field next => TACInstruction.

    public field index => UInt32.

    public field operation => TACOperation.
    public field result => TACValue.
    public field operands => Array.

    public field resultRegister => TACPhysicalLocation.
    public field operandRegisters => Array.
    public field scratchRegisters => Array.

    public field callingConvention => TACCallingConvention.

    public method initialize => Void := {
        super initialize.
        operands := #().
    }.

    public method isTerminator => Boolean
        := operation isTerminator.

    public method fullPrintOn: (stream: Stream) ::=> Void := {
        result ifNotNil: (stream print: result; nextPutAll: " := ").
        stream print: operation.
        operands doWithIndex: {:(TACValue)eachOperand :(Size)index :: Void |
            index = 0sz
                ifTrue: (stream space)
                ifFalse: (stream nextPutAll: ", ").
            stream print: eachOperand
        }.
    }.

    public method markLiveRange => Void := {
        result ifNotNil: (result markWriteAt: index).
        operands do: {:(TACValue)value :: Void |
            value markUsageAt: index
        }
    }.

    public method resetRegisterAllocation => Void := {
        resultRegister := nil.
        operandRegisters := operands size > 0sz ifTrue: (Array new: operands size) ifFalse: #().
        scratchRegisters := #().
    }.

    public method firstOperandRegister => TACPhysicalLocation := operandRegisters first.
    public method secondOperandRegister => TACPhysicalLocation := operandRegisters second.
    public method thirdOperandRegister => TACPhysicalLocation := operandRegisters third.

    public method firstScratchRegister => TACPhysicalLocation := scratchRegisters first.
    public method secondScratchRegister => TACPhysicalLocation := scratchRegisters first.
}.

public global TAC::Operation::Branch := TACOperation terminatorNamed: #branch.
public global TAC::Operation::ConditionalBranch := TACOperation terminatorNamed: #condBranch.

public global TAC::Operation::Move := TACOperation named: #move.

public global TAC::Operation::CallInt32 := TACOperation named: #callInt32.
public global TAC::Operation::CallInt64 := TACOperation named: #callInt64.
public global TAC::Operation::CallFloat32 := TACOperation named: #callFloat32.
public global TAC::Operation::CallFloat64 := TACOperation named: #callFloat64.
public global TAC::Operation::CallStruct := TACOperation named: #callStruct.
public global TAC::Operation::CallVoid := TACOperation named: #callVoid.

public global TAC::Operation::ReturnInt32 := TACOperation terminatorNamed: #returnInt32.
public global TAC::Operation::ReturnInt64 := TACOperation terminatorNamed: #returnInt64.
public global TAC::Operation::ReturnFloat32 := TACOperation terminatorNamed: #returnFloat32.
public global TAC::Operation::ReturnFloat64 := TACOperation terminatorNamed: #returnFloat64.
public global TAC::Operation::ReturnStruct := TACOperation terminatorNamed: #returnStruct.
public global TAC::Operation::ReturnVoid := TACOperation terminatorNamed: #returnVoid.

public global TAC::Operation::AddInt8 := TACOperation named: #addInt8.
public global TAC::Operation::AddInt16 := TACOperation named: #addInt16.
public global TAC::Operation::AddInt32 := TACOperation named: #addInt32.
public global TAC::Operation::AddInt64 := TACOperation named: #addInt64.

public global TAC::Operation::SubInt8 := TACOperation named: #addInt8.
public global TAC::Operation::SubInt16 := TACOperation named: #addInt16.
public global TAC::Operation::SubInt32 := TACOperation named: #addInt32.
public global TAC::Operation::SubInt64 := TACOperation named: #addInt64.

public global TAC::Operation::Trap := TACOperation terminatorNamed: #trap.

TACBasicBlock definition: {
    public field name => Symbol.
    public field index => UInt32.

    public field previous => TACBasicBlock.
    public field next => TACBasicBlock.

    public field firstInstruction => TACInstruction.
    public field lastInstruction => TACInstruction.

    public override method physicalLocationClass => TACPhysicalLocation class
        := TACPhysicalIntegerRegister.

    public override method isRelativeImmediate32 => Boolean := true.


    public method addInstruction: (instruction: TACInstruction) before: (position: TACInstruction) ::=> Void := {
        let before := position ifNotNil: position previous ifNil: lastInstruction.
        let after := position.

        ## Do not add instructions after a terminator.
        before isNotNil && before isTerminator ifTrue: (return: void).

        before ifNotNil: {
            before next: instruction.
            instruction previous: before.
        } ifNil: {
            firstInstruction := instruction
        }.

        after ifNotNil: {
            after previous: instruction.
            instruction next: after
        } ifNil: {
            lastInstruction := instruction
        }.
    }.

    public method addInstruction: (instruction: TACInstruction) ::=> Void := {
        self addInstruction: instruction before: nil
    }.

    public method instructionsDo: aBlock ::=> Void := {
        let position mutable := firstInstruction.
        while: (position isNotNil) do: {
            let nextPosition := position next.
            aBlock(position).
            position := nextPosition
        }
    }.

    public method printOn: (stream: Stream) ::=> Void := {
        stream nextPut: '@'; print: index.
        name ifNotNil: (stream nextPut: ':'; nextPutAll: name)
    }.

    public method fullPrintOn: (stream: Stream) ::=> Void := {
        stream print: self; nextPut: ':'; nl.
        self instructionsDo: {:(TACBasicBlock)each :: Void |
            stream nextPutAll: "    "; fullPrint: each; nl
        }.
    }.
}.

public final class TACFunction superclass: TACProgramEntity; definition: {
    public field callingConvention => TACCallingConvention.

    public field arguments => Array.
    public field captures => Array.
    public field temporaries => OrderedCollection.

    public field firstBasicBlock => TACBasicBlock.
    public field lastBasicBlock => TACBasicBlock.

    public override method isFunction => Boolean := true.

    public override method physicalLocationClass => TACPhysicalLocation class
        := TACPhysicalIntegerRegister.

    public override method isRelativeImmediate32 => Boolean := true.

    public method initialize => Void := {
        arguments := #().
        captures := #().
        temporaries := OrderedCollection new
    }.

    public method addTemporary: (temporary: TACTemporaryVariable) ::=> TACTemporaryVariable := {
        temporaries add: temporary.
        temporary
    }.

    public method newArgument: (name: Symbol) withType: (type: Type) ::=> TACArgumentVariable
        := TACArgumentVariable new
            name: name;
            type: type;
            size: (type valueSizeForTacTarget: compilationTarget) asUInt64;
            alignment: (type valueAlignmentForTacTarget: compilationTarget) asUInt64;
            physicalLocationClass: type valueTacPhysicalLocationClass;
            yourself.

    public method newArgumentWithType: (type: Type) ::=> TACArgumentVariable
        := self newArgument: nil withType: type.

    public method newCapture: (name: Symbol) withType: (type: Type) ::=> TACCaptureVariable
        := TACCaptureVariable new
            name: name;
            type: type;
            size: (type valueSizeForTacTarget: compilationTarget) asUInt64;
            alignment: (type valueAlignmentForTacTarget: compilationTarget) asUInt64;
            physicalLocationClass: type valueTacPhysicalLocationClass;
            yourself.

    public method newCaptureWithType: (type: Type) ::=> TACCaptureVariable
        := self newCapture: nil withType: type.

    public method newTemporary: (name: Symbol) withType: (type: Type) ::=> TACTemporaryVariable
        := self addTemporary: (TACTemporaryVariable new
            name: name;
            type: type;
            size: (type valueSizeForTacTarget: compilationTarget) asUInt64;
            alignment: (type valueAlignmentForTacTarget: compilationTarget) asUInt64;
            physicalLocationClass: type valueTacPhysicalLocationClass;
            yourself).

    public method newTemporaryWithType: (type: Type) ::=> TACTemporaryVariable
        := self newTemporary: nil withType: type.

    public method newTemporaryUInt8 => TACTemporaryVariable
        := self newTemporaryWithType: UInt8.

    public method newTemporaryInt8 => TACTemporaryVariable
        := self newTemporaryWithType: Int8.

    public method newTemporaryUInt16 => TACTemporaryVariable
        := self newTemporaryWithType: UInt16.

    public method newTemporaryInt16 => TACTemporaryVariable
        := self newTemporaryWithType: Int8.

    public method newTemporaryUInt32 => TACTemporaryVariable
        := self newTemporaryWithType: UInt32.

    public method newTemporaryInt32 => TACTemporaryVariable
        := self newTemporaryWithType: Int32.

    public method newTemporaryUInt64 => TACTemporaryVariable
        := self newTemporaryWithType: UInt64.

    public method newTemporaryInt64 => TACTemporaryVariable
        := self newTemporaryWithType: Int64.

    public method newTemporaryUIntPointer => TACTemporaryVariable
        := compilationTarget pointerSize = 8sz
            ifTrue: (self newTemporaryUInt64)
            ifFalse: (self newTemporaryUInt32).

    public method newTemporaryIntPointer => TACTemporaryVariable
        := compilationTarget pointerSize = 8sz
            ifTrue: (self newTemporaryInt64)
            ifFalse: (self newTemporaryInt32).

    public method newTemporaryFloat32 => TACTemporaryVariable
        := self newTemporaryWithType: Float32.

    public method newTemporaryFloat64 => TACTemporaryVariable
        := self newTemporaryWithType: Float64.

    public method addBasicBlock: (basicBlock: TACBasicBlock) before: (position: TACBasicBlock) ::=> Void := {
        let before := position ifNotNil: position previous ifNil: lastBasicBlock.
        let after := position.

        before ifNotNil: {
            before next: basicBlock.
            basicBlock previous: before.
        } ifNil: {
            firstBasicBlock := basicBlock
        }.

        after ifNotNil: {
            after previous: basicBlock.
            basicBlock next: after
        } ifNil: {
            lastBasicBlock := basicBlock
        }.
    }.

    public method addBasicBlock: (basicBlock: TACBasicBlock) ::=> Void := {
        self addBasicBlock: basicBlock before: nil
    }.

    public method basicBlocksDo: (aBlock: (TACBasicBlock) => Void) ::=> Void := {
        let position mutable := firstBasicBlock.
        while: (position isNotNil) do: {
            let nextPosition := position next.
            aBlock(position).
            position := nextPosition
        }
    }.

    public method enumerateBlocks => Void := {
        let index mutable := 0u32.
        self basicBlocksDo: {:(TACBasicBlock)each :: Void |
            each index: index.
            index := index + 1u32.
        }.
    }.

    public method instructionsDo: (aBlock: (TACInstruction) => Void) ::=> Void := {
        self basicBlocksDo: {:(TACBasicBlock)each :: Void |
            each instructionsDo: aBlock
        }.
    }.

    public method enumerateInstructions => Void := {
        let index mutable := 1u32.
        self instructionsDo: {:(TACInstruction)each :: Void |
            each index: index.
            index := index + 1u32
        }
    }.

    public method allLocalVariablesDo: (aBlock: (TACLocalVariable) => Void) ::=> Void := {
        arguments do: aBlock.
        captures do: aBlock.
        temporaries do: aBlock.
    }.

    public method enumerateLocals => Void := {
        let index mutable := 0u32.
        self allLocalVariablesDo: {:(TACLocalVariable)each :: Void |
            each index: index.
            index := index + 1u32
        }
    }.

    public method computeLiveRanges => Void := {
        self enumerateInstructions.
        self allLocalVariablesDo: {:(TACLocalVariable)eachLocal :: Void |
            eachLocal resetLiveRange
        }.
        self instructionsDo: {:(TACInstruction)eachInstruction :: Void |
            eachInstruction markLiveRange
        }.
    }.

    public method fullPrintOn: (stream: Stream) ::=> Void := {
        stream nextPutAll: "function ".
        name ifNotNil: (stream nextPutAll: name; space).
        stream nextPut: '{'; nl.
        self enumerateBlocks; enumerateLocals.
        self basicBlocksDo: {:(TACBasicBlock)each :: Void |
            stream fullPrint: each
        }.
        stream nextPut: '}'; nl.
    }.
}.

public final class TACBlockBuilder superclass: Object; definition: {
    public field block => TACBasicBlock.
    public field function => TACFunction.

    ## Debugging information
    public field debugSourcePosition => SourcePosition.
    public field debugSourceNode => ASTNode.
    public field debugSourceEnvironment => Environment.

    public method addInstruction: (instruction: TACInstruction) ::=> TACInstruction := {
        block addInstruction: instruction.
        instruction
            debugSourcePosition: debugSourcePosition;
            debugSourceNode: debugSourceNode;
            debugSourceEnvironment: debugSourceEnvironment.
        instruction
    }.

    public method temporaryUInt8 => TACTemporaryVariable := function newTemporaryUInt8.
    public method temporaryInt8 => TACTemporaryVariable := function newTemporaryInt8.
    public method temporaryUInt16 => TACTemporaryVariable := function newTemporaryUInt16.
    public method temporaryInt16 => TACTemporaryVariable := function newTemporaryInt16.
    public method temporaryUInt32 => TACTemporaryVariable := function newTemporaryUInt32.
    public method temporaryInt32 => TACTemporaryVariable := function newTemporaryInt32.
    public method temporaryUInt64 => TACTemporaryVariable := function newTemporaryUInt64.
    public method temporaryInt64 => TACTemporaryVariable := function newTemporaryInt64.
    public method temporaryUIntPointer => TACTemporaryVariable := function newTemporaryUIntPointer.
    public method temporaryFloat32 => TACTemporaryVariable := function newTemporaryFloat32.
    public method temporaryFloat64 => TACTemporaryVariable := function newTemporaryFloat64.

    public method compilationTarget => TACCompilationTarget := function compilationTarget.
    public method pointerSize => Size := function compilationTarget pointerSize.
    public method uintPointerType => Type := function compilationTarget uintPointerType.
    public method has64BitsPointers => Boolean := self pointerSize = 8sz.

    public method operation: (operation: TACOperation) ::=> TACInstruction
        := self addInstruction: (TACInstruction new operation: operation; yourself).

    public method operation: (operation: TACOperation) with: (operand: TACValue) ::=> TACInstruction
        := self addInstruction: (TACInstruction new operation: operation; operands: (Array with: operand); yourself).

    public method operation: (operation: TACOperation) with: (operand: TACValue) result: (result: TACValue)::=> TACInstruction
        := self addInstruction: (TACInstruction new operation: operation; result: result; operands: (Array with: operand); yourself).

    public method operation: (operation: TACOperation) with: (firstOperand: TACValue) with: (secondOperand: TACValue) ::=> TACInstruction
        := self addInstruction: (TACInstruction new operation: operation; operands: (Array with: firstOperand with: secondOperand); yourself).

    public method operation: (operation: TACOperation) with: (firstOperand: TACValue) with: (secondOperand: TACValue) result: (result: TACValue) ::=> TACInstruction
        := self addInstruction: (TACInstruction new operation: operation; result: result; operands: (Array with: firstOperand with: secondOperand); yourself).

    public method operation: (operation: TACOperation) with: (firstOperand: TACValue) with: (secondOperand: TACValue) with: (thirdOperand: TACValue) ::=> TACInstruction
        := self addInstruction: (TACInstruction new operation: operation; operands: (Array with: firstOperand with: secondOperand with: thirdOperand); yourself).

    public method operation: (operation: TACOperation) with: (operand: TACValue) result: (result: TACValue) ::=> TACInstruction
        := self addInstruction: (TACInstruction new operation: operation; result: result; operands: (Array with: operand); yourself).

    public method branch: (destination: TACValue) ::=> TACInstruction
        := self operation: TAC::Operation::Branch with: destination.

    public method when: (condition: TACValue) branchIfTrue: (trueDestination: TACValue) branchIfFalse: (falseDestination: TACValue) ::=> TACInstruction
        := self operation: TAC::Operation::ConditionalBranch with: condition with: trueDestination with: falseDestination.

    public method move: (source: TACValue) into: (destination: TACValue) ::=> TACInstruction
        := self operation: TAC::Operation::Move with: source result: destination.

    public method call: (function: TACValue) operation: (callOperation: TACOperation) convention: (callingConvention: TACCallingConvention) arguments: (arguments: Array) result: (result: TACValue) ::=> TACInstruction
        := self addInstruction: (TACInstruction new
            operation: callOperation;
            operands: (Array with: function) -- arguments;
            callingConvention: callingConvention;
            result: result;
            yourself).

    public method callInt32: (function: TACValue) convention: (callingConvention: TACCallingConvention) arguments: (arguments: Array) result: (result: TACValue) ::=> TACInstruction
        := self call: function operation: TAC::Operation::CallInt32 convention: self compilationTarget defaultCallingConvention arguments: arguments result: result.

    public method callInt32: (function: TACValue) arguments: (arguments: Array) result: (result: TACValue) ::=> TACInstruction
        := self callInt32: function convention: self compilationTarget defaultCallingConvention arguments: arguments result: result.

    public method callInt64: (function: TACValue) convention: (callingConvention: TACCallingConvention) arguments: (arguments: Array) result: (result: TACValue) ::=> TACInstruction
        := self call: function operation: TAC::Operation::CallInt64 convention: self compilationTarget defaultCallingConvention arguments: arguments result: result.

    public method callInt64: (function: TACValue) arguments: (arguments: Array) result: (result: TACValue) ::=> TACInstruction
        := self callInt64: function convention: self compilationTarget defaultCallingConvention arguments: arguments result: result.

    public method callPointer: (function: TACValue) convention: (callingConvention: TACCallingConvention) arguments: (arguments: Array) result: (result: TACValue) ::=> TACInstruction
        := self call: function
            operation: (self has64BitsPointers ifTrue: (TAC::Operation::CallInt64) ifFalse: (TAC::Operation::CallInt32))
            convention: self compilationTarget defaultCallingConvention arguments: arguments result: result.

    public method callPointer: (function: TACValue) arguments: (arguments: Array) result: (result: TACValue) ::=> TACInstruction
        := self callPointer: function convention: self compilationTarget defaultCallingConvention arguments: arguments result: result.

    public method callFloat32: (function: TACValue) convention: (callingConvention: TACCallingConvention) arguments: (arguments: Array) result: (result: TACValue) ::=> TACInstruction
        := self call: function operation: TAC::Operation::CallFloat32 convention: self compilationTarget defaultCallingConvention arguments: arguments result: result.

    public method callFloat32: (function: TACValue) arguments: (arguments: Array) result: (result: TACValue) ::=> TACInstruction
        := self callFloat32: function convention: self compilationTarget defaultCallingConvention arguments: arguments result: result.

    public method callFloat64: (function: TACValue) convention: (callingConvention: TACCallingConvention) arguments: (arguments: Array) result: (result: TACValue) ::=> TACInstruction
        := self call: function operation: TAC::Operation::CallFloat64 convention: self compilationTarget defaultCallingConvention arguments: arguments result: result.

    public method callFloat64: (function: TACValue) arguments: (arguments: Array) result: (result: TACValue) ::=> TACInstruction
        := self callFloat64: function convention: self compilationTarget defaultCallingConvention arguments: arguments result: result.

    public method callVoid: (function: TACValue) convention: (callingConvention: TACCallingConvention) arguments: (arguments: Array) ::=> TACInstruction
        := self call: function operation: TAC::Operation::CallInt64 convention: self compilationTarget defaultCallingConvention arguments: arguments result: nil.

    public method callVoid: (function: TACValue) arguments: (arguments: Array) ::=> TACInstruction
        := self callVoid: function convention: self compilationTarget defaultCallingConvention arguments: arguments.

    public method returnVoid ::=> TACInstruction
        := self operation: TAC::Operation::ReturnVoid.

    public method returnInt32: (value: TACValue) ::=> TACInstruction
        := self operation: TAC::Operation::ReturnInt32 with: value.

    public method returnInt64: (value: TACValue) ::=> TACInstruction
        := self operation: TAC::Operation::ReturnInt64 with: value.

    public method returnPointer: (value: TACValue) ::=> TACInstruction
        := self has64BitsPointers
            ifTrue: (self returnInt32: value)
            ifFalse: (self returnInt64: value).

    public method returnFloat32: (value: TACValue) ::=> TACInstruction
        := self operation: TAC::Operation::ReturnFloat32 with: value.

    public method returnFloat64: (value: TACValue) ::=> TACInstruction
        := self operation: TAC::Operation::ReturnFloat64 with: value.

    public method trap ::=> TACInstruction
        := self operation: TAC::Operation::Trap.

    public method addInt8: (left: TACValue) with: (right: TACValue) into: (result: TACValue) ::=> TACInstruction
        := self operation: TAC::Operation::AddInt8 with: left with: right result: result.

    public method addInt16: (left: TACValue) with: (right: TACValue) into: (result: TACValue) ::=> TACInstruction
        := self operation: TAC::Operation::AddInt16 with: left with: right result: result.

    public method addInt32: (left: TACValue) with: (right: TACValue) into: (result: TACValue) ::=> TACInstruction
        := self operation: TAC::Operation::AddInt32 with: left with: right result: result.

    public method addInt64: (left: TACValue) with: (right: TACValue) into: (result: TACValue) ::=> TACInstruction
        := self operation: TAC::Operation::AddInt64 with: left with: right result: result.

    public method subInt8: (left: TACValue) with: (right: TACValue) into: (result: TACValue) ::=> TACInstruction
        := self operation: TAC::Operation::SubInt8 with: left with: right result: result.

    public method subInt16: (left: TACValue) with: (right: TACValue) into: (result: TACValue) ::=> TACInstruction
        := self operation: TAC::Operation::SubInt16 with: left with: right result: result.

    public method subInt32: (left: TACValue) with: (right: TACValue) into: (result: TACValue) ::=> TACInstruction
        := self operation: TAC::Operation::SubInt32 with: left with: right result: result.

    public method subInt64: (left: TACValue) with: (right: TACValue) into: (result: TACValue) ::=> TACInstruction
        := self operation: TAC::Operation::SubInt64 with: left with: right result: result.
}.

public final class TACFunctionBuilder superclass: Object; definition: {
    public field function => TACFunction.

    public method basicBlock: (name: Symbol) build: (aBlock: (TACBlockBuilder) => Void) ::=> Void := {
        let block := TACBasicBlock new name: name; yourself.
        function addBasicBlock: block.

        let blockBuilder := TACBlockBuilder new
            block: block;
            function: function;
            yourself.
        aBlock(blockBuilder).
        block.
    }.
}.

public final class TACModule superclass: TACProgramEntity; definition: {
    public field compilationTarget => TACCompilationTarget.
    public field programEntities => OrderedCollection.

    public method initialize => Void := {
        super initialize.
        programEntities := OrderedCollection new.
    }.

    public method addProgramEntity: (programEntity: TACProgramEntity) ::=> Void := {
        programEntities add: programEntity
    }.

    public method build: (name: Symbol) function: (aBlock: (TACFunctionBuilder) => Void) ::=> TACFunction := {
        let function := TACFunction new
            compilationTarget: compilationTarget;
            callingConvention: compilationTarget defaultCallingConvention;
            name: name;
            yourself.
        self addProgramEntity: function.

        let builder := TACFunctionBuilder new
            function: function;
            yourself.
        aBlock(builder).
        function
    }.

    public method fullPrintOn: (stream: Stream) ::=> Void := {
        self programEntities do: {:(TACProgramEntity)each :: Void |
            stream fullPrint: each; nl
        }
    }.

    public method asTargetIR => AnyValue
        := compilationTarget generateTargetIRForTACModule: self
}.

TACCallingConvention definition: {
    public abstract method computeArgumentPassingLayoutOf: (function: TACFunction) ::=> Void
        := self subclassResponsibility.
}.

TACCompilationTarget definition: {
    public abstract method name => Symbol
        := self subclassResponsibility.

    public abstract method pointerSize => Size
        := self subclassResponsibility.

    public abstract method pointerAlignment => Size
        := self subclassResponsibility.

    public abstract method uintPointerType => Type
        := self subclassResponsibility.

    public abstract method stackFrameAlignment => Size
        := self subclassResponsibility.

    public abstract method allIntegerRegisters => Array
        := self subclassResponsibility.

    public abstract method allocableIntegerRegisters => Array
        := self subclassResponsibility.

    public abstract method allFloatRegisters => Array
        := self subclassResponsibility.

    public abstract method allocableFloatRegisters => Array
        := self subclassResponsibility.

    public abstract method allVectorRegisters => Array
        := self subclassResponsibility.

    public abstract method allocableVectorRegisters => Array
        := self subclassResponsibility.

    public abstract method generateTargetIRForTACModule: (module: TACModule) ::=> AnyValue
        := self subclassResponsibility.

    public abstract method defaultCallingConvention => TACCallingConvention
        := self subclassResponsibility.
}.
