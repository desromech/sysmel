public abstract class TACCompilationTarget superclass: Object.
public abstract class TACCallingConvention superclass: Object.
public abstract class TACValue superclass: Object.

public abstract class TACPhysicalLocation superclass: Object; definition: {
    public virtual method isMemory => Boolean := false.
    public virtual method isImmediate => Boolean := false.
    public virtual method isRegister => Boolean := false.
    public virtual method isIntegerRegister => Boolean := false.
    public virtual method isFloatRegister => Boolean := false.
    public virtual method isVectorRegister => Boolean := false.
}.

public abstract class TACPhysicalLocationMemory superclass: TACPhysicalLocation; definition: {
    public virtual method isMemory => Boolean := true.

    __Meta__ definition: {
        let singleton := TACPhysicalLocationMemory new.
        public method uniqueInstance => TACPhysicalLocationMemory
            := singleton.
    }
}.

public abstract class TACPhysicalLocationRegister superclass: TACPhysicalLocation; definition: {
    public virtual method isRegister => Boolean := true.
}.

public abstract class TACPhysicalIntegerRegister superclass: TACPhysicalLocationRegister; definition: {
    public virtual method isIntegerRegister => Boolean := true.
}.

public abstract class TACPhysicalFloatRegister superclass: TACPhysicalLocationRegister; definition: {
    public virtual method isFloatRegister => Boolean := true.
}.

public abstract class TACPhysicalVectorRegister superclass: TACPhysicalLocationRegister; definition: {
    public virtual method isVectorRegister => Boolean := true.
}.

public class TACPhysicalLocationImmediate superclass: TACPhysicalLocation; definition: {
    public field value => TACValue.

    __Meta__ definition: {
        public method for: (value: TACValue) ::=> self
            := self new value: value; yourself
    }.

    public virtual method isImmediate => Boolean := true.
}.

Type extend: {
    public method valueSizeForTacTarget: (target: TACCompilationTarget) ::=> Size
        := target pointerSize.

    public method valueAlignmentForTacTarget: (target: TACCompilationTarget) ::=> Size
        := target pointerAlignment.

    public method valueTacPhysicalLocationClass => TACPhysicalLocation class
        := TACPhysicalIntegerRegister.

    public method valueIsSignedExtended => Boolean := false.
}.

ValueType extend: {
    public method valueSizeForTacTarget: (target: TACCompilationTarget) ::=> Size
        := self valueSize.

    public method valueAlignmentForTacTarget: (target: TACCompilationTarget) ::=> Size
        := self valueAlignment.

}.

Int8 class extend: {
    public method valueIsSignedExtended => Boolean := true.
}.

Int16 class extend: {
    public method valueIsSignedExtended => Boolean := true.
}.

Int32 class extend: {
    public method valueIsSignedExtended => Boolean := true.
}.

Int64 class extend: {
    public method valueIsSignedExtended => Boolean := true.
}.

Float32 class extend: {
    public method valueTacPhysicalLocationClass => TACPhysicalLocation class
        := TACPhysicalFloatRegister.
}.

Float64 class extend: {
    public method valueTacPhysicalLocationClass => TACPhysicalLocation class
        := TACPhysicalFloatRegister.
}.

TACValue definition: {
    public field debugSourcePosition => SourcePosition.
    public field debugSourceNode => ASTNode.
    public field debugSourceEnvironment => Environment.

    public virtual method type => Type
        := self subclassResponsibility.

    public virtual method physicalLocationClass => TACPhysicalLocation class
        := self subclassResponsibility.

    public virtual method size => UInt64
        := self subclassResponsibility.

    public virtual method alignment => UInt64
        := self subclassResponsibility.

    public virtual method isSignedExtended => Boolean := false.
    public virtual method isFloatingPoint => Boolean := false.
    public virtual method isVector => Boolean := false.

    public virtual method isProgramEntity => Boolean := false.
    public virtual method isFunction => Boolean := false.
    public virtual method isLocalVariable => Boolean := false.

    public virtual method isVariable => Boolean := false.
    public virtual method isArgumentVariable => Boolean := false.
    public virtual method isCaptureVariable => Boolean := false.
    public virtual method isTemporaryVariable => Boolean := false.
    public virtual method isGlobalVariable => Boolean := false.

    public virtual method isConstant => Boolean := false.
    public virtual method isConstantInt32 => Boolean := false.
    public virtual method isConstantUInt32 => Boolean := false.

    public virtual method isImmediate32 => Boolean := false.
    public virtual method isImmediate64 => Boolean := self isImmediate32.
    public virtual method isRelativeImmediate32 => Boolean := false.

    public virtual method markUsageAt: (usageIndex: UInt32) ::=> Void := {}.
    public virtual method markWriteAt: (writeIndex: UInt32) ::=> Void := {}.
    public virtual method markSpillingRequired ::=> Void := {}.
}.

public final class TACBasicBlock.

public abstract class TACProgramEntity superclass: TACValue; definition: {
    public field name => Symbol.
    public field compilationTarget => TACCompilationTarget.

    public override method isProgramEntity => Boolean := true.
}.

public abstract class TACVariable superclass: TACProgramEntity; definition: {
    public field type => Type.
    public field size => UInt64.
    public field alignment => UInt64.
    public field physicalLocationClass => TACPhysicalLocation class.
    public field isSignedExtended => Boolean.
    public field isGCRoot => Boolean.

    public override method isVariable => Boolean := true.
}.

public final class TACLocalVariable superclass: TACVariable; definition: {
    public field offset => Int64.
    public field index => UInt32.
    public field registerAssignment => TACPhysicalLocation.

    public field needsSpilling => Boolean.
    public field firstUsageIndex => Int32.
    public field lastUsageIndex => Int32.
    public field firstWriteIndex => Int32.
    public field lastWriteIndex => Int32.

    public override method markSpillingRequired ::=> Void := {
        needsSpilling := true.
    }.

    public method needsStackAllocation => Boolean
        := needsSpilling || registerAssignment isNil.

    public override method isLocalVariable => Boolean := true.

    public method resetLiveRange => Void := {
        firstUsageIndex := -1i32.
        lastUsageIndex := -1i32.
        firstWriteIndex := -1i32.
        lastWriteIndex := -1i32.
    }.

    public virtual method markUsageAt: (usageIndex: UInt32) ::=> Void := {
        firstUsageIndex < 0i32 ifTrue: (firstWriteIndex := usageIndex asInt32).
        lastUsageIndex := usageIndex asInt32
    }.

    public virtual method markWriteAt: (writeIndex: UInt32) ::=> Void := {
        firstWriteIndex < 0i32 ifTrue: (firstWriteIndex := writeIndex asInt32).
        lastWriteIndex := writeIndex asInt32
    }.
}.

public final class TACArgumentVariable superclass: TACLocalVariable; definition: {
    public field passingRegister => TACPhysicalLocation.

    public override method isArgumentVariable => Boolean := true.

    public method printOn: (stream: Stream) ::=> Void := {
        stream nextPut: 'a'; print: index.
        name ifNotNil: (stream space; string: name)
    }.
}.

public final class TACCaptureVariable superclass: TACLocalVariable; definition: {
    public override method isCaptureVariable => Boolean := true.

    public method printOn: (stream: Stream) ::=> Void := {
        stream nextPut: 'c'; print: index.
        name ifNotNil: (stream space; string: name)
    }.
}.

public final class TACTemporaryVariable superclass: TACLocalVariable; definition: {
    public override method isTemporaryVariable => Boolean := true.

    public method printOn: (stream: Stream) ::=> Void := {
        stream nextPut: 't'; print: index.
        name ifNotNil: (stream space; string: name)
    }.
}.

public final class TACGlobalVariable superclass: TACVariable; definition: {
    public override method isGlobalVariable => Boolean := true.

    public method printOn: (stream: Stream) ::=> Void := {
        stream nextPutAll: "global".
        name ifNotNil: (stream space; string: name).
    }.

    public method fullPrintOn: (stream: Stream) ::=> Void := {
        stream print: self; nextPutAll: " => "; print: type.
    }.
}.

public abstract class TACConstant superclass: TACValue; definition: {
    public override method isConstant => Boolean := true.
}.

public abstract class TACConstantInteger superclass: TACValue; definition: {
    public override method isConstant => Boolean := true.

    public override method physicalLocationClass => TACPhysicalLocation class
        := TACPhysicalIntegerRegister.
}.

public final class TACGenericObjectPointerConstant superclass: TACConstant; definition: {
    public field object => Untyped.
    public field size => Size.
    public field alignment => Size.
    public field type => Type.

    public method printOn: (stream: Stream) ::=> Void := {
        stream nextPutAll: "genericObjectPointerConstant("; print: object; nextPut: ')'
    }.
}.

public final class TACConstantInt8 superclass: TACConstantInteger; definition: {
    public field value => Int8.

    public override method isSignedExtended => Boolean := true.
    public override method isConstantInt8 => Boolean := true.
    public override method isImmediate32 => Boolean := true.

    public override method type => Type := Int8.
    public override method size => UInt64 := 1u64.
    public override method alignment => UInt64 := 1u64.

    public method printOn: (stream: Stream) ::=> Void := {
        stream print: value; nextPutAll: "i8"
    }.

    Int8 extend: {
        public method asTacConstant => TACConstantInt8
            := TACConstantInt8 new value: self; yourself
    }
}.

public final class TACConstantUInt8 superclass: TACConstantInteger; definition: {
    public field value => UInt8.

    public override method isConstantUInt8 => Boolean := true.
    public override method isImmediate32 => Boolean := true.

    public override method type => Type := UInt8.
    public override method size => UInt64 := 1u64.
    public override method alignment => UInt64 := 1u64.
    
    public method printOn: (stream: Stream) ::=> Void := {
        stream print: value; nextPutAll: "u8"
    }.

    UInt8 extend: {
        public method asTacConstant => TACConstantUInt8
            := TACConstantUInt8 new value: self; yourself
    }
}.

public final class TACConstantInt16 superclass: TACConstantInteger; definition: {
    public field value => Int16.

    public override method isSignedExtended => Boolean := true.
    public override method isConstantInt16 => Boolean := true.
    public override method isImmediate32 => Boolean := true.

    public override method type => Type := Int16.
    public override method size => UInt64 := 2u64.
    public override method alignment => UInt64 := 2u64.

    public method printOn: (stream: Stream) ::=> Void := {
        stream print: value; nextPutAll: "i16"
    }.

    Int16 extend: {
        public method asTacConstant => TACConstantInt16
            := TACConstantInt16 new value: self; yourself
    }
}.

public final class TACConstantUInt16 superclass: TACConstantInteger; definition: {
    public field value => UInt16.

    public override method isConstantUInt16 => Boolean := true.
    public override method isImmediate32 => Boolean := true.

    public override method type => Type := UInt16.
    public override method size => UInt64 := 2u64.
    public override method alignment => UInt64 := 2u64.

    public method printOn: (stream: Stream) ::=> Void := {
        stream print: value; nextPutAll: "u16"
    }.

    UInt16 extend: {
        public method asTacConstant => TACConstantUInt16
            := TACConstantUInt16 new value: self; yourself
    }
}.

public final class TACConstantInt32 superclass: TACConstantInteger; definition: {
    public field value => Int32.

    public override method isSignedExtended => Boolean := true.
    public override method isConstantInt32 => Boolean := true.
    public override method isImmediate32 => Boolean := true.

    public override method type => Type := Int32.
    public override method size => UInt64 := 4u64.
    public override method alignment => UInt64 := 4u64.

    public method printOn: (stream: Stream) ::=> Void := {
        stream print: value; nextPutAll: "i32"
    }.

    Int32 extend: {
        public method asTacConstant => TACConstantInt32
            := TACConstantInt32 new value: self; yourself
    }
}.

public final class TACConstantUInt32 superclass: TACConstantInteger; definition: {
    public field value => UInt32.

    public override method isConstantUInt32 => Boolean := true.
    public override method isImmediate32 => Boolean := true.

    public override method type => Type := UInt32.
    public override method size => UInt64 := 4u64.
    public override method alignment => UInt64 := 4u64.

    public method printOn: (stream: Stream) ::=> Void := {
        stream print: value; nextPutAll: "u32"
    }.

    UInt32 extend: {
        public method asTacConstant => TACConstantUInt32
            := TACConstantUInt32 new value: self; yourself
    }
}.

public final class TACConstantInt64 superclass: TACConstantInteger; definition: {
    public field value => Int64.

    public override method isSignedExtended => Boolean := true.
    public override method isConstantInt64 => Boolean := true.
    public override method isImmediate32 => Boolean := true.

    public override method type => Type := Int64.
    public override method alignment => UInt64 := 8u64.
    public override method size => UInt64 := 8u64.
    
    public method printOn: (stream: Stream) ::=> Void := {
        stream print: value; nextPutAll: "i64"
    }.

    Int64 extend: {
        public method asTacConstant => TACConstantInt64
            := TACConstantInt64 new value: self; yourself
    }
}.

public final class TACConstantUInt64 superclass: TACConstantInteger; definition: {
    public field value => UInt64.

    public override method isConstantUInt64 => Boolean := true.
    public override method isImmediate64 => Boolean := true.

    public override method type => Type := UInt64.
    public override method alignment => UInt64 := 8u64.
    public override method size => UInt64 := 8u64.

    public method printOn: (stream: Stream) ::=> Void := {
        stream print: value; nextPutAll: "u64"
    }.

    UInt64 extend: {
        public method asTacConstant => TACConstantUInt64
            := TACConstantUInt64 new value: self; yourself
    }.
}.

public final class TACConstantFloatingPoint superclass: TACConstant; definition: {
    public override method isFloatingPoint => Boolean := true.
    public override method isConstantFloat => Boolean := true.
}.

public final class TACConstantFloat32 superclass: TACConstantFloatingPoint; definition: {
    public field value => Float32.

    public override method isConstantFloat32 => Boolean := true.
    public override method isImmediate32 => Boolean := true.

    public override method type => Type := Float32.
    public override method alignment => UInt64 := 4u64.
    public override method size => UInt64 := 4u64.

    public method printOn: (stream: Stream) ::=> Void := {
        stream print: value; nextPutAll: "f32"
    }.

    Float32 extend: {
        public method asTacConstant => TACConstantFloat32
            := TACConstantFloat32 new value: self; yourself
    }.
}.

public final class TACConstantFloat64 superclass: TACConstantFloatingPoint; definition: {
    public field value => Float64.

    public override method isConstantFloat64 => Boolean := true.
    public override method isImmediate64 => Boolean := true.

    public override method type => Type := Float64.
    public override method alignment => UInt64 := 8u64.
    public override method size => UInt64 := 8u64.

    public method printOn: (stream: Stream) ::=> Void := {
        stream print: value; nextPutAll: "f64"
    }.

    Float64 extend: {
        public method asTacConstant => TACConstantFloat64
            := TACConstantFloat64 new value: self; yourself
    }.
}.

public final class TACOperation superclass: Object; definition: {
    public field name => Symbol.
    public field isTerminator => Boolean.

    protected field perTargetCodeGenerators => IdentityDictionary.
    protected field perTargetRegisterConstraints => IdentityDictionary.

    __Meta__ definition: {
        public method named: (name: Symbol) ::=> self
            := self new name: name; yourself.

        public method terminatorNamed: (name: Symbol) ::=> self
            := self new name: name; isTerminator: true; yourself.
    }.

    public method initialize => Void := {
        perTargetCodeGenerators := IdentityDictionary new.
        perTargetRegisterConstraints := IdentityDictionary new.
    }.

    public method printOn: (stream: Stream) ::=> Void := {
        stream string: name
    }.
}.

public final class TACInstruction superclass: TACValue; definition: {
    public field previous => TACInstruction.
    public field next => TACInstruction.

    public field index => UInt32.

    public field operation => TACOperation.
    public field result => TACValue.
    public field operands => Array.

    public field resultRegister => TACPhysicalLocation.
    public field operandRegisters => Array.
    public field scratchRegisters => Array.

    public field callingConvention => TACCallingConvention.

    public method initialize => Void := {
        super initialize.
        operands := #().
    }.

    public method isTerminator => Boolean
        := operation isTerminator.

    public method fullPrintOn: (stream: Stream) ::=> Void := {
        result ifNotNil: (stream print: result; nextPutAll: " := ").
        stream print: operation.
        operands doWithIndex: {:(TACValue)eachOperand :(Size)index :: Void |
            index = 0sz
                ifTrue: (stream space)
                ifFalse: (stream nextPutAll: ", ").
            stream print: eachOperand
        }.
    }.

    public method markLiveRange => Void := {
        result ifNotNil: (result markWriteAt: index).
        operands do: {:(TACValue)value :: Void |
            value markUsageAt: index
        }
    }.

    public method resetRegisterAllocation => Void := {
        resultRegister := nil.
        operandRegisters := operands size > 0sz ifTrue: (Array new: operands size) ifFalse: #().
        scratchRegisters := #().
    }.

    public method firstOperandRegister => TACPhysicalLocation := operandRegisters first.
    public method secondOperandRegister => TACPhysicalLocation := operandRegisters second.
    public method thirdOperandRegister => TACPhysicalLocation := operandRegisters third.

    public method firstScratchRegister => TACPhysicalLocation := scratchRegisters first.
    public method secondScratchRegister => TACPhysicalLocation := scratchRegisters first.
}.

public global TAC::Operation::Branch := TACOperation terminatorNamed: #branch.
public global TAC::Operation::ConditionalBranch := TACOperation terminatorNamed: #condBranch.

public global TAC::Operation::Move := TACOperation named: #move.

public global TAC::Operation::CallInt32 := TACOperation named: #callInt32.
public global TAC::Operation::CallInt64 := TACOperation named: #callInt64.
public global TAC::Operation::CallFloat32 := TACOperation named: #callFloat32.
public global TAC::Operation::CallFloat64 := TACOperation named: #callFloat64.
public global TAC::Operation::CallStruct := TACOperation named: #callStruct.
public global TAC::Operation::CallVoid := TACOperation named: #callVoid.

public global TAC::Operation::ReturnInt32 := TACOperation terminatorNamed: #returnInt32.
public global TAC::Operation::ReturnInt64 := TACOperation terminatorNamed: #returnInt64.
public global TAC::Operation::ReturnFloat32 := TACOperation terminatorNamed: #returnFloat32.
public global TAC::Operation::ReturnFloat64 := TACOperation terminatorNamed: #returnFloat64.
public global TAC::Operation::ReturnStruct := TACOperation terminatorNamed: #returnStruct.
public global TAC::Operation::ReturnVoid := TACOperation terminatorNamed: #returnVoid.

public global TAC::Operation::Trap := TACOperation terminatorNamed: #trap.

TACBasicBlock definition: {
    public field name => Symbol.
    public field index => UInt32.

    public field previous => TACBasicBlock.
    public field next => TACBasicBlock.

    public field firstInstruction => TACInstruction.
    public field lastInstruction => TACInstruction.

    public override method physicalLocationClass => TACPhysicalLocation class
        := TACPhysicalIntegerRegister.

    public override method isRelativeImmediate32 => Boolean := true.


    public method addInstruction: (instruction: TACInstruction) before: (position: TACInstruction) ::=> Void := {
        let before := position ifNotNil: position previous ifNil: lastInstruction.
        let after := position.

        ## Do not add instructions after a terminator.
        before isNotNil && before isTerminator ifTrue: (return: void).

        before ifNotNil: {
            before next: instruction.
            instruction previous: before.
        } ifNil: {
            firstInstruction := instruction
        }.

        after ifNotNil: {
            after previous: instruction.
            instruction next: after
        } ifNil: {
            lastInstruction := instruction
        }.
    }.

    public method addInstruction: (instruction: TACInstruction) ::=> Void := {
        self addInstruction: instruction before: nil
    }.

    public method instructionsDo: aBlock ::=> Void := {
        let position mutable := firstInstruction.
        while: (position isNotNil) do: {
            let nextPosition := position next.
            aBlock(position).
            position := nextPosition
        }
    }.

    public method printOn: (stream: Stream) ::=> Void := {
        stream nextPut: '@'; print: index.
        name ifNotNil: (stream nextPut: ':'; string: name)
    }.

    public method fullPrintOn: (stream: Stream) ::=> Void := {
        stream print: self; nextPut: ':'; nl.
        self instructionsDo: {:(TACBasicBlock)each :: Void |
            stream nextPutAll: "    "; fullPrint: each; nl
        }.
    }.
}.

public final class TACFunction superclass: TACProgramEntity; definition: {
    public field callingConvention => TACCallingConvention.

    public field arguments => Array.
    public field captures => Array.
    public field temporaries => OrderedCollection.

    public field firstBasicBlock => TACBasicBlock.
    public field lastBasicBlock => TACBasicBlock.

    public override method isFunction => Boolean := true.

    public override method physicalLocationClass => TACPhysicalLocation class
        := TACPhysicalIntegerRegister.

    public override method isRelativeImmediate32 => Boolean := true.

    public method initialize => Void := {
        arguments := #().
        captures := #().
        temporaries := OrderedCollection new
    }.

    public method addTemporary: (temporary: TACTemporaryVariable) ::=> TACTemporaryVariable := {
        temporaries add: temporary.
        temporary
    }.

    public method newArgument: (name: Symbol) withType: (type: Type) ::=> TACArgumentVariable
        := TACArgumentVariable new
            name: name;
            type: type;
            size: (type valueSizeForTacTarget: compilationTarget) asUInt64;
            alignment: (type valueAlignmentForTacTarget: compilationTarget) asUInt64;
            isGCRoot: type isGarbageCollectedPointerType;
            physicalLocationClass: type valueTacPhysicalLocationClass;
            yourself.

    public method newArgumentWithType: (type: Type) ::=> TACArgumentVariable
        := self newArgument: nil withType: type.

    public method newCapture: (name: Symbol) withType: (type: Type) ::=> TACCaptureVariable
        := TACCaptureVariable new
            name: name;
            type: type;
            size: (type valueSizeForTacTarget: compilationTarget) asUInt64;
            alignment: (type valueAlignmentForTacTarget: compilationTarget) asUInt64;
            isGCRoot: type isGarbageCollectedPointerType;
            physicalLocationClass: type valueTacPhysicalLocationClass;
            yourself.

    public method newCaptureWithType: (type: Type) ::=> TACCaptureVariable
        := self newCapture: nil withType: type.

    public method newTemporary: (name: Symbol) withType: (type: Type) ::=> TACTemporaryVariable
        := self addTemporary: (TACTemporaryVariable new
            name: name;
            type: type;
            size: (type valueSizeForTacTarget: compilationTarget) asUInt64;
            alignment: (type valueAlignmentForTacTarget: compilationTarget) asUInt64;
            isGCRoot: type isGarbageCollectedPointerType;
            physicalLocationClass: type valueTacPhysicalLocationClass;
            yourself).

    public method newTemporaryWithType: (type: Type) ::=> TACTemporaryVariable
        := self newTemporary: nil withType: type.

    public method newTemporaryUInt8 => TACTemporaryVariable
        := self newTemporaryWithType: UInt8.

    public method newTemporaryInt8 => TACTemporaryVariable
        := self newTemporaryWithType: Int8.

    public method newTemporaryUInt16 => TACTemporaryVariable
        := self newTemporaryWithType: UInt16.

    public method newTemporaryInt16 => TACTemporaryVariable
        := self newTemporaryWithType: Int8.

    public method newTemporaryUInt32 => TACTemporaryVariable
        := self newTemporaryWithType: UInt32.

    public method newTemporaryInt32 => TACTemporaryVariable
        := self newTemporaryWithType: Int32.

    public method newTemporaryUInt64 => TACTemporaryVariable
        := self newTemporaryWithType: UInt64.

    public method newTemporaryInt64 => TACTemporaryVariable
        := self newTemporaryWithType: Int64.

    public method newTemporaryUIntPointer => TACTemporaryVariable
        := compilationTarget pointerSize = 8sz
            ifTrue: (self newTemporaryUInt64)
            ifFalse: (self newTemporaryUInt32).

    public method newTemporaryIntPointer => TACTemporaryVariable
        := compilationTarget pointerSize = 8sz
            ifTrue: (self newTemporaryInt64)
            ifFalse: (self newTemporaryInt32).

    public method newTemporaryFloat32 => TACTemporaryVariable
        := self newTemporaryWithType: Float32.

    public method newTemporaryFloat64 => TACTemporaryVariable
        := self newTemporaryWithType: Float64.

    public method addBasicBlock: (basicBlock: TACBasicBlock) before: (position: TACBasicBlock) ::=> Void := {
        let before := position ifNotNil: position previous ifNil: lastBasicBlock.
        let after := position.

        before ifNotNil: {
            before next: basicBlock.
            basicBlock previous: before.
        } ifNil: {
            firstBasicBlock := basicBlock
        }.

        after ifNotNil: {
            after previous: basicBlock.
            basicBlock next: after
        } ifNil: {
            lastBasicBlock := basicBlock
        }.
    }.

    public method addBasicBlock: (basicBlock: TACBasicBlock) ::=> Void := {
        self addBasicBlock: basicBlock before: nil
    }.

    public method basicBlocksDo: (aBlock: (TACBasicBlock) => Void) ::=> Void := {
        let position mutable := firstBasicBlock.
        while: (position isNotNil) do: {
            let nextPosition := position next.
            aBlock(position).
            position := nextPosition
        }
    }.

    public method enumerateBlocks => Void := {
        let index mutable := 0u32.
        self basicBlocksDo: {:(TACBasicBlock)each :: Void |
            each index: index.
            index := index + 1u32.
        }.
    }.

    public method instructionsDo: (aBlock: (TACInstruction) => Void) ::=> Void := {
        self basicBlocksDo: {:(TACBasicBlock)each :: Void |
            each instructionsDo: aBlock
        }.
    }.

    public method enumerateInstructions => Void := {
        let index mutable := 1u32.
        self instructionsDo: {:(TACInstruction)each :: Void |
            each index: index.
            index := index + 1u32
        }
    }.

    public method allLocalVariablesDo: (aBlock: (TACLocalVariable) => Void) ::=> Void := {
        arguments do: aBlock.
        captures do: aBlock.
        temporaries do: aBlock.
    }.

    public method enumerateLocals => Void := {
        let index mutable := 0u32.
        self allLocalVariablesDo: {:(TACLocalVariable)each :: Void |
            each index: index.
            index := index + 1u32
        }
    }.

    public method computeLiveRanges => Void := {
        self enumerateInstructions.
        self allLocalVariablesDo: {:(TACLocalVariable)eachLocal :: Void |
            eachLocal resetLiveRange
        }.
        self instructionsDo: {:(TACInstruction)eachInstruction :: Void |
            eachInstruction markLiveRange
        }.
    }.

    public method printOn: (stream: Stream) ::=> Void := {
        stream nextPutAll: "function".
        name ifNotNil: (stream space; string: name).
    }.

    public method fullPrintOn: (stream: Stream) ::=> Void := {
        stream print: self; nextPutAll: " {"; nl.
        self enumerateBlocks; enumerateLocals.
        self basicBlocksDo: {:(TACBasicBlock)each :: Void |
            stream fullPrint: each
        }.
        stream nextPut: '}'; nl.
    }.
}.

public final class TACBlockBuilder superclass: Object; definition: {
    public field block => TACBasicBlock.
    public field function => TACFunction.

    ## Debugging information
    public field debugSourcePosition => SourcePosition.
    public field debugSourceNode => ASTNode.
    public field debugSourceEnvironment => Environment.

    public method addInstruction: (instruction: TACInstruction) ::=> TACInstruction := {
        block addInstruction: instruction.
        instruction
            debugSourcePosition: debugSourcePosition;
            debugSourceNode: debugSourceNode;
            debugSourceEnvironment: debugSourceEnvironment.
        instruction
    }.

    public method temporaryUInt8 => TACTemporaryVariable := function newTemporaryUInt8.
    public method temporaryInt8 => TACTemporaryVariable := function newTemporaryInt8.
    public method temporaryUInt16 => TACTemporaryVariable := function newTemporaryUInt16.
    public method temporaryInt16 => TACTemporaryVariable := function newTemporaryInt16.
    public method temporaryUInt32 => TACTemporaryVariable := function newTemporaryUInt32.
    public method temporaryInt32 => TACTemporaryVariable := function newTemporaryInt32.
    public method temporaryUInt64 => TACTemporaryVariable := function newTemporaryUInt64.
    public method temporaryInt64 => TACTemporaryVariable := function newTemporaryInt64.
    public method temporaryUIntPointer => TACTemporaryVariable := function newTemporaryUIntPointer.
    public method temporaryFloat32 => TACTemporaryVariable := function newTemporaryFloat32.
    public method temporaryFloat64 => TACTemporaryVariable := function newTemporaryFloat64.

    public method compilationTarget => TACCompilationTarget := function compilationTarget.
    public method pointerSize => Size := function compilationTarget pointerSize.
    public method uintPointerType => Type := function compilationTarget uintPointerType.
    public method has64BitsPointers => Boolean := self pointerSize = 8sz.

    public method operation: (operation: TACOperation) ::=> TACInstruction
        := self addInstruction: (TACInstruction new operation: operation; yourself).

    public method operation: (operation: TACOperation) with: (operand: TACValue) ::=> TACInstruction
        := self addInstruction: (TACInstruction new operation: operation; operands: (Array with: operand); yourself).

    public method operation: (operation: TACOperation) with: (operand: TACValue) result: (result: TACValue)::=> TACInstruction
        := self addInstruction: (TACInstruction new operation: operation; result: result; operands: (Array with: operand); yourself).

    public method operation: (operation: TACOperation) with: (firstOperand: TACValue) with: (secondOperand: TACValue) ::=> TACInstruction
        := self addInstruction: (TACInstruction new operation: operation; operands: (Array with: firstOperand with: secondOperand); yourself).

    public method operation: (operation: TACOperation) with: (firstOperand: TACValue) with: (secondOperand: TACValue) result: (result: TACValue) ::=> TACInstruction
        := self addInstruction: (TACInstruction new operation: operation; result: result; operands: (Array with: firstOperand with: secondOperand); yourself).

    public method operation: (operation: TACOperation) with: (firstOperand: TACValue) with: (secondOperand: TACValue) with: (thirdOperand: TACValue) ::=> TACInstruction
        := self addInstruction: (TACInstruction new operation: operation; operands: (Array with: firstOperand with: secondOperand with: thirdOperand); yourself).

    public method operation: (operation: TACOperation) with: (operand: TACValue) result: (result: TACValue) ::=> TACInstruction
        := self addInstruction: (TACInstruction new operation: operation; result: result; operands: (Array with: operand); yourself).

    public method branch: (destination: TACValue) ::=> TACInstruction
        := self operation: TAC::Operation::Branch with: destination.

    public method when: (condition: TACValue) branchIfTrue: (trueDestination: TACValue) branchIfFalse: (falseDestination: TACValue) ::=> TACInstruction
        := self operation: TAC::Operation::ConditionalBranch with: condition with: trueDestination with: falseDestination.

    public method move: (source: TACValue) into: (destination: TACValue) ::=> TACInstruction
        := self operation: TAC::Operation::Move with: source result: destination.

    public method call: (function: TACValue) operation: (callOperation: TACOperation) convention: (callingConvention: TACCallingConvention) arguments: (arguments: Array) result: (result: TACValue) ::=> TACInstruction
        := self addInstruction: (TACInstruction new
            operation: callOperation;
            operands: (Array with: function) -- arguments;
            callingConvention: callingConvention;
            result: result;
            yourself).

    public method callInt32: (function: TACValue) convention: (callingConvention: TACCallingConvention) arguments: (arguments: Array) result: (result: TACValue) ::=> TACInstruction
        := self call: function operation: TAC::Operation::CallInt32 convention: self compilationTarget defaultCallingConvention arguments: arguments result: result.

    public method callInt32: (function: TACValue) arguments: (arguments: Array) result: (result: TACValue) ::=> TACInstruction
        := self callInt32: function convention: self compilationTarget defaultCallingConvention arguments: arguments result: result.

    public method callInt64: (function: TACValue) convention: (callingConvention: TACCallingConvention) arguments: (arguments: Array) result: (result: TACValue) ::=> TACInstruction
        := self call: function operation: TAC::Operation::CallInt64 convention: self compilationTarget defaultCallingConvention arguments: arguments result: result.

    public method callInt64: (function: TACValue) arguments: (arguments: Array) result: (result: TACValue) ::=> TACInstruction
        := self callInt64: function convention: self compilationTarget defaultCallingConvention arguments: arguments result: result.

    public method callPointer: (function: TACValue) convention: (callingConvention: TACCallingConvention) arguments: (arguments: Array) result: (result: TACValue) ::=> TACInstruction
        := self call: function
            operation: (self has64BitsPointers ifTrue: (TAC::Operation::CallInt64) ifFalse: (TAC::Operation::CallInt32))
            convention: self compilationTarget defaultCallingConvention arguments: arguments result: result.

    public method callPointer: (function: TACValue) arguments: (arguments: Array) result: (result: TACValue) ::=> TACInstruction
        := self callPointer: function convention: self compilationTarget defaultCallingConvention arguments: arguments result: result.

    public method callFloat32: (function: TACValue) convention: (callingConvention: TACCallingConvention) arguments: (arguments: Array) result: (result: TACValue) ::=> TACInstruction
        := self call: function operation: TAC::Operation::CallFloat32 convention: self compilationTarget defaultCallingConvention arguments: arguments result: result.

    public method callFloat32: (function: TACValue) arguments: (arguments: Array) result: (result: TACValue) ::=> TACInstruction
        := self callFloat32: function convention: self compilationTarget defaultCallingConvention arguments: arguments result: result.

    public method callFloat64: (function: TACValue) convention: (callingConvention: TACCallingConvention) arguments: (arguments: Array) result: (result: TACValue) ::=> TACInstruction
        := self call: function operation: TAC::Operation::CallFloat64 convention: self compilationTarget defaultCallingConvention arguments: arguments result: result.

    public method callFloat64: (function: TACValue) arguments: (arguments: Array) result: (result: TACValue) ::=> TACInstruction
        := self callFloat64: function convention: self compilationTarget defaultCallingConvention arguments: arguments result: result.

    public method callVoid: (function: TACValue) convention: (callingConvention: TACCallingConvention) arguments: (arguments: Array) ::=> TACInstruction
        := self call: function operation: TAC::Operation::CallInt64 convention: self compilationTarget defaultCallingConvention arguments: arguments result: nil.

    public method callVoid: (function: TACValue) arguments: (arguments: Array) ::=> TACInstruction
        := self callVoid: function convention: self compilationTarget defaultCallingConvention arguments: arguments.

    public method returnVoid ::=> TACInstruction
        := self operation: TAC::Operation::ReturnVoid.

    public method returnInt32: (value: TACValue) ::=> TACInstruction
        := self operation: TAC::Operation::ReturnInt32 with: value.

    public method returnInt64: (value: TACValue) ::=> TACInstruction
        := self operation: TAC::Operation::ReturnInt64 with: value.

    public method returnPointer: (value: TACValue) ::=> TACInstruction
        := self has64BitsPointers
            ifTrue: (self returnInt32: value)
            ifFalse: (self returnInt64: value).

    public method returnFloat32: (value: TACValue) ::=> TACInstruction
        := self operation: TAC::Operation::ReturnFloat32 with: value.

    public method returnFloat64: (value: TACValue) ::=> TACInstruction
        := self operation: TAC::Operation::ReturnFloat64 with: value.

    public method trap ::=> TACInstruction
        := self operation: TAC::Operation::Trap.
}.

public final class TACFunctionBuilder superclass: Object; definition: {
    public field function => TACFunction.

    TACFunction extend: {
        public method build: (aBlock: (TACFunctionBuilder) => Void) ::=> Void := {
            let builder := TACFunctionBuilder new
                function: self;
                yourself.
            aBlock(builder).
        }.
    }.

    public method basicBlock: (name: Symbol) build: (aBlock: (TACBlockBuilder) => Void) ::=> Void := {
        let block := TACBasicBlock new name: name; yourself.
        function addBasicBlock: block.

        let blockBuilder := TACBlockBuilder new
            block: block;
            function: function;
            yourself.
        aBlock(blockBuilder).
        block.
    }.
}.

#(
    Int8BitNot Int16BitNot Int32BitNot Int64BitNot
    Int8Negate Int16Negate Int32Negate Int64Negate

    Float32Negate Float64Negate
    Float32Sqrt Float64Sqrt
) do: {:(Symbol)operationName :: Void |
    let operationNameString := operationName asString.
    let lowerOperationNameString := operationNameString first asLowercase asString -- operationNameString allButFirst.
    let lowerOperationName := lowerOperationNameString asSymbol.
    let operation := TACOperation named: lowerOperationName.
    let globalName := ("TAC::Operation::" -- operationNameString) asSymbol.

    TACBlockBuilder
        withSelector: (lowerOperationNameString -- ":into:") asSymbol addMethod: {:(TACBlockBuilder)self :(TACValue)operand :(TACValue)result :: TACInstruction |
            self operation: operation with: operand result: result.
        }.
    __OwnerProgramEntity__ setPublicSymbol: globalName value: operation
}.

#(
    Int8Add Int16Add Int32Add Int64Add
    Int8Sub Int16Sub Int32Sub Int64Sub
    Int8Mul Int16Mul Int32Mul Int64Mul
    Int8SDiv Int16SDiv Int32SDiv Int64SDiv
    Int8UDiv Int16UDiv Int32UDiv Int64UDiv
    Int8SRem Int16SRem Int32SRem Int64SRem
    Int8URem Int16URem Int32URem Int64URem

    Int8BitAnd Int16BitAnd Int32BitAnd Int64BitAnd
    Int8BitOr Int16BitOr Int32BitOr Int64BitOr
    Int8BitXor Int16BitXor Int32BitXor Int64BitXor
    Int8ArithmeticShiftRight Int16ArithmeticShiftRight Int32ArithmeticShiftRight Int64ArithmeticShiftRight
    Int8LogicalShiftLeft Int16LogicalShiftLeft Int32LogicalShiftLeft Int64LogicalShiftLeft
    Int8LogicalShiftRight Int16LogicalShiftRight Int32LogicalShiftRight Int64LogicalShiftRight

    Int8Equals Int16Equals Int32Equals Int64Equals
    Int8NotEquals Int16NotEquals Int32NotEquals Int64NotEquals

    Int8Compare Int16Compare Int32Compare Int64Compare
    Int8LessThan Int16LessThan Int32LessThan Int64LessThan
    Int8LessOrEquals Int16LessOrEquals Int32LessOrEquals Int64LessOrEquals
    Int8GreaterThan Int16GreaterThan Int32GreaterThan Int64GreaterThan
    Int8GreaterOrEquals Int16GreaterOrEquals Int32GreaterOrEquals Int64GreaterOrEquals

    UInt8LessThan UInt16LessThan UInt32LessThan UInt64LessThan
    UInt8LessOrEquals UInt16LessOrEquals UInt32LessOrEquals UInt64LessOrEquals
    UInt8GreaterThan UInt16GreaterThan UInt32GreaterThan UInt64GreaterThan
    UInt8GreaterOrEquals UInt16GreaterOrEquals UInt32GreaterOrEquals UInt64GreaterOrEquals

    Float32Add Float64Add
    Float32Sub Float64Sub
    Float32Mul Float64Mul
    Float32Div Float64Div

    Float32UnorderedEquals Float64UnorderedEquals
    Float32UnorderedNotEquals Float64UnorderedNotEquals
    Float32UnorderedCompare Float64UnorderedCompare
    Float32UnorderedLessThan Float64UnorderedLessThan
    Float32UnorderedLessOrEquals Float64UnorderedLessOrEquals
    Float32UnorderedGreaterThan Float64UnorderedGreaterThan
    Float32UnorderedGreaterOrEquals Float64UnorderedGreaterOrEquals
) do: {:(Symbol)operationName :: Void |
    let operationNameString := operationName asString.
    let lowerOperationNameString := operationNameString first asLowercase asString -- operationNameString allButFirst.
    let lowerOperationName := lowerOperationNameString asSymbol.
    let operation := TACOperation named: lowerOperationName.
    let globalName := ("TAC::Operation::" -- operationNameString) asSymbol.

    TACBlockBuilder
        withSelector: (lowerOperationNameString -- ":with:into:") asSymbol addMethod: {:(TACBlockBuilder)self :(TACValue)left :(TACValue)right :(TACValue)result :: TACInstruction |
            self operation: operation with: left with: right result: result.
        }.
    __OwnerProgramEntity__ setPublicSymbol: globalName value: operation
}.

public final class TACModule superclass: TACProgramEntity; definition: {
    public field compilationTarget => TACCompilationTarget.
    public field programEntities => OrderedCollection.

    public method initialize => Void := {
        super initialize.
        programEntities := OrderedCollection new.
    }.

    public method addProgramEntity: (programEntity: TACProgramEntity) ::=> Void := {
        programEntities add: programEntity
    }.

    public method build: (name: Symbol) function: (aBlock: (TACFunctionBuilder) => Void) ::=> TACFunction := {
        let function := TACFunction new
            compilationTarget: compilationTarget;
            callingConvention: compilationTarget defaultCallingConvention;
            name: name;
            yourself.
        self addProgramEntity: function.
        function build: aBlock; yourself
    }.

    public method fullPrintOn: (stream: Stream) ::=> Void := {
        self programEntities do: {:(TACProgramEntity)each :: Void |
            stream fullPrint: each; nl
        }
    }.

    public method asTargetIR => AnyValue
        := compilationTarget generateTargetIRForTACModule: self
}.

TACCallingConvention definition: {
    public abstract method computeArgumentPassingLayoutOf: (function: TACFunction) ::=> Void
        := self subclassResponsibility.
}.

TACCompilationTarget definition: {
    public abstract method name => Symbol
        := self subclassResponsibility.

    public abstract method pointerSize => Size
        := self subclassResponsibility.

    public abstract method pointerAlignment => Size
        := self subclassResponsibility.

    public abstract method uintPointerType => Type
        := self subclassResponsibility.

    public abstract method stackFrameAlignment => Size
        := self subclassResponsibility.

    public abstract method allIntegerRegisters => Array
        := self subclassResponsibility.

    public abstract method allocableIntegerRegisters => Array
        := self subclassResponsibility.

    public abstract method allFloatRegisters => Array
        := self subclassResponsibility.

    public abstract method allocableFloatRegisters => Array
        := self subclassResponsibility.

    public abstract method allVectorRegisters => Array
        := self subclassResponsibility.

    public abstract method allocableVectorRegisters => Array
        := self subclassResponsibility.

    public abstract method generateTargetIRForTACModule: (module: TACModule) ::=> AnyValue
        := self subclassResponsibility.

    public abstract method defaultCallingConvention => TACCallingConvention
        := self subclassResponsibility.
}.
