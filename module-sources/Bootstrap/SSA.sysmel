public class SSAValue superclass: Object.
public class SSAConstant superclass: SSAValue.
public class SSAFunction superclass: SSAConstant.
public class SSAFunctionLocalValue superclass: SSAValue.
public final class SSAFunctionArgument superclass: SSAFunctionLocalValue.
public class SSABasicBlock superclass: SSAFunctionLocalValue.
public class SSAInstruction superclass: SSAFunctionLocalValue.
public final class SSAInstructionBuilder superclass: Object.

SSAValue definition: {
    public field type => Type.
    public field sourcePosition => SourcePosition.
    public field sourceASTNode => ASTNode.
    public field sourceEnvironment => Environment.

    public method isConstant => Boolean := false.
    public method isLiteralConstant => Boolean := false.
    public method isFunction => Boolean := false.
    public method isFunctionLocalValue => Boolean := false.
    public method isBasicBlock => Boolean := false.
    
    public method isInstruction => Boolean := false.
    public method isTerminatorInstruction => Boolean := false.
}.

SSAConstant definition: {
    public method isConstant => Boolean := true.
}.

public class SSALiteralConstant superclass: SSAConstant; definition: {
    public field value.

    public method isLiteralConstant => Boolean := true.

    public method printOn: (stream: Stream) ::=> Void
        := stream nextPutAll: "Literal("; print: self value; nextPutAll: " => "; print: self type; nextPut: ')'.
}.

SSAFunction definition: {
    public field name.
    public field arguments => Array.

    public field firstBasicBlock => SSABasicBlock.
    public field lastBasicBlock => SSABasicBlock.

    public method isFunction => Boolean := true.

    public method addBasicBlock: (basicBlock: SSABasicBlock) before: (position: SSABasicBlock) ::=> Void := {
        let before := position ifNotNil: position previousBlock ifNil: self lastBasicBlock.
        let after := position.

        before ifNotNil: {
            before nextBlock: basicBlock.
            basicBlock previousBlock: before.
        } ifNil: {
            self firstBasicBlock: basicBlock
        }.

        after ifNotNil: {
            after previousBlock: basicBlock.
            basicBlock nextBlock: after
        } ifNil: {
            self lastBasicBlock: basicBlock
        }.
    }.

    public method addBasicBlock: (basicBlock: SSABasicBlock) after: (position: SSABasicBlock) ::=> Void := {
        let before := position .
        let after := position ifNotNil: position nextBlock ifNil: self firstBasicBlock.

        before ifNotNil: {
            before nextBlock: basicBlock.
            basicBlock previousBlock: before.
        } ifNil: {
            self firstBasicBlock: basicBlock
        }.

        after ifNotNil: {
            after previousBlock: basicBlock.
            basicBlock nextBlock: after
        } ifNil: {
            self lastBasicBlock: basicBlock
        }.
    }.

    public method addBasicBlock: (basicBlock: SSABasicBlock) ::=> Void
        := self addBasicBlock: basicBlock before: nil.

    public method addFirstBasicBlock: (basicBlock: SSABasicBlock) ::=> Void
        := self addBasicBlock: basicBlock after: nil.

    public method basicBlocksDo: aBlock ::=> Void := {
        let position := ValueBox with: self firstBasicBlock.
        while: position _ isNotNil do: (
            aBlock(position _)
        ) continueWith: (position := position _ nextBlock)
    }.

    public method localValuesDo: aBlock ::=> Void := {
        self arguments do: aBlock.
        self basicBlocksDo: {:basicBlock :: Void |
            aBlock(basicBlock).
            basicBlock instructionsDo: aBlock
        }.
    }.

    public method enumerateLocalValueIndices => Void := {
        let index := ValueBox with: 0sz.
        self localValuesDo: {:localValue :: Void |
            localValue localValueIndex: index _.
            index := index _ + 1sz
        }
    }.

    public method printOn: (stream: Stream) ::=> Void := {
        stream nextPut: '@'.
        self name ifNil: {
            stream print: self sourcePosition.
        } ifNotNil: {:name :: Void |
            stream print: self name
        }
    }.

    public method fullPrintOn: (stream: Stream) ::=> Void := {
        self enumerateLocalValueIndices.
        self printOn: stream.
        
        stream nextPut: '('.
        self arguments doWithIndex: {:(SSAFunctionArgument)argument :(Size)index :: Void |
            index > 0sz ifTrue: (stream nextPutAll: ", ").
            stream print: argument
        }.
        stream nextPut: ')'.

        stream nextPutAll: " := {"; nl.
        self basicBlocksDo: {:(SSABasicBlock)basicBlock :: Void |
            basicBlock fullPrintOn: stream
        }.
        stream nextPutAll: "}"; nl.
    }.
}.

SSAFunctionLocalValue definition: {
    public field name.
    public field localValueIndex => Size.

    public method initialize => Void := {
        self localValueIndex: 0sz
    }.

    public method isFunctionLocalValue => Boolean := true.

    public method printOn: (stream: Stream) ::=> Void := {
        stream nextPut: '$'; print: self localValueIndex.

        self name ifNotNil: {:name |
            stream nextPut: ':'; nextPutAll: self name.
        }.
        self type ifNotNil: {:type |
            stream nextPutAll: " => "; print: self type.
        }.
    }.
}.

SSABasicBlock definition: {

    public field previousBlock => SSABasicBlock.
    public field nextBlock => SSABasicBlock.

    public field firstInstruction => SSAInstruction.
    public field lastInstruction => SSAInstruction.

    public method isBasicBlock => Boolean := true.

    public method addInstruction: (instruction: SSAInstruction) before: (position: SSAInstruction) ::=> Void := {
        let before := position ifNotNil: position previousInstruction ifNil: self lastInstruction.
        let after := position.

        before ifNotNil: {
            before nextInstruction: instruction.
            instruction previousInstruction: before.
        } ifNil: {
            self firstInstruction: instruction
        }.

        after ifNotNil: {
            after previousInstruction: instruction.
            instruction nextInstruction: after
        } ifNil: {
            self lastInstruction: instruction
        }.
    }.

    public method addInstruction: (instruction: SSAInstruction) after: (position: SSAInstruction) ::=> Void := {
        let before := position .
        let after := position ifNotNil: position nextInstruction ifNil: self firstInstruction.

        before ifNotNil: {
            before nextInstruction: instruction.
            instruction previousInstruction: before.
        } ifNil: {
            self firstInstruction: instruction
        }.

        after ifNotNil: {
            after previousInstruction: instruction.
            instruction nextInstruction: after
        } ifNil: {
            self lastInstruction: instruction
        }.
    }.

    public method addInstruction: (instruction: SSAInstruction) ::=> Void
        := self addInstruction: instruction before: nil.

    public method addFirstInstruction: (instruction: SSAInstruction) ::=> Void
        := self addInstruction: instruction after: nil.

    public method instructionsDo: aBlock ::=> Void := {
        let position := ValueBox with: self firstInstruction.
        while: position _ isNotNil do: (
            aBlock(position _)
        ) continueWith: (position := position _ nextInstruction)
    }.

    public method fullPrintOn: (stream: Stream) ::=> Void := {
        self printOn: stream.
        stream nextPutAll: ":"; nl.
        self instructionsDo: {:(SSAInstruction)instruction :: Void |
            stream nextPutAll: "    ".
            instruction fullPrintOn: stream.
            stream nl.
        }.
    }.
}.

SSAInstruction definition: {
    public method isInstruction => Boolean := true.
    
    public field previousInstruction => SSAInstruction.
    public field nextInstruction => SSAInstruction.
}.

public final class SSABranchInstruction superclass: SSAInstruction; definition: {
    public field destination => SSABasicBlock.

    public method isTerminatorInstruction => Boolean := true.

    public method fullPrintOn: (stream: Stream) ::=> Void
        := stream nextPutAll: "branch: "; print: self destination.
}.

public final class SSACallInstruction superclass: SSAInstruction; definition: {
    public field calledFunction => SSAValue.
    public field arguments => Array.

    public method fullPrintOn: (stream: Stream) ::=> Void := {
        stream
            print: self; nextPutAll: " := ";
            nextPutAll: "call "; print: self calledFunction.
        self arguments do: {:(SSAValue)argument :: Void |
            stream nextPutAll: ", ".
            stream print: argument
        }
    }.
}.

public final class SSACoerceValueInstruction superclass: SSAInstruction; definition: {
    public field value => SSAValue.
    public field targetType => SSAValue.

    public method fullPrintOn: (stream: Stream) ::=> Void
        := stream print: self; nextPutAll: " := coerceValue: "; print: self value;
            nextPut: ' '; print: self targetType
}.

public final class SSAConditionalBranchInstruction superclass: SSAInstruction; definition: {
    public field condition => SSAValue.
    public field trueDestination => SSABasicBlock.
    public field falseDestination => SSABasicBlock.

    public method isTerminatorInstruction => Boolean := true.

    public method fullPrintOn: (stream: Stream) ::=> Void
        := stream nextPutAll: "condBranch: "; print: self condition;
            nextPut: ' '; print: self trueDestination;
            nextPut: ' '; print: self falseDestination.
}.

public final class SSAPhiInstruction superclass: SSAInstruction; definition: {
    public field incomingValues => Array.
    public field incomingBlocks => Array.

    public method fullPrintOn: (stream: Stream) ::=> Void := {
        stream print: self; nextPutAll: " := phi ["; nl.
        let incomingValues := self incomingValues.
        self incomingBlocks doWithIndex: {:(SSABasicBlock)block :(Size)index :: Void |
            let value := incomingValues at: index.
            stream nextPutAll: "        "; print: value; nextPutAll: " from "; print: block; nl 
        }.

        stream nextPutAll: "    ]"
    }.

    public method addValue: (value: SSAValue) incomingFrom: (block: SSABasicBlock) ::=> Void := {
        self incomingValues: self incomingValues -- (Array with: value).
        self incomingBlocks: self incomingBlocks -- (Array with: block).
    }.
}.

public final class SSAReturnInstruction superclass: SSAInstruction; definition: {
    public field value => SSAValue.

    public method isTerminatorInstruction => Boolean := true.

    public method fullPrintOn: (stream: Stream) ::=> Void
        := stream nextPutAll: "return: "; print: self value.
}.

public final class SSASendInstruction superclass: SSAInstruction; definition: {
    public field receiver => SSAValue.
    public field selector => SSAValue.
    public field arguments => Array.

    public method fullPrintOn: (stream: Stream) ::=> Void := {
        stream
            print: self; nextPutAll: " := ";
            nextPutAll: "send "; print: self receiver;
            nextPutAll: ", "; print: self selector.

        self arguments doWithIndex: {:(SSAValue)argument :(Size)index :: Void |
            index = 0sz
                ifTrue: (stream nextPut: ' ')
                ifFalse: (stream nextPutAll: ", ").
            stream print: argument
        }
    }.
}.

public final class SSAUnreachableInstruction superclass: SSAInstruction; definition: {
    public method isUnreachableInstruction => Boolean := true.

    public method fullPrintOn: (stream: Stream) ::=> Void
        := stream nextPutAll: "unreachable".
}.

SSAInstructionBuilder definition: {
    public field sourcePosition => SourcePosition.
    public field sourceASTNode => ASTNode.
    public field sourceEnvironment => Environment.

    public field function => SSAFunction.
    public field basicBlock => SSABasicBlock.

    __Meta__ definition: {
        public method for: (function: SSAFunction)
            := self new function: function; yourself.
    }.

    public method newBasicBlockNamed: name ::=> SSABasicBlock := {
        let newBasicBlock := SSABasicBlock new
            name: name;
            sourcePosition: self sourcePosition;
            sourceASTNode: self sourceASTNode;
            sourceEnvironment: self sourceEnvironment;
            yourself.
        newBasicBlock
    }.

    public method beginBasicBlock: (newBasicBlock: SSABasicBlock) ::=> SSABasicBlock := {
        self basicBlock: newBasicBlock.
        self function addBasicBlock: newBasicBlock.
        newBasicBlock
    }.

    public method beginBasicBlockNamed: name ::=> SSABasicBlock
        := self beginBasicBlock: (self newBasicBlockNamed: name).

    public method addInstruction: (instruction: SSAInstruction) ::=> instruction __type__ := {
        instruction
            sourcePosition: self sourcePosition;
            sourceASTNode: self sourceASTNode;
            sourceEnvironment: self sourceEnvironment.
        self basicBlock addInstruction: instruction.
        instruction
    }.

    public method withSourcePosition: (sourcePosition: SourcePosition) do: aBlock := {
        let oldPosition := self sourcePosition.
        self sourcePosition: sourcePosition.
        let result := aBlock().
        self sourcePosition: oldPosition.
        result
    }.

    public method withSourceASTNode: (sourceASTNode: ASTNode) do: aBlock := {
        let oldSourceASTNode := self sourceASTNode.
        self sourceASTNode: sourceASTNode.
        let result := self withSourcePosition: sourceASTNode sourcePosition do: aBlock.
        self sourceASTNode: oldSourceASTNode.
        result
    }.

    public method withSourceEnvironment: (sourceEnvironment: Environment) do: aBlock := {
        let oldSourceEnvironment := self sourceEnvironment.
        self sourceEnvironment: sourceEnvironment.
        let result := aBlock().
        self sourceEnvironment: oldSourceEnvironment.
        result
    }.

    public method branch: (destination: SSAValue) ::=> SSABranchInstruction
        := self addInstruction: (SSABranchInstruction new
            destination: destination;
            type: Void;
            yourself).

    public method call: (calledFunction: SSAValue) arguments: (arguments: Array) resultType: (resultType: Type) ::=> SSACallInstruction
        := self addInstruction: (SSACallInstruction new
            calledFunction: calledFunction;
            arguments: arguments;
            type: resultType;
            yourself).

    public method call: (receiver: SSAValue) selector: (selector: SSAValue) arguments: (arguments: Array) ::=> SSASendInstruction
        := self call: receiver selector: selector arguments: arguments resultType: nil.

    public method coerceValue: (value: SSAValue) into: (targetType: SSAValue) ::=> SSAValue := {
        (targetType == nil) || (targetType isLiteralConstant && (value type == targetType value)) ifTrue: {
            value
        } ifFalse: {
            self addInstruction: (SSACoerceValueInstruction new
                value: value;
                targetType: targetType;
                type: (targetType isLiteralConstant ifTrue: targetType value ifFalse: nil);
                yourself)
        }.
    }.

    public method conditionalBranch: (condition: SSAValue) trueDestination: (trueDestination: SSABasicBlock) falseDestination: (falseDestination: SSABasicBlock) ::=> SSAConditionalBranchInstruction
        := self addInstruction: (SSAConditionalBranchInstruction new
            condition: condition;
            trueDestination: trueDestination;
            falseDestination: falseDestination;
            type: Void;
            yourself).

    public method literal: value type: type ::=> SSALiteralConstant
        := SSALiteralConstant new
            sourcePosition: self sourcePosition;
            sourceASTNode: self sourceASTNode;
            sourceEnvironment: self sourceEnvironment;
            value: value;
            type: type;
            yourself.

    public method literal: value ::=> SSALiteralConstant
        := self literal: value type: value __type__.

    public method phi: (type: Type) ::=> SSAPhiInstruction
        := self addInstruction: (SSAPhiInstruction new
            incomingBlocks: ();
            incomingValues: ();
            type: type;
            yourself).

    public method return: (value: SSAValue) ::=> SSAReturnInstruction
        := self addInstruction: (SSAReturnInstruction new
            value: value;
            yourself).

    public method returnVoid ::=> SSAReturnInstruction
        := self return: (self literal: void).

    public method send: (receiver: SSAValue) selector: (selector: SSAValue) arguments: (arguments: Array) resultType: (resultType: Type) ::=> SSASendInstruction
        := self addInstruction: (SSASendInstruction new
            receiver: receiver;
            selector: selector;
            arguments: arguments;
            type: resultType;
            yourself).

    public method send: (receiver: SSAValue) selector: (selector: SSAValue) arguments: (arguments: Array) ::=> SSASendInstruction
        := self send: receiver selector: selector arguments: arguments resultType: nil.

    public method lastInstruction => SSAInstruction
        := self basicBlock ifNotNil: {:basicBlock :: SSAInstruction | basicBlock lastInstruction }.

    public method isLastTerminator => Boolean
        := self lastInstruction
            ifNil: false
            ifNotNil: {:instruction :: Boolean | instruction isTerminatorInstruction }.
}.

public class SSAFunctionCompilationContext superclass: Object; definition: {
    public field functionDefinition => FunctionDefinition.
    public field ssaFunction => SSAFunction.
    public field builder => SSAInstructionBuilder.
    public field bindingDictionary => IdentityDictionary.

    public field breakDestination => SSABasicBlock.
    public field continueDestination => SSABasicBlock.

    public method initialize => Void := {
        self bindingDictionary: IdentityDictionary new.
    }.

    public method generateArgumentForNode: (argumentNode: ASTArgumentNode) ::=> SSAFunctionArgument := {
        let binding := argumentNode binding.
        self assert: binding isNotNil.

        let ssaArgument := SSAFunctionArgument new
            name: binding name;
            type: binding type;
            yourself.

        self bindingDictionary at: binding put: ssaArgument.

        ssaArgument
    }.

    public method setValue: (value: SSAValue) forBinding: (binding: SymbolBinding) ::=> Void := {
        self assert: binding isNotNil.
        self bindingDictionary at: binding put: value
    }.

    public method compileFunctionDefinition: (functionDefinition: FunctionDefinition) ::=> SSAFunction := {
        let ssaFunction := SSAFunction new.
        self functionDefinition: functionDefinition.
        self ssaFunction: ssaFunction.

        ssaFunction
            ##name: functionDefinition name;
            sourcePosition: functionDefinition sourcePosition.

        ssaFunction arguments: (functionDefinition analyzedArgumentNodes collect: {:(ASTArgumentNode)argumentNode :: SSAFunctionArgument |
            self generateArgumentForNode: argumentNode
        }) asArray.

        functionDefinition analyzedBodyNode ifNotNil: {:bodyNode |
            self builder: (SSAInstructionBuilder new
                sourcePosition: bodyNode sourcePosition;
                function: ssaFunction;
                beginBasicBlockNamed: #entry;
                yourself).
            
            let resultValue := bodyNode generateSSAValueWith: self.
            self builder isLastTerminator ifFalse: (self builder return: resultValue).
        }.

        ssaFunction
    }.

    public method getValueForLocalBinding: localBinding ::=> SSAValue
        := self bindingDictionary at: localBinding
}.

ASTNode extend: {
    public method generateSSAValueWith: (context: SSAFunctionCompilationContext) ::=> SSAValue
        := context builder withSourceASTNode: self do: {:: SSAValue |
            self doGenerateSSAValueWith: context
    }.

    public method doGenerateSSAValueWith: (context: SSAFunctionCompilationContext) ::=> SSAValue
        := self subclassResponsibility.
}.

ASTBreakNode extend: {
    public method doGenerateSSAValueWith: (context: SSAFunctionCompilationContext) ::=> SSAValue := {
        context breakDestination ifNil: (self error: 'Invalid break at ' context).
        context builder branch: context breakDestination.
        context builder literal: void
    }.
}.

ASTContinueNode extend: {
    public method doGenerateSSAValueWith: (context: SSAFunctionCompilationContext) ::=> SSAValue := {
        context continueDestination ifNil: (self error: 'Invalid continue at ' context).
        context builder branch: context continueDestination.
        context builder literal: void
    }.
}.

ASTFunctionApplicationNode extend: {
    public method doGenerateSSAValueWith: (context: SSAFunctionCompilationContext) ::=> SSAValue
        := context builder call: (self functionExpression generateSSAValueWith: context)
            arguments: (self arguments collect: {:(ASTNode)each :: SSAValue | each generateSSAValueWith: context }) asArray
            resultType: self analyzedType
}.

ASTLexicalBlockNode extend: {
    public method doGenerateSSAValueWith: (context: SSAFunctionCompilationContext) ::=> SSAValue
        := context builder withSourceEnvironment: self bodyEnvironment do: {:: SSAValue | self body generateSSAValueWith: context }.
}.

ASTLiteralNode extend: {
    public method doGenerateSSAValueWith: (context: SSAFunctionCompilationContext) ::=> SSAValue
        := context builder literal: self value type: self analyzedType.
}.

ASTLocalDefinitionNode extend: {
    public method doGenerateSSAValueWith: (context: SSAFunctionCompilationContext) ::=> SSAValue := {
        let typeExpression := self typeExpression.
        let type := typeExpression
            ifNotNil: (typeExpression generateSSAValueWith: context)
            ifNil: nil.

        let valueExpression := self valueExpression.
        let value := valueExpression
            ifNotNil: (valueExpression generateSSAValueWith: context)
            ifNil: (context builder literal: nil).

        let coercedValue := context builder coerceValue: value into: type.

        context setValue: coercedValue forBinding: self binding.
        coercedValue
    }.
}.

SymbolArgumentBinding extend: {
    public method generateSSAValueWith: (context: SSAFunctionCompilationContext) ::=> SSAValue
        := context getValueForLocalBinding: self.
}.

SymbolLocalBinding extend: {
    public method generateSSAValueWith: (context: SSAFunctionCompilationContext) ::=> SSAValue
        := context getValueForLocalBinding: self.
}.

ASTIdentifierReferenceNode extend: {
    public method doGenerateSSAValueWith: (context: SSAFunctionCompilationContext) ::=> SSAValue
        := self binding generateSSAValueWith: context.
}.

ASTIfNode extend: {
    public method doGenerateSSAValueWith: (context: SSAFunctionCompilationContext) ::=> SSAValue := {
        let builder := context builder.

        ## Condition
        let condition := self conditionExpression
            ifNotNil: {:condition :: SSAValue | condition generateSSAValueWith: context}
            ifNil: (builder literal: false).
        
        let conditionBlock := builder basicBlock.
        let mergeBlock := builder newBasicBlockNamed: #ifMerge.

        let trueExpression := self trueExpression.
        let trueDestination := trueExpression
            ifNotNil: (builder newBasicBlockNamed: #ifTrue)
            ifNil: mergeBlock.

        let falseExpression := self falseExpression.
        let falseDestination := falseExpression
            ifNotNil: (builder newBasicBlockNamed: #ifFalse)
            ifNil: mergeBlock.

        builder conditionalBranch: condition trueDestination: trueDestination falseDestination: falseDestination.

        ## True branch
        let trueResult := ValueBox with: nil.
        let trueResultBlock := ValueBox with: conditionBlock.
        let trueResultIsTerminator := ValueBox with: false.

        trueExpression ifNotNil: {
            builder beginBasicBlock: trueDestination.
            trueResult := trueExpression generateSSAValueWith: context.
            trueResultBlock := builder basicBlock.

            let isTerminator := builder isLastTerminator.
            trueResultIsTerminator := isTerminator.
            isTerminator
                ifTrue: (trueResult := builder literal: void)
                ifFalse: (builder branch: mergeBlock)
        } ifNil: {
            trueResult := builder literal: void
        }.

        ## False branch
        let falseResult := ValueBox with: nil.
        let falseResultBlock := ValueBox with: conditionBlock.
        let falseResultIsTerminator := ValueBox with: false.
        falseExpression ifNotNil: {
            builder beginBasicBlock: falseDestination.
            falseResult := falseExpression generateSSAValueWith: context.
            falseResultBlock := builder basicBlock.

            let isTerminator := builder isLastTerminator.
            falseResultIsTerminator := isTerminator.
            isTerminator
                ifTrue: (falseResult := builder literal: void)
                ifFalse: (builder branch: mergeBlock)
        } ifNil: {
            falseResult := builder literal: void
        }.

        ## Merge
        trueResultIsTerminator _ ifFalse: {
            builder beginBasicBlock: mergeBlock.
            trueResultIsTerminator _ ifTrue: (
                falseResult _
            ) ifFalse: (
                falseResultIsTerminator _ ifTrue: (
                    trueResult _
                ) ifFalse: (
                    (builder phi: self analyzedType)
                        addValue: trueResult _ incomingFrom: trueResultBlock _;
                        addValue: falseResult _ incomingFrom: falseResultBlock _;
                        yourself
                )
            ).
        } ifTrue: {
            builder literal: void
        }.
    }
}.

ASTMessageSendNode extend: {
    public method doGenerateSSAValueWith: (context: SSAFunctionCompilationContext) ::=> SSAValue
        := context builder send: (self receiver generateSSAValueWith: context)
            selector: (self selector generateSSAValueWith: context)
            arguments: (self arguments collect: {:(ASTNode)each :: SSAValue | each generateSSAValueWith: context }) asArray
            resultType: self analyzedType
}.

ASTSequenceNode extend: {
    public method doGenerateSSAValueWith: (context: SSAFunctionCompilationContext) ::=> SSAValue := {
        let result := ValueBox with: (context builder literal: void).
        self expressions do: {:(ASTNode)expression :: Void |
            context builder isLastTerminator ifFalse: {
                result := expression generateSSAValueWith: context
            }
        }.

        result _
    }
}.

ASTReturnNode extend: {
    public method doGenerateSSAValueWith: (context: SSAFunctionCompilationContext) ::=> SSAValue
        := context builder return: (self expression generateSSAValueWith: context)
}.

FunctionDefinition extend: {
    public method asSSAFunction => SSAFunction := {
        SSAFunctionCompilationContext new
            compileFunctionDefinition: self
    }.
}
